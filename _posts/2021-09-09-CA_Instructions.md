---
published: true
title: "[컴퓨터 구조] Instruction(명령어) 이란?"
date: 2021-09-09 12:00:00
toc: true
toc_sticky: true
toc_label: "Instruction 이란"
categories:
- Computer Architecture
tags:
- Computer Architecture
---

<br><br><br>

## ✅ Number Representations
인간은 기본적으로 모든 수를 10진수에 기반해 생각한다. 그러나 컴퓨터는 모든 연산을 0과 1로 처리를 하는 2진수에 기반한다. 이 때문에 컴퓨터 구조를 이해하기 위해서는 기본적으로 컴퓨터가 어떻게 2진수로 연산을 하고 처리하는지 알 필요가 있다. 컴퓨터는 산술 연산(덧셈, 뺄셈 등)을 명령어를 통해 수행하기 때문에 먼저 어떻게 음수와 양수를 2진수로 표현하는지 알아보자.

<br><br>

### 📌 2's Complement( = 2의 보수 )
<hr>
양수는 이진법으로 어떻게 나타내는지 잘 알고 있을 것이다. 8비트 수가 주어진다고 했을때 11을 이진수로 나타낸다면 다음과 같다.

> **0000 1011<sub>2</sub>**

그렇다면 -11을 이진수로 나타내려면 어떻게 표기해야 할까? 이때 우리는 **2의 보수**라는 것을 사용해서 음수를 표현할 수 있다. 컴퓨터 시스템에서 음수를 표현하고 연산을 수행하는 데 사용된다.

방법은 간단하다. 이진법으로 나타낸 수의 각 비트를 반전시켜 먼저 1의 보수로 만들고 그 결과에 1을 더하면 2의 보수를 구할 수 있다. **한마디로 1로 나타낸 수는 0으로, 0으로 나타낸 수는 1로 바꿔주고 그 결과에 1을 더하면 된다.**

<p class="notice--info">
⚠️ 1의 보수 : 이진수의 각 비트를 반전(0을 1로, 1을 0으로)시킨 것. <br>
⚠️ 2의 보수 : 1의 보수에 1을 더한 것.
</p>

<br><Br>


> **+11 : 0000 1011**  
> **-11 :  1111 0101**  

이렇게 0과 1을 변경해주고 마지막에 1만 더해주면 음수로 바꿀수 있다. 그런데 우리가 일반적으로 32비트 연산에서 -11이라고 표현한 위의 수는 실제로는 128 + 64 + 32 + 16 + 4 + 1 = 242 이다. 우리는 1111 0101<sub>2</sub>를 아무도 -11이라고 생각하지 않는다.

그러나 컴퓨터 시스템에서는 **연산의 편의**를 위해 1의 보수, 2의 보수라는 개념을 정의했고 사용한다. 1111 0101<sub>2</sub>를 -11로 인식하게 끔 정의한 것이다. **그렇다면 2의 보수가 어떤식으로 연산의 편의를 제공하길래 이렇게 정의한걸까?** 

<br><br>

앞서 살펴본 +11과 -11을 이진법으로 나타낸 각 자리를 한번 더해보자. 

> **+11 : 0000 1011**  
> **-11 :  1111 0101**  
> **00 : 10000 0000**  

**모든 자릿수의 합이 2가 되면서 올림이 들어가고 결국 맨 앞에 1이 올림된다. 그러나 컴퓨터는 32bit 혹은 64bit를 사용하기 때문에 올림된 1은 결국 overflow되어 버려진다.** 최종적으로 2의 보수를 활용한다면 **양수 + 음수 = 0** 이라는 산수의 진리를 만족하면서도 **양수끼리의 합**으로 뺄셈 연산까지 표현할 수 있는 컴퓨터 시스템을 만들어 낼 수 있다.

<br><br>

이를 통해 우리는 몇가지 공식을 뽑아낼 수 있다.

> **A + A's(A의 보수) = 1111 1111 <sub>2</sub>**  
>**-A = A's + 1**  

이를 통해 오로지 양수만으로 컴퓨터 산술 연산(덧셈, 뺄셈)을 할 수 있게 된 것이다. 이와 관련된 간단한 연습 문제를 살펴보자.

<br><br>

### 📌 연습 문제
<hr>

<p align="center">
<img src="https://github.com/idkim97/idkim97.github.io/blob/master/img/2's.jpg?raw=true">
</p>

1111 1111 1111 1111 1111 1111 1111 1000<sub>2</sub>의 값을 구하라는 문제이다. 물론 컴퓨터 시스템 내에서의 값을 말한다.

2의 보수를 모른다면 풀 수 없을 것이다. 저걸 언제 다 계산해서 정답을 작성 할 수 있을까..
당연히 2의 보수를 사용하면 쉽게 풀 수 있다.

-A = A's +1 을 활용한다면 정답은
 -0000 0000 0000 0000 0000 0000 0000 1000 <sub>2</sub> 즉, -8이 된다.

<br><br><br><br><br><br>

## ✅ The Von-Nuemann Model ( 폰 노이만 구조 )

<p align="center">
<img src="https://github.com/idkim97/idkim97.github.io/blob/master/img/Von.png?raw=true">
</p>

<br>

Instruction을 알고싶어서 포스팅을 보고있는데 도대체 폰노이만 구조는 왜나오는 거야.. 싶겠지만 컴퓨터가 명령어를 처리하고 실행하는 방식을 설명하는데 폰노이만 구조는 매우 중요하다. 폰노이만 구조에 대해 간략하게 알아보고 넘어가자.

폰 노이만 구조는 컴퓨터 시스템의 기본적인 설계 원리를 제시한 모델로 다음과 같은 주요 구성 요소로 이루어져 있다.

1. **메모리** : 데이터를 저장하는 공간으로, 프로그램의 명령어와 데이터를 저장한다.

2. **중앙 처리 장치(CPU)** : 명령어를 해석하고 실행하는 장치이다.
	- **산술 논리 장치(ALU)** : 산술 연산과 논리 연산을 수행한다.
	- **레지스터** : 연산에 필요한 데이터를 일시적으로 저장하는 작은 메모리이다.
	- **제어 장치** : 명령어를 해석하고 실행 순서를 제어한다.

3. **입출력 장치 (I/O)** : 외부와 데이터를 주고받는 장치이다.

4. **버스** : 데이터, 주소, 제어 신호를 전달하는 통로이다.

<br><br>

### 📌 폰 노이만 구조와 명령어 사이클
<hr>
폰 노이만 구조에서는 명령어를 처리하기 위해 명령어 사이클(Instruction Cycle)을 따른다. 명령어 사이클은 다음과 같은 단계로 이루어진다.

-   **명령어 인출(Fetch)**: 메모리에서 명령어를 가져온다.
-   **명령어 해독(Decode)**: 가져온 명령어를 해석하여 어떤 작업을 수행해야 하는지 결정한다.
-   **명령어 실행(Execute)**: 해석된 명령어에 따라 실제 작업을 수행한다.
-   **명령어 저장(Store)**: 연산 결과를 저장한다.

<br><br>

### 📌 폰 노이만 구조를 왜 알아야해?
<hr>

폰 노이만 구조는 명령어가 어떻게 인출, 해독, 실행되는지 이해하는데 가장 기본이 된다. 이를 통해 컴퓨터가 명령어를 처리하는 방식을 이해할 수 있다. 또한  폰 노이만 구조에서 메모리는 프로그램의 명령어와 데이터를 저장한다. 명령어는 메모리에서 인출되어 CPU에 의해 처리되므로, 메모리와 명령어의 관계를 이해하는 것 역시 중요하다. 

<br><br><br><br><br><br>

## ✅ Instructions (명령어) 란?

**Instruction(명령어)은 컴퓨터가 수행할 특정 작업을 정의하는 명령이다.** 명령어는 컴퓨터 프로그램을 구성하는 기본 단위로, CPU가 해석하고 실행하여 다양한 연산을 수행하게 한다. 컴퓨터 시스템에서 명령어는 주로 기계어(machine language) 또는 어셈블리어(assembly language)로 표현된다.

<br><br>

### 📌Instruction의 구성 요소
<hr>

-   **연산 코드(Operation Code, Opcode)**:
    
    -   명령어가 수행할 작업의 종류를 정의한다. 예를 들어, 덧셈, 뺄셈, 데이터 이동 등의 작업이 포함된다.

-   **오퍼랜드(Operands)**:
    
    -   명령어가 처리할 데이터 또는 데이터의 위치를 지정한다. 이는 레지스터, 메모리 주소, 상수 값 등이 될 수 있다.

-   **주소 지정 모드(Addressing Mode)**:
    
    -   오퍼랜드를 참조하는 방법을 정의한다. 이는 직접 주소 지정, 간접 주소 지정, 즉시 주소 지정 등의 방식으로 데이터를 참조한다.


<br><br>

### 📌Instruction 예시
<hr>

위의 정의만으로는 Instruction이 무엇인지 크게 와닿지 않을 것 같아 간단한 예시와 함께 설명하도록 하겠다.

1. **ADD R1, R2, R3:**
- 연산 코드 : ADD(덧셈)
- 오퍼랜드 : R1, R2, R3 (레지스터)
- 의미 : R2와 R3의 값을 더하여 R1에 저장한다.


2. **MOV R1, 5:**
- 연산 코드 : MOV (데이터 이동)
- 오퍼랜드 : R1, 5
- 의미 : 상수 5를 R1 레지스터에 저장한다.

3. **LOAD R1, [1000]:**
- 연산 코드 : LOAD (메모리에서 데이터읽기)
- 오퍼랜드 : R1, [1000] (메모리 주소)
- 의미 : 메모리 주소 1000번지의 값을 R1에 저장한다.


사실 우리가 직접 명령어를 작성하거나 명령어를 두눈으로 볼 일은 거의 없을 것 같다. 이정도의 글을 읽는 정도 수준이면 대부분 CS이론을 학습하는 학생이거나 비전공자 정도 일테니 깊게 모든 예제를 파악할 필요는 없어보인다. 일단 명령어가 무엇이고 이런 식으로 쓰이는구나 정도만 알아가면 될 것 같다.


<BR><BR><BR><BR><BR><BR>

## ✅ 결론

Instruction은 컴퓨터가 수행할 작업을 정의하는 기본 단위로, 컴퓨터 시스템의 작동 원리를 이해하는 데 핵심적인 역할을 한다. 명령어는 연산 코드, 오퍼랜드, 주소 지정 모드 등의 구성 요소로 이루어져 있으며, 이러한 명령어들이 모여 프로그램을 형성한다. 

컴퓨터 구조에 대한 깊이 있는 이해는 효율적인 소프트웨어 개발과 하드웨어 설계를 가능하게 하며, 나아가 컴퓨팅 성능을 극대화하는 데 도움을 준다. 앞으로의 학습에서도 이 기본 개념들을 바탕으로 더 복잡하고 정교한 컴퓨터 시스템의 작동 방식을 이해해 나가기를 바란다.
