---
title: "[알고리즘] 동적 계획법(Dynamic Programming) "
date: 2022-01-01 01:00:00
categories:
- Algorithm
tags:
- 알고리즘
- 다이나믹 프로그래밍
---

# 동적 계획법 ( Dynamic Programming )
<hr>

## 동적 계획법 개요
**동적 계획법**은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법을 사용하는 알고리즘들 또한 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내는 방식이기 때문이다.

동적 계획법과 분할 정복의 가장 큰 차이는 **문제를 나누는 방식**이다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용 될 수 있기 때문에 이를 여러번 계산하는 것 대신 한번만 계산하게 만듦으로써 속도 향상을 꾀할 수 있다. 그러기 위해선 부분 문제를 메모리에 저장해 둘 필요가 있는데 이 메모리 장소를 **캐시(cache)**라고 부른다.

<br><br><br><br><br><br>

이를 피보나치 수열 함수를 예로 설명해보겠다.
<p align="center">
<img src="https://github.com/idkim97/idkim97.github.io/blob/master/img/Fibo.png?raw=true">
</p>
위의 그림은 피보나치 함수를 분할 정복방식으로 구현한 것이다. 함수 이름을 fib(n) 이라고 했을때, 예시처럼 fib(5)를 구하기 위해선 총 **15번**의 함수 호출이 필요하다. 이때, fib(2)는 총 3번 호출되는것을 볼 수 있는데 이는 **동일한 계산과정을 3번이나 반복하게 되어 알고리즘의 실행시간이 길어지게 된다**.

<br><br><br>

이런 중복계산을 **캐시에 저장시킨 뒤 필요할 때마다 결과값만을 가져와서 사용하는 방식**을 **동적 계획법 ( Dynamic Programming )** 이라고한다.

<br><br><br><br><br><br>

동적 계획법 알고리즘의 가장 유명한 예 중 하나를 더 설명해보겠다. 바로 **이항 계수의 계산**이다. 이항 계수는 서로다른 n개의 원소중에서 r개의 원소를 순서없이 골라내는 방법의 수를 계산하는 것으로 다음과 같은 점화식이 성립한다.
<p align="center">
<img src="https://github.com/idkim97/idkim97.github.io/blob/master/img/ncr.png?raw=true">
</p>

<br><br><br><br><br><br>

이 점화식을 활용하여 n,r의 값이 주어질 때 그 결과를 반환하는 함수 **bino(n,r)**를 다음과 같이 작성할 수 있다.

```c++
int bino(int n, int r) {
	if(r == 0 || n == r) return 1;
	return bino(n-1,r-1) + bino(n-1,r)
```
이 코드는 **분할 정복 알고리즘**을 사용한 것으로 **중복 계산**이 발생한다.
<br><br><br><br><br><br>


이를 **동적 계획법 알고리즘**으로 변환하여 작성한 코드는 다음과 같다.
```c++
// -1로 초기화해둔다
int cache[30][30];

int bino2(int n, int r) {
	if(r == 0 || n == r ) return 1;
	
	if(cache[n][r]!= -1) 
	return cache[n][r];

	return cache[n][r] = bino2(n-1,r-1) + bino2(n-1,r);
```
코드처럼 cache라는 배열을 생성해준뒤 이곳에 값을 저장하는 방식을 사용하면 된다. 이를 **메모이제이션(memoization)** 이라고 부른다.


<br><br><br><br><br><br>

## 메모이제이션 구현 패턴

동적계획법은 가장 흔한 문제 유형 중 하나이기 때문에 메모이제이션을 굉장히 많이 구현하게 된다. 그렇기 때문에 **한가지 패턴**을 정해놓고 문제를 항상 같은 형태로 풀어가게 되면 문제 풀이에 도움이 많이 된다. 이 패턴을 소개해 보겠다.

<br><br><br>

1. **항상 예외처리를 제일 먼저 처리해라.**

	예외상황은 각종 오류를 유발하므로 제일 먼저 처리해놓는 것이 좋다.
	
2. **cache를 초기화 해줘라. feat. memset( )**

	초기화 할때는 C++ STL에 내재되어 있는 memset( ) 메소드를 활용하면 편리하다. **memset ( 메모리시작주소, 값, 크기 )** 를 사용하면 된다.
	EX ) memset ( cache, -1, sizeof(cache) ) 
	 
3. **return 값을 활용해라.**
	cache를 사용할 때마다 매번 cache[n][r]처럼 쓰지말고 return값을 활용해라.

4. **점화식을 만들어라.**
	
<br><br><br><br><br><br>


