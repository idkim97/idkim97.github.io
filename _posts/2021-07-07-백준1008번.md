---
title: "[백준] 1008번 : A/B"
date: 2021-07-07 17:00:00 -0400
categories: 
  - Algorithm
tags:
  - 백준
  - 알고리즘
  - 단계별 풀어보기
---
* **문제**
<br><br>

![백준_1008번](https://github.com/idkim97/idkim97.github.io/blob/master/img/1008.jpg?raw=true)

<br><br><br><br>

***

<br><br>

* **알고리즘 [접근 방법]**

<br>

이 문제는 '부동 소수점'에 대한 이해를 필요로 하는 문제다.  

부동 소수점은 직역하자면 **'떠서 움직이는 소수점'**을 의미한다. 왜 떠서 움직인다고 할까?  

컴퓨터는 기본적으로 0과 1 즉,비트로 수를 표현한다. 예로들어 1001은 9를 의미하듯이 말이다. 하지만 한정 된 비트 안에 수를 표현하다 보면 제약점이 많은데,
바로 소수점 표현 방식이다.  

예를들어 1/3을 표현한다고 해보자. 결과값은 0.33333....으로 무한소수다. 이를 정확하게 표기하려면 비트가 무한개 있어야 한다는 뜻이나 마찬가지이다.  

결국 유한 자리수로 표현해 표기하기 위해 나온 것이 **'실수 근사 방식'** 이다.

![비트설명](https://github.com/idkim97/idkim97.github.io/blob/master/img/bit.png?raw=true)

<br>

아무래도 '근사값'을 표현하다 보니 오차가 발생할 수 밖에 없는 것이다.  

이런 오차를 줄이기 위해서는 최대한 많은 비트를 쓸 수 있는 자료형을 선택해야 하는데, 이번 문제에서는 오차가 10<sup>-9</sup> 이하여야 한다.  

여기서 우리가 쓸 수 있는 실수형 자료형은 크게 두가지가 있다.  

**float** : 32비트(4바이트) 자료형이다.  
**double** : 64비트(8바이트) 자료형이다.  

결국 오차를 줄이기 위해선 많은 비트를 사용하는 큰 자료형을 써야하는데, 만약 float을 쓰게되면 오차범위가 10<sup>-7</sup> 전후 정도가 되어 오답이 된다.  

참고로 double은 10<sup>-15</sup>정도라고 한다. 

또한 오차범위가 10<sup>-9</sup>이하여야 하기 때문에 출력 할 때도 소수점 자리를 9개 이상 출력하도록 해야한다는 점 유의해야 한다!  

<br><br>

***

<br>

* **풀이**

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {

	double A, B;

	scanf("%lf %lf", &A, &B); // double형을 받음

	printf("%.9lf\n", A / B); // 소수점 9자리 출력!



	return 0;

}
```

