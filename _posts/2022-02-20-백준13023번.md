---
title: "[백준] [C/C++] 13023번 :  ABCDE"
date: 2022-02-20 22:00:00
categories:
- 백준
tags:
- 백준
- 알고리즘
- 그래프
---

## 문제


BOJ 알고리즘 캠프에는 총 N명이 참가하고 있다. 사람들은 0번부터 N-1번으로 번호가 매겨져 있고, 일부 사람들은 친구이다.

오늘은 다음과 같은 친구 관계를 가진 사람 A, B, C, D, E가 존재하는지 구해보려고 한다.

-   A는 B와 친구다.
-   B는 C와 친구다.
-   C는 D와 친구다.
-   D는 E와 친구다.

위와 같은 친구 관계가 존재하는지 안하는지 구하는 프로그램을 작성하시오..

<br><br><br><br><br><br>

  

## 입력


첫째 줄에 사람의 수 N (5 ≤ N ≤ 2000)과 친구 관계의 수 M (1 ≤ M ≤ 2000)이 주어진다.

둘째 줄부터 M개의 줄에는 정수 a와 b가 주어지며, a와 b가 친구라는 뜻이다. (0 ≤ a, b ≤ N-1, a ≠ b) 같은 친구 관계가 두 번 이상 주어지는 경우는 없다.

<br><br><br><br><br><br>

  

## 출력
문제의 조건에 맞는 A, B, C, D, E가 존재하면 1을 없으면 0을 출력한다.

<br><br><br><br><br><br>

  

## 예제 입력 1
5 4  
0 1  
1 2  
2 3  
3 4  

## 예제 출력 1
1

## 예제 입력 2
8 8  
1 7  
3 7  
4 7  
3 4  
4 6  
3 5  
0 4  
2 7  

## 예제 출력 2
1
<br><br><br><br><br><br>

## 알고리즘 [ 접근 방법 ]
그래프를 이용해 풀 수 있는 기본적인 문제이다. DFS방식으로도 풀이 할 수 있지만 그래프 구현을 연습해보기 위한 문제풀이를 해보았다.

인접행렬, 인접리스트, 간선리스트 모두를 활용한 문제풀이를 살펴보자.


<br><br><br><br><br><br>

## 풀이

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool a[2000][2000]; // 인접행렬
vector <int> g[2000]; // 인접리스트
vector <pair<int, int>> edges;  // 간선리스트


int main() {

	int n, m;
	cin >> n >> m;

	for (int i = 0; i < m; i++) {
		int from, to;
		cin >> from >> to;

		edges.push_back({ from, to }); // 간선리스트 만들기 ... etc) edges[0] = 0 1  , edges[1] = 1 2
		edges.push_back({ to, from }); // 간선리스트 만들기

		a[from][to] = a[to][from] = true; // 인접행렬 만들기 ... etc) 연결되어있으면 1 아니면 0

		g[from].push_back(to); // 인접리스트 만들기 ... etc) g[0] 1  , g[1] 0 2 
		g[to].push_back(from); // 인접리스트 만들기
	}

	m *= 2;

	for (int i = 0; i < m; i++) {
		for (int j = 0; j < m; j++) {

			// A->B
			int A = edges[i].first;
			int B = edges[i].second;

			// C->D
			int C = edges[j].first;
			int D = edges[j].second;

			if (A == B || B == C || C == D || A == C || A == D || B == D) continue;

			// B->C
			if (!a[B][C]) continue;

			for (int E : g[D]) {
				if (A == E || B == E || C == E || D == E) continue;
				cout << 1 << "\n";
				return 0;
			}
		}
	}

	cout << 0 << endl;
	return 0;

}

```

