{"x2LBqte2UHd95dF6/content":{"id":"x2LBqte2UHd95dF6/content","type":"content","text":"# Welcome to StackEdit!\n\nHi! I'm your first Markdown file in **StackEdit**. If you want to learn about StackEdit, you can read me. If you want to play with Markdown, you can edit me. Once you have finished with me, you can create new files by opening the **file explorer** on the left corner of the navigation bar.\n\n\n# Files\n\nStackEdit stores your files in your browser, which means all your files are automatically saved locally and are accessible **offline!**\n\n## Create files and folders\n\nThe file explorer is accessible using the button in left corner of the navigation bar. You can create a new file by clicking the **New file** button in the file explorer. You can also create folders by clicking the **New folder** button.\n\n## Switch to another file\n\nAll your files and folders are presented as a tree in the file explorer. You can switch from one to another by clicking a file in the tree.\n\n## Rename a file\n\nYou can rename the current file by clicking the file name in the navigation bar or by clicking the **Rename** button in the file explorer.\n\n## Delete a file\n\nYou can delete the current file by clicking the **Remove** button in the file explorer. The file will be moved into the **Trash** folder and automatically deleted after 7 days of inactivity.\n\n## Export a file\n\nYou can export the current file by clicking **Export to disk** in the menu. You can choose to export the file as plain Markdown, as HTML using a Handlebars template or as a PDF.\n\n\n# Synchronization\n\nSynchronization is one of the biggest features of StackEdit. It enables you to synchronize any file in your workspace with other files stored in your **Google Drive**, your **Dropbox** and your **GitHub** accounts. This allows you to keep writing on other devices, collaborate with people you share the file with, integrate easily into your workflow... The synchronization mechanism takes place every minute in the background, downloading, merging, and uploading file modifications.\n\nThere are two types of synchronization and they can complement each other:\n\n- The workspace synchronization will sync all your files, folders and settings automatically. This will allow you to fetch your workspace on any other device.\n\t> To start syncing your workspace, just sign in with Google in the menu.\n\n- The file synchronization will keep one file of the workspace synced with one or multiple files in **Google Drive**, **Dropbox** or **GitHub**.\n\t> Before starting to sync files, you must link an account in the **Synchronize** sub-menu.\n\n## Open a file\n\nYou can open a file from **Google Drive**, **Dropbox** or **GitHub** by opening the **Synchronize** sub-menu and clicking **Open from**. Once opened in the workspace, any modification in the file will be automatically synced.\n\n## Save a file\n\nYou can save any file of the workspace to **Google Drive**, **Dropbox** or **GitHub** by opening the **Synchronize** sub-menu and clicking **Save on**. Even if a file in the workspace is already synced, you can save it to another location. StackEdit can sync one file with multiple locations and accounts.\n\n## Synchronize a file\n\nOnce your file is linked to a synchronized location, StackEdit will periodically synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be resolved.\n\nIf you just have modified your file and you want to force syncing, click the **Synchronize now** button in the navigation bar.\n\n> **Note:** The **Synchronize now** button is disabled if you have no file to synchronize.\n\n## Manage file synchronization\n\nSince one file can be synced with multiple locations, you can list and manage synchronized locations by clicking **File synchronization** in the **Synchronize** sub-menu. This allows you to list and remove synchronized locations that are linked to your file.\n\n\n# Publication\n\nPublishing in StackEdit makes it simple for you to publish online your files. Once you're happy with a file, you can publish it to different hosting platforms like **Blogger**, **Dropbox**, **Gist**, **GitHub**, **Google Drive**, **WordPress** and **Zendesk**. With [Handlebars templates](http://handlebarsjs.com/), you have full control over what you export.\n\n> Before starting to publish, you must link an account in the **Publish** sub-menu.\n\n## Publish a File\n\nYou can publish your file by opening the **Publish** sub-menu and by clicking **Publish to**. For some locations, you can choose between the following formats:\n\n- Markdown: publish the Markdown text on a website that can interpret it (**GitHub** for instance),\n- HTML: publish the file converted to HTML via a Handlebars template (on a blog for example).\n\n## Update a publication\n\nAfter publishing, StackEdit keeps your file linked to that publication which makes it easy for you to re-publish it. Once you have modified your file and you want to update your publication, click on the **Publish now** button in the navigation bar.\n\n> **Note:** The **Publish now** button is disabled if your file has not been published yet.\n\n## Manage file publication\n\nSince one file can be published to multiple locations, you can list and manage publish locations by clicking **File publication** in the **Publish** sub-menu. This allows you to list and remove publication locations that are linked to your file.\n\n\n# Markdown extensions\n\nStackEdit extends the standard Markdown syntax by adding extra **Markdown extensions**, providing you with some nice features.\n\n> **ProTip:** You can disable any **Markdown extension** in the **File properties** dialog.\n\n\n## SmartyPants\n\nSmartyPants converts ASCII punctuation characters into \"smart\" typographic punctuation HTML entities. For example:\n\n|                |ASCII                          |HTML                         |\n|----------------|-------------------------------|-----------------------------|\n|Single backticks|`'Isn't this fun?'`            |'Isn't this fun?'            |\n|Quotes          |`\"Isn't this fun?\"`            |\"Isn't this fun?\"            |\n|Dashes          |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|\n\n\n## KaTeX\n\nYou can render LaTeX mathematical expressions using [KaTeX](https://khan.github.io/KaTeX/):\n\nThe *Gamma function* satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral\n\n$$\n\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\n$$\n\n> You can find more information about **LaTeX** mathematical expressions [here](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference).\n\n\n## UML diagrams\n\nYou can render UML diagrams using [Mermaid](https://mermaidjs.github.io/). For example, this will produce a sequence diagram:\n\n```mermaid\nsequenceDiagram\nAlice ->> Bob: Hello Bob, how are you?\nBob-->>John: How about you John?\nBob--x Alice: I am good thanks!\nBob-x John: I am good thanks!\nNote right of John: Bob thinks a long<br/>long time, so long<br/>that the text does<br/>not fit on a row.\n\nBob-->Alice: Checking with John...\nAlice->John: Yes... John, how are you?\n```\n\nAnd this will produce a flow chart:\n\n```mermaid\ngraph LR\nA[Square Rect] -- Link text --> B((Circle))\nA --> C(Round Rect)\nB --> D{Rhombus}\nC --> D\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-332455363,"tx":1},"x2LBqte2UHd95dF6/contentState":{"id":"x2LBqte2UHd95dF6/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710111436002,"tx":1},"x2LBqte2UHd95dF6/syncedContent":{"id":"x2LBqte2UHd95dF6/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1710111435512,"tx":1},"00TrVRATmgNqHn1N":{"id":"00TrVRATmgNqHn1N","type":"file","name":"2023-02-15-TCP와 UDP의 특징과 차이","parentId":"9CXoipIqNc6euydo","hash":2041825287,"tx":3},"06MckntYpMDISZ8b":{"id":"06MckntYpMDISZ8b","type":"file","name":"2023-07-11-컴포넌트 스캔(ComponentScan)","parentId":"ilIvoK9bdEIgCIvn","hash":-33819402,"tx":3},"0jwjWW7L0cw2iQtV":{"id":"0jwjWW7L0cw2iQtV","type":"file","name":"2023-06-22-Thread","parentId":"AAphmch3Ge6p9ZRi","hash":-633421909,"tx":3},"1N5zQwL2CvCdrU9B":{"id":"1N5zQwL2CvCdrU9B","type":"file","name":"Studium","parentId":"3fRCd89AZkTI6CKF","hash":126434083,"tx":3},"1hoxohbjUViggy6d":{"id":"1hoxohbjUViggy6d","type":"file","name":"2023-07-14-의존관계 자동 주입","parentId":"ilIvoK9bdEIgCIvn","hash":-1144560792,"tx":3},"1oEHvsghUe5VhiGy":{"id":"1oEHvsghUe5VhiGy","type":"folder","name":"BruteForce","parentId":"fAbQ4GrjYnuIv4xU","hash":1568701204,"tx":3},"1yvS1owczbvG7a0y":{"id":"1yvS1owczbvG7a0y","type":"file","name":"2023-08-10-네트워크 토폴로지의 종류와 특징","parentId":"aisCZOCBzm0r8Jcd","hash":81267180,"tx":3},"27FCLunQqiKehP51":{"id":"27FCLunQqiKehP51","type":"file","name":"2022-02-19-알고리즘_Graph","parentId":"CXkDYxCp5Qq9ere0","hash":-181130542,"tx":3},"2DVrg5MrmpVbUmh6":{"id":"2DVrg5MrmpVbUmh6","type":"file","name":"2023-02-23-HTTP 상태코드(2) - 3xx ( Redirection )","parentId":"9CXoipIqNc6euydo","hash":-1507183113,"tx":3},"2OTxNzpMQajxUPNa":{"id":"2OTxNzpMQajxUPNa","type":"file","name":"2022-08-17-싱글톤(Singleton)패턴","parentId":"Q6xmU68w98wuNklY","hash":711571155,"tx":3},"2YcBlgoRtPYITlYT":{"id":"2YcBlgoRtPYITlYT","type":"file","name":"2021-09-25-MachineLearning_EM","parentId":"zaeb9S3ugI5mUe9I","hash":-812923146,"tx":3},"2rs7iPXVJKE420nw":{"id":"2rs7iPXVJKE420nw","type":"file","name":"2022-01-04-백준14002번","parentId":"qu70Oe3aus3CVeFP","hash":1988787040,"tx":3},"30ZHndsjczBXKG2t":{"id":"30ZHndsjczBXKG2t","type":"file","name":"2021-08-17-알고리즘_QuickSort","parentId":"CXkDYxCp5Qq9ere0","hash":-1494688936,"tx":3},"31JAF1na3LcScLsv":{"id":"31JAF1na3LcScLsv","type":"file","name":"2021-07-31-백준3053번","parentId":"U3QLvyaFPGVPjqhG","hash":468002193,"tx":3},"31ixuwejQY1ahmSf":{"id":"31ixuwejQY1ahmSf","type":"file","name":"2022-02-20-백준13023번","parentId":"lrjscqeSvZS8Oz9S","hash":-219859688,"tx":3},"3LsY0S6l92HdtfPP":{"id":"3LsY0S6l92HdtfPP","type":"file","name":"2021-09-02-백준1406번","parentId":"BUPXu7gnwQkTDAja","hash":771393512,"tx":3},"3MlAcPk2jd146ZWA":{"id":"3MlAcPk2jd146ZWA","type":"file","name":"2021-07-29-백준2581번","parentId":"U3QLvyaFPGVPjqhG","hash":1696475097,"tx":3},"3czWpyCWVN518JXE":{"id":"3czWpyCWVN518JXE","type":"folder","name":"Computer Architecture","parentId":null,"hash":-1052857529,"tx":3},"3fRCd89AZkTI6CKF":{"id":"3fRCd89AZkTI6CKF","type":"folder","name":"Project","parentId":null,"hash":-896079416,"tx":3},"4VlIZeIFebGuQ7Yr":{"id":"4VlIZeIFebGuQ7Yr","type":"file","name":"2021-07-18-백준1157번","parentId":"U3QLvyaFPGVPjqhG","hash":-1937455437,"tx":3},"5FRWO0TTd1nBmf8a":{"id":"5FRWO0TTd1nBmf8a","type":"folder","name":"자료구조","parentId":"fAbQ4GrjYnuIv4xU","hash":-735307137,"tx":3},"5wKp8vROJwBo4Sce":{"id":"5wKp8vROJwBo4Sce","type":"file","name":"2023-02-17-웹 브라우저 요청 흐름","parentId":"9CXoipIqNc6euydo","hash":1133283443,"tx":3},"6d0K7UYUnaJHcUwH":{"id":"6d0K7UYUnaJHcUwH","type":"file","name":"2023-05-22-AWS 스토리지 서비스 - S3 ( Simple Storage Service )","parentId":"G2bkxcGIHGuRm29Z","hash":-1880298215,"tx":3},"74ZWcTXgBSlLBzjE":{"id":"74ZWcTXgBSlLBzjE","type":"file","name":"BuyBooks","parentId":"3fRCd89AZkTI6CKF","hash":-1387829818,"tx":3},"7MH9EXPbwlEyua1N":{"id":"7MH9EXPbwlEyua1N","type":"file","name":"2021-08-09-백준1436번","parentId":"U3QLvyaFPGVPjqhG","hash":-575734608,"tx":3},"8onLCMS0jHIZdwsP":{"id":"8onLCMS0jHIZdwsP","type":"file","name":"2022-01-09-백준1149번","parentId":"qu70Oe3aus3CVeFP","hash":-584978935,"tx":3},"9BAGvpdsYjjYTrvN":{"id":"9BAGvpdsYjjYTrvN","type":"file","name":"2021-12-31-백준15990번","parentId":"qu70Oe3aus3CVeFP","hash":-1327373974,"tx":3},"9CXoipIqNc6euydo":{"id":"9CXoipIqNc6euydo","type":"folder","name":"HTTP","parentId":null,"hash":982274439,"tx":3},"9JHueTxb1xmg5ZXP":{"id":"9JHueTxb1xmg5ZXP","type":"file","name":"2022-08-16-라이브러리 vs 프레임워크","parentId":"ifp1fePK1xXUjFE4","hash":-2042484602,"tx":3},"9TTmPv43PVpNQndV":{"id":"9TTmPv43PVpNQndV","type":"file","name":"2022-08-07-1주차인턴일기","parentId":"v5e2bsf3UmIOg5eS","hash":-629901003,"tx":3},"ADbe6HrECGC5ROmU":{"id":"ADbe6HrECGC5ROmU","type":"file","name":"2023-11-10-생산자&소비자(Producer&Consumer) 패턴","parentId":"Q6xmU68w98wuNklY","hash":-615749766,"tx":3},"ATRuUFMbG6IBvDuO":{"id":"ATRuUFMbG6IBvDuO","type":"file","name":"2022-05-14-스프링 입문_MVC와 템플릿엔진","parentId":"ijBr8Otur9vUslbg","hash":-1962525758,"tx":3},"BUPXu7gnwQkTDAja":{"id":"BUPXu7gnwQkTDAja","type":"folder","name":"문자열","parentId":"fAbQ4GrjYnuIv4xU","hash":1216748907,"tx":3},"Bars6CC7H5Joqa8P":{"id":"Bars6CC7H5Joqa8P","type":"file","name":"2023-06-29-DB설계 예제와 고민","parentId":"CnmO7dcKc1ZOG1KX","hash":-1309533867,"tx":3},"C8kg3so81QVoun72":{"id":"C8kg3so81QVoun72","type":"file","name":"2023-06-19-String, StringBuffer와 StringBuilder","parentId":"AAphmch3Ge6p9ZRi","hash":-217934907,"tx":3},"CP6FQYPqjeJhYtSB":{"id":"CP6FQYPqjeJhYtSB","type":"file","name":"2021-08-01-백준2447번","parentId":"U3QLvyaFPGVPjqhG","hash":267103305,"tx":3},"CVoMq6D4LAjPbCG5":{"id":"CVoMq6D4LAjPbCG5","type":"file","name":"2022-05-15-스프링 입문_API","parentId":"ijBr8Otur9vUslbg","hash":-998131506,"tx":3},"CXkDYxCp5Qq9ere0":{"id":"CXkDYxCp5Qq9ere0","type":"folder","name":"Algorithm","parentId":null,"hash":1331905438,"tx":3},"CnmO7dcKc1ZOG1KX":{"id":"CnmO7dcKc1ZOG1KX","type":"folder","name":"DB","parentId":null,"hash":-1736582659,"tx":3},"D6AI3WmiULa0MQox":{"id":"D6AI3WmiULa0MQox","type":"file","name":"2021-09-24-MachineLearning_SVM","parentId":"zaeb9S3ugI5mUe9I","hash":-530487961,"tx":3},"DYReayvPEWh2qfnj":{"id":"DYReayvPEWh2qfnj","type":"file","name":"2021-09-14-MachineLearning_LogisticRegression","parentId":"zaeb9S3ugI5mUe9I","hash":1049272719,"tx":3},"EAHxuW5JgATJ3mo2":{"id":"EAHxuW5JgATJ3mo2","type":"file","name":"2021-07-13-백준10950번","parentId":"U3QLvyaFPGVPjqhG","hash":507856723,"tx":3},"EO4J8PI1VIfZ6v35":{"id":"EO4J8PI1VIfZ6v35","type":"file","name":"2022-10-25-스프링 입문_회원 관리 예제","parentId":"ijBr8Otur9vUslbg","hash":-17710833,"tx":3},"FfQclKsMdVNJJRNd":{"id":"FfQclKsMdVNJJRNd","type":"file","name":"2023-02-18-HTTP의 특징 ( Stateless, Connectionless )","parentId":"9CXoipIqNc6euydo","hash":-763503198,"tx":3},"Fhx75tVk2bMRrChl":{"id":"Fhx75tVk2bMRrChl","type":"file","name":"2022-08-22-아파치(Apache)와 톰캣(Tomcat) (feat.Web 서버와 WAS)","parentId":"RmtXmh2lrGLVBbOm","hash":383351009,"tx":3},"Fr15DxYxCrywoW1c":{"id":"Fr15DxYxCrywoW1c","type":"file","name":"코테 모르는거","parentId":"CXkDYxCp5Qq9ere0","hash":958220234,"tx":3},"G2bkxcGIHGuRm29Z":{"id":"G2bkxcGIHGuRm29Z","type":"folder","name":"AWS","parentId":null,"hash":-493875028,"tx":3},"HImeteZ1A700ZipO":{"id":"HImeteZ1A700ZipO","type":"file","name":"SQL 코테","parentId":"CXkDYxCp5Qq9ere0","hash":-470289772,"tx":3},"I9XIrcsCCqJCsXnW":{"id":"I9XIrcsCCqJCsXnW","type":"file","name":"2021-09-24-백준3085번","parentId":"1oEHvsghUe5VhiGy","hash":918232863,"tx":3},"INiNbmVlPhYbw2lt":{"id":"INiNbmVlPhYbw2lt","type":"file","name":"2023-02-16-URI와 URL 그리고 URN","parentId":"9CXoipIqNc6euydo","hash":-20108622,"tx":3},"If5aQIxmIA2QnlwG":{"id":"If5aQIxmIA2QnlwG","type":"file","name":"2021-07-28-백준10757번","parentId":"U3QLvyaFPGVPjqhG","hash":-81784950,"tx":3},"IqjGfqqQQvpdMUmv":{"id":"IqjGfqqQQvpdMUmv","type":"file","name":"2021-09-01-백준9093번","parentId":"5FRWO0TTd1nBmf8a","hash":-1593413474,"tx":3},"J3qxgGs4hhBbD0IK":{"id":"J3qxgGs4hhBbD0IK","type":"file","name":"2023-05-22-AWS IAM","parentId":"G2bkxcGIHGuRm29Z","hash":-468813674,"tx":3},"Kl8goLjOCe4Y2iU1":{"id":"Kl8goLjOCe4Y2iU1","type":"file","name":"2022-08-25-팩토리 메소드(Factory Method) 패턴","parentId":"Q6xmU68w98wuNklY","hash":1124753122,"tx":3},"KvfIbjNY2ObhRnU0":{"id":"KvfIbjNY2ObhRnU0","type":"file","name":"2021-07-14-백준11720번","parentId":"U3QLvyaFPGVPjqhG","hash":-2129224270,"tx":3},"LEhxYp8G5u90fiYq":{"id":"LEhxYp8G5u90fiYq","type":"file","name":"2021-09-16-백준10824번","parentId":"BUPXu7gnwQkTDAja","hash":495027119,"tx":3},"LOPgwVDwC6boRNzS":{"id":"LOPgwVDwC6boRNzS","type":"file","name":"2022-08-17-디자인 패턴의 종류","parentId":"Q6xmU68w98wuNklY","hash":438394593,"tx":3},"MRasIncXHMnDEsl4":{"id":"MRasIncXHMnDEsl4","type":"file","name":"2023-01-05-Error Code 1452 : Cannot add or update a child row: a foreign key constraint fails ​해결","parentId":"CnmO7dcKc1ZOG1KX","hash":1967568513,"tx":3},"MTb2rEZmbJruPLxT":{"id":"MTb2rEZmbJruPLxT","type":"file","name":"2022-08-30-의존성 주입(DI)","parentId":"ilIvoK9bdEIgCIvn","hash":817991584,"tx":3},"N72RguIezt8KuflR":{"id":"N72RguIezt8KuflR","type":"file","name":"2023-07-04-빈 스코프 - 싱글톤, 프로토타입","parentId":"ilIvoK9bdEIgCIvn","hash":-1550474622,"tx":3},"Nz2EkixXKQGcuEag":{"id":"Nz2EkixXKQGcuEag","type":"file","name":"2022-08-29-제어의 역전(IoC)","parentId":"ilIvoK9bdEIgCIvn","hash":-1667773645,"tx":3},"OZdRQujNaQC3tGVz":{"id":"OZdRQujNaQC3tGVz","type":"folder","name":"클라우드","parentId":null,"hash":1880686003,"tx":3},"OiVTXhxEC6PT4wfS":{"id":"OiVTXhxEC6PT4wfS","type":"file","name":"2022-10-28-스프링 입문_웹 MVC 개발","parentId":"ijBr8Otur9vUslbg","hash":-59599085,"tx":3},"PV7SRqnI3929RHIh":{"id":"PV7SRqnI3929RHIh","type":"file","name":"2022-05-01-OESense","parentId":"uvNLKPUHyvxwNYwJ","hash":-287033078,"tx":3},"Q630m9jJvuuKh53I":{"id":"Q630m9jJvuuKh53I","type":"file","name":"2023-03-03-알고리즘_Arrays.sort와 Collections.sort","parentId":"CXkDYxCp5Qq9ere0","hash":-1322068014,"tx":3},"Q6xmU68w98wuNklY":{"id":"Q6xmU68w98wuNklY","type":"folder","name":"디자인 패턴","parentId":null,"hash":247472303,"tx":3},"QBAJWTNeLD7raJPY":{"id":"QBAJWTNeLD7raJPY","type":"file","name":"2022-08-12-2주차인턴일기","parentId":"v5e2bsf3UmIOg5eS","hash":-1707093168,"tx":3},"QfcCQHZlB9I2iOQ0":{"id":"QfcCQHZlB9I2iOQ0","type":"file","name":"2023-05-19-AWS 글로벌 인프라 ( 리전, 가용영역, 엣지로케이션 )","parentId":"G2bkxcGIHGuRm29Z","hash":2138921488,"tx":3},"QjUYHBSBdQAHLPXV":{"id":"QjUYHBSBdQAHLPXV","type":"file","name":"2021-09-06-백준17298번","parentId":"5FRWO0TTd1nBmf8a","hash":48662461,"tx":3},"RPnGLdVL2Co43fn3":{"id":"RPnGLdVL2Co43fn3","type":"file","name":"2023-02-20-HTTP 메서드 총정리","parentId":"9CXoipIqNc6euydo","hash":1400539913,"tx":3},"RTduSDZPEbBuUVtA":{"id":"RTduSDZPEbBuUVtA","type":"file","name":"2022-08-23-서블릿(Servlet)이란","parentId":"RmtXmh2lrGLVBbOm","hash":134441340,"tx":3},"RhDb97gjgmCAcjXo":{"id":"RhDb97gjgmCAcjXo","type":"file","name":"Camptact","parentId":"3fRCd89AZkTI6CKF","hash":563350625,"tx":3},"RmtXmh2lrGLVBbOm":{"id":"RmtXmh2lrGLVBbOm","type":"folder","name":"Web & Server","parentId":null,"hash":-770356024,"tx":3},"S7I9qtkAaIcuOTIm":{"id":"S7I9qtkAaIcuOTIm","type":"file","name":"2021-08-19-백준10814번","parentId":"U3QLvyaFPGVPjqhG","hash":765165223,"tx":3},"U3QLvyaFPGVPjqhG":{"id":"U3QLvyaFPGVPjqhG","type":"folder","name":"단계별 풀어보기","parentId":"fAbQ4GrjYnuIv4xU","hash":1853572455,"tx":3},"VifWnBgyL1lMo6QC":{"id":"VifWnBgyL1lMo6QC","type":"file","name":"JSP_Bulletin_WebPage","parentId":"3fRCd89AZkTI6CKF","hash":-1860720091,"tx":3},"WD9Bzi9mPGSI4cK9":{"id":"WD9Bzi9mPGSI4cK9","type":"file","name":"2023-02-21-HTTP의 안전, 멱등, 캐시가능 속성","parentId":"9CXoipIqNc6euydo","hash":-130428059,"tx":3},"WJFVWbFTBiUUqpiQ":{"id":"WJFVWbFTBiUUqpiQ","type":"file","name":"2023-05-19-AWS 루트 사용자 Access Key 삭제, MFA 활성화","parentId":"G2bkxcGIHGuRm29Z","hash":1996085517,"tx":3},"Wg83VoN5zGPoNo1y":{"id":"Wg83VoN5zGPoNo1y","type":"file","name":"Youtube_Clone","parentId":"3fRCd89AZkTI6CKF","hash":665449523,"tx":3},"X3mDwXGkmeIJpTbt":{"id":"X3mDwXGkmeIJpTbt","type":"file","name":"2023-08-22-컨테이너","parentId":"OZdRQujNaQC3tGVz","hash":-1486931830,"tx":3},"XB8qeLyuDIPE5NtZ":{"id":"XB8qeLyuDIPE5NtZ","type":"file","name":"2021-09-01-백준9012번","parentId":"5FRWO0TTd1nBmf8a","hash":1794047671,"tx":3},"YRBZD8HJuJFWJ7Aj":{"id":"YRBZD8HJuJFWJ7Aj","type":"file","name":"2021-07-29-백준11653번","parentId":"U3QLvyaFPGVPjqhG","hash":1728926351,"tx":3},"ZQ1P22aGt9pYBZQY":{"id":"ZQ1P22aGt9pYBZQY","type":"file","name":"2023-08-30-외부 프로퍼티 적용","parentId":"ilIvoK9bdEIgCIvn","hash":485630579,"tx":3},"Zd6WgSyDwAy0BrDK":{"id":"Zd6WgSyDwAy0BrDK","type":"file","name":"2021-07-13-백준10951번","parentId":"U3QLvyaFPGVPjqhG","hash":1477437746,"tx":3},"ZrlBGkPkFqYFyKak":{"id":"ZrlBGkPkFqYFyKak","type":"file","name":"2023-05-23-AWS","parentId":"G2bkxcGIHGuRm29Z","hash":283622914,"tx":3},"aae7rBzpuqHuDhqC":{"id":"aae7rBzpuqHuDhqC","type":"file","name":"2021-08-03-백준2798번","parentId":"U3QLvyaFPGVPjqhG","hash":1863052556,"tx":3},"aisCZOCBzm0r8Jcd":{"id":"aisCZOCBzm0r8Jcd","type":"folder","name":"네트워크","parentId":null,"hash":-1056679373,"tx":3},"cXAfswLPLBmPzNUg":{"id":"cXAfswLPLBmPzNUg","type":"file","name":"2021-09-16-알고리즘_DynamicProgramming","parentId":"CXkDYxCp5Qq9ere0","hash":1426061647,"tx":3},"cc0DNjIMHfpFRRJW":{"id":"cc0DNjIMHfpFRRJW","type":"file","name":"2021-12-29-백준1463번","parentId":"qu70Oe3aus3CVeFP","hash":1007432267,"tx":3},"d9OhY4avzY2oqiLM":{"id":"d9OhY4avzY2oqiLM","type":"file","name":"2022-05-11-백준10816번","parentId":"lrjscqeSvZS8Oz9S","hash":1898645642,"tx":3},"dmRttHYhrK5WFmOh":{"id":"dmRttHYhrK5WFmOh","type":"file","name":"2022-08-19-3주차인턴일기","parentId":"v5e2bsf3UmIOg5eS","hash":1221122456,"tx":3},"dsPZqXB2XwSOXmhf":{"id":"dsPZqXB2XwSOXmhf","type":"file","name":"2021-08-17-백준11650번","parentId":"U3QLvyaFPGVPjqhG","hash":-1570600204,"tx":3},"eZPD4ts8Xo7mlluk":{"id":"eZPD4ts8Xo7mlluk","type":"file","name":"몰랐던거","parentId":"yUIaIw4G8JNVFyuC","hash":717566588,"tx":3},"erk03SWntmHYKgf9":{"id":"erk03SWntmHYKgf9","type":"file","name":"2023-02-22-HTTP 상태코드(1) - 2xx ( Successful )","parentId":"9CXoipIqNc6euydo","hash":3361886,"tx":3},"f5vTQlCLsBu2JtIV":{"id":"f5vTQlCLsBu2JtIV","type":"file","name":"2021-09-09-머신러닝_DecisionTreeRegression","parentId":"zaeb9S3ugI5mUe9I","hash":1212830911,"tx":3},"fAbQ4GrjYnuIv4xU":{"id":"fAbQ4GrjYnuIv4xU","type":"folder","name":"Baekjoon","parentId":null,"hash":-1356482200,"tx":3},"fazmhohPrMfu2qvK":{"id":"fazmhohPrMfu2qvK","type":"file","name":"2023-05-19-AWS 컴퓨팅 서비스 EC2","parentId":"G2bkxcGIHGuRm29Z","hash":689709418,"tx":3},"fuIXk253HaqdwDFg":{"id":"fuIXk253HaqdwDFg","type":"file","name":"2021-09-08-머신러닝_DecisionTree","parentId":"zaeb9S3ugI5mUe9I","hash":1525742621,"tx":3},"iXzCHT0T4V83pjgR":{"id":"iXzCHT0T4V83pjgR","type":"file","name":"2022-10-27-스프링 입문_스프링 빈과 의존관계","parentId":"ijBr8Otur9vUslbg","hash":-1427231430,"tx":3},"ifp1fePK1xXUjFE4":{"id":"ifp1fePK1xXUjFE4","type":"folder","name":"개발 상식","parentId":null,"hash":490725099,"tx":3},"ijBr8Otur9vUslbg":{"id":"ijBr8Otur9vUslbg","type":"folder","name":"SpringBoot","parentId":null,"hash":-859387906,"tx":3},"ilIvoK9bdEIgCIvn":{"id":"ilIvoK9bdEIgCIvn","type":"folder","name":"Spring","parentId":null,"hash":-987818004,"tx":3},"jFo1UfZG6pqBFoBN":{"id":"jFo1UfZG6pqBFoBN","type":"file","name":"2022-04-12-스프링 입문_프로젝트 환경설정","parentId":"ijBr8Otur9vUslbg","hash":-1091281159,"tx":3},"jWIAbpACKd6mffUH":{"id":"jWIAbpACKd6mffUH","type":"file","name":"2021-08-10-알고리즘_MergeSort","parentId":"CXkDYxCp5Qq9ere0","hash":1801094026,"tx":3},"jfgRCpZEYsDIHUmY":{"id":"jfgRCpZEYsDIHUmY","type":"file","name":"2022-05-10-백준2206번","parentId":"lrjscqeSvZS8Oz9S","hash":1472692907,"tx":3},"kRBjdpE8Q87pKDBk":{"id":"kRBjdpE8Q87pKDBk","type":"file","name":"2023-02-24-HTTP 상태코드(3) - 4xx ( Client Error ) , 5xx ( Server Error )","parentId":"9CXoipIqNc6euydo","hash":1802560240,"tx":3},"lrjscqeSvZS8Oz9S":{"id":"lrjscqeSvZS8Oz9S","type":"folder","name":"Graph","parentId":"fAbQ4GrjYnuIv4xU","hash":-870530307,"tx":3},"mXfQrwQgdNgA8wLp":{"id":"mXfQrwQgdNgA8wLp","type":"file","name":"2022-08-17-CRUD란","parentId":"ifp1fePK1xXUjFE4","hash":-1853804916,"tx":3},"miFoxjEkLW2xg652":{"id":"miFoxjEkLW2xg652","type":"file","name":"BuyBooks 세부사항","parentId":"3fRCd89AZkTI6CKF","hash":-150538633,"tx":3},"mnof4lJop1YAYqO6":{"id":"mnof4lJop1YAYqO6","type":"file","name":"2022-01-21-백준14500번","parentId":"U3QLvyaFPGVPjqhG","hash":-1153553870,"tx":3},"mqHezxUzK3yVL3FH":{"id":"mqHezxUzK3yVL3FH","type":"file","name":"2021-08-19-백준11651번","parentId":"U3QLvyaFPGVPjqhG","hash":-560344431,"tx":3},"nXXCz6aLiQ6QA2QE":{"id":"nXXCz6aLiQ6QA2QE","type":"file","name":"2022-04-19-백준14502번","parentId":"lrjscqeSvZS8Oz9S","hash":-1130154517,"tx":3},"nfsPiciyqnl9eDk3":{"id":"nfsPiciyqnl9eDk3","type":"file","name":"2021-08-13-백준10989번","parentId":"U3QLvyaFPGVPjqhG","hash":901223150,"tx":3},"ni3ScMP3VaGaeIOQ":{"id":"ni3ScMP3VaGaeIOQ","type":"file","name":"2021-12-30-백준11052번","parentId":"qu70Oe3aus3CVeFP","hash":-1745413078,"tx":3},"oPPKCabe4PCAuTpL":{"id":"oPPKCabe4PCAuTpL","type":"file","name":"2021-09-16-백준11656번","parentId":"BUPXu7gnwQkTDAja","hash":-269785357,"tx":3},"p9UokYwup7mYh1M9":{"id":"p9UokYwup7mYh1M9","type":"file","name":"2021-07-31-백준9020번","parentId":"U3QLvyaFPGVPjqhG","hash":86713463,"tx":3},"pDeZuAQGE7zRuhXc":{"id":"pDeZuAQGE7zRuhXc","type":"file","name":"2021-07-19-백준1152번","parentId":"U3QLvyaFPGVPjqhG","hash":-1797000551,"tx":3},"qu70Oe3aus3CVeFP":{"id":"qu70Oe3aus3CVeFP","type":"folder","name":"DP","parentId":"fAbQ4GrjYnuIv4xU","hash":-1018786741,"tx":3},"rCaBeFyH6dZGb5Ou":{"id":"rCaBeFyH6dZGb5Ou","type":"file","name":"Messenger","parentId":"3fRCd89AZkTI6CKF","hash":1610790565,"tx":3},"s15Pyg21tX1o16W5":{"id":"s15Pyg21tX1o16W5","type":"file","name":"OJeomMo","parentId":"3fRCd89AZkTI6CKF","hash":1478414972,"tx":3},"sJA3I2YlEcsXd7KN":{"id":"sJA3I2YlEcsXd7KN","type":"file","name":"2021-07-23-백준2292번","parentId":"U3QLvyaFPGVPjqhG","hash":-780439082,"tx":3},"tUKHjSE4AzMkDcu6":{"id":"tUKHjSE4AzMkDcu6","type":"file","name":"2021-07-23-백준2775번","parentId":"U3QLvyaFPGVPjqhG","hash":941122060,"tx":3},"tyTfzmPd7F6kUOPq":{"id":"tyTfzmPd7F6kUOPq","type":"file","name":"2021-08-02-백준11729번","parentId":"U3QLvyaFPGVPjqhG","hash":1911254155,"tx":3},"uvNLKPUHyvxwNYwJ":{"id":"uvNLKPUHyvxwNYwJ","type":"folder","name":"RA","parentId":null,"hash":-1927663762,"tx":3},"v5e2bsf3UmIOg5eS":{"id":"v5e2bsf3UmIOg5eS","type":"folder","name":"인턴","parentId":null,"hash":-1361495365,"tx":3},"vznoAKrCVFYxkwJ0":{"id":"vznoAKrCVFYxkwJ0","type":"file","name":"2022-08-26-4주차인턴일기","parentId":"v5e2bsf3UmIOg5eS","hash":1530715701,"tx":3},"wmLsksMuEWVovfap":{"id":"wmLsksMuEWVovfap","type":"file","name":"2022-05-13-스프링 입문_정적컨텐츠","parentId":"ijBr8Otur9vUslbg","hash":-445600894,"tx":3},"yUIaIw4G8JNVFyuC":{"id":"yUIaIw4G8JNVFyuC","type":"folder","name":"블로그 운영","parentId":null,"hash":238656380,"tx":3},"yZcqkNTKpThPrnfx":{"id":"yZcqkNTKpThPrnfx","type":"file","name":"2023-07-03-스프링 컨테이너","parentId":"ilIvoK9bdEIgCIvn","hash":-826574305,"tx":3},"ybpPTUQRubuccvNK":{"id":"ybpPTUQRubuccvNK","type":"file","name":"2021-07-19-백준1712번","parentId":"U3QLvyaFPGVPjqhG","hash":1085763407,"tx":3},"ygsX3wnSWEPl4aQH":{"id":"ygsX3wnSWEPl4aQH","type":"file","name":"2023-02-19-HTTP 메세지","parentId":"9CXoipIqNc6euydo","hash":148505139,"tx":3},"ysh4WSkm4ITJnEGN":{"id":"ysh4WSkm4ITJnEGN","type":"file","name":"2021-07-14-백준8958번","parentId":"U3QLvyaFPGVPjqhG","hash":-2028399411,"tx":3},"zaeb9S3ugI5mUe9I":{"id":"zaeb9S3ugI5mUe9I","type":"folder","name":"Machine Learning","parentId":null,"hash":-1994256298,"tx":3},"zwQGgTuOeVYHa8VM":{"id":"zwQGgTuOeVYHa8VM","type":"file","name":"2021-08-10-백준2751번","parentId":"U3QLvyaFPGVPjqhG","hash":1637116683,"tx":3},"dataSyncData":{"id":"dataSyncData","type":"data","data":{"settings":{"id":"1xO0KSHdTTwsefBGrZKKBG-Ylyu-ONF5MAoS2U2ziNhIYDsPduA","itemId":"settings","type":"data","hash":-1377341055},"badgeCreations":{"id":"1xy3XCpqypITO1oLCga4eijjXH0VB-kDEZMC_DkmcU_S79_n2bA","itemId":"badgeCreations","type":"data","hash":50628595}},"hash":-497524401,"tx":5},"fuIXk253HaqdwDFg/content":{"id":"fuIXk253HaqdwDFg/content","type":"content","text":"---\ntitle: \"[머신러닝] [Python] 1. Decision Trees (결정 트리)\"\ndate: 2021-09-06 02:00:00\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- \n---\n\n## Decision Tree란\n\n**Decision Tree (결정 트리, 의사결정트리, 의사결정나무)** 는 **분류(Classification)와 회귀(Regression)**이 모두 가능한 지도 학습 모델(Supervised Learning) 중 하나이다. 이러한 특성 때문에 **CART(Classification and Regression Tree) 알고리즘**의 하나이기도 하다. 결정 트리는 예/아니오 질문을 이어가며 학습하는데 예를 들어 매, 펭귄, 돌고래, 곰을 구분한다고 보자. 매와 펭귄은 날개가 있고, 돌고래와 곰은 날개가 없다. 날개가 있나요? 라는 질문을 통해 매, 펭귄 / 돌고래, 곰 으로 집단을 나눌 수 있다. 매와 펭귄은 날 수 있나요? 라는 질문을 통해 매 / 펭귄으로 나눌 수 있고 돌고래와 곰은 지느러미가 있나요? 라는 질문을 통해 나눌 수 있다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/%EA%B2%B0%EC%A0%95%ED%8A%B8%EB%A6%AC.png?raw=true\">\n</p>\n\n이렇게 특정 기준에 따라 데이터를 구분하는 모델을 트리 모델이라고 한다. 한번의 분기마다 영역을 여러개로 나누고 이때 기준 하나하나를 노드(Node)라고 한다. 맨 처음 분류 기준을 Root Node라고 하며 맨 마지막 노드를 Leaf Node라고 한다.\n\n<br><br><br><br><br><br>\n\n## 트리를 어떻게 나눌까?\n트리구조를 만들기 위해서는 고려해야할 사항이 몇가지 있다.\n<br>\n\n**1. 데이터를 나누는 기준**\n\t\t\n**2. Determine the Best Split**\n\n크게 보면 이렇게 두가지 인데 먼저 첫번째 고려사항부터 살펴보자.\n\n<br><br><br><br><br><br>\n\n### 1. 데이터를 나누는 기준\n<hr>\n데이터를 나누는 기준은 **1. 데이터 타입**과 **2. 나눌 가짓수** 에 따라 나눈다.\n\n- **1.데이터 타입**\n\t - **Categorical attribute ( 문자 )**\n\t\t - nominal attribute ( 순서가 없는 데이터)\n\t\t - ordinal attribute ( 순서가 있는 데이터 ex) \"S, M, L, XL\" )\t \n\t -  **Continuous arrtibute ( 숫자 )**\n\t\t - Discretization (이산화)\n\t\t - Binary Decision\n\n<br>\n\n\n- **2.나눌 가짓수**\n\t- **2-way split**\n\t- **multi-way split**\n\n<br><br><br><br><br><br>\n\n### 2. Determine the Best Split \n종류가 같은 / 비슷한 class로 분배하는것이 가장 적절하다. 여기서 class란 target과 같은 의미이다. 이는 데이터의 **impurity**가 낮다는것을 의미한다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/split.jpg?raw=true)\n\n<br><br><br><br><br><br>\n\n## 노드의 Impurity(불순도)\n\n### 1. Entropy\n불순도를 수치화한 지표 중 하나이며 엔트로피의 값에 따라 Decision Tree의 분류가 일어난다.\n\n**Entropy가 0일 경우,** 개체의 속성이 모두 동일하다. 즉 분류가 필요없다.\n\n**Entropy가 1에 가까울 경우,** 불순도가 높다.\n\n**Entropy가 0에 가까울 경우,** 불순도가 낮다.\n\n한마디로 **Impurity와 Entropy는 비례관계**라고 볼 수 있다.\n\n엔트로피의 계산공식은 아래와 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/entropy.png?raw=true\">\n</p>\n\n\n<br><br><br><br><br><br>\n\n### 2. Gini Index ( 지니계수 )\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/gini1.jpg?raw=true)\n\n불순도를 측정하는 지표로 통계적 분산정도를 정량화하여 표현한 값이다.\n\n지니계수가 클수록 데이터가 equally distributed, 즉 비효율적으로 분산된것이고\n**지니계수가 작을수록 데이터가 가장 이상적으로 분산된 것을 의미한다.**\n\n지니계수의 계산은 아래 그림과 같다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/gini2.jpg?raw=true)\n\n<br><br><br><br><br><br>\n\n**※ 그렇다면 Gini Index를 이용해서 Split의 기준을 정할 때 \n아래 그림처럼 Gini Index를 비교하는 방법을 무엇일까?**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ginigain.jpg?raw=true\">\n</p>\n\nA와 B 둘중 어떤 것이 더 잘 분기된것인지를 알기 위해선 **Gini Gain**을 활용해야 한다.\n\n<br><br><br><br><br><br>\n\n### 2-1. Gini Gain\nGini Gain은 각 데이터의 Gini Index를 비교하기 위한 수치이다.\n\n좀 더 쉬운 이해를 위해 예제와 함께 살펴보자.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/ginigain3.jpg?raw=true)![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/ginigain2.jpg?raw=true)  \n\n분기 이전 원래 데이터의 Gini 계수 :\n**Gini(Parent) = 1 - (6/12)<sup>2</sup> - (6/12)<sup>2</sup> = 0.5**\n\nN1의 Gini 계수 :\n**Gini(N1) = 1 - (5/7)<sup>2</sup> - (2/7)<sup>2</sup> = 0.41**\n\nN2의 Gini 계수 :\n**Gini(N2) = 1 - (1/5)<sup>2</sup> - (4/5)<sup>2</sup> = 0.32**\n\nGini Gain을 활용한 분기 이후 Gini 계수 :\n**Gini(children) = 7/12 x 0.41 + 5/12 x 0.32 = 0.372**\n\n<br><br><br><br><br><br>\n\n### 3. Classification Error (분류 오차)\n지니계수와 거의 비슷하지만 조금더 단순하고 간단하다. 어려운 내용은 아니니 예제로 바로 설명해보겠다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/cla.jpg?raw=true\">\n</p>\n\nC1과 C2의 Error값을 각각 계산해주고 둘중 더 큰값을 1에서 빼주면 되는 간단한 수식이다.\n\nClassification Error는 간단하게 계산 가능하다는 장점이 있지만 Gini Index보다는 Impurity를 판단하는 정확도가 떨어진다는 단점이 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1085769069,"tx":7},"fuIXk253HaqdwDFg/syncedContent":{"id":"fuIXk253HaqdwDFg/syncedContent","type":"syncedContent","historyData":{"-1085769069":{"id":"fuIXk253HaqdwDFg/content","type":"content","text":"---\ntitle: \"[머신러닝] [Python] 1. Decision Trees (결정 트리)\"\ndate: 2021-09-06 02:00:00\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- \n---\n\n## Decision Tree란\n\n**Decision Tree (결정 트리, 의사결정트리, 의사결정나무)** 는 **분류(Classification)와 회귀(Regression)**이 모두 가능한 지도 학습 모델(Supervised Learning) 중 하나이다. 이러한 특성 때문에 **CART(Classification and Regression Tree) 알고리즘**의 하나이기도 하다. 결정 트리는 예/아니오 질문을 이어가며 학습하는데 예를 들어 매, 펭귄, 돌고래, 곰을 구분한다고 보자. 매와 펭귄은 날개가 있고, 돌고래와 곰은 날개가 없다. 날개가 있나요? 라는 질문을 통해 매, 펭귄 / 돌고래, 곰 으로 집단을 나눌 수 있다. 매와 펭귄은 날 수 있나요? 라는 질문을 통해 매 / 펭귄으로 나눌 수 있고 돌고래와 곰은 지느러미가 있나요? 라는 질문을 통해 나눌 수 있다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/%EA%B2%B0%EC%A0%95%ED%8A%B8%EB%A6%AC.png?raw=true\">\n</p>\n\n이렇게 특정 기준에 따라 데이터를 구분하는 모델을 트리 모델이라고 한다. 한번의 분기마다 영역을 여러개로 나누고 이때 기준 하나하나를 노드(Node)라고 한다. 맨 처음 분류 기준을 Root Node라고 하며 맨 마지막 노드를 Leaf Node라고 한다.\n\n<br><br><br><br><br><br>\n\n## 트리를 어떻게 나눌까?\n트리구조를 만들기 위해서는 고려해야할 사항이 몇가지 있다.\n<br>\n\n**1. 데이터를 나누는 기준**\n\t\t\n**2. Determine the Best Split**\n\n크게 보면 이렇게 두가지 인데 먼저 첫번째 고려사항부터 살펴보자.\n\n<br><br><br><br><br><br>\n\n### 1. 데이터를 나누는 기준\n<hr>\n데이터를 나누는 기준은 **1. 데이터 타입**과 **2. 나눌 가짓수** 에 따라 나눈다.\n\n- **1.데이터 타입**\n\t - **Categorical attribute ( 문자 )**\n\t\t - nominal attribute ( 순서가 없는 데이터)\n\t\t - ordinal attribute ( 순서가 있는 데이터 ex) \"S, M, L, XL\" )\t \n\t -  **Continuous arrtibute ( 숫자 )**\n\t\t - Discretization (이산화)\n\t\t - Binary Decision\n\n<br>\n\n\n- **2.나눌 가짓수**\n\t- **2-way split**\n\t- **multi-way split**\n\n<br><br><br><br><br><br>\n\n### 2. Determine the Best Split \n종류가 같은 / 비슷한 class로 분배하는것이 가장 적절하다. 여기서 class란 target과 같은 의미이다. 이는 데이터의 **impurity**가 낮다는것을 의미한다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/split.jpg?raw=true)\n\n<br><br><br><br><br><br>\n\n## 노드의 Impurity(불순도)\n\n### 1. Entropy\n불순도를 수치화한 지표 중 하나이며 엔트로피의 값에 따라 Decision Tree의 분류가 일어난다.\n\n**Entropy가 0일 경우,** 개체의 속성이 모두 동일하다. 즉 분류가 필요없다.\n\n**Entropy가 1에 가까울 경우,** 불순도가 높다.\n\n**Entropy가 0에 가까울 경우,** 불순도가 낮다.\n\n한마디로 **Impurity와 Entropy는 비례관계**라고 볼 수 있다.\n\n엔트로피의 계산공식은 아래와 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/entropy.png?raw=true\">\n</p>\n\n\n<br><br><br><br><br><br>\n\n### 2. Gini Index ( 지니계수 )\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/gini1.jpg?raw=true)\n\n불순도를 측정하는 지표로 통계적 분산정도를 정량화하여 표현한 값이다.\n\n지니계수가 클수록 데이터가 equally distributed, 즉 비효율적으로 분산된것이고\n**지니계수가 작을수록 데이터가 가장 이상적으로 분산된 것을 의미한다.**\n\n지니계수의 계산은 아래 그림과 같다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/gini2.jpg?raw=true)\n\n<br><br><br><br><br><br>\n\n**※ 그렇다면 Gini Index를 이용해서 Split의 기준을 정할 때 \n아래 그림처럼 Gini Index를 비교하는 방법을 무엇일까?**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ginigain.jpg?raw=true\">\n</p>\n\nA와 B 둘중 어떤 것이 더 잘 분기된것인지를 알기 위해선 **Gini Gain**을 활용해야 한다.\n\n<br><br><br><br><br><br>\n\n### 2-1. Gini Gain\nGini Gain은 각 데이터의 Gini Index를 비교하기 위한 수치이다.\n\n좀 더 쉬운 이해를 위해 예제와 함께 살펴보자.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/ginigain3.jpg?raw=true)![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/ginigain2.jpg?raw=true)  \n\n분기 이전 원래 데이터의 Gini 계수 :\n**Gini(Parent) = 1 - (6/12)<sup>2</sup> - (6/12)<sup>2</sup> = 0.5**\n\nN1의 Gini 계수 :\n**Gini(N1) = 1 - (5/7)<sup>2</sup> - (2/7)<sup>2</sup> = 0.41**\n\nN2의 Gini 계수 :\n**Gini(N2) = 1 - (1/5)<sup>2</sup> - (4/5)<sup>2</sup> = 0.32**\n\nGini Gain을 활용한 분기 이후 Gini 계수 :\n**Gini(children) = 7/12 x 0.41 + 5/12 x 0.32 = 0.372**\n\n<br><br><br><br><br><br>\n\n### 3. Classification Error (분류 오차)\n지니계수와 거의 비슷하지만 조금더 단순하고 간단하다. 어려운 내용은 아니니 예제로 바로 설명해보겠다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/cla.jpg?raw=true\">\n</p>\n\nC1과 C2의 Error값을 각각 계산해주고 둘중 더 큰값을 1에서 빼주면 되는 간단한 수식이다.\n\nClassification Error는 간단하게 계산 가능하다는 장점이 있지만 Gini Index보다는 Impurity를 판단하는 정확도가 떨어진다는 단점이 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1085769069}},"syncHistory":{"main":[-1085769069,null,null]},"v":1,"hash":1710111498307,"tx":7},"f5vTQlCLsBu2JtIV/content":{"id":"f5vTQlCLsBu2JtIV/content","type":"content","text":"---\ntitle: \"[머신러닝] [Python] 2. Decision Trees Regression (결정 트리 회기)\"\ndate: 2021-09-09 02:00:00\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- \n---\n\n## Decision Tree For Regression\n\n - **ID3 알고리즘**\n\t Categorical 속성값을 갖는 데이터에 대한 결정트리 학습\n\t \n - **C4.5 알고리즘**\n\t Categorical 속성값과 numerical 속성값을 갖는 데이터에 대한 결정트리 학습. ID3를 개선한 알고리즘이다.\n\t \n - **CART 알고리즘**\n\t Numerical 속성값을 갖는 데이터에 대한 결정트리 학습\n\t \n<br><br><br><br><br><br>\n\n## ID3 알고리즘\n\n1986년 로스 퀸란에 의해 개발된 ID3는 결정 트리의 가장 초창기 모델 중 하나이다. 결정 트리의 핵심은 변별력이 좋은 질문을 위에서 부터 하나하나 세팅하는 것인데, 이를 위해 ID3는 Information Gain과 엔트로피 그리고 Standard Deviation Reduction(표준편차)를 활용한다.\n이 포스팅에서는 일반적으로 쓰이는 **엔트로피를 활용한 ID3가 아닌 Standard Deviation Reduction을 활용한 ID3를 소개하겠다.**\n\n<br><br><br><br><br><br>\n\n## Building a Decision Tree for Regression ( STEP )\n데이터셋이 주어지고 해당 데이터셋을 SDR을 활용해 Decision Tree로 변환하는 과정을 보면서 설명해보겠다.\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ex1.jpg?raw=true\">\n</p>\n\nOutlook, Temp, Humidity, Windy가 Predictors이고 Hours Played가 Target 데이터이다. Target 데이터가 Numerical 데이터라는걸 잘 염두해 둬야한다.\n\n<br><br><br><br><br><br>\n\n### STEP 1\n<hr>\n**Root 노드를 어떤 predictor로 할지 결정해야만 한다.**\n\n이를 위해선 **각 predictor의 SD(Standard Deviation)를 계산**해준뒤 \n\n**SDR(Standard Deviation Reduction)이 가장 큰 요소**를 선택하면 된다.\n\n이때 **SDR = (Target의 SD - 각 Predictor의 SD)**를 말한다.\n\n<br><br><br><br><br><br>\n\n### STEP 2\n<hr>\n**Target 데이터의 SD값을 계산해준다.**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step2.jpg?raw=true\">\n</p>\n주어진 데이터의 **SD = 9.32**이다.\n\n이때 **SD는 Decision Tree의 Branching, 즉 분기를 위해 사용하는 값**이고,\n\n**CV와 Count는 Branching을 계속 할지 말지를 결정하기 위해 사용하는 값,**\n\n**Average는 Tree가 완성되면 Leaf Node에 적어줄 값**을 의미한다.\n\n이 부분에 대해서는 STEP을 넘어가면서 차차 설명 하겠다.\n\n<br><br><br><br><br><br>\n\n### STEP 3\n<hr>\n**하나의 Predictor에 대한 SD값을 구한다. 이때 Predictor에 속한 모든 요소들의 SD를 각각 구한뒤 Count에 따라 가중치를 주고 Predictor의 SD를 구한다.**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step3.jpg?raw=true\">\n</p>\n\n위의 그림처럼 하나의 Predictor (Outlook) 에서 Overcast, Rainy, Sunny 요소의 SD를 각각 구해준 뒤 가중치를 이용해 Outlook의 SD를 구해줘야 한다.\n\n**SD(Outlook) = (4/14) x 3.49 + (5/14) x 7.78 + (5/14) x 10.87 = 7.66**\n\n<br><br><br><br><br><br>\n\n### STEP 4\n<hr>\nSTEP3의 방식으로 다른 모든 Predictor들에 대한 SD를 구한뒤 Target과의 SDR을 구해서 SDR이 가장 큰값을 Root Node로 선정한다!\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step4.jpg?raw=true\">\n</p>\n\nTarget인 Played Hours 의 SD가 9.32이고 Overcast 의 SD가 7.66이므로\n\nOutlook의 SDR이 1.66으로 가장 크다.\n\n이때문에 Outlook을 Root Node로 선정한다.\n<br><br><br><br><br><br>\n\n### STEP 5\n<hr>\nOutlook을 Root Node로 한 초기 Decision Tree는 다음과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step5.jpg?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n### STEP 6\n<hr>\n이제 똑같은 과정을 반복해서 Branching을 할건데 여기에 termination criteria( 가지치기 종료 기준)를 설정해주겠다.\n\n1. **Coefficient of Deviation (CV)** 가 10%보다 작아지는 경우\n2. 데이터의 수가 **Threshold(3)**보다 작거나 같아지는 경우\n\n위의 기준은 사용자에 따라 다르게 설정할 수 있다.\n\n<br><br><br><br><br><br>\n\n### STEP 7\n이제 각각의 요소에 대해서 Termination criteria를 비교하면서\n branching을 더 할지 말지 결정해 보는 과정이다.\n\n**[ Overcast ]**\n\n**SD(Hours Played) = 3.49**\n\n**Average(Hours Played) = (43 + 43 + 52 + 44) / 4 = 46.3**\n\n**CV(Hours Played) = SD / AVG x 100 = 3.49 / 46.3 x 100 = 7.53% ( 약 8 % )**\n\nCV가 10%보다 작아지는 경우 Branching을 멈추는것으로 설정했으므로\nOutlook의 Overcast같은 경우는 더이상 Branching을 멈추고\n**Target value의 평균값인 46.3을 Leaf node로 가진다.**\n\nRainy와 Sunny는 CV가 10보다 크고 Count도 3보다 크므로 Branching을 계속한다.\n\n<br><br><br><br><br><br>\n\n### STEP 8\n<hr>\n나머지 Predictor인 Temp, Humidity, Windy에도 위와같은 과정을 거쳐 Branching 해준다.\n\n<br><br><br><br><br><br>\n\n### STEP 9\n<hr>\n최종 **Decision Tree**를 구현한다!\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step9.jpg?raw=true\">\n</p>\n\n","properties":"\n","discussions":{},"comments":{},"hash":730747747,"tx":9},"f5vTQlCLsBu2JtIV/syncedContent":{"id":"f5vTQlCLsBu2JtIV/syncedContent","type":"syncedContent","historyData":{"730747747":{"id":"f5vTQlCLsBu2JtIV/content","type":"content","text":"---\ntitle: \"[머신러닝] [Python] 2. Decision Trees Regression (결정 트리 회기)\"\ndate: 2021-09-09 02:00:00\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- \n---\n\n## Decision Tree For Regression\n\n - **ID3 알고리즘**\n\t Categorical 속성값을 갖는 데이터에 대한 결정트리 학습\n\t \n - **C4.5 알고리즘**\n\t Categorical 속성값과 numerical 속성값을 갖는 데이터에 대한 결정트리 학습. ID3를 개선한 알고리즘이다.\n\t \n - **CART 알고리즘**\n\t Numerical 속성값을 갖는 데이터에 대한 결정트리 학습\n\t \n<br><br><br><br><br><br>\n\n## ID3 알고리즘\n\n1986년 로스 퀸란에 의해 개발된 ID3는 결정 트리의 가장 초창기 모델 중 하나이다. 결정 트리의 핵심은 변별력이 좋은 질문을 위에서 부터 하나하나 세팅하는 것인데, 이를 위해 ID3는 Information Gain과 엔트로피 그리고 Standard Deviation Reduction(표준편차)를 활용한다.\n이 포스팅에서는 일반적으로 쓰이는 **엔트로피를 활용한 ID3가 아닌 Standard Deviation Reduction을 활용한 ID3를 소개하겠다.**\n\n<br><br><br><br><br><br>\n\n## Building a Decision Tree for Regression ( STEP )\n데이터셋이 주어지고 해당 데이터셋을 SDR을 활용해 Decision Tree로 변환하는 과정을 보면서 설명해보겠다.\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ex1.jpg?raw=true\">\n</p>\n\nOutlook, Temp, Humidity, Windy가 Predictors이고 Hours Played가 Target 데이터이다. Target 데이터가 Numerical 데이터라는걸 잘 염두해 둬야한다.\n\n<br><br><br><br><br><br>\n\n### STEP 1\n<hr>\n**Root 노드를 어떤 predictor로 할지 결정해야만 한다.**\n\n이를 위해선 **각 predictor의 SD(Standard Deviation)를 계산**해준뒤 \n\n**SDR(Standard Deviation Reduction)이 가장 큰 요소**를 선택하면 된다.\n\n이때 **SDR = (Target의 SD - 각 Predictor의 SD)**를 말한다.\n\n<br><br><br><br><br><br>\n\n### STEP 2\n<hr>\n**Target 데이터의 SD값을 계산해준다.**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step2.jpg?raw=true\">\n</p>\n주어진 데이터의 **SD = 9.32**이다.\n\n이때 **SD는 Decision Tree의 Branching, 즉 분기를 위해 사용하는 값**이고,\n\n**CV와 Count는 Branching을 계속 할지 말지를 결정하기 위해 사용하는 값,**\n\n**Average는 Tree가 완성되면 Leaf Node에 적어줄 값**을 의미한다.\n\n이 부분에 대해서는 STEP을 넘어가면서 차차 설명 하겠다.\n\n<br><br><br><br><br><br>\n\n### STEP 3\n<hr>\n**하나의 Predictor에 대한 SD값을 구한다. 이때 Predictor에 속한 모든 요소들의 SD를 각각 구한뒤 Count에 따라 가중치를 주고 Predictor의 SD를 구한다.**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step3.jpg?raw=true\">\n</p>\n\n위의 그림처럼 하나의 Predictor (Outlook) 에서 Overcast, Rainy, Sunny 요소의 SD를 각각 구해준 뒤 가중치를 이용해 Outlook의 SD를 구해줘야 한다.\n\n**SD(Outlook) = (4/14) x 3.49 + (5/14) x 7.78 + (5/14) x 10.87 = 7.66**\n\n<br><br><br><br><br><br>\n\n### STEP 4\n<hr>\nSTEP3의 방식으로 다른 모든 Predictor들에 대한 SD를 구한뒤 Target과의 SDR을 구해서 SDR이 가장 큰값을 Root Node로 선정한다!\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step4.jpg?raw=true\">\n</p>\n\nTarget인 Played Hours 의 SD가 9.32이고 Overcast 의 SD가 7.66이므로\n\nOutlook의 SDR이 1.66으로 가장 크다.\n\n이때문에 Outlook을 Root Node로 선정한다.\n<br><br><br><br><br><br>\n\n### STEP 5\n<hr>\nOutlook을 Root Node로 한 초기 Decision Tree는 다음과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step5.jpg?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n### STEP 6\n<hr>\n이제 똑같은 과정을 반복해서 Branching을 할건데 여기에 termination criteria( 가지치기 종료 기준)를 설정해주겠다.\n\n1. **Coefficient of Deviation (CV)** 가 10%보다 작아지는 경우\n2. 데이터의 수가 **Threshold(3)**보다 작거나 같아지는 경우\n\n위의 기준은 사용자에 따라 다르게 설정할 수 있다.\n\n<br><br><br><br><br><br>\n\n### STEP 7\n이제 각각의 요소에 대해서 Termination criteria를 비교하면서\n branching을 더 할지 말지 결정해 보는 과정이다.\n\n**[ Overcast ]**\n\n**SD(Hours Played) = 3.49**\n\n**Average(Hours Played) = (43 + 43 + 52 + 44) / 4 = 46.3**\n\n**CV(Hours Played) = SD / AVG x 100 = 3.49 / 46.3 x 100 = 7.53% ( 약 8 % )**\n\nCV가 10%보다 작아지는 경우 Branching을 멈추는것으로 설정했으므로\nOutlook의 Overcast같은 경우는 더이상 Branching을 멈추고\n**Target value의 평균값인 46.3을 Leaf node로 가진다.**\n\nRainy와 Sunny는 CV가 10보다 크고 Count도 3보다 크므로 Branching을 계속한다.\n\n<br><br><br><br><br><br>\n\n### STEP 8\n<hr>\n나머지 Predictor인 Temp, Humidity, Windy에도 위와같은 과정을 거쳐 Branching 해준다.\n\n<br><br><br><br><br><br>\n\n### STEP 9\n<hr>\n최종 **Decision Tree**를 구현한다!\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/step9.jpg?raw=true\">\n</p>\n\n","properties":"\n","discussions":{},"comments":{},"hash":730747747}},"syncHistory":{"main":[730747747,null,null]},"v":1,"hash":1710111499456,"tx":9},"DYReayvPEWh2qfnj/syncedContent":{"id":"DYReayvPEWh2qfnj/syncedContent","type":"syncedContent","historyData":{"-1865698563":{"id":"DYReayvPEWh2qfnj/content","type":"content","text":"---\ntitle: \"[머신러닝] [Python] 3. Logistic Regression (로지스틱 회귀)\"\ndate: 2021-09-14 02:00:00\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- Regression\n- Linear Regression\n- Logistic Regression\n---\n\n이번 포스팅에서는 Categorical 변수를 예측하는 모델인 Logistic Regression ( 로지스틱 회귀)에 대해 살펴보겠습니다. 포스팅에서 사용된 자료에 대해서는 가천대학교 소프트웨어학과 김원 교수님의 강의를 기반으로 작성되었음을 밝힙니다.\n\n<br><br><br><br><br><br>\n\n# Linear Regression ( 선형 회귀 )\n<hr>\nLogistic Regression에 대한 설명에 앞서 기본적인 이해를 위해 선형 회귀에 대해서 간단하게 알아보겠습니다. \n\n<br><br><br><br><br><br>\n\n시험 공부하는 시간을 늘리면 늘릴 수록 성적이 잘 나옵니다. 하루에 걷는 횟수를 늘릴 수록, 몸무게는 줄어듭니다. 집의 평수가 클수록, 집의 매매 가격은 비싼 경향이 있습니다. 이는 수학적으로 생각해보면 어떤 요인의 수치에 따라서 특정 요인의 수치가 영향을 받고있다고 말할 수 있습니다. 조금 더 수학적인 표현을 써보면 어떤 변수의 값에 따라서 특정 변수의 값이 영향을 받고 있다고 볼 수 있습니다. 다른 변수의 값을 변하게 하는 변수를 x, 변수 x에 의해서 값이 종속적으로 변하는 변수 y라고 해봅시다.\n\n이때 변수 x의 값은 독립적으로 변할 수 있는 것에 반해, y값은 계속해서 x의 값에 의해서, 종속적으로 결정되므로 **x를 독립 변수**, **y를 종속 변수**라고도 합니다. **선형 회귀**는 **한 개 이상의 독립 변수 x와 y의 선형 관계**를 모델링합니다. 만약, **독립 변수 x가 1개라면 단순 선형 회귀**라고 합니다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/linear.jpg?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n생각해보니 집의 매매가격은 단순히 집의 평수가 크다고 결정되는 것이 아니라, 집의 층수, 방의 개수, 역세권인지 아닌지 등 여러가지 요소에 영향을 많이 받는것 같습니다. 이제 이러한 다수의 요소를 가지고 집의 매매 가격을 예측해 보고 싶습니다. y(집의 매매가격)는 여전히 1개이지만 x(층수, 방개수, 역세권 등)는 여러개가 되었습니다. 이를 **Multiple Linear Regression (다중 선형 회귀)**라고 부릅니다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/multi.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n# Logistic Regression ( 로지스틱 회귀)\n<hr>\n**Logistic Regression**은 데이터가 어떤 범주에 속할 확률을 0에서 1사이의 값으로 예측하고 그 확률에 따라 가능성이 더 높은 범주에 속하는 것으로 분류해주는 지도 학습 알고리즘이다.\n\n스펨 메일 분류기 같은 예시를 생각하면 쉬운데, 어떤 메일을 받았을 때 그 메일이 스팸일 확률이 0.5이상이면 스팸으로 분류하고, 메일이 스팸일 확률이 0.5보다 낮으면 일반 메일로 분류하는 것이다. 이렇게 데이터가 2개의 범주 중 하나에 속하도록 결정하는 것을 **Binary Classification (2진 분류)**라고 한다.\n\n로지스틱 회귀 역시 X와 Y의 관계식으로 설명 할 수 있는데, X는 **Binary(양분된), Categorical(범주형), Continuous(연속형)** 한 데이터 모두를 가질 수 있지만, Y는 **Binary**한 데이터만을 가질 수 있다.\n\n<br><br><br><br><br><br>\n\n예시를 보며 자세히 살펴보자.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/data.png?raw=true\">\n</p>\n\n**X로 Age**가 주어졌고 **Y로는 심장병 유무**가 주어진 데이터셋이다.\n\n<br><br><br>\n\n이를 **Linear Regression**으로 나타내면 아래 그림과 같다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/linear1.png?raw=true\">\n</p>\n한눈에 보기에도 이상하다. Y가 Binary한 데이터로 주어졌기 때문에 Linear Regression으로 표현하면 정확도가 떨어지는 문제가 발생한다. 이를 해결하기 위해 데이터셋을 일부 수정한 뒤  **Logistic Regression**으로 나타내 보겠다.\n\n<br><br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logic1.png?raw=true\">\n</p>\nX로 주어진 Age를 나이대별로 묶은 뒤 심장병에 걸린 사람수를 나타낸 데이터셋이다. 이를 **Logistic Regression**으로 나타내면 아래 그림과 같다.\n\n<br><br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logic2.png?raw=true\">\n</p>\nY값은 0~1사이의 값으로 표현되며 y<0.5일때는 0으로 치환되고 y>=0.5일때는 1로 치환되는 결과를 보여준다. 위의 그래프처럼 나타내는 것을 **Sigmoid Function** (시그모이드 함수) 이라고 부른다.\n\n**이처럼 Y가 Binary한 데이터로 주어질때는 Linear Regression을 사용하는 것 보다는 Logistic Regression을 사용하는 것이 훨씬 정확도가 높다.**\n\n<br><br><br><br><br><br>\n\n# Logit(로짓) - log + odds \n<hr>\nLogistic Regression을 구현하는 것은 어렵지 않다. 파이썬에 있는 scikit-learn 라이브러리를 사용하면 코드 몇줄로 바로 구현할 수 있다. 그러나 그 작동 원리를 알고 구현하는 것과 모른채 blackbox식으로 구현하는 것은 엄연히 다르다. Logistic Regression의 작동 원리를 공부하기 위해 선행되어 알아야만 하는 몇가지 Keyword를 소개하겠다.\n\n<br><br><br>\n\n## Odds\n**Odds**는 **어떤 사건이 발생할 확률을 발생하지 않을 확률로 나눈 값**을 의미한다. 어떤 사건이 일어날 확률을 p라고 했을때 **Odds값은 p / (1-p)** 이다.\n\n예를 들어 p가 0.2라면 Odds = 0.2 / (1 - 0.8) = 0.25 이다.\n<br><br><br>\n\n## Odds Ratio\nOdds Ratio는 두개의 Odds의 비율을 나타내는 값이다.\n\n예를들어 Odds1 = 0.25 이고 Odds2 = 0.30이면 Odds Ratio = 0.25 / 0.30 = 0.833이다.\n\n<br><br><br>\n\n## Logit\n사실상 Logit을 설명하기 위해 앞서 Odds와 Odds Ratio를 소개했다고 봐도 무방하다. \n\n확률 p의 Logit은 다음과 같이 정의된다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logit.jpg?raw=true\">\n</p>\n\n즉, Odds에 자연로그를 씌운 형태로 Logit이라는 말이 Log + Odds에서 나온말이다.\n\n예를들어, p=0.5라고 하면 Odds = 0.5 / 0.5 = 1, Logit = ln(1) = 0 이된다.\n\n<br><br><br>\n\n# Solver Algorithms for Logistic Regression \n<hr>\n파이썬의 Scikit-Learn에서는 다섯개의 알고리즘으로 Logic Regression을 해결한다. 각각의 알고리즘이 어떤식으로 동작하는지는 내용이 너무 방대하므로 설명하지 않겠고 그냥 이런게 있구나 하고 넘어가면 좋을 것 같다.\n\n - **newton-cg**\n - **lbfgs**\n - **liblinear**\n - **sag**\n - **saga**\n\n<br><br><br><br><br><br>\n\n# Logistic Regression Python Code\n<hr>\n\n이제 로지스틱 회귀를 파이썬으로 직접 구현하는 연습을 해보자.\n\n## 1. 데이터 불러오기\n먼저 seaborn에 내재된 타이타닉 데이터셋을 불러오도록 하자.\n```python\nimport seaborn as sns  \n  \npassengers = sns.load_dataset('titanic')  \nprint(passengers.shape)  \nprint(passengers.head())\n```\n\n<br><br><br>\n\n총 891명의 데이터가 있고 총 15개의 컬럼이 있는걸 확인했다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/res.png?raw=true\">\n</p>\n\n우리의 Target 데이터는 survived 이다. 살았는지 죽었는지 확인하는 컬럼이고 1은 생존, 0는 사망을 의미한다.\n\n<br><br><br>\n\n## 2. 데이터 전처리\n\n### 분석에 사용할 Feature 선택\n\n먼저 생존여부에 큰 영향을 미쳤을 것으로 예상되는 컬럼을 sex, age, pclass로 지정했다. 여성, 어린이, 1/2/3등석 순으로 살아남을 확률이 높다고 가정해본 것이다.\n\n<br><br><br>\n### 문자열을 숫자로 변환\nsex는 male과 female로 설정되있으므로 이를 숫자 데이터 1과 0으로 바꿔주자.\n여성이 살아남을 확률이 높을것으로 예상하므로 남성을 0, 여성을 1이라고 바꿔주자.\n```python\npassengers['sex'] = passengers['sex'].map({'female':1,'male':0})\n```\n\n<br><br><br>\n\n### 결측치 채워주기\n데이터를 살펴보면 age가 비어있는 경우가 있다. 이는 age의 평균치로 대체하겠다.\n```python\npassengers['age'].fillna(value=passengers['age'].mean(), inplace=True)\n```\n\n<br><br><br>\n### Feature 분리하기\npclass의 경우 1등석에 탔는지, 2등석에 탔는지 각각의 feature로 만들어주기 위해 컬럼을 새로 생성해 분류하겠다.\n```python\npassengers['FirstClass'] = passengers['pclass'].apply(lambda x: 1 if x == 1 else 0)  \npassengers['SecondClass'] = passengers['pclass'].apply(lambda x: 1 if x == 2 else 0)\n```\n\n```python\nfeatures = passengers[['sex', 'age', 'FirstClass', 'SecondClass']]  \nsurvival = passengers['survived']\n```\n<br><br><br>\n## 3. Train/Test set 분리하기\n```python\nfrom sklearn.model_selection import train_test_split  \n  \ntrain_features, test_features, train_labels, test_labels = train_test_split(features, survival)\n```\n<br><br><br>\n\n## 4. 데이터 정규화(Scaling) 하기\nStandardScaler를 사용해 데이터를 정규화 하였다.\n```python\nfrom sklearn.preprocessing import StandardScaler  \n  \nscaler = StandardScaler()  \n  \ntrain_features = scaler.fit_transform(train_features)  \ntest_features = scaler.transform(test_features)\n```\n<br><br><br>\n\n## 5. 모델 생성 및 평가하기\n```python\nfrom sklearn.linear_model import LogisticRegression  \n  \nmodel = LogisticRegression()  \nmodel.fit(train_features, train_labels)\n```\nmodel을 생성해 LogisticRegression 함수를 넣어주면 끝이다.\n\n<br><br><br>\n\n이제 학습세트로 정확도를 바로 알아보자.\n```python\nprint(model.score(train_features, train_labels))\n```\n\n\n결과 : \n```\n0.7919161676646707\n```\n\n79%의 정확도를 가진다고 나온다.\n\n<br><br><br>\n\nTest Set에서도 정확도를 확인해보자.\n```python\nprint(model.score(test_features, test_labels))\n```\n결과 : \n```\n0.766816143498\n```\n76%의 정확도를 가진다고 나온다.\n\n<br><br><br>\n\n이제 각 Feature들의 계수(Coefficients)를 확인해볼 차례이다. 어떤 Feature가 생존에 큰 영향을 주는지 확인해 볼 수 있다.\n```python\nprint(model.coef_)\n```\n결과 : \n```\n[[ 1.21512352 -0.34590989  0.99346516  0.49466482]]\n```\nsex, age, firstclass, secondclass 순으로 넣었으므로 그순서대로 확인해주면 된다. 성별은 1에 가까우므로 여자이고, 일등석 탑승 여부가 중요하다는 걸 알 수 있다. 반면에 나이는 음수가 나오는데 이는 나이가 많을수록 생존 확률이 낮아진다는 의미로 해석할 수 있다.\n\n<br><br><br>\n\n## 5. 예측하기\n이번에는 새로운 임의의 데이터를 넣어서 예측해보자.\n```python\nJack = np.array([0.0, 20.0, 0.0, 0.0])  \nRose = np.array([1.0, 17.0, 1.0, 0.0])  \nME = np.array([0.0, 32.0, 1.0, 0.0])\n\nsample_passengers = np.array([Jack, Rose, ME])\n```\n\n<br><br><br>\n이제 스케일링을 다시해주자.\n```python\nsample_passengers = scaler.transform(sample_passengers)\n```\n\n<br><br><br>\n마지막으로 예측을 해보자.\n```python\nprint(model.predict(sample_passengers))  \n  \nprint(model.predict_proba(sample_passengers))\n```\n```\n[0 1 0]\n\n[[0.88995985 0.11004015]\n [0.05240318 0.94759682]\n [0.51644668 0.48355332]]\n ```\nJack과 나는 죽고 Rose만 산다..\n","properties":"\n","discussions":{},"comments":{},"hash":-1865698563}},"syncHistory":{"main":[-1865698563,null,null]},"v":1,"hash":1710111501241,"tx":11},"JZO7E1GRXJiiFfhC/syncedContent":{"id":"JZO7E1GRXJiiFfhC/syncedContent","type":"syncedContent","historyData":{"-1090010526":{"id":"JZO7E1GRXJiiFfhC/content","type":"content","text":"---\ntitle: \"[컴퓨터 구조] 1. Instruction 이란\"\ndate: 2021-09-09 22:00:00\ncategories:\n- Computer Architecture\ntags:\n- Number representations\n- The Von-Neumann Model\n- Instruction\n- Instruction Set Architecture\n---\n\n## Number Representations\n인간은 기본적으로 모든 수를 10진수에 기반해 생각한다. 그러나 컴퓨터는 모든 연산을 0과 1로 처리를 하는 2진수에 기반한다. 이때문에 컴퓨터 구조를 이해하기 위해서는 기본적으로 컴퓨터가 어떻게 2진수로 연산을 하고 처리하는지 알 필요가 있다. 먼저 컴퓨터가 어떻게 음수와 양수를 2진수로 표현하는지 알아보자.\n\n<br><br><br><br><br><br>\n\n### 2's Complement( = 2의 보수 )\n<hr>\n먼저 양수는 기본적인 산수실력만 갖추고 있다면 이진법으로 어떻게 나타내는지 잘 알고 있을 것이다.\n\n예를들어 32비트 수가 주어진다고 했을때 11을 이진수로 나타낸다면 다음과 같다.\n\n> **0000 0000 0000 0000 0000 0000 0000 1011<sub>2</sub>**\n\n그러나 이를 음수, 즉 -11로 나타내려면 어떻게 표기해야 할까?\n\n정답은 **2의 보수**를 사용하는 것이다. 그리 어렵지 않다.\n\n**1로 나타낸 수는 0으로**, **0으로 나타낸 수는 1로 바꿔주고** **1을 더하면 된다.**\n\n<br><br><br><br><br><br>\n\n앞선 11을 다시 예로 들어보겠다.\n\n> **+11 : 0000 0000 0000 0000 0000 0000 0000 1011**\n> **-11 : 1111 1111 1111 1111 1111 1111 1111 0101**\n\n이렇게 0과 1을 변경해주고 마지막에 1만 더해주면 음수로 바꿀수 있다.\n\n그렇다면 X + (-X) 는 어떻게 표현될까?\n\n> **(1) 0000 0000 0000 0000 0000 0000 0000 0000**\n\n모든 자릿수에서 올림이 들어가고 결국 1이 overflow되어 나타난다.\n\n<br><br><br><br><br><br>\n\n이를 통해 우리는 몇가지 공식을 뽑아낼 수 있다.\n\n> **A + A's(A의 보수) = 1111 1111 <sub>2</sub>**\n>**-A = A's + 1**\n\n이를 통해 우리는 컴퓨터 연산에서 뺄셈을 덧셈으로 변경할 수 있다.\n\n이를 잘 적용할 수 있는 연습문제를 하나 풀어보자.\n\n<br><br><br><br><br><br>\n\n**[ 연습문제 ]**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/2's.jpg?raw=true\">\n</p>\n\n1111 1111 1111 1111 1111 1111 1111 1000<sub>2</sub>의 값을 구하라는 문제다.\n\n2의 보수를 노골적으로 사용하라는게 보이지 않는가?\n\n-A = A's +1 을 활용한다면 정답은\n\n -0000 0000 0000 0000 0000 0000 0000 1000 <sub>2</sub> 즉, -8이 된다.\n\n<br><br><br><br><br><br>\n\n## The Von-Nuemann Model ( 폰 노이만 구조 )\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/Von.png?raw=true\">\n</p>\n\n<br>\n\n**CPU ( 산술논리장치 )** : Instructions(명령어)를 Fetch, Interpret, Execute 하는 작업을 한다.\n\n\t- Fetch : 메모리상에 존재하는 명령어를 CPU로 가져오는 작업\n\t- Interpret : 가져온 명령어를 CPU가 해석하는 작업\n\t- Execute : 해석된 명령어대로 CPU가 실행하는 작업\n\n\n**Memory** : W비트 만큼의 N words를 저장한다.\n\n<br><br><br><br><br><br>\n\n## Instructions ( 명령어 ) 란?\n\n컴퓨터의 언어, 그중에서도 **단어** 라고 볼 수 있다.\n\nCPU는 Instruction 사이클을 반복해서 프로그램을 실행한다.\n\n\n<br><br><br><br><br><br>\n\n### Instruction Set Architecture (ISA)\n<hr>\n**Instruction Set Architecture (ISA)**는 **문장**이라고 볼 수 있다.\n\n**ISA**는 **HW와 SW간의 추상적인 인터페이스**로 Machine Language Program을 작성하기 위해 필요한 **모든 정보**를 말하며 단순히 Instructions의 집합뿐만 아니라 **register, memory, access** 등을 포함한 모든 정보를 일컫는다.\n\n<br><br><br><br><br><br>\n\n### Two types of Instruction Set\n<hr>\n1. **Complex Instruction Set Computer**  ( CISC )\n\n- 1000개가 넘는 Instructions를 가진다.\n- 명령어를 해석하는데 시간이 오래걸리며 명령어 해석에 필요한 회로도 복잡하다.\n- 10여개가 넘는 addressing mode를 가진다.\n- 대표적으로 x86 이있다.\n\n**2. Reduced Instruction Set Computer ( CISC )**\n- 비교적 적은 명령어를 가져 구조가 좀더 간단하다.\n- 적은수의 명령어로 Instruction Set을 이루므로 속도가 빠르다.\n- 일반적으로 많이 쓰이는 명령어를 주로 가진다.\n- **메모리에 접근하는 명령어**로 **load와 store**만을 가진다!\n- 대표적으로 MIPS 가 있다.\n\n<br><br><br><br><br><br>\n\n### RISC vs CISC\n<hr>\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/RISC.jpg?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1090010526}},"syncHistory":{"main":[-1090010526,null,null]},"v":1,"hash":1710111502361,"tx":13},"jWIAbpACKd6mffUH/content":{"id":"jWIAbpACKd6mffUH/content","type":"content","text":"---\ntitle: \"[알고리즘] 합병 정렬(Merge Sort) \"\ndate: 2021-08-10 20:00:00\ncategories:\n- Algorithm\ntags:\n- 알고리즘\n- 정렬\n---\n## Goal\n\n> Merge Sort 알고리즘을 이해한다.\n> Merge Sort 알고리즘의 특징 \n> Merge Sort 알고리즘을 C언어로 구현한다.\n\n<br><br><br><br><br><br>\n\n## Merge Sort 알고리즘 개념 요약\n\n - **분할 정복 (Divide and Conquer)** 알고리즘의 하나이다.\n \n - 분할 정복 알고리즘은 대게 **Recursion**을 활용하여 구현한다.\n \n -  간단한 과정 설명\n\t- 배열의 길이가 0 또는 1이면 이미 정렬이 다 된것으로 본다.\n\t- 정렬되지 않은 배열을 반으로 잘라 두개의 배열로 나눈다.\n\t- 각 배열을 재귀적으로(Recursion) 다시 Merge Sort를 이용해 정렬한다.\n\t- 정렬된 모든 배열을 다시 하나의 배열로 Merge 해준다.\n\n\n<br><br><br><br><br><br>\n\n## Merge Sort 알고리즘 구체적 개념\n\n- 하나의 배열을 두 개의 균등한 크기로 분할하고 분할 된 배열을 정렬한 다음, 두개의 정렬 된 배열을 다시 합하여 최종적으로 정렬된 리스트가 되게 하는 알고리즘 이다.\n\n- Merge Sort는 다음과 같은 단계들로 이루어진다.\n\t- 분할(Divide) : 배열을 같은 크기의 부분 배열 2개로 분할한다.\n\t- 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 1 또는 0이 아닐때는 Recursion을 활용해 Divide를 다시 한다.\n\t- 결합(Combine) : 정렬된 부분배열들을 다시 하나의 배열로 결합한다.\n\n<br> <br> <br><br> <br> <br>\n\n\n## Merge Sort 알고리즘 예제\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/MergeSort.png?raw=true)\n\n**Ⅰ**. 배열에 21, 10, 12, 20, 25, 13, 15, 22가 들어있다고 보고 이를 **Merge Sort**해보자\n**Ⅱ**. 먼저 배열을 두개로 쪼개어 나눈다 **(Divide)**\n**Ⅲ**. 배열의 원소 개수가 1개가 될때 까지 계속 나눈다 **(Divide)**\n**Ⅳ**. 나뉜 배열을 두개씩 비교해 정렬하고 합친다 **( Conquer & Combine )**\n**Ⅴ**. 합치는 과정을 반복해 최종적으로 정렬된 배열을 찾는다.\n\n <br> <br> <br><br> <br> <br>\n\n## Merge Sort 알고리즘 과정\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/MergeSort2.png?raw=true)\n\n## Merge Sort 코드\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n// i = 정렬된 왼쪽 배열의 인덱스\n// j = 정렬된 오른쪽 배열의 인덱스\n// k = 최종 정렬된 배열의 인덱스\nvoid merge(int* arr, int left, int mid, int right) {\n\n\tint* temp = (int*)malloc(sizeof(int) * (right - left + 1));\n\tint i = left;\n\tint j = mid + 1;\n\tint k = 0;\n\n\twhile (i <= mid && j <= right) {\n\t\tif (arr[i] <= arr[j]) temp[k++] = arr[i++];\n\t\telse temp[k++] = arr[j++];\n\t}\n\n\twhile (i <= mid) temp[k++] = arr[i++];\n\n\twhile (j <= right) temp[k++] = arr[j++];\n\n\ti = left;\n\tk = 0;\n\n\twhile (i <= right) arr[i++] = temp[k++];\n\n\tfree(temp);\n}\n\n\nvoid mergeSort(int* arr, int left, int right) {\n\tif (left < right) {\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(arr, left, mid);\n\t\tmergeSort(arr, mid + 1, right);\n\t\tmerge(arr, left, mid, right);\n\t}\n}\n\n\nint main() {\n\tint n = 0;\n\tscanf(\"%d\", &n);\n\n\tint* pArr = (int*)malloc(sizeof(int) * n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &pArr[i]);\n\t}\n\n\t// 배열 시작부터 끝까지 mergesort실행\n\tmergeSort(pArr, 0, n - 1);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", pArr[i]);\n\t}\n\n\tfree(pArr);\n\treturn 0;\n}\n```\n\n<br><br><br><br><br><br>\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-94761757,"tx":15},"jWIAbpACKd6mffUH/syncedContent":{"id":"jWIAbpACKd6mffUH/syncedContent","type":"syncedContent","historyData":{"-94761757":{"id":"jWIAbpACKd6mffUH/content","type":"content","text":"---\ntitle: \"[알고리즘] 합병 정렬(Merge Sort) \"\ndate: 2021-08-10 20:00:00\ncategories:\n- Algorithm\ntags:\n- 알고리즘\n- 정렬\n---\n## Goal\n\n> Merge Sort 알고리즘을 이해한다.\n> Merge Sort 알고리즘의 특징 \n> Merge Sort 알고리즘을 C언어로 구현한다.\n\n<br><br><br><br><br><br>\n\n## Merge Sort 알고리즘 개념 요약\n\n - **분할 정복 (Divide and Conquer)** 알고리즘의 하나이다.\n \n - 분할 정복 알고리즘은 대게 **Recursion**을 활용하여 구현한다.\n \n -  간단한 과정 설명\n\t- 배열의 길이가 0 또는 1이면 이미 정렬이 다 된것으로 본다.\n\t- 정렬되지 않은 배열을 반으로 잘라 두개의 배열로 나눈다.\n\t- 각 배열을 재귀적으로(Recursion) 다시 Merge Sort를 이용해 정렬한다.\n\t- 정렬된 모든 배열을 다시 하나의 배열로 Merge 해준다.\n\n\n<br><br><br><br><br><br>\n\n## Merge Sort 알고리즘 구체적 개념\n\n- 하나의 배열을 두 개의 균등한 크기로 분할하고 분할 된 배열을 정렬한 다음, 두개의 정렬 된 배열을 다시 합하여 최종적으로 정렬된 리스트가 되게 하는 알고리즘 이다.\n\n- Merge Sort는 다음과 같은 단계들로 이루어진다.\n\t- 분할(Divide) : 배열을 같은 크기의 부분 배열 2개로 분할한다.\n\t- 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 1 또는 0이 아닐때는 Recursion을 활용해 Divide를 다시 한다.\n\t- 결합(Combine) : 정렬된 부분배열들을 다시 하나의 배열로 결합한다.\n\n<br> <br> <br><br> <br> <br>\n\n\n## Merge Sort 알고리즘 예제\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/MergeSort.png?raw=true)\n\n**Ⅰ**. 배열에 21, 10, 12, 20, 25, 13, 15, 22가 들어있다고 보고 이를 **Merge Sort**해보자\n**Ⅱ**. 먼저 배열을 두개로 쪼개어 나눈다 **(Divide)**\n**Ⅲ**. 배열의 원소 개수가 1개가 될때 까지 계속 나눈다 **(Divide)**\n**Ⅳ**. 나뉜 배열을 두개씩 비교해 정렬하고 합친다 **( Conquer & Combine )**\n**Ⅴ**. 합치는 과정을 반복해 최종적으로 정렬된 배열을 찾는다.\n\n <br> <br> <br><br> <br> <br>\n\n## Merge Sort 알고리즘 과정\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/MergeSort2.png?raw=true)\n\n## Merge Sort 코드\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n// i = 정렬된 왼쪽 배열의 인덱스\n// j = 정렬된 오른쪽 배열의 인덱스\n// k = 최종 정렬된 배열의 인덱스\nvoid merge(int* arr, int left, int mid, int right) {\n\n\tint* temp = (int*)malloc(sizeof(int) * (right - left + 1));\n\tint i = left;\n\tint j = mid + 1;\n\tint k = 0;\n\n\twhile (i <= mid && j <= right) {\n\t\tif (arr[i] <= arr[j]) temp[k++] = arr[i++];\n\t\telse temp[k++] = arr[j++];\n\t}\n\n\twhile (i <= mid) temp[k++] = arr[i++];\n\n\twhile (j <= right) temp[k++] = arr[j++];\n\n\ti = left;\n\tk = 0;\n\n\twhile (i <= right) arr[i++] = temp[k++];\n\n\tfree(temp);\n}\n\n\nvoid mergeSort(int* arr, int left, int right) {\n\tif (left < right) {\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(arr, left, mid);\n\t\tmergeSort(arr, mid + 1, right);\n\t\tmerge(arr, left, mid, right);\n\t}\n}\n\n\nint main() {\n\tint n = 0;\n\tscanf(\"%d\", &n);\n\n\tint* pArr = (int*)malloc(sizeof(int) * n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &pArr[i]);\n\t}\n\n\t// 배열 시작부터 끝까지 mergesort실행\n\tmergeSort(pArr, 0, n - 1);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", pArr[i]);\n\t}\n\n\tfree(pArr);\n\treturn 0;\n}\n```\n\n<br><br><br><br><br><br>\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-94761757}},"syncHistory":{"main":[-94761757,null,null]},"v":1,"hash":1710111503516,"tx":15},"30ZHndsjczBXKG2t/content":{"id":"30ZHndsjczBXKG2t/content","type":"content","text":"---\ntitle: \"[알고리즘] 퀵 정렬(Quick Sort) \"\ndate: 2021-08-18 01:00:00\ncategories:\n- Algorithm\ntags:\n- 알고리즘\n- 정렬\n---\n\n## Goal\n\n> Quick Sort 알고리즘을 이해한다.\n> Quick Sort 알고리즘의 특징 \n> Quick Sort 알고리즘을 C언어로 구현한다.\n\n<br><br><br><br><br><br>\n\n## Merge Sort 알고리즘 개념 요약\n\n - **분할 정복 (Divide and Conquer)** 알고리즘의 하나이다.\n\n - 분할 정복 알고리즘은 대게 **Recursion**을 활용하여 구현한다.\n\n - 간단한 과정 설명\n\t - 배열의 한 요소를 아무거나 선택한다. 이를 **피벗(pivot)**이라고 한다.\n\t - 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮기고 피벗보다 큰 요소들은 오른쪽으로 옮긴다.\n\t - 피벗을 제외한 왼쪽 배열과 오른쪽 배열을 다시 정렬한다.\n\t - 부분 배열들이 더이상 분할이 불가능 할때까지 이를 반복한다.\n\n<br><br><br><br><br><br>\n\n## Quick Sort 알고리즘 구체적 개념\n\n- 하나의 배열을 **피벗(pivot)**을 기준으로 두 개의 배열로 분할하고 분할된 부분 배열을 정렬한 다음, 두 개의 정렬된 부분 배열을 합하여 전체가 정렬된 배열이 되게 하는 방법이다.\n\n\n- Quick Sort는 다음과 같은 단계들로 이루어진다.\n\t- **분할(Divide)** : 입력 배열을 피벗을 기준으로 두개의 부분 배열로 분할한다.\n\t- **정복(Conquer)** : 부분 배열을 정렬한다. 이때 부분 배열의 크기가 0 또는 1이 될 때까지 **Recursive**하게 **Divide & Conquer**를 반복한다.\n\t- **결합(Combine)** : 정렬된 모든 배열들을 하나의 배열에 합병한다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/quicksort1.png?raw=true)\n\n\n<br> <br> <br><br> <br> <br>\n\n## Quick Sort 알고리즘 예제\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/quicksort2.png?raw=true)\n\n<br>\n\n**Ⅰ**. 피벗값을 입력 배열의 첫번째 데이터로 하자. ( 다른 값이여도 상관없다)\n**Ⅱ**.  2개의 인덱스 변수 (low, high)를 이용해 두개의 배열로 나눠준다.\n**Ⅲ**. 1회전 : 피벗이 5인 경우\n\n> ⅰ. low는 왼쪽에서 오른쪽으로 탐색하다가 피벗보다 큰 데이터(8)를 찾으면 멈춘다.  \n> ⅱ. high는 오른쪽에서 왼쪽으로\n> 탐색하다가 피벗보다 작은 데이터(2)를 찾으면 멈춘다.\n> ⅲ. low와 high가 가리키는 데이터를 서로 교환한다.\n> ⅳ. 이 과정은 low와 high가 서로 엇갈릴 때까지 반복한다.\n\n**Ⅳ**. 2회전 : 피벗(1회전의 왼쪽 배열의 첫번째 데이터)이 1인 경우\n\n> 위의 과정(ⅰ~ⅳ)을 반복한다.\n\n**Ⅴ**. 3회전 : 피벗(1회전의 오른쪽 배열의 첫번째 데이터)이 9인 경우\n\n> 위의 과정(ⅰ~ⅳ)을 반복한다.\n\n\n<br><br><br><br><br><br>\n\n## Quick Sort C언어 코드\n```c\n# include <stdio.h>\n# define MAX_SIZE 9\n# define SWAP(x, y, temp) ( (temp)=(x), (x)=(y), (y)=(temp) )\n\n// 1. 피벗을 기준으로 2개의 부분 리스트로 나눈다.\n// 2. 피벗보다 작은 값은 모두 왼쪽 부분 리스트로, 큰 값은 오른쪽 부분 리스트로 옮긴다.\n/* 2개의 비균등 배열 list[left...pivot-1]와 list[pivot+1...right]의 합병 과정 */\n/* (실제로 숫자들이 정렬되는 과정) */\nint partition(int list[], int left, int right){\n  int pivot, temp;\n  int low, high;\n\n  low = left;\n  high = right + 1;\n  pivot = list[left]; // 정렬할 리스트의 가장 왼쪽 데이터를 피벗으로 선택(임의의 값을 피벗으로 선택)\n\n  /* low와 high가 교차할 때까지 반복(low<high) */\n  do{\n    /* list[low]가 피벗보다 작으면 계속 low를 증가 */\n    do {\n      low++; // low는 left+1 에서 시작\n    } while (low<=right && list[low]<pivot);\n\n    /* list[high]가 피벗보다 크면 계속 high를 감소 */\n    do {\n      high--; //high는 right 에서 시작\n    } while (high>=left && list[high]>pivot);\n\n    // 만약 low와 high가 교차하지 않았으면 list[low]를 list[high] 교환\n    if(low<high){\n      SWAP(list[low], list[high], temp);\n    }\n  } while (low<high);\n\n  // low와 high가 교차했으면 반복문을 빠져나와 list[left]와 list[high]를 교환\n  SWAP(list[left], list[high], temp);\n\n  // 피벗의 위치인 high를 반환\n  return high;\n}\n\n// 퀵 정렬\nvoid quick_sort(int list[], int left, int right){\n\n  /* 정렬할 범위가 2개 이상의 데이터이면(리스트의 크기가 0이나 1이 아니면) */\n  if(left<right){\n    // partition 함수를 호출하여 피벗을 기준으로 리스트를 비균등 분할 -분할(Divide)\n    int q = partition(list, left, right); // q: 피벗의 위치\n\n    // 피벗은 제외한 2개의 부분 리스트를 대상으로 순환 호출\n    quick_sort(list, left, q-1); // (left ~ 피벗 바로 앞) 앞쪽 부분 리스트 정렬 -정복(Conquer)\n    quick_sort(list, q+1, right); // (피벗 바로 뒤 ~ right) 뒤쪽 부분 리스트 정렬 -정복(Conquer)\n  }\n\n}\n\nvoid main(){\n  int i;\n  int n = MAX_SIZE;\n  int list[n] = {5, 3, 8, 4, 9, 1, 6, 2, 7};\n\n  // 퀵 정렬 수행(left: 배열의 시작 = 0, right: 배열의 끝 = 8)\n  quick_sort(list, 0, n-1);\n\n  // 정렬 결과 출력\n  for(i=0; i<n; i++){\n    printf(\"%d\\n\", list[i]);\n  }\n}\nhttps://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html\n```\n코드 출처 : [https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)\n\n<br><br><br><br><br><br>\n\n\n## Quick Sort 라이브러리를 활용한 C언어 코드\n```c\n#include <stdio.h>\n#include <stdlib.h>    // qsort 함수가 선언된 헤더 파일\n\nint compare(const void *a, const void *b)    // 오름차순 비교 함수 구현\n{\n    int num1 = *(int *)a; // void 포인터를 int 포인터로 변환한 뒤 역참조하여 값을 가져옴\n    int num2 = *(int *)b; // void 포인터를 int 포인터로 변환한 뒤 역참조하여 값을 가져옴\n\n    if (num1 < num2) // a가 b보다 작을 때는\n        return -1;      // -1 반환\n    \n    if (num1 > num2)    // a가 b보다 클 때는\n        return 1;       // 1 반환\n    \n    return 0; // a와 b가 같을 때는 0 반환\n}\n\nint main()\n{\n    int numArr[10] = { 8, 4, 2, 5, 3, 7, 10, 1, 6, 9 };    // 정렬되지 않은 배열\n\n    // 정렬할 배열, 요소 개수, 요소 크기, 비교 함수를 넣어줌\n    qsort(numArr, sizeof(numArr) / sizeof(int), sizeof(int), compare);\n\n    for (int i = 0; i < 10; i++)\n    {\n        printf(\"%d \", numArr[i]); // 1 2 3 4 5 6 7 8 9 10\n    }\n\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n코드 출처 : [https://dojang.io/mod/page/view.php?id=638](https://dojang.io/mod/page/view.php?id=638)\n\n그때 그때 정렬 코드를 직접 짜는것은 공부 단계에서는 적절하겠지만 실제 코딩 테스트나 실무에서 적용하는데는 라이브러리를 활용하는것이 좋겠다.\n","properties":"\n","discussions":{},"comments":{},"hash":486623268,"tx":17},"30ZHndsjczBXKG2t/syncedContent":{"id":"30ZHndsjczBXKG2t/syncedContent","type":"syncedContent","historyData":{"486623268":{"id":"30ZHndsjczBXKG2t/content","type":"content","text":"---\ntitle: \"[알고리즘] 퀵 정렬(Quick Sort) \"\ndate: 2021-08-18 01:00:00\ncategories:\n- Algorithm\ntags:\n- 알고리즘\n- 정렬\n---\n\n## Goal\n\n> Quick Sort 알고리즘을 이해한다.\n> Quick Sort 알고리즘의 특징 \n> Quick Sort 알고리즘을 C언어로 구현한다.\n\n<br><br><br><br><br><br>\n\n## Merge Sort 알고리즘 개념 요약\n\n - **분할 정복 (Divide and Conquer)** 알고리즘의 하나이다.\n\n - 분할 정복 알고리즘은 대게 **Recursion**을 활용하여 구현한다.\n\n - 간단한 과정 설명\n\t - 배열의 한 요소를 아무거나 선택한다. 이를 **피벗(pivot)**이라고 한다.\n\t - 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮기고 피벗보다 큰 요소들은 오른쪽으로 옮긴다.\n\t - 피벗을 제외한 왼쪽 배열과 오른쪽 배열을 다시 정렬한다.\n\t - 부분 배열들이 더이상 분할이 불가능 할때까지 이를 반복한다.\n\n<br><br><br><br><br><br>\n\n## Quick Sort 알고리즘 구체적 개념\n\n- 하나의 배열을 **피벗(pivot)**을 기준으로 두 개의 배열로 분할하고 분할된 부분 배열을 정렬한 다음, 두 개의 정렬된 부분 배열을 합하여 전체가 정렬된 배열이 되게 하는 방법이다.\n\n\n- Quick Sort는 다음과 같은 단계들로 이루어진다.\n\t- **분할(Divide)** : 입력 배열을 피벗을 기준으로 두개의 부분 배열로 분할한다.\n\t- **정복(Conquer)** : 부분 배열을 정렬한다. 이때 부분 배열의 크기가 0 또는 1이 될 때까지 **Recursive**하게 **Divide & Conquer**를 반복한다.\n\t- **결합(Combine)** : 정렬된 모든 배열들을 하나의 배열에 합병한다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/quicksort1.png?raw=true)\n\n\n<br> <br> <br><br> <br> <br>\n\n## Quick Sort 알고리즘 예제\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/quicksort2.png?raw=true)\n\n<br>\n\n**Ⅰ**. 피벗값을 입력 배열의 첫번째 데이터로 하자. ( 다른 값이여도 상관없다)\n**Ⅱ**.  2개의 인덱스 변수 (low, high)를 이용해 두개의 배열로 나눠준다.\n**Ⅲ**. 1회전 : 피벗이 5인 경우\n\n> ⅰ. low는 왼쪽에서 오른쪽으로 탐색하다가 피벗보다 큰 데이터(8)를 찾으면 멈춘다.  \n> ⅱ. high는 오른쪽에서 왼쪽으로\n> 탐색하다가 피벗보다 작은 데이터(2)를 찾으면 멈춘다.\n> ⅲ. low와 high가 가리키는 데이터를 서로 교환한다.\n> ⅳ. 이 과정은 low와 high가 서로 엇갈릴 때까지 반복한다.\n\n**Ⅳ**. 2회전 : 피벗(1회전의 왼쪽 배열의 첫번째 데이터)이 1인 경우\n\n> 위의 과정(ⅰ~ⅳ)을 반복한다.\n\n**Ⅴ**. 3회전 : 피벗(1회전의 오른쪽 배열의 첫번째 데이터)이 9인 경우\n\n> 위의 과정(ⅰ~ⅳ)을 반복한다.\n\n\n<br><br><br><br><br><br>\n\n## Quick Sort C언어 코드\n```c\n# include <stdio.h>\n# define MAX_SIZE 9\n# define SWAP(x, y, temp) ( (temp)=(x), (x)=(y), (y)=(temp) )\n\n// 1. 피벗을 기준으로 2개의 부분 리스트로 나눈다.\n// 2. 피벗보다 작은 값은 모두 왼쪽 부분 리스트로, 큰 값은 오른쪽 부분 리스트로 옮긴다.\n/* 2개의 비균등 배열 list[left...pivot-1]와 list[pivot+1...right]의 합병 과정 */\n/* (실제로 숫자들이 정렬되는 과정) */\nint partition(int list[], int left, int right){\n  int pivot, temp;\n  int low, high;\n\n  low = left;\n  high = right + 1;\n  pivot = list[left]; // 정렬할 리스트의 가장 왼쪽 데이터를 피벗으로 선택(임의의 값을 피벗으로 선택)\n\n  /* low와 high가 교차할 때까지 반복(low<high) */\n  do{\n    /* list[low]가 피벗보다 작으면 계속 low를 증가 */\n    do {\n      low++; // low는 left+1 에서 시작\n    } while (low<=right && list[low]<pivot);\n\n    /* list[high]가 피벗보다 크면 계속 high를 감소 */\n    do {\n      high--; //high는 right 에서 시작\n    } while (high>=left && list[high]>pivot);\n\n    // 만약 low와 high가 교차하지 않았으면 list[low]를 list[high] 교환\n    if(low<high){\n      SWAP(list[low], list[high], temp);\n    }\n  } while (low<high);\n\n  // low와 high가 교차했으면 반복문을 빠져나와 list[left]와 list[high]를 교환\n  SWAP(list[left], list[high], temp);\n\n  // 피벗의 위치인 high를 반환\n  return high;\n}\n\n// 퀵 정렬\nvoid quick_sort(int list[], int left, int right){\n\n  /* 정렬할 범위가 2개 이상의 데이터이면(리스트의 크기가 0이나 1이 아니면) */\n  if(left<right){\n    // partition 함수를 호출하여 피벗을 기준으로 리스트를 비균등 분할 -분할(Divide)\n    int q = partition(list, left, right); // q: 피벗의 위치\n\n    // 피벗은 제외한 2개의 부분 리스트를 대상으로 순환 호출\n    quick_sort(list, left, q-1); // (left ~ 피벗 바로 앞) 앞쪽 부분 리스트 정렬 -정복(Conquer)\n    quick_sort(list, q+1, right); // (피벗 바로 뒤 ~ right) 뒤쪽 부분 리스트 정렬 -정복(Conquer)\n  }\n\n}\n\nvoid main(){\n  int i;\n  int n = MAX_SIZE;\n  int list[n] = {5, 3, 8, 4, 9, 1, 6, 2, 7};\n\n  // 퀵 정렬 수행(left: 배열의 시작 = 0, right: 배열의 끝 = 8)\n  quick_sort(list, 0, n-1);\n\n  // 정렬 결과 출력\n  for(i=0; i<n; i++){\n    printf(\"%d\\n\", list[i]);\n  }\n}\nhttps://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html\n```\n코드 출처 : [https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)\n\n<br><br><br><br><br><br>\n\n\n## Quick Sort 라이브러리를 활용한 C언어 코드\n```c\n#include <stdio.h>\n#include <stdlib.h>    // qsort 함수가 선언된 헤더 파일\n\nint compare(const void *a, const void *b)    // 오름차순 비교 함수 구현\n{\n    int num1 = *(int *)a; // void 포인터를 int 포인터로 변환한 뒤 역참조하여 값을 가져옴\n    int num2 = *(int *)b; // void 포인터를 int 포인터로 변환한 뒤 역참조하여 값을 가져옴\n\n    if (num1 < num2) // a가 b보다 작을 때는\n        return -1;      // -1 반환\n    \n    if (num1 > num2)    // a가 b보다 클 때는\n        return 1;       // 1 반환\n    \n    return 0; // a와 b가 같을 때는 0 반환\n}\n\nint main()\n{\n    int numArr[10] = { 8, 4, 2, 5, 3, 7, 10, 1, 6, 9 };    // 정렬되지 않은 배열\n\n    // 정렬할 배열, 요소 개수, 요소 크기, 비교 함수를 넣어줌\n    qsort(numArr, sizeof(numArr) / sizeof(int), sizeof(int), compare);\n\n    for (int i = 0; i < 10; i++)\n    {\n        printf(\"%d \", numArr[i]); // 1 2 3 4 5 6 7 8 9 10\n    }\n\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n코드 출처 : [https://dojang.io/mod/page/view.php?id=638](https://dojang.io/mod/page/view.php?id=638)\n\n그때 그때 정렬 코드를 직접 짜는것은 공부 단계에서는 적절하겠지만 실제 코딩 테스트나 실무에서 적용하는데는 라이브러리를 활용하는것이 좋겠다.\n","properties":"\n","discussions":{},"comments":{},"hash":486623268}},"syncHistory":{"main":[486623268,null,null]},"v":1,"hash":1710111504708,"tx":17},"cXAfswLPLBmPzNUg/content":{"id":"cXAfswLPLBmPzNUg/content","type":"content","text":"---\ntitle: \"[알고리즘] 동적 계획법(Dynamic Programming) \"\ndate: 2022-01-01 01:00:00\ncategories:\n- Algorithm\ntags:\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n# 동적 계획법 ( Dynamic Programming )\n<hr>\n\n## 동적 계획법 개요\n**동적 계획법**은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법을 사용하는 알고리즘들 또한 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내는 방식이기 때문이다.\n\n동적 계획법과 분할 정복의 가장 큰 차이는 **문제를 나누는 방식**이다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용 될 수 있기 때문에 이를 여러번 계산하는 것 대신 한번만 계산하게 만듦으로써 속도 향상을 꾀할 수 있다. 그러기 위해선 부분 문제를 메모리에 저장해 둘 필요가 있는데 이 메모리 장소를 **캐시(cache)**라고 부른다.\n\n<br><br><br><br><br><br>\n\n이를 피보나치 수열 함수를 예로 설명해보겠다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/Fibo.png?raw=true\">\n</p>\n위의 그림은 피보나치 함수를 분할 정복방식으로 구현한 것이다. 함수 이름을 fib(n) 이라고 했을때, 예시처럼 fib(5)를 구하기 위해선 총 **15번**의 함수 호출이 필요하다. 이때, fib(2)는 총 3번 호출되는것을 볼 수 있는데 이는 **동일한 계산과정을 3번이나 반복하게 되어 알고리즘의 실행시간이 길어지게 된다**.\n\n<br><br><br>\n\n이런 중복계산을 **캐시에 저장시킨 뒤 필요할 때마다 결과값만을 가져와서 사용하는 방식**을 **동적 계획법 ( Dynamic Programming )** 이라고한다.\n\n<br><br><br><br><br><br>\n\n동적 계획법 알고리즘의 가장 유명한 예 중 하나를 더 설명해보겠다. 바로 **이항 계수의 계산**이다. 이항 계수는 서로다른 n개의 원소중에서 r개의 원소를 순서없이 골라내는 방법의 수를 계산하는 것으로 다음과 같은 점화식이 성립한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ncr.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n이 점화식을 활용하여 n,r의 값이 주어질 때 그 결과를 반환하는 함수 **bino(n,r)**를 다음과 같이 작성할 수 있다.\n\n```c++\nint bino(int n, int r) {\n\tif(r == 0 || n == r) return 1;\n\treturn bino(n-1,r-1) + bino(n-1,r)\n```\n이 코드는 **분할 정복 알고리즘**을 사용한 것으로 **중복 계산**이 발생한다.\n<br><br><br><br><br><br>\n\n\n이를 **동적 계획법 알고리즘**으로 변환하여 작성한 코드는 다음과 같다.\n```c++\n// -1로 초기화해둔다\nint cache[30][30];\n\nint bino2(int n, int r) {\n\tif(r == 0 || n == r ) return 1;\n\t\n\tif(cache[n][r]!= -1) \n\treturn cache[n][r];\n\n\treturn cache[n][r] = bino2(n-1,r-1) + bino2(n-1,r);\n```\n코드처럼 cache라는 배열을 생성해준뒤 이곳에 값을 저장하는 방식을 사용하면 된다. 이를 **메모이제이션(memoization)** 이라고 부른다.\n\n\n<br><br><br><br><br><br>\n\n## 메모이제이션 구현 패턴\n\n동적계획법은 가장 흔한 문제 유형 중 하나이기 때문에 메모이제이션을 굉장히 많이 구현하게 된다. 그렇기 때문에 **한가지 패턴**을 정해놓고 문제를 항상 같은 형태로 풀어가게 되면 문제 풀이에 도움이 많이 된다. 이 패턴을 소개해 보겠다.\n\n<br><br><br>\n\n1. **항상 예외처리를 제일 먼저 처리해라.**\n\n\t예외상황은 각종 오류를 유발하므로 제일 먼저 처리해놓는 것이 좋다.\n\t\n2. **cache를 초기화 해줘라. feat. memset( )**\n\n\t초기화 할때는 C++ STL에 내재되어 있는 memset( ) 메소드를 활용하면 편리하다. **memset ( 메모리시작주소, 값, 크기 )** 를 사용하면 된다.\n\tEX ) memset ( cache, -1, sizeof(cache) ) \n\t \n3. **return 값을 활용해라.**\n\tcache를 사용할 때마다 매번 cache[n][r]처럼 쓰지말고 return값을 활용해라.\n\n4. **점화식을 만들어라.**\n\t\n<br><br><br><br><br><br>\n\n\n===========================================================\n\n**※ 2022-01-14 추가**\n\n근 한달간 DP문제를 쭉 풀어보면서 깨달은 문제풀이 방법을 정리해보도록 하겠다.\n\n<br><br><br>\n\n### 1. 문제에서 구하려고 하는 답을 점화식으로 나타낸다.\nDP모든 문제는 점화식으로 표현이 가능하다. \n점화식으로만 표현한다면 문제는 사실상 거의 다 풀린것이나 다름없다.\n점화식에는 꼭 한가지 식만 들어갈 필요도 없다. \n여러 식을 혼합해도 되고 변수를 이용해도 좋다\n[백준 14002번 : 가장 긴 증가하는 부분 수열4](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%8014002%EB%B2%88/) 문제에서 여러 식과 변수가 혼합된 점화식을 살펴볼 수 있다!\n<br><br>\n\n### 2. 점화식은 이차원 배열을 사용하기도 한다.\n이차원 배열을 잘 활용해 점화식을 만들면 편리한 경우도 많다.\n[백준 15990번 : 1,2,3 더하기 5](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%8015990%EB%B2%88/) 문제는 이차원 배열을 사용하는 대표예제이다.\n<br><br>\n\n### 3. 최소값, 최대값을 구할때는 초기화가 중요하다.\n최소, 최대값은 비교대상이 필요하기 때문에 메모이제이션을 할 때 초기화를 해주는 것이 좋다.\n어떤 값으로 초기화 해주는지는 문제에 따라 잘 고려하여 해줘야만 한다. \n보통 최소값을 구하기 위한 초기값은 변수의 범위 이상 값을 넣어주고  \n최대값을 구하기 위한 초기값은 0을 넣어주는것이 일반적이지만 절대적이지는 않다!\n\n<br><br>\n\n### 4. Top-Down / Bottom-Up 두가지 방식 모두 생각하라!\n보통 두가지 방식으로 같이 풀리는 경우가 많지만 그렇지 않은 경우도 꽤 있다.\n두가지 방식을 동시에 생각하는 사고를 반드시 가지자!!\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":363413327,"tx":19},"cXAfswLPLBmPzNUg/syncedContent":{"id":"cXAfswLPLBmPzNUg/syncedContent","type":"syncedContent","historyData":{"363413327":{"id":"cXAfswLPLBmPzNUg/content","type":"content","text":"---\ntitle: \"[알고리즘] 동적 계획법(Dynamic Programming) \"\ndate: 2022-01-01 01:00:00\ncategories:\n- Algorithm\ntags:\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n# 동적 계획법 ( Dynamic Programming )\n<hr>\n\n## 동적 계획법 개요\n**동적 계획법**은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법을 사용하는 알고리즘들 또한 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내는 방식이기 때문이다.\n\n동적 계획법과 분할 정복의 가장 큰 차이는 **문제를 나누는 방식**이다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용 될 수 있기 때문에 이를 여러번 계산하는 것 대신 한번만 계산하게 만듦으로써 속도 향상을 꾀할 수 있다. 그러기 위해선 부분 문제를 메모리에 저장해 둘 필요가 있는데 이 메모리 장소를 **캐시(cache)**라고 부른다.\n\n<br><br><br><br><br><br>\n\n이를 피보나치 수열 함수를 예로 설명해보겠다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/Fibo.png?raw=true\">\n</p>\n위의 그림은 피보나치 함수를 분할 정복방식으로 구현한 것이다. 함수 이름을 fib(n) 이라고 했을때, 예시처럼 fib(5)를 구하기 위해선 총 **15번**의 함수 호출이 필요하다. 이때, fib(2)는 총 3번 호출되는것을 볼 수 있는데 이는 **동일한 계산과정을 3번이나 반복하게 되어 알고리즘의 실행시간이 길어지게 된다**.\n\n<br><br><br>\n\n이런 중복계산을 **캐시에 저장시킨 뒤 필요할 때마다 결과값만을 가져와서 사용하는 방식**을 **동적 계획법 ( Dynamic Programming )** 이라고한다.\n\n<br><br><br><br><br><br>\n\n동적 계획법 알고리즘의 가장 유명한 예 중 하나를 더 설명해보겠다. 바로 **이항 계수의 계산**이다. 이항 계수는 서로다른 n개의 원소중에서 r개의 원소를 순서없이 골라내는 방법의 수를 계산하는 것으로 다음과 같은 점화식이 성립한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ncr.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n이 점화식을 활용하여 n,r의 값이 주어질 때 그 결과를 반환하는 함수 **bino(n,r)**를 다음과 같이 작성할 수 있다.\n\n```c++\nint bino(int n, int r) {\n\tif(r == 0 || n == r) return 1;\n\treturn bino(n-1,r-1) + bino(n-1,r)\n```\n이 코드는 **분할 정복 알고리즘**을 사용한 것으로 **중복 계산**이 발생한다.\n<br><br><br><br><br><br>\n\n\n이를 **동적 계획법 알고리즘**으로 변환하여 작성한 코드는 다음과 같다.\n```c++\n// -1로 초기화해둔다\nint cache[30][30];\n\nint bino2(int n, int r) {\n\tif(r == 0 || n == r ) return 1;\n\t\n\tif(cache[n][r]!= -1) \n\treturn cache[n][r];\n\n\treturn cache[n][r] = bino2(n-1,r-1) + bino2(n-1,r);\n```\n코드처럼 cache라는 배열을 생성해준뒤 이곳에 값을 저장하는 방식을 사용하면 된다. 이를 **메모이제이션(memoization)** 이라고 부른다.\n\n\n<br><br><br><br><br><br>\n\n## 메모이제이션 구현 패턴\n\n동적계획법은 가장 흔한 문제 유형 중 하나이기 때문에 메모이제이션을 굉장히 많이 구현하게 된다. 그렇기 때문에 **한가지 패턴**을 정해놓고 문제를 항상 같은 형태로 풀어가게 되면 문제 풀이에 도움이 많이 된다. 이 패턴을 소개해 보겠다.\n\n<br><br><br>\n\n1. **항상 예외처리를 제일 먼저 처리해라.**\n\n\t예외상황은 각종 오류를 유발하므로 제일 먼저 처리해놓는 것이 좋다.\n\t\n2. **cache를 초기화 해줘라. feat. memset( )**\n\n\t초기화 할때는 C++ STL에 내재되어 있는 memset( ) 메소드를 활용하면 편리하다. **memset ( 메모리시작주소, 값, 크기 )** 를 사용하면 된다.\n\tEX ) memset ( cache, -1, sizeof(cache) ) \n\t \n3. **return 값을 활용해라.**\n\tcache를 사용할 때마다 매번 cache[n][r]처럼 쓰지말고 return값을 활용해라.\n\n4. **점화식을 만들어라.**\n\t\n<br><br><br><br><br><br>\n\n\n===========================================================\n\n**※ 2022-01-14 추가**\n\n근 한달간 DP문제를 쭉 풀어보면서 깨달은 문제풀이 방법을 정리해보도록 하겠다.\n\n<br><br><br>\n\n### 1. 문제에서 구하려고 하는 답을 점화식으로 나타낸다.\nDP모든 문제는 점화식으로 표현이 가능하다. \n점화식으로만 표현한다면 문제는 사실상 거의 다 풀린것이나 다름없다.\n점화식에는 꼭 한가지 식만 들어갈 필요도 없다. \n여러 식을 혼합해도 되고 변수를 이용해도 좋다\n[백준 14002번 : 가장 긴 증가하는 부분 수열4](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%8014002%EB%B2%88/) 문제에서 여러 식과 변수가 혼합된 점화식을 살펴볼 수 있다!\n<br><br>\n\n### 2. 점화식은 이차원 배열을 사용하기도 한다.\n이차원 배열을 잘 활용해 점화식을 만들면 편리한 경우도 많다.\n[백준 15990번 : 1,2,3 더하기 5](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%8015990%EB%B2%88/) 문제는 이차원 배열을 사용하는 대표예제이다.\n<br><br>\n\n### 3. 최소값, 최대값을 구할때는 초기화가 중요하다.\n최소, 최대값은 비교대상이 필요하기 때문에 메모이제이션을 할 때 초기화를 해주는 것이 좋다.\n어떤 값으로 초기화 해주는지는 문제에 따라 잘 고려하여 해줘야만 한다. \n보통 최소값을 구하기 위한 초기값은 변수의 범위 이상 값을 넣어주고  \n최대값을 구하기 위한 초기값은 0을 넣어주는것이 일반적이지만 절대적이지는 않다!\n\n<br><br>\n\n### 4. Top-Down / Bottom-Up 두가지 방식 모두 생각하라!\n보통 두가지 방식으로 같이 풀리는 경우가 많지만 그렇지 않은 경우도 꽤 있다.\n두가지 방식을 동시에 생각하는 사고를 반드시 가지자!!\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":363413327}},"syncHistory":{"main":[363413327,null,null]},"v":1,"hash":1710111505823,"tx":19},"AccPceb6fVYGLjbn/content":{"id":"AccPceb6fVYGLjbn/content","type":"content","text":"---\ntitle: \"[자료구조] 큐( Queue ) \"\ndate: 2021-09-03 01:00:00\ncategories:\n- 자료구조\ntags:\n- 자료구조\n---\n\n## Goal\n\n> Queue의 기본개념을 이해한다.   \n> Queue의 구조를 확인한다.   \n> Queue를 C/C++ 로 구현한다.  \n\n<br><br><br><br><br><br>\n\n## 큐(Queue)의 개념\n먼저 삽입한 데이터가 먼저나오는 **FIFO(First In First Out)** 형식의 자료구조이다.  \n**Stack**과는 정반대라고 생각하면 쉽다.\n\n<br><br><br><br><br><br>\n\n## 큐(Queue)의 종류\n\nQueue는 일반적으로 연결 리스트 (Linked List)를 이용하며 구현 형태에 따라 선형 큐, 원형 큐 등으로 나뉜다.\n\n\n<br><br><br>\n\n### 1) 선형 큐\n<hr>\n선형 큐는 배열을 선형으로 나타낸 형태이다. 자료의 삽입이나 삭제가 용이하나 큐에 빈 자리가 있어도 포화 상태로 인식하는 경우가 있어 빈 자리를 따로 정리 과정을 거쳐야 한다는 단점이 있다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/queue_concept_01.png?raw=true)\n\n<br><br><br>\n\n### 2) 원형 큐\n<hr>\n배열을 원형의 모습으로 표현한 것으로 논리적으로 배열의 처음과 끝을 연결한 형태이다. 자리를 이동시킬 필요가 없어 실용적인 특징을 가지고 있다.\n\n원형 큐에서는 초기 공백 상태에서 front와 rear의 값을 0으로 하고 공백 상태와 포화 상태를 구분하기 위해 자리를 비워둔다. 자료를 삽일할 경우 rear의 위치를 한 칸 앞으로 옮기고 그곳에 자료를 삽입한다. 따라서 front가 지정하는 위치는 항상 비워진 상태로 유지된다.\n\n\n<br><br><br><br><br><br>\n\n\n\n## 큐(Queue)의 STL 라이브러리 \n### 1) Queue 헤더파일과 선언\n\n```c++\n#include <queue>\t// 헤더파일\nqueue <int> qu;\t\t// queue < 데이터타입 > 이름;\n```\n\n<br>\n\n### 2) Queue 기본 함수\n\n**▣ Queue에 데이터 추가하기**\n```c++\nqu.push(element);\n```\n\n<br><br>\n\n**▣ Queue 데이터 삭제하기**\n```c++\nqu.pop();\n```\n\n<br><br>\n\n**▣ Queue의 첫번째 데이터 반환**\n```c++\nqu.front();\n```\n\n<br><br>\n\n**▣ Queue의 마지막 데이터 반환**\n```c++\nqu.back();\n```\n\n<br><br>\n\n**▣ Queue 사이즈 반환**\n```c++\nqu.size()\n```\n\n<br><br>\n\n**▣ Queue가 비어있는지 확인**\n```c++\nqu.empty()\n```\n<br><br><br><br><br><br>\n\n\n## 큐(Queue) 코드 구현 [ C++ / STL ]\n[\"백준 10845번 : 큐\"   ](https://www.acmicpc.net/problem/10845)\n```c++\n#include <iostream>\n#include <queue>\n\nusing namespace std;\nusing std::cout;\nusing std::cin;\n\nint main() {\n\n\tint num;\n\tcin >> num;\n\tqueue <int> qu;\n\n\twhile (num--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tint temp;\n\t\tif (str == \"push\") {\n\t\t\tcin >> temp;\n\t\t\tqu.push(temp);\n\t\t}\n\t\telse if (str == \"front\") {\n\t\t\tif (qu.empty()) {\n\t\t\t\tcout << \"-1\" << endl;\n\t\t\t}\n\t\t\telse cout << qu.front() << endl;\n\t\t}\n\t\telse if (str == \"back\") {\n\t\t\tif (qu.empty()) {\n\t\t\t\tcout << \"-1\" << endl;\n\t\t\t}\n\t\t\telse cout << qu.back() << endl;\n\t\t}\n\t\telse if (str == \"size\") {\n\t\t\tcout << qu.size() << endl;\n\t\t}\n\t\telse if (str == \"pop\") {\n\t\t\tif (qu.empty()) cout << \"-1\" << endl;\n\t\t\telse {\n\t\t\t\tcout << qu.front() << endl;\n\t\t\t\tqu.pop();\n\n\t\t\t}\n\t\t}\n\t\telse if (str == \"empty\") {\n\t\t\tif (qu.empty()) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n```\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1466512106,"tx":23},"AccPceb6fVYGLjbn/syncedContent":{"id":"AccPceb6fVYGLjbn/syncedContent","type":"syncedContent","historyData":{"-1466512106":{"id":"AccPceb6fVYGLjbn/content","type":"content","text":"---\ntitle: \"[자료구조] 큐( Queue ) \"\ndate: 2021-09-03 01:00:00\ncategories:\n- 자료구조\ntags:\n- 자료구조\n---\n\n## Goal\n\n> Queue의 기본개념을 이해한다.   \n> Queue의 구조를 확인한다.   \n> Queue를 C/C++ 로 구현한다.  \n\n<br><br><br><br><br><br>\n\n## 큐(Queue)의 개념\n먼저 삽입한 데이터가 먼저나오는 **FIFO(First In First Out)** 형식의 자료구조이다.  \n**Stack**과는 정반대라고 생각하면 쉽다.\n\n<br><br><br><br><br><br>\n\n## 큐(Queue)의 종류\n\nQueue는 일반적으로 연결 리스트 (Linked List)를 이용하며 구현 형태에 따라 선형 큐, 원형 큐 등으로 나뉜다.\n\n\n<br><br><br>\n\n### 1) 선형 큐\n<hr>\n선형 큐는 배열을 선형으로 나타낸 형태이다. 자료의 삽입이나 삭제가 용이하나 큐에 빈 자리가 있어도 포화 상태로 인식하는 경우가 있어 빈 자리를 따로 정리 과정을 거쳐야 한다는 단점이 있다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/queue_concept_01.png?raw=true)\n\n<br><br><br>\n\n### 2) 원형 큐\n<hr>\n배열을 원형의 모습으로 표현한 것으로 논리적으로 배열의 처음과 끝을 연결한 형태이다. 자리를 이동시킬 필요가 없어 실용적인 특징을 가지고 있다.\n\n원형 큐에서는 초기 공백 상태에서 front와 rear의 값을 0으로 하고 공백 상태와 포화 상태를 구분하기 위해 자리를 비워둔다. 자료를 삽일할 경우 rear의 위치를 한 칸 앞으로 옮기고 그곳에 자료를 삽입한다. 따라서 front가 지정하는 위치는 항상 비워진 상태로 유지된다.\n\n\n<br><br><br><br><br><br>\n\n\n\n## 큐(Queue)의 STL 라이브러리 \n### 1) Queue 헤더파일과 선언\n\n```c++\n#include <queue>\t// 헤더파일\nqueue <int> qu;\t\t// queue < 데이터타입 > 이름;\n```\n\n<br>\n\n### 2) Queue 기본 함수\n\n**▣ Queue에 데이터 추가하기**\n```c++\nqu.push(element);\n```\n\n<br><br>\n\n**▣ Queue 데이터 삭제하기**\n```c++\nqu.pop();\n```\n\n<br><br>\n\n**▣ Queue의 첫번째 데이터 반환**\n```c++\nqu.front();\n```\n\n<br><br>\n\n**▣ Queue의 마지막 데이터 반환**\n```c++\nqu.back();\n```\n\n<br><br>\n\n**▣ Queue 사이즈 반환**\n```c++\nqu.size()\n```\n\n<br><br>\n\n**▣ Queue가 비어있는지 확인**\n```c++\nqu.empty()\n```\n<br><br><br><br><br><br>\n\n\n## 큐(Queue) 코드 구현 [ C++ / STL ]\n[\"백준 10845번 : 큐\"   ](https://www.acmicpc.net/problem/10845)\n```c++\n#include <iostream>\n#include <queue>\n\nusing namespace std;\nusing std::cout;\nusing std::cin;\n\nint main() {\n\n\tint num;\n\tcin >> num;\n\tqueue <int> qu;\n\n\twhile (num--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tint temp;\n\t\tif (str == \"push\") {\n\t\t\tcin >> temp;\n\t\t\tqu.push(temp);\n\t\t}\n\t\telse if (str == \"front\") {\n\t\t\tif (qu.empty()) {\n\t\t\t\tcout << \"-1\" << endl;\n\t\t\t}\n\t\t\telse cout << qu.front() << endl;\n\t\t}\n\t\telse if (str == \"back\") {\n\t\t\tif (qu.empty()) {\n\t\t\t\tcout << \"-1\" << endl;\n\t\t\t}\n\t\t\telse cout << qu.back() << endl;\n\t\t}\n\t\telse if (str == \"size\") {\n\t\t\tcout << qu.size() << endl;\n\t\t}\n\t\telse if (str == \"pop\") {\n\t\t\tif (qu.empty()) cout << \"-1\" << endl;\n\t\t\telse {\n\t\t\t\tcout << qu.front() << endl;\n\t\t\t\tqu.pop();\n\n\t\t\t}\n\t\t}\n\t\telse if (str == \"empty\") {\n\t\t\tif (qu.empty()) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n```\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1466512106}},"syncHistory":{"main":[-1466512106,null,null]},"v":1,"hash":1710111508442,"tx":23},"D6AI3WmiULa0MQox/syncedContent":{"id":"D6AI3WmiULa0MQox/syncedContent","type":"syncedContent","historyData":{"175872295":{"id":"D6AI3WmiULa0MQox/content","type":"content","text":"---\ntitle: \"[머신러닝] [Python] 4. Support Vector Machine  (SVM)\"\ndate: 2021-09-24 06:00:00\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- Classification\n---\n# 서포트 벡터 머신이란\n<hr>\n**서포트 벡터 머신(이하 SVM)**은  **결정 경계(Decision Boundary)**, 즉 분류를 위한 기준 선을 정의하는 모델이다. 그래서 분류되지 않은 새로운 점이 나타나면 경계의 어느 쪽에 속하는지 확인해서 분류 과제를 수행할 수 있게 된다.\n\n결국 이  **결정 경계**라는 걸 어떻게 정의하고 계산하는지 이해하는 게 중요하다는 뜻이다.\n\n예시를 들어 보자.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm1.png?raw=true\">\n</p>\n\n데이터에 2개의 속성만 존재한다면 위와같은 분포가 나타날 것이다. 이때 두 데이터 분포를 완벽하게 나누는 선, 즉 **결정 경계**는 무수히 많이 존재할 수 있다.\n\n<br><br><br><br><br><br>\n\n# Decision Boundary ( 최적의 결정경계 )\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm2.png?raw=true\">\n</p>\n\n그렇다면 **어떤 결정 경계가 가장 최적의 결정 경계일까**를 판단하는것이 관건이 된다. 위의 그림에서는 오른쪽 분포가 최적의 결정 경계를 나타낸다. 그 이유는 **경계를 기준으로 데이터가 더 멀리 분포되어 있기 때문이다**.\n<br><br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm3.png?raw=true\">\n</p>\n이제 간단히 용어정리를 하고 넘어가겠다.\n두개의 cluster를 나누는 선을 **Separating line 혹은 Decision boundary 혹은 Classifier**\nSeparating line의 가장 경계부분에 있는 데이터를 **Support Vectors**\nSeparating line부터 Support Vectors까지의 영역을 **Margin** 이라고 부른다.\n\n<br><br><br>\n\n여기서 하나의 결론을 얻을 수 있다. **최적의 결정 경계는 마진을 최대화한다.**\n\n또한 SVM알고리즘의 장점을 하나 알수 있다.\n\n대부분의 머신러닝 지도 학습 알고리즘은 학습 데이터 모두를 사용하여 모델을 학습한다. 그런데 **SVM에서는 결정 경계를 정의하는 게 결국 서포트 벡터이기 때문에 데이터 포인트 중에서 서포트 벡터만 잘 골라내면 나머지 쓸 데 없는 수많은 데이터 포인트들을 무시할 수 있다. 그래서 매우 빠르다.**\n\n<br><br><br><br><br><br>\n\n\n\n앞서 들은 예시는 매우 이상적인 형태의 데이터 분포로 명확하게 Decision Boundary를 구할 수 있었다. 그러나 대부분의 데이터들은 명확하게 분류 할 수 없는 형태를 띈다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm4.png?raw=true\">\n</p>\n\n이런 경우에는 두가지 방법을 사용해 분류 할 수 있다.\n\n**1) Soft Margin\n2) Kernel Trick**\n\n<br><br><br><br><br><br>\n\n# Soft Margin\n<hr>\n소프트 마진은 두가지만 기억하면 된다.\n\n**1. 마진을 크게  \n2. 약간의 error를 허용하는것**  \n\n이를 위해선 **\"C\"**라고 불리는 penalty parameter를 사용한다.\n\n**C값이 클수록 하드마진( 오류 허용안함), 작을수록 소프트마진(오류를 허용함)을 의미한다.**\n\nC값의 최적 값은 데이터마다 다르므로 여러가지 C값을 넣어보면서 모델을 검증하는 수밖에 없다.\n\nscikit-learn에서는 SVM모델이 오류를 어느정도 허용할 것인지를 파라미터 C를 통해 지정할 수 있다. (기본 값은 1이다.)\n\n```python\nclassifier = SVC(C=0.01)\n```\n\n<br><br><br>\n\n## \"C\" 의 Tradeoffs\nC를 사용해 마진의 너비를 조절하면 그 장단점이 분명하다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm5.png?raw=true\">\n</p>\n\n**C값을 줄이면 ( 소프트마진 ) 마진은 커지고 Error도 커진다.\nC값을 늘리면 ( 하드마진 ) 마진은 작아지고 Error도 작아진다.**\n\n\n<br><br><br><br><br><br>\n\n# Kernel\n<hr>\n앞서 설명한 것들은 모두 Linear하게 분리가 가능한 데이터셋이였지만 만약 선형으로 분리 할 수 없는 데이터셋이 있다면 어떻게 해야할까?\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm6.png?raw=true\">\n</p>\n\n위와같은 데이터는 어떤식으로는 선형으로 분류할 수 없는 데이터이다.\n이때 사용 할 수 있는 개념이 **Kernel**이다.\n\n**Kernel**이란 **데이터셋을 현재차원보다 고차원으로 변형시켜 선형으로 분류가 가능하게끔 만드는 것을 말한다**.\n\n위의 데이터를 Kernel을 사용해 선형 분류한 최종 결과는 아래 그림과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm7.png?raw=true\">\n</p>\n\n<br><br><br>\n\nscikit-learn에서 Kernel로 사용할 수 있는 함수는 대표적으로 4가지가 있다.\n\n - **Linear kernel**   \n - **Polynomial kernel**   \n - **RBF kernel (=Gaussian kernel)**   \n - **Sigmoid kernel**  \n\nLinear역시 커널의 한종류이며 RBF커널에 대해 좀더 자세히 알아보자.\n\n<br><br><br><br><br><br>\n\n## RBF kernel\n\n**RBF 커널** 혹은 **가우시안 커널**이라고 부른다.\n\nRBF커널은 2차원의 점을 무한한 차원의 점으로 변환한다. 이 과정에서 상당히 복잡한 선형대수학이 사용되지만 생략하도록 하겠다.\n\n이를 scikit-learn으로 구현한 코드는 아래와 같다.\n```python\nfrom sklearn.svm import SVC\n\nclassifier = SVC(kernel='rbf')\n```\n모델을 불러올 때 kernel의 기본값은 `'rbf'`로 설정되어 있고 이 외에도 `'linear'`, `'poly'`, `'sigmoid'` 같은 걸로 지정해줄 수도 있다.\n\n<br><br><br><br><br><br>\n\n## Gamma\n커널을 사용할 때 C말고도 사용할 수 있는 파라미터가 하나 더 있는데 그게 바로 **감마(gamma)**이다.  `'rbf'`,  `'poly'`,  `'sigmoid'` 커널을 사용할 때 `gamma`를 설정해줘야 한다.\n```python\nclassifier = SVC(kernel = \"rbf\", C = 2, gamma = 0.5)\n```\n\n`gamma`는 결정 경계를 얼마나 유연하게 그을지 정해주는 것이다. 학습 데이터에 얼마나 민감하게 반응할 것인지 모델을 조정하는 것이므로 C와 비슷하다고 볼 수 있다.\n\n<br><br><br>\n\n-   `gamma`값을  **높이면**  학습 데이터에 많이 의존해서  **결정 경계를 구불구불**  긋게 된다. 이는  **오버피팅**을 초래할 수 있다.\n\n-   반대로  `gamma`를  **낮추면**  학습 데이터에 별로 의존하지 않고  **결정 경계를 직선에 가깝게**  긋게 된다. 이러면  **언더피팅**이 발생할 수 있다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm8.png?raw=true\">\n</p>\n\n위의 그림을 보면 감마에 대한 이해가 쉽다.\ngamma = 3.0 인경우가 적당한 경우의 모습이라고 보면되고\ngamma = 0.008인 경우 너무 낮아 경계가 직선형을 띄는 모습\ngamma = 11.0인 경우 너무 높아 경계가 제대로 이루어지지 못한 모습이다.\n\n<br><br><br><br><br><br>\n\n# Multi-Class SVM\n<hr>\nSVM은 Binary Classifier로 이진분류만 가능하지만 SVM을 이용해 다중 Class의 분류도 가능하다. 간단하게 예시를 들어 맛만보자.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm9.png?raw=true\">\n</p>\n\n원리는 간단하다. 세개의 클래스중 한개를 제외한 나머지를 하나의 클래스로 분류한뒤 이진분류를 진행해주면 된다.\n\n<br><br><br><br><br><br>\n\n# SVM의 장/단점\n\n## Advantages\n\n - 마진이 명확하게 구분될때 잘 작동한다. \n - 고차원 데이터 ( Feature가 많은 경우) 일때 효과적이다. \n - Support Vector만 사용해 경계를 계산하므로 메모리를 효율적으로 쓴다.\n\n## Disadvantages\n- 데이터셋이 많은 경우 Training time이 오래걸린다.\n- 데이터에 noise가 많은 경우 잘 작동하지 않는다\n- 정확도를 직접적으로 보여주진 않는다.\n\n<br><br><br><br><br><br>\n\n# SVM을 사용할 때 유의점\n<hr>\n1. 어떤 커널을 사용할 지 결정해야만 한다. \n\t- `rgf`가 기본값으로 설정되어있다.\n2. 커널 파라미터를 결정해야 한다.\n\t- gamma, 가우시안 커널의 σ\n3. 하드마진 vs 소프트마진 어떤걸 사용할지 C를 이용해 결정해야 한다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":175872295}},"syncHistory":{"main":[175872295,null,null]},"v":1,"hash":1710111509761,"tx":25},"2YcBlgoRtPYITlYT/content":{"id":"2YcBlgoRtPYITlYT/content","type":"content","text":"---\ntitle: \"[머신러닝] [Python] 5. Expectation-Maximization (EM)\"\ndate: 2021-09-25 06:00:00\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- Classification\n- EM\n---\n\n# EM 알고리즘 이란\n<hr>\nExpectation-Maximization 알고리즘이란, 관측되지 않은 잠재변수에 의존하는 확률 모델에서 Maximum Likelihood ( 최대가능도 ) 나 Maximum A Posteriori ( 최대사후확률)을 갖는 모수의 추정값을 찾는 반복적인 알고리즘이다. \n\nEM 알고리즘은 모수에 관한 추정값으로 로그가능도 ( Log Likelihood )의 기댓값을 계산하는 **(E) 단계**와 이 기댓값을 최대화하는 모수 추정값들을 구하는 최대화 **(M) 단계**를 번갈아가면서 적용한다. \n\n처음보는 단어가 많아 그 정의를 정확하게 이해가기가 어려울 것이다. 예시를 들어 쉽게 설명해 보겠다.\n\n<br><br><br><br><br><br>\n\n> **상태를 아는 경우 (State Known)**\n\n동전 A와 동전 B가 주어진다.  우리는 각 동전의 앞/뒷면이 나오는 확률을 모르고 이 확률을 구하고자 한다. 이때 두개의 동전 중 하나를 랜덤하게 선택한다. 동전 B가 먼저 선택되었다면 이를 열번 던져 앞면(H)과 뒷면(T)이 나오는 경우의 수를 차례대로 적는다. 이렇게 동전을 선택하고 열번 던지는 과정을 5번 반복한다. \n\n여기서 우리는 각 차수마다 동전 A를 선택했는지, B를 선택했는지 알고 있다. 이는 우리가 상태를 아는 경우에 해당한다. 이때 우리는 **각 동전의 앞/뒷면이 나올 확률**을 구하고 싶다. 이를 구하기 위해서는 Maximum Likelihood (최대 가능도) 를 사용한다. 다음과 같이 동전 A를 선택하였을 때 앞면이 나온 총 횟수 24와 뒷면이 나온 총 횟수 6을 사용하여 앞면이 나올 최대 가능도는 24/24+6 = 0.8을 구할 수 있다. 마찬가지로 동전 B의 앞면이 나올 확률 0.45를 구할 수 있다. 각 차수마다 어떤 동전을 선택했는지 아는 상태이기에, 한 차수에는 한 동전에 대한 가능성만을 계산한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/em1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n> **상태를 모르는 경우 (State Unknown)**\n\n위의 예시와 동일하지만 단 한가지가 다른 경우를 살펴보자. 똑같이 각 동전A와 동전 B의 앞/뒷면이 나올 확률을 구하고자 하지만 어떤 동전이 선택된지 모른채 동전을 던진다고 가정해보자. 우리는 **각 차수에 어떤 동전이 선택되었는지 추가로 추측**을 해야하며 각 동전의 확률을 구해야만 한다.\n\n이를 해결할 수 있는 방법이 바로 **EM Algorithm**이다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/em2.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n# EM 알고리즘\n\n계속해서 위와 동일한 예시로 EM알고리즘을 구현하는 과정을 설명해보겠다.\n5개의 동전이 있고 이를 랜덤으로 선택해 각각 열번씩 던진다고 가정하자. 이때 우리는 각 차수마다 어떤 동전을 선택했는지 모르는 상황(State Unknown)이다.\n\n<br><br><br>\n\n## 초기값\nEM알고리즘의 시작은 초기값 설정이다. 동전 A의 앞면이 나올 확률을 p=0.6, 동전 B의 앞면이 나올 확률을 q=0.5라고 임의로 설정한다. 이때 초기값은 **랜덤하게 결정**해주는 것이다.\n\n<br><br><br>\n\n## E-Step\n주어진 추정값( 초기는 랜덤값 )을 사용하여 각 차수마다 동전의 앞/뒷면이 나올 확률을 구해본다. 그림에서 1번 차수는 HTTTHHTHTH로 주어졌으므로 이를 활용한다. 이때 **베이즈 정리**를 활용해 계산을 해야하는데 베이즈 정리에 대해 간단히 정리해보겠다.\n\n <br><br><br>\n\n동전 A를 사용한 경우 *a = p<sup>5</sup> x (1-p)<sup>5</sup>= 0.6<sup>5</sup> x 0.4<sup>5</sup>*\n\n동전 B를 사용한 경우 *b = q<sup>5</sup> x (1-q)<sup>5</sup>= 0.6<sup>5</sup> x 0.4<sup>5</sup>*\n\n이때 H가 5번, T가 5번이 나왔으므로 각각 5제곱을 해준것이다.\n\n1차수에서 동전 A를 사용했을 비율 : *a / ( a + b ) = 0.45*\n\n1차수에서 동전 B를 사용했을 비율 : *b / ( a + b ) = 0.55* \n\n<br><br><br>\n\n## M-Step\n1차수에서 A를 사용했을 확률은 0.45, B를 사용했을 확률은 0.55로 측정됐다.\n\n이때 1차수에서는 H가 5번, T가 5번 나왔으므로 \n\n - 동전 A인 경우 H 개수 : 0.45 x 5 = 2.2   \n - 동전 A인 경우 T 개수 : 0.45 x 5 = 2.2   \n - 동전 B인 경우 H 개수 : 0.55 x 5 = 2.8   \n - 동전 B인 경우 T 개수 : 0.55 x 5 = 2.8  \n\n이에 더해 1차수부터 5차수까지 같은 과정을 반복하면 아래와 같은 결과가 나온다.\n\n\n - 동전 A인 경우 전체 H 개수 : 21.3   \n - 동전 A인 경우 전체 T 개수 : 8.6   \n - 동전 B인 경우 전체 H 개수 : 11.7  \n - 동전 B인 경우 전체 T 개수 : 8.4  \n\n동전 A의 H가 나올 확률 p : 21.3 / (21.3 + 8.6) = 0.71\n동전 B의 H가 나올 확률 q : 11.7 / (11.7 + 8.4) = 0.58\n\n처음 추정한 p : 0.6 -> p : 0.71\n처음 추정한 q : 0.5 -> q : 0.58로 변화된 것을 알 수 있다.\n\n<br><br><br><br><br><br>\n\n## E-M Step의 반복\n\nE-M 과정을 한번 거쳤을 때 p : 0.71 q : 0.58이 나왔다.\n이 과정을최종적으로 p와 q값이 크게 변하지 않을 때까지 반복한다.\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":336953453,"tx":27},"2YcBlgoRtPYITlYT/syncedContent":{"id":"2YcBlgoRtPYITlYT/syncedContent","type":"syncedContent","historyData":{"336953453":{"id":"2YcBlgoRtPYITlYT/content","type":"content","text":"---\ntitle: \"[머신러닝] [Python] 5. Expectation-Maximization (EM)\"\ndate: 2021-09-25 06:00:00\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- Classification\n- EM\n---\n\n# EM 알고리즘 이란\n<hr>\nExpectation-Maximization 알고리즘이란, 관측되지 않은 잠재변수에 의존하는 확률 모델에서 Maximum Likelihood ( 최대가능도 ) 나 Maximum A Posteriori ( 최대사후확률)을 갖는 모수의 추정값을 찾는 반복적인 알고리즘이다. \n\nEM 알고리즘은 모수에 관한 추정값으로 로그가능도 ( Log Likelihood )의 기댓값을 계산하는 **(E) 단계**와 이 기댓값을 최대화하는 모수 추정값들을 구하는 최대화 **(M) 단계**를 번갈아가면서 적용한다. \n\n처음보는 단어가 많아 그 정의를 정확하게 이해가기가 어려울 것이다. 예시를 들어 쉽게 설명해 보겠다.\n\n<br><br><br><br><br><br>\n\n> **상태를 아는 경우 (State Known)**\n\n동전 A와 동전 B가 주어진다.  우리는 각 동전의 앞/뒷면이 나오는 확률을 모르고 이 확률을 구하고자 한다. 이때 두개의 동전 중 하나를 랜덤하게 선택한다. 동전 B가 먼저 선택되었다면 이를 열번 던져 앞면(H)과 뒷면(T)이 나오는 경우의 수를 차례대로 적는다. 이렇게 동전을 선택하고 열번 던지는 과정을 5번 반복한다. \n\n여기서 우리는 각 차수마다 동전 A를 선택했는지, B를 선택했는지 알고 있다. 이는 우리가 상태를 아는 경우에 해당한다. 이때 우리는 **각 동전의 앞/뒷면이 나올 확률**을 구하고 싶다. 이를 구하기 위해서는 Maximum Likelihood (최대 가능도) 를 사용한다. 다음과 같이 동전 A를 선택하였을 때 앞면이 나온 총 횟수 24와 뒷면이 나온 총 횟수 6을 사용하여 앞면이 나올 최대 가능도는 24/24+6 = 0.8을 구할 수 있다. 마찬가지로 동전 B의 앞면이 나올 확률 0.45를 구할 수 있다. 각 차수마다 어떤 동전을 선택했는지 아는 상태이기에, 한 차수에는 한 동전에 대한 가능성만을 계산한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/em1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n> **상태를 모르는 경우 (State Unknown)**\n\n위의 예시와 동일하지만 단 한가지가 다른 경우를 살펴보자. 똑같이 각 동전A와 동전 B의 앞/뒷면이 나올 확률을 구하고자 하지만 어떤 동전이 선택된지 모른채 동전을 던진다고 가정해보자. 우리는 **각 차수에 어떤 동전이 선택되었는지 추가로 추측**을 해야하며 각 동전의 확률을 구해야만 한다.\n\n이를 해결할 수 있는 방법이 바로 **EM Algorithm**이다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/em2.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n# EM 알고리즘\n\n계속해서 위와 동일한 예시로 EM알고리즘을 구현하는 과정을 설명해보겠다.\n5개의 동전이 있고 이를 랜덤으로 선택해 각각 열번씩 던진다고 가정하자. 이때 우리는 각 차수마다 어떤 동전을 선택했는지 모르는 상황(State Unknown)이다.\n\n<br><br><br>\n\n## 초기값\nEM알고리즘의 시작은 초기값 설정이다. 동전 A의 앞면이 나올 확률을 p=0.6, 동전 B의 앞면이 나올 확률을 q=0.5라고 임의로 설정한다. 이때 초기값은 **랜덤하게 결정**해주는 것이다.\n\n<br><br><br>\n\n## E-Step\n주어진 추정값( 초기는 랜덤값 )을 사용하여 각 차수마다 동전의 앞/뒷면이 나올 확률을 구해본다. 그림에서 1번 차수는 HTTTHHTHTH로 주어졌으므로 이를 활용한다. 이때 **베이즈 정리**를 활용해 계산을 해야하는데 베이즈 정리에 대해 간단히 정리해보겠다.\n\n <br><br><br>\n\n동전 A를 사용한 경우 *a = p<sup>5</sup> x (1-p)<sup>5</sup>= 0.6<sup>5</sup> x 0.4<sup>5</sup>*\n\n동전 B를 사용한 경우 *b = q<sup>5</sup> x (1-q)<sup>5</sup>= 0.6<sup>5</sup> x 0.4<sup>5</sup>*\n\n이때 H가 5번, T가 5번이 나왔으므로 각각 5제곱을 해준것이다.\n\n1차수에서 동전 A를 사용했을 비율 : *a / ( a + b ) = 0.45*\n\n1차수에서 동전 B를 사용했을 비율 : *b / ( a + b ) = 0.55* \n\n<br><br><br>\n\n## M-Step\n1차수에서 A를 사용했을 확률은 0.45, B를 사용했을 확률은 0.55로 측정됐다.\n\n이때 1차수에서는 H가 5번, T가 5번 나왔으므로 \n\n - 동전 A인 경우 H 개수 : 0.45 x 5 = 2.2   \n - 동전 A인 경우 T 개수 : 0.45 x 5 = 2.2   \n - 동전 B인 경우 H 개수 : 0.55 x 5 = 2.8   \n - 동전 B인 경우 T 개수 : 0.55 x 5 = 2.8  \n\n이에 더해 1차수부터 5차수까지 같은 과정을 반복하면 아래와 같은 결과가 나온다.\n\n\n - 동전 A인 경우 전체 H 개수 : 21.3   \n - 동전 A인 경우 전체 T 개수 : 8.6   \n - 동전 B인 경우 전체 H 개수 : 11.7  \n - 동전 B인 경우 전체 T 개수 : 8.4  \n\n동전 A의 H가 나올 확률 p : 21.3 / (21.3 + 8.6) = 0.71\n동전 B의 H가 나올 확률 q : 11.7 / (11.7 + 8.4) = 0.58\n\n처음 추정한 p : 0.6 -> p : 0.71\n처음 추정한 q : 0.5 -> q : 0.58로 변화된 것을 알 수 있다.\n\n<br><br><br><br><br><br>\n\n## E-M Step의 반복\n\nE-M 과정을 한번 거쳤을 때 p : 0.71 q : 0.58이 나왔다.\n이 과정을최종적으로 p와 q값이 크게 변하지 않을 때까지 반복한다.\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":336953453}},"syncHistory":{"main":[336953453,null,null]},"v":1,"hash":1710111510972,"tx":27},"1x2SS92trda8Dql0/syncedContent":{"id":"1x2SS92trda8Dql0/syncedContent","type":"syncedContent","historyData":{"1984698982":{"id":"1x2SS92trda8Dql0/content","type":"content","text":"---\ntitle: \"[컴퓨터 구조] 2. Instruction Set\"\ndate: 2021-09-12 03:00:00\ncategories:\n- Computer Architecture\ntags:\n- Instruction\n- Instruction Set Architecture\n- ARMv8\n---\n\n지난 포스팅에 이어 ISA에 대해 작성하겠다. 마이크로프로세서마다 기계어 코드의 길이와 숫자 코드가 다르기 때문에 그 양이 방대하므로 본 포스팅에서는 **ARMv8**의 ISA에 대해서 다루도록 하겠다.\n\n<br><br><br><br><br><br>\n\n# Arithmetic Operations ( 산술 연산 )\n\nadd와 sub, 그리고 3개의 operands(피연산자)가 존재한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ari.jpg?raw=true\">\n</p>\noperands에는 두개의 source(b,c)와 한개의 destination(a)이 존재한다.\n\n모든 산술연산은 이러한 형태를 가지고있다.\n\n### Design Principle 1 : Simplicity favors regularity\n여기서 첫번째 하드웨어 설계원칙을 살펴볼 수 있다. 모든 명령어가 operand를 3개씩 갖도록 제한함으로써 하드웨어를 단순하게 할 수 있다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ari2.jpg?raw=true\">\n</p>\n\n위 그림에서 Arithmetic Operation의 산술 과정을 살펴보자.\n\n**C 코드 :** \n```c\nf = ( g + h ) - ( i + j )\n```\n컴퓨터는 위의 코드를 다음과 같이 처리한다.\n\nt0 라는 임의의 변수에 g + h 값을 저장하고 t1이라는 변수에 i + j를 저장한다.\n\n그후 sub operation은 t0 - t1을 수행해 결과를 출력한다.\n\n<br><br><br><br><br><br>\n\n## The Stored-Program Concept\n\n위의 산술 연산자 뿐만아니라 다른 연산자를 실행할때 컴퓨터가 데이터를 저장하는 방법에 대해 알아보자.\n\n> **Instructions와 Data는 Binary(2진법)으로 Main Memory에 저장된다.**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ari3.jpg?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n본 노이만 컴퓨터 구조에서 반드시 알아둬야할 몇가지 note를 보자\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ari4.jpg?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n## Register Operands\n**레지스터는 프로세서 내부적으로 관리하는 저장공간**으로, 데이터를 담을 수 있는 가장 기본적인 단위이다. 일반적으로 레지스터의 크기는 **32bit**이다.\n\n그러나 본 포스팅에서 다룰 LEGv8같은 경우는 32,64bit의 레지스터를 둘다 가지며\n\n**64-bit 데이터는 \"double word\" 라고 불리우며\n32-bit 데이터는 \"word\" 라고 불린다.**\n\n**이때 레지스터는 0~31로 번호가 매겨져 있음을 유의해야 한다.**\n\n<br><br><br><br><br><br>\n\n### Design Principle 2 : Smaller is Faster\nLEGv8에서 레지스터의 수는 32개로 제한 됐으며 이는 더 빠른 연산을 위함이다.\ncf ) 메인메모리는 수백만개의 저장공간을 가진다.\n\n<br><br><br><br><br><br>\n\nLEGv8에서 제공하는 레지스터의 역할은 다음과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/re1.jpg?raw=true\">\n</p>\n\n**X0 ~ X7 : Procedure arguments / results\nX9 ~ X15 : 임시적으로 값을 저장\nX19 ~ X27 : 레지스터 저장\nXZR ( = X31 ) : 절대상수 0을 항상 갖고있음**\n\n<br><br><br><br><br><br>\n\n레지스터 피연산자의 예시를 보자.\n\n**C코드 :**\n```c\nf = ( g + h ) - ( i + j )\n```\n\n이때 f, ... , j 는 X19, X20, X21, X22, X23 에 각각 저장된다.\n이를 LEGv8 내부에서 인식하는 코드로 살펴보면 다음과 같다.\n\n\n\n> **ADD X9, X20, X21** \n> **ADD X10, X22, X23** \n> **SUB X19, X9, X10**\n\n<BR><BR><BR><BR><BR><BR>\n\n## Register vs Main Memory\n\n레지스터는 32비트 혹은 64비트의 저장소를 32개 가지므로 128B / 256B 의 크기를 가진다.\n\n메모리는 훨씬 큰 데이터를 저장할 수 있다.\n\n레지스터는 CPU내에 존재하는데 더 빠른 데이터 처리를 위해 존재한다. CPU가 메모리에 접근할 때마다 **BUS를 통해 이동하는 시간 + 메모리 처리 시간**이 소요되는데 이를 절약하기 위해 레지스터에 필요한 데이터를 미리 저장해두고 필요할 때마다 메모리에 접근하지 않고 레지스터에서 데이터를 빼가는 구조이다.\n\n이런 구조속에서 메모리와 레지스터 간에 데이터를 전달하기 위해서 우리는 **data transfer instruction**가 반드시 필요하다. 이때 사용되는 명령어는 단 두개! **load와 store**가 있다.\n\n> **load : memory -> register** \n> **store : register -> memory**\n\n이때 load와 store를 하기 위해선 반드시 **Memory Operands(Address)**가 필요하다.\n\n<br><br><br><br><br><br>\n\n## Memory Operands\n\n - **보통 메모리는 혼합된 데이터 ( 배열, 구조체, 동적할당 등 )을 위해 사용된다.** \n - **Arithmetic Operation을 위해 Register Operand를 사용하려면,** \n - **가장 먼저 Memory의 데이터를 Register로 Load 해야한다.**\n - **그리고 Register에서 연산하고, 결과 값을 다시 Memory에 Store한다.** \n - **이런 구조를 Load - Store 구조라고 한다.**\n\n<br><br><br><br><br><br>\n\n## Memory Operand Example\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mo1.jpg?raw=true\">\n</p>\n\n **1. h는 X21 레지스터에 저장되어 있고, 배열 A의 base address는 X22에 있다.\n 2. 먼저 A[8]을 가져오기 위해 Load 명령어를 실행한다.\n 3. A의 base address인 X22 레지스터부터\n 4. 배열의 8번째 값을 load하기 위해 8byte x 8번째 = 64의 byte offset을  X9라는 임시레지스터에서 Load한다.\n 5. X9에 저장된 A[8]과 X21에 저장된 h를 더해 X9에 다시 저장한다.\n 6. X9에 h + A[8]의 값인 A[12]를 Store 한다.**\n\n<br><br><br><br><br><br>\n\n## Immediate Operands\n우리가 상수를 더하고자 할때는 Instruction을 Load하는 과정을 거치지 않고 직접 더해버린다.\n\n**C코드 :** \n```c\nx = x + 4\n```\n이를 LEGv8에서는 다음과 같이 컴파일한다.\n\n> **ADDI X22, X22, #4**\n\n<br><br><br><br><br><br>\n\n### Design Principle 3 : Make the common case fast\n-> 작은 상수는 common에 해당한다.\n-> Immediate Operand는 불필요한 Load를 피한다!\n\n<br><br><br><br><br><br>\n\n## The Constant Zero\nLEGv8의 31번째 레지스터는 XZR, 즉 절대상수 0이다.\n이는 Common Operations에 굉장히 유용하다.\n\n**C코드 :** \n```c\ny = z\n```\n\n위와 같은 연산을 처리할때 또 다른 Instruction을 만들지말고 XZR을 활용할 수 있다.\n\n> **ADD X10, X11, XZR 또는 ORR X10, X11, XZR**\n\n","properties":"\n","discussions":{},"comments":{},"hash":1984698982}},"syncHistory":{"main":[1984698982,null,null]},"v":1,"hash":1710111512198,"tx":29},"tLqdQCgLBZOSaYBm/syncedContent":{"id":"tLqdQCgLBZOSaYBm/syncedContent","type":"syncedContent","historyData":{"-1401528883":{"id":"tLqdQCgLBZOSaYBm/content","type":"content","text":"---\ntitle: \"[컴퓨터 구조] 3. Instruction Set (2)\"\ndate: 2021-09-28 01:00:00\ncategories:\n- Computer Architecture\ntags:\n- Instruction\n- Instruction Set Architecture\n- ARMv8\n- Logical Operations\n---\n\n지난 포스팅에 이어 Instruction Set에 대해 작성해보겠다. 해당 포스팅은 가천대학교 소프트웨어학과 정용주 교수님의 강의를 기반으로 필요한 정보를 더 추가해 제작했음을 알립니다. \n\n<br><br><br><br><br><br>\n\n# Instruction Format ( 명령어 구조 )\n<hr>\nInstruction은 일정한 구조를 띈 채로 저장되는데 그 구조는 그림과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa1.png?raw=true\">\n</p>\n\n▪ LEGv8에서 Instruction (명령어)는 정확히 **32비트**의 크기를 가진다.\n▪ 각각의 segment는 **\"field\"**라고 부른다\n<br><br><br>\n명령어 구조는 우리가 보기 편하게 나타낸 것이고 실제로 컴퓨터가 받아드리는 것은 **binary number**로 인식한다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa2.png?raw=true\">\n</p>\n\n위와같이 numeric 하게 표현된 명령어를 **Machine Language (기계어)**라고 부른다.\n\n<br><br><br><br><br><br>\n\n# Types of Instructions\n<hr>\n\n명령어에는 일반적으로 3가지 종류가 있다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa3.png?raw=true\">\n</p>\n\n지금부터 각 명령어의 구조에 대해서 살펴보자.\n\n<br><br><br><br><br><br>\n\n## R-Format Instructions\n두개의 operand를 가지는 레지스터 2개와 연산 결과를 저장하는 레지스터 1개를 가리키는 명령어 구조이며, 일반적으로 **Arithmetic Operation**이나 **Logic Operation**에 사용된다. ( add, sub, mul, div, and, or 등 )\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa4.png?raw=true\">\n</p>\n\n▪ **Opcode** : 명령어의 종류를 나타낸다. ( Operation Code )\n\n▪ **Rm** : 두번째 오퍼랜드가 들어가는 레지스터의 주소를 담고있다. ( Source register )\n\n▪ **shamt** : 얼마나 쉬프트를 할지에 대한 정보를 담고있다. ( Shift amount )\n\n▪ **Rn** : 첫번째 오퍼랜드가 들어가는 레지스터의 주소를 담고있다. ( Target register )\n\n▪ **Rd** : 결과값이 담길 레지스터의 주소를 담고 있다. ( Destination register )\n\n<br><br><br>\n\n## R-Format Example\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa5.png?raw=true\">\n</p>\n\n▪ ADD X9, X20, X21 이라는 명령어가 주어졌을 때의 명령어 집합이다.\n\n▪ X9 = X20 + X21을 의미한다.\n\n▪ LEGv8에서 ADD의 opcode는 1112로 지정되어있다.\n\n▪ Rm에는 두번째 오퍼랜드인 X21의 레지스터 주소인 10101<sub>2</sub>(=21)을 담고있다.\n\n▪ shamt에는 따로 쉬프트 연산이 존재하지 않으므로 000000<sub>2</sub>을 담고있다.\n\n▪ Rn에는 첫번째 오퍼랜드인 X20의 레지스터 주소인 10100<sub>2</sub>(=20)을 담고있다.\n\n▪ Rd에는 결과값인 X9의 레지스터 주소인 01001<sub>2</sub>(=9)을 담고있다.\n\n▪ **이때 Rm, Rn, Rd는 5bit만 담을 수 있는데 그 이유는 LEGv8이 32개의 레지스터를 가지기 때문이다.**\n\n<br><br><br><br><br><br>\n\n## D-Format Instruction\nData Transfer를 하는 명령어 구조이다. **데이터를 가져오는 LDUR**과 **데이터를 저장하는 STUR 명령어**가 대표적이다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa6.png?raw=true\">\n</p>\n\n▪ **Opcode** : 명령어의 종류를 나타낸다. ( Operation Code )\n\n▪ **Address** : 저장될 데이터 Base register의 Offset ( 상대주소 ) 이 저장된다 \n\n▪ **Rn** : Base register의 주소를 담고있다.\n\n▪ **Rt** : Destination(Load) 또는 Source(Store)의 레지스터 주소를 담고있다.\n\n\n<br><br><br>\n\n## D-Format Example\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa7.png?raw=true\">\n</p>\n\n▪  LDUR : 어떤 데이터를 저장하겠다는 명령어이다.\n\n▪  X9가 Rt, 즉 결과값이 저장될 Destination이다.\n\n▪  [ X10 , #240 ] : X10 레지스터에 저장된 Base register의 240bit (= 30바이트) 짜리 크기가 240bit( = 30byte )인 데이터를 의미한다.\n\n<br><br><br><br><br><br>\n\n## I - Format Instruction\n\nImmediate Operation, Transfer(lw/sw 등), Branch 등을 위해 사용되는 Instruction Format이다. I-Foramt이 쓰이는 가장 중요한 이유는 레지스터가 아닌 메모리에 접근해서 무언가를 가져오거나, 상수를 반드시 써야할 때 사용된다. (레지스터가 아닌 오퍼랜드를 쓸때 I Format을 유용하게 사용한다)\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa8.png?raw=true\">\n</p>\n\n▪ 다른 format과 거의 비슷한 구조이므로 나머지는 생략하겠다.\n\n▪ **immediate** : 나타내고 싶은 상수의 값은 **byte offset**으로 표현한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1401528883}},"syncHistory":{"main":[-1401528883,null,null]},"v":1,"hash":1710111513257,"tx":31},"2rs7iPXVJKE420nw/content":{"id":"2rs7iPXVJKE420nw/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] [★] 14002번 : 가장 긴 증가하는 부분 수열 4\"\ndate: 2022-01-04 02:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n- LIS\n---\n\n## 문제\n\n수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.\n\n예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**,  **20**, 10,  **30**, 20,  **50**} 이고, 길이는 4이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.\n\n둘째 줄에는 수열 A를 이루고 있는 A<sub>i</sub>가 주어진다. (1 ≤ A<sub>i</sub>  ≤ 1,000)\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.\n\n둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다. 그러한 수열이 여러가지인 경우 아무거나 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n6  \n10 20 10 30 20 50\n\n## 예제 출력 1\n4  \n10 20 30 50 \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\nDP를 사용해 푸는 **LIS** (**L**ongest **I**ncreasing **S**ubsequence)문제이다. \n\n이전에 문제를 점화식으로 바로 바꿔서 풀던 문제와는 직접 일일히 비교를 한뒤 점화식으로 나타내 풀어낼 수 있다.\n\nD[i] = A[1], ... , A[i] 까지 수열이 있을 때, A[i]를 마지막으로 하는 가장 긴 부분 수열의 길이\nD[i]는 A[i]가 반드시 포함되어야만 한다.\n\n이때 A[?], A[?], ... , A[j]는 D[j]라고 나타낼 수 있고 아래 그림같은 과정을 보인다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/백준14002.jpg?raw=true\">\n</p>\n\n이때 **D[i] = max ( D[j] ) + 1 , (단, j<i 이고 A[j] < A[i]) 라고 정의 할 수 있다.**\n\n**★★★여기서 점화식을 세울때 반드시 기억해야할 것이 하나있다!!!\n점화식에 또 다른 변수가 들어간다면 반드시 변수의 범위를 지정해줄 필요가 있다!!!**\n\n여기까지가 LIS의 길이를 구하는 과정이고, 문제에서는 LIS인 수열까지 출력하라는 문제이므로 추가 조건이 필요하다.\n\n<br><br><br>\n\n**[ 역추적 ]**\n 하나의 값이 다른 하나의 값에 의해서 변화 될 때, 어떤 값에 의해서 변화하는지를 저장해두는 과정을 말하고 보통 재귀함수를 이용해 구현한다.\n\n<br><br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/백준14002-2.jpg?raw=true\">\n</p>\n\n여기서 D[i]의 값은 어떤 값에 의해서 결정되는지를 역추적 해보면 된다.\nD[6] = 4인 이유는 i=4일때 D[4]=3이므로 +1을 해서 4가 된것이다.\n따라서 D[6]을 결정지은 값은 i=4 이고 이를 새로운 배열 v에 넣어준다.\n\n같은 과정으로 D[5]= 2인 이유는 i=3일때에 의해 결정된 것이므로\ni=3을 v에 넣어준다.\n\n즉, **V[i] = A[i]의 앞에 와야하는 수의 인덱스** 를 의미한다.\n이 과정을 역추적이라고 하고 굉장히 많이 사용되는 방법이므로 반드시 알아둬야 한다.\n\n이를 코드로 구현하면 다음과 같다.\n```c++\n// 역추적 재귀함수\nvoid go(int p) {\n\t// ? -> ? -> ... -> a[v[p]] -> a[p]\n\n\tif (p == -1) return;\n\tgo(v[p]);\n\tcout << a[p] << \" \";\n}\n```\n\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\nusing namespace std;\nint d[1001];\nint a[1001];\nint v[1001];\n\n// 역추적 재귀함수\nvoid go(int p) {\n\t// ? -> ? -> ... -> a[v[p]] -> a[p]\n\n\tif (p == -1) return; // v[i] 를 -1로 초기화했기때문에\n\tgo(v[p]);\n\tcout << a[p] << \" \";\n}\n\nint main() {\n\tint num;\n\tcin >> num;\n\n\n\tfor (int i = 0; i < num; i++) cin >> a[i];\n\n\tfor (int i = 0; i < num; i++) {\n\t\td[i] = 1;\n\t\tv[i] = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] < a[i] && d[i] < d[j] + 1) {\n\t\t\t\td[i] = d[j] + 1;\n\t\t\t\tv[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tint max = d[0];\n\tint p = 0;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tif (max < d[i]) {\n\t\t\tmax = d[i];\n\t\t\tp = i;\n\t\t}\n\t}\n\n\tcout << max << endl;\n\tgo(p);\n}\n```\n\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-445259290,"tx":33},"2rs7iPXVJKE420nw/syncedContent":{"id":"2rs7iPXVJKE420nw/syncedContent","type":"syncedContent","historyData":{"-445259290":{"id":"2rs7iPXVJKE420nw/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] [★] 14002번 : 가장 긴 증가하는 부분 수열 4\"\ndate: 2022-01-04 02:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n- LIS\n---\n\n## 문제\n\n수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.\n\n예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**,  **20**, 10,  **30**, 20,  **50**} 이고, 길이는 4이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.\n\n둘째 줄에는 수열 A를 이루고 있는 A<sub>i</sub>가 주어진다. (1 ≤ A<sub>i</sub>  ≤ 1,000)\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.\n\n둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다. 그러한 수열이 여러가지인 경우 아무거나 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n6  \n10 20 10 30 20 50\n\n## 예제 출력 1\n4  \n10 20 30 50 \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\nDP를 사용해 푸는 **LIS** (**L**ongest **I**ncreasing **S**ubsequence)문제이다. \n\n이전에 문제를 점화식으로 바로 바꿔서 풀던 문제와는 직접 일일히 비교를 한뒤 점화식으로 나타내 풀어낼 수 있다.\n\nD[i] = A[1], ... , A[i] 까지 수열이 있을 때, A[i]를 마지막으로 하는 가장 긴 부분 수열의 길이\nD[i]는 A[i]가 반드시 포함되어야만 한다.\n\n이때 A[?], A[?], ... , A[j]는 D[j]라고 나타낼 수 있고 아래 그림같은 과정을 보인다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/백준14002.jpg?raw=true\">\n</p>\n\n이때 **D[i] = max ( D[j] ) + 1 , (단, j<i 이고 A[j] < A[i]) 라고 정의 할 수 있다.**\n\n**★★★여기서 점화식을 세울때 반드시 기억해야할 것이 하나있다!!!\n점화식에 또 다른 변수가 들어간다면 반드시 변수의 범위를 지정해줄 필요가 있다!!!**\n\n여기까지가 LIS의 길이를 구하는 과정이고, 문제에서는 LIS인 수열까지 출력하라는 문제이므로 추가 조건이 필요하다.\n\n<br><br><br>\n\n**[ 역추적 ]**\n 하나의 값이 다른 하나의 값에 의해서 변화 될 때, 어떤 값에 의해서 변화하는지를 저장해두는 과정을 말하고 보통 재귀함수를 이용해 구현한다.\n\n<br><br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/백준14002-2.jpg?raw=true\">\n</p>\n\n여기서 D[i]의 값은 어떤 값에 의해서 결정되는지를 역추적 해보면 된다.\nD[6] = 4인 이유는 i=4일때 D[4]=3이므로 +1을 해서 4가 된것이다.\n따라서 D[6]을 결정지은 값은 i=4 이고 이를 새로운 배열 v에 넣어준다.\n\n같은 과정으로 D[5]= 2인 이유는 i=3일때에 의해 결정된 것이므로\ni=3을 v에 넣어준다.\n\n즉, **V[i] = A[i]의 앞에 와야하는 수의 인덱스** 를 의미한다.\n이 과정을 역추적이라고 하고 굉장히 많이 사용되는 방법이므로 반드시 알아둬야 한다.\n\n이를 코드로 구현하면 다음과 같다.\n```c++\n// 역추적 재귀함수\nvoid go(int p) {\n\t// ? -> ? -> ... -> a[v[p]] -> a[p]\n\n\tif (p == -1) return;\n\tgo(v[p]);\n\tcout << a[p] << \" \";\n}\n```\n\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\nusing namespace std;\nint d[1001];\nint a[1001];\nint v[1001];\n\n// 역추적 재귀함수\nvoid go(int p) {\n\t// ? -> ? -> ... -> a[v[p]] -> a[p]\n\n\tif (p == -1) return; // v[i] 를 -1로 초기화했기때문에\n\tgo(v[p]);\n\tcout << a[p] << \" \";\n}\n\nint main() {\n\tint num;\n\tcin >> num;\n\n\n\tfor (int i = 0; i < num; i++) cin >> a[i];\n\n\tfor (int i = 0; i < num; i++) {\n\t\td[i] = 1;\n\t\tv[i] = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] < a[i] && d[i] < d[j] + 1) {\n\t\t\t\td[i] = d[j] + 1;\n\t\t\t\tv[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tint max = d[0];\n\tint p = 0;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tif (max < d[i]) {\n\t\t\tmax = d[i];\n\t\t\tp = i;\n\t\t}\n\t}\n\n\tcout << max << endl;\n\tgo(p);\n}\n```\n\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-445259290}},"syncHistory":{"main":[-445259290,null,null]},"v":1,"hash":1710111514336,"tx":33},"8onLCMS0jHIZdwsP/content":{"id":"8onLCMS0jHIZdwsP/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] [★] 1149번 : RGB거리\"\ndate: 2022-01-09 03:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n## 문제\n\n\nRGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.\n\n집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.\n\n-   1번 집의 색은 2번 집의 색과 같지 않아야 한다.\n-   N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.\n-   i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n3  \n26 40 83  \n49 60 57  \n13 89 99  \n\n## 예제 출력 1\n96\n\n## 예제 입력 2\n6  \n30 19 5  \n64 77 64  \n15 19 97  \n4 71 57  \n90 86 84  \n93 32 91  \n\n## 예제 출력 2\n208\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\nDP문제이고 앞서 풀어본 문제 [백준 15990번 : 1,2,3 더하기 5](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%8015990%EB%B2%88/) 문제와 굉장히 유사하다.\n\n문제의 조건을 정리해보면 **\"연속한 집은 같은 색을 가질수 없다\"** 는 말이다.\n\n주어진 문제를 점화식으로 표현해보면 다음과 같다.\n\n**D[i][j] = i번째 집을 j색으로 칠했을때, 1~i까지 색깔을 칠하는 비용의 최솟값**\n\n**이때 j=0,1,2 는 각각 R,G,B를 의미한다.**\n\n**A[i][j] = i번째집에 j색을 칠하는 비용**\n\ni번째 집이 0(=Red)으로 칠해진 경우에는 i-1번째집이 1로 칠해진 경우와 2로 칠해진 경우중 더 큰값을 구하고 이에 i번째 집에 0으로 칠하는 경우를 더해주면 된다.\n\n이를 점화식으로 나타내면 다음과 같다.\n\n**D[i][0] = max( D[i-1][1] , D[i-1][2] ) + A[i][0]**   \n**D[i][1] = max( D[i-1][0] , D[i-1][2] ) + A[i][1]**  \n**D[i][2] = max( D[i-1][0] , D[i-1][1] ) + A[i][2]**  \n<br><br><br><br><br><br>\n\n이제 이를 코드로 보이면 된다.\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint color[1001][3];\nint d[1001][3]; // i번째집을 j로 칠했을 때, 1~i까지 칠하는 비용의 최솟값\n\t\t\t\t// 0=R, 1=G, 2=B\n\nint main() {\n\n\tint test;\n\tcin >> test;\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> color[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= test; i++) {\n\t\td[i][0] = min(d[i - 1][1], d[i - 1][2]) + color[i][0];\n\t\td[i][1] = min(d[i - 1][0], d[i - 1][2]) + color[i][1];\n\t\td[i][2] = min(d[i - 1][0], d[i - 1][1]) + color[i][2];\n\t}\n\t\n\t// min이나 max에 인자가 3개들어가는 경우에는 괄호안에 대괄호를 넣어주면 된다.\n\tint res = min({ d[test][0], d[test][1], d[test][2] });\n\t\n\tcout << res << endl;\n\n\n}\n```\n\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1010334825,"tx":35},"8onLCMS0jHIZdwsP/syncedContent":{"id":"8onLCMS0jHIZdwsP/syncedContent","type":"syncedContent","historyData":{"-1010334825":{"id":"8onLCMS0jHIZdwsP/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] [★] 1149번 : RGB거리\"\ndate: 2022-01-09 03:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n## 문제\n\n\nRGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.\n\n집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.\n\n-   1번 집의 색은 2번 집의 색과 같지 않아야 한다.\n-   N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.\n-   i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n3  \n26 40 83  \n49 60 57  \n13 89 99  \n\n## 예제 출력 1\n96\n\n## 예제 입력 2\n6  \n30 19 5  \n64 77 64  \n15 19 97  \n4 71 57  \n90 86 84  \n93 32 91  \n\n## 예제 출력 2\n208\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\nDP문제이고 앞서 풀어본 문제 [백준 15990번 : 1,2,3 더하기 5](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%8015990%EB%B2%88/) 문제와 굉장히 유사하다.\n\n문제의 조건을 정리해보면 **\"연속한 집은 같은 색을 가질수 없다\"** 는 말이다.\n\n주어진 문제를 점화식으로 표현해보면 다음과 같다.\n\n**D[i][j] = i번째 집을 j색으로 칠했을때, 1~i까지 색깔을 칠하는 비용의 최솟값**\n\n**이때 j=0,1,2 는 각각 R,G,B를 의미한다.**\n\n**A[i][j] = i번째집에 j색을 칠하는 비용**\n\ni번째 집이 0(=Red)으로 칠해진 경우에는 i-1번째집이 1로 칠해진 경우와 2로 칠해진 경우중 더 큰값을 구하고 이에 i번째 집에 0으로 칠하는 경우를 더해주면 된다.\n\n이를 점화식으로 나타내면 다음과 같다.\n\n**D[i][0] = max( D[i-1][1] , D[i-1][2] ) + A[i][0]**   \n**D[i][1] = max( D[i-1][0] , D[i-1][2] ) + A[i][1]**  \n**D[i][2] = max( D[i-1][0] , D[i-1][1] ) + A[i][2]**  \n<br><br><br><br><br><br>\n\n이제 이를 코드로 보이면 된다.\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint color[1001][3];\nint d[1001][3]; // i번째집을 j로 칠했을 때, 1~i까지 칠하는 비용의 최솟값\n\t\t\t\t// 0=R, 1=G, 2=B\n\nint main() {\n\n\tint test;\n\tcin >> test;\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> color[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= test; i++) {\n\t\td[i][0] = min(d[i - 1][1], d[i - 1][2]) + color[i][0];\n\t\td[i][1] = min(d[i - 1][0], d[i - 1][2]) + color[i][1];\n\t\td[i][2] = min(d[i - 1][0], d[i - 1][1]) + color[i][2];\n\t}\n\t\n\t// min이나 max에 인자가 3개들어가는 경우에는 괄호안에 대괄호를 넣어주면 된다.\n\tint res = min({ d[test][0], d[test][1], d[test][2] });\n\t\n\tcout << res << endl;\n\n\n}\n```\n\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1010334825}},"syncHistory":{"main":[-1010334825,null,null]},"v":1,"hash":1710111515934,"tx":35},"9BAGvpdsYjjYTrvN/content":{"id":"9BAGvpdsYjjYTrvN/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] [★] 15990번 : 1,2,3 더하기 5 \"\ndate: 2021-12-31 21:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n## 문제\n정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.\n\n-   1+2+1\n-   1+3\n-   3+1\n\n정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n3  \n4  \n7  \n10  \n\n## 예제 출력 1\n3  \n9  \n27  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n다이나믹 프로그래밍 문제이다. \n간단해 보이지만 같은 수를 두번 이상 연속해서 사용하면 안된다는 조건때문에 까다로운 문제이다.\n\n위의 조건이 없다면 문제의 점화식은 다음과 같다.\n**d[N] = 정수 N을 1,2,3의 합으로 나타내는 방법의 수**\n**d[N] = d[N-1]+d[N-2]+d[N-3]**\n여기에 같은 수를 두번 이상 연속해서 사용하면 안된다는 조건을 어떻게 붙일까?\n\n**연속, 증가, 감소**라는 조건이 나왔을 때는 연속한 두개의 수를 살펴보면 된다.\n\n만약 마지막에 더한 수가 +1이라면 그 앞에 올 수 있는 수는 +2,+3일 것이고,\n마지막에 더한 수가 +2이라면 그 앞에 올 수 있는 수는 +1,+3,\n마지막에 더한 수가 +3이라면 그 앞에 올 수 있는 수는 +1,+2일 것이다.\n\n이를 점화식으로 나타내면,\n**d[N][j] = 정수 N을 1,2,3,의 합으로 나타내는 방법의수, 마지막 수가 j인 경우** \n\n이를 코드로 구현하면 된다.\n\n사실 이를 생각해내는것은 그다지 어렵지 않았지만,\n실제 이를 코드로 구현해낼때 어떤방식으로 구현해야 할지 헷갈려 풀지 못하고 답안을 살펴봤다. DP문제를 좀 더 풀어보고 나중에 다시한번 풀어봐야 할 것 같다.\n\n\n\n\n\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\nusing namespace std;\n\nlong long int d[1000001][4]; // N이 주어졌을때 1,2,3의 합으로 나타나는 방법의 수, j= 맨뒤에 나온 수\nconst long long mod = 1000000009LL;\nconst int limit = 100000;\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test;\n\tcin >> test;\n\n\tint num;\n\n\tfor (int i = 1; i <= limit; i++) {\n\t\tif (i - 1 >= 0) {\n\t\t\td[i][1] = d[i - 1][2] + d[i - 1][3];\n\t\t\tif (i == 1) d[i][1] = 1;\n\t\t}\n\n\t\tif (i - 2 >= 0) {\n\t\t\td[i][2] = d[i - 2][1] + d[i - 2][3];\n\t\t\tif (i == 2) d[i][2] = 1;\n\t\t}\n\n\t\tif (i - 3 >= 0) {\n\t\t\td[i][3] = d[i - 3][1] + d[i - 3][2];\n\t\t\tif (i == 3) d[i][3] = 1;\n\t\t}\n\n\t\td[i][1] %= mod;\n\t\td[i][2] %= mod;\n\t\td[i][3] %= mod;\n\t}\n\n\twhile (test--) {\n\t\tcin >> num;\n\t\tlong long int res = (d[num][1] + d[num][2] + d[num][3]) % mod;\n\t\tcout << res << endl;\n\t}\n\n\n}\n\n```\n\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":569007155,"tx":37},"9BAGvpdsYjjYTrvN/syncedContent":{"id":"9BAGvpdsYjjYTrvN/syncedContent","type":"syncedContent","historyData":{"569007155":{"id":"9BAGvpdsYjjYTrvN/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] [★] 15990번 : 1,2,3 더하기 5 \"\ndate: 2021-12-31 21:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n## 문제\n정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.\n\n-   1+2+1\n-   1+3\n-   3+1\n\n정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n3  \n4  \n7  \n10  \n\n## 예제 출력 1\n3  \n9  \n27  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n다이나믹 프로그래밍 문제이다. \n간단해 보이지만 같은 수를 두번 이상 연속해서 사용하면 안된다는 조건때문에 까다로운 문제이다.\n\n위의 조건이 없다면 문제의 점화식은 다음과 같다.\n**d[N] = 정수 N을 1,2,3의 합으로 나타내는 방법의 수**\n**d[N] = d[N-1]+d[N-2]+d[N-3]**\n여기에 같은 수를 두번 이상 연속해서 사용하면 안된다는 조건을 어떻게 붙일까?\n\n**연속, 증가, 감소**라는 조건이 나왔을 때는 연속한 두개의 수를 살펴보면 된다.\n\n만약 마지막에 더한 수가 +1이라면 그 앞에 올 수 있는 수는 +2,+3일 것이고,\n마지막에 더한 수가 +2이라면 그 앞에 올 수 있는 수는 +1,+3,\n마지막에 더한 수가 +3이라면 그 앞에 올 수 있는 수는 +1,+2일 것이다.\n\n이를 점화식으로 나타내면,\n**d[N][j] = 정수 N을 1,2,3,의 합으로 나타내는 방법의수, 마지막 수가 j인 경우** \n\n이를 코드로 구현하면 된다.\n\n사실 이를 생각해내는것은 그다지 어렵지 않았지만,\n실제 이를 코드로 구현해낼때 어떤방식으로 구현해야 할지 헷갈려 풀지 못하고 답안을 살펴봤다. DP문제를 좀 더 풀어보고 나중에 다시한번 풀어봐야 할 것 같다.\n\n\n\n\n\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\nusing namespace std;\n\nlong long int d[1000001][4]; // N이 주어졌을때 1,2,3의 합으로 나타나는 방법의 수, j= 맨뒤에 나온 수\nconst long long mod = 1000000009LL;\nconst int limit = 100000;\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test;\n\tcin >> test;\n\n\tint num;\n\n\tfor (int i = 1; i <= limit; i++) {\n\t\tif (i - 1 >= 0) {\n\t\t\td[i][1] = d[i - 1][2] + d[i - 1][3];\n\t\t\tif (i == 1) d[i][1] = 1;\n\t\t}\n\n\t\tif (i - 2 >= 0) {\n\t\t\td[i][2] = d[i - 2][1] + d[i - 2][3];\n\t\t\tif (i == 2) d[i][2] = 1;\n\t\t}\n\n\t\tif (i - 3 >= 0) {\n\t\t\td[i][3] = d[i - 3][1] + d[i - 3][2];\n\t\t\tif (i == 3) d[i][3] = 1;\n\t\t}\n\n\t\td[i][1] %= mod;\n\t\td[i][2] %= mod;\n\t\td[i][3] %= mod;\n\t}\n\n\twhile (test--) {\n\t\tcin >> num;\n\t\tlong long int res = (d[num][1] + d[num][2] + d[num][3]) % mod;\n\t\tcout << res << endl;\n\t}\n\n\n}\n\n```\n\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":569007155}},"syncHistory":{"main":[569007155,null,null]},"v":1,"hash":1710111517082,"tx":37},"cc0DNjIMHfpFRRJW/content":{"id":"cc0DNjIMHfpFRRJW/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 1463번 : 1로 만들기 \"\ndate: 2021-12-29 21:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n## 문제\n\n정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.\n\n1.  X가 3으로 나누어 떨어지면, 3으로 나눈다.\n2.  X가 2로 나누어 떨어지면, 2로 나눈다.\n3.  1을 뺀다.\n\n정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n2\n\n## 예제 출력 1\n1\n\n## 예제 입력 2\n10\n\n## 예제 출력 2\n3\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n쉬운 형태의 다이나믹 프로그래밍 문제이다. 대부분 첫번째로 생각할 수 있는 문제풀이 방식은 다음과 같다.\n1. 3으로 나누기\n2. 2로 나누기\n3. 1을 빼기\n\n를 우선순위로 하여 주어진 수 N을 1로 만드는 방법이다. 그러나 해당 방법은 정답을 구할 수 없다.\n\n간단한 예로 10을 들 수 있는데 위의 순서대로 10을 1로 만들면\n10->5->4->2->1 총 4번의 과정이 필요하지만\n10->9->3->1 과 같이 3번만에 1로 만드는 과정이 존재하므로 위의 우선순위는 틀리다.\n\n따라서 DP방식으로 문제를 쪼개어 풀 필요가 있다.\n\nDP문제를 풀 때에는 주어진 문제를 점화식으로 표현하는것이 첫번째이다.\n\nD[N] = N을 1로만드는데 필요한 최소 연산 횟수라고 정의하자.\n\n이때 N이 3으로 나누어 떨어질때 N을 3으로 나누는 과정을 살펴보면\nN을 N/3으로 만들고 N/3을 1로 만드는 것이므로 1+D[N/3]이라는 점화식으로\n표현가능하다.\n\n마찬가지로 D[N/2]+1 , D[N-1]+1이라는 점화식을 만들어낼 수 있고 최종적으로\n\n**D[N] = min( D[N/3] , D[N/2] , D[N-1] ) +1** 이라는 점화식을 산출할 수 있다. \n\n이때의 **시간복잡도 = 문제의 개수 X 문제 1개푸는데 걸리는 시간** 이므로\n**T(N) = N X O(1) = O(N)** 이다.\n\n<br><br><br><br><br><br>\n\n## 풀이1\n\n```c++\n#include <iostream>\nusing namespace std;\n\n// Top-Down 방식\n\nint D[1000000]; // D[N]을 1로 만드는데 필요한 연산 횟수\n\nint func(int num) {\n\n\tif (num == 1) return 0; // D[1]인경우 0번연산하므로 \n\tif (D[num] > 0) return D[num]; // memoization\n\n\tD[num] = func(num - 1) + 1; // 아무때나 쓸수있는 비교대상 먼저 코드 작성\n\n\tif (num % 3 == 0) {\n\t\tint temp = func(num / 3) + 1;\n\t\tif (D[num] > temp) D[num] = temp;\n\t}\n\n\tif (num % 2 == 0) {\n\t\tint temp = func(num / 2) + 1;\n\t\tif (D[num] > temp)  D[num] = temp;\n\t}\n\t\n\treturn D[num];\n}\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint num;\n\tcin >> num;\n\n\tint res = func(num);\n\tcout << res;\n}\n```\n\n## 풀이2\n```c++\n#include <iostream>\nusing namespace std;\n\n// BottomUp 방식\nint D[1000000];\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tint num;\n\tcin >> num;\n\n\tD[1] = 0;\n\n\tfor (int i = 2; i <= num; i++) {\n\t\tD[i] = D[i - 1] + 1;\n\t\tif (i % 3 == 0 && D[i] > D[i / 3] + 1)\n\t\t\tD[i] = D[i / 3] + 1;\n\t\tif (i % 2 == 0 && D[i] > D[i / 2] + 1)\n\t\t\tD[i] = D[i / 2] + 1;\n\t}\n\n\tcout << D[num] << endl;\n}\n```\n<br><br><br><br><br><br>\n## 알아두기\n**Q ) D[N/3]이나 D[N/2]가 아닌 D[N-1]부터 구현하는 이유는 뭘까?**\n\n**A ) 문제가 최소값을 구하는 것이기 때문에 비교대상이 필요하다.**\n1. 3으로 나누어 떨어질때\n2. 2로 나누어 떨어질때\n3. 1로 뺄때\n\n위의 1,2번 두개의 조건은 나누어 떨어질 때 라는 조건이 필요하지만\n3번 조건은 어떤 수든지 상관없이 아무때나 사용 가능하다.\n\n따라서 3번 조건을 먼저 코드작성을 해줘서 비교대상을 만들어준뒤\n1,2번 조건을 구현하면 최솟값을 구할 수 있다.\n\t\n\n","properties":"\n","discussions":{},"comments":{},"hash":81728621,"tx":39},"cc0DNjIMHfpFRRJW/syncedContent":{"id":"cc0DNjIMHfpFRRJW/syncedContent","type":"syncedContent","historyData":{"81728621":{"id":"cc0DNjIMHfpFRRJW/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 1463번 : 1로 만들기 \"\ndate: 2021-12-29 21:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n## 문제\n\n정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.\n\n1.  X가 3으로 나누어 떨어지면, 3으로 나눈다.\n2.  X가 2로 나누어 떨어지면, 2로 나눈다.\n3.  1을 뺀다.\n\n정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n2\n\n## 예제 출력 1\n1\n\n## 예제 입력 2\n10\n\n## 예제 출력 2\n3\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n쉬운 형태의 다이나믹 프로그래밍 문제이다. 대부분 첫번째로 생각할 수 있는 문제풀이 방식은 다음과 같다.\n1. 3으로 나누기\n2. 2로 나누기\n3. 1을 빼기\n\n를 우선순위로 하여 주어진 수 N을 1로 만드는 방법이다. 그러나 해당 방법은 정답을 구할 수 없다.\n\n간단한 예로 10을 들 수 있는데 위의 순서대로 10을 1로 만들면\n10->5->4->2->1 총 4번의 과정이 필요하지만\n10->9->3->1 과 같이 3번만에 1로 만드는 과정이 존재하므로 위의 우선순위는 틀리다.\n\n따라서 DP방식으로 문제를 쪼개어 풀 필요가 있다.\n\nDP문제를 풀 때에는 주어진 문제를 점화식으로 표현하는것이 첫번째이다.\n\nD[N] = N을 1로만드는데 필요한 최소 연산 횟수라고 정의하자.\n\n이때 N이 3으로 나누어 떨어질때 N을 3으로 나누는 과정을 살펴보면\nN을 N/3으로 만들고 N/3을 1로 만드는 것이므로 1+D[N/3]이라는 점화식으로\n표현가능하다.\n\n마찬가지로 D[N/2]+1 , D[N-1]+1이라는 점화식을 만들어낼 수 있고 최종적으로\n\n**D[N] = min( D[N/3] , D[N/2] , D[N-1] ) +1** 이라는 점화식을 산출할 수 있다. \n\n이때의 **시간복잡도 = 문제의 개수 X 문제 1개푸는데 걸리는 시간** 이므로\n**T(N) = N X O(1) = O(N)** 이다.\n\n<br><br><br><br><br><br>\n\n## 풀이1\n\n```c++\n#include <iostream>\nusing namespace std;\n\n// Top-Down 방식\n\nint D[1000000]; // D[N]을 1로 만드는데 필요한 연산 횟수\n\nint func(int num) {\n\n\tif (num == 1) return 0; // D[1]인경우 0번연산하므로 \n\tif (D[num] > 0) return D[num]; // memoization\n\n\tD[num] = func(num - 1) + 1; // 아무때나 쓸수있는 비교대상 먼저 코드 작성\n\n\tif (num % 3 == 0) {\n\t\tint temp = func(num / 3) + 1;\n\t\tif (D[num] > temp) D[num] = temp;\n\t}\n\n\tif (num % 2 == 0) {\n\t\tint temp = func(num / 2) + 1;\n\t\tif (D[num] > temp)  D[num] = temp;\n\t}\n\t\n\treturn D[num];\n}\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint num;\n\tcin >> num;\n\n\tint res = func(num);\n\tcout << res;\n}\n```\n\n## 풀이2\n```c++\n#include <iostream>\nusing namespace std;\n\n// BottomUp 방식\nint D[1000000];\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tint num;\n\tcin >> num;\n\n\tD[1] = 0;\n\n\tfor (int i = 2; i <= num; i++) {\n\t\tD[i] = D[i - 1] + 1;\n\t\tif (i % 3 == 0 && D[i] > D[i / 3] + 1)\n\t\t\tD[i] = D[i / 3] + 1;\n\t\tif (i % 2 == 0 && D[i] > D[i / 2] + 1)\n\t\t\tD[i] = D[i / 2] + 1;\n\t}\n\n\tcout << D[num] << endl;\n}\n```\n<br><br><br><br><br><br>\n## 알아두기\n**Q ) D[N/3]이나 D[N/2]가 아닌 D[N-1]부터 구현하는 이유는 뭘까?**\n\n**A ) 문제가 최소값을 구하는 것이기 때문에 비교대상이 필요하다.**\n1. 3으로 나누어 떨어질때\n2. 2로 나누어 떨어질때\n3. 1로 뺄때\n\n위의 1,2번 두개의 조건은 나누어 떨어질 때 라는 조건이 필요하지만\n3번 조건은 어떤 수든지 상관없이 아무때나 사용 가능하다.\n\n따라서 3번 조건을 먼저 코드작성을 해줘서 비교대상을 만들어준뒤\n1,2번 조건을 구현하면 최솟값을 구할 수 있다.\n\t\n\n","properties":"\n","discussions":{},"comments":{},"hash":81728621}},"syncHistory":{"main":[81728621,null,null]},"v":1,"hash":1710111518347,"tx":39},"ni3ScMP3VaGaeIOQ/content":{"id":"ni3ScMP3VaGaeIOQ/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 11052번 : 카드 구매하기 (+ 16194번) \"\ndate: 2021-12-29 14:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n## 문제\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/백준11052.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 민규가 구매하려고 하는 카드의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)\n\n둘째 줄에는 P<sub>i</sub>가 P<sub>1</sub>부터 P<sub>N</sub>까지 순서대로 주어진다. (1 ≤ P<sub>i</sub>  ≤ 10,000)\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 민규가 카드 N개를 갖기 위해 지불해야 하는 금액의 최댓값을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n4\n1 5 6 7\n\n## 예제 출력 1\n10\n\n## 예제 입력 2\n5\n10 9 8 7 6 \n\n## 예제 출력 2\n50\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n다이나믹 프로그래밍으로 풀 수 있는 문제이다.\n먼저 우리가 풀어야할 문제를 식으로 나타내면 다음과 같다.\n<br><br><br>\n\n**D[N] = 카드 N개를 구매하는 최대비용**\n**i번째 카드팩은 i개의 카드를 담고 있고, 가격은 buy[i]원이다.**\nN개의 카드를 구매할때 카드팩은 N개가 담긴 카드팩까지 존재한다.\n<br><br><br>\n\n[ 카드팩 ] + [ 카드팩 ] + [ 카드팩 ] + [ 카드팩 ] = N개\n위와 같은 형태로 최대비용을 지불하는 카드팩의 형태가 존재할 때,\n하나의  카드팩에는 몇개의 카드가 존재하는지는 알 수 없다.\n\n<br><br><br>\n\n이때 맨 마지막 카드팩에 i개의 카드가 들어있다고 가정하면\n이전의 카드팩들에는 N-i개의 카드가 들어있다고 볼 수 있다.\n\n이를 점화식으로 나타내면 다음과같다.\n**D[N]  = D[N-i] + buy[i]**\n\n이를 코드로 구현하면 된다!\n\n\n\n<br><br><br><br><br><br>\n\n## 풀이1\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint D[1001]; // N개를 구매하는데 필요한 최대 비용\n\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test;\n\tcin >> test;\n\tint res = 0;\n\n\tint buy[10001]; // i개를 구매하는데 필요한 값\n\tD[0] = 0;\n\tbuy[0] = 0;\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tcin >> buy[i];\n\t}\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tD[i] = max(D[i], D[i - j] + buy[j]);\n\t\t}\n\t}\n\n\tcout << D[test] << endl;\n}\n```\n\n\n<br><br><br><br><br><br>\n\n<br><br><br><br><br><br>\n## 알아두기\n\n카드 N개를 구매하는데 필요한 **최대비용**을 구하는 문제였는데 그렇다면\n**최소비용**을 구하는 문제는 어떻게 풀 수 있을까?\n\n아주간단하다. 앞선 코드에서 **max**부분을 **min**으로 바꿔주기만 하면된다!\n\n```c++\n\tfor (int i = 1; i <= test; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tD[i] = min(D[i], D[i - j] + buy[j]);\n\t\t}\n\t}\n```\n<br><br><br>\n\n그러나 이대로 코드를 실행하게 되면 결과는 항상 0이 나온다.\n카드를 구매하는 비용은 0보다 크기 때문에, min의 결과는 항상 0이다.\n따라서 **배열의 초기값을 잘 설정해줄 필요가 있다!**\n\n```c++\n\tfor (int i = 1; i <= test; i++) {\n\t\tcin >> buy[i];\n\t\tD[i] = 1000 * 10000;\n\t}\n```\n<br><br><br>\n\n카드의 개수 N<=1,000 이고 카드팩의 가격 <=10,000이므로 위와같이 초기값을 설정한다.\n\n<br><br><br><br><br><br>\n\n또 다른 방법으로는 D[N]을 -1로 초기화 하는 방법도 있다.\n\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint D[1001]; // N개를 구매하는데 필요한 최대 비용\n\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test;\n\tcin >> test;\n\tint res = 0;\n\n\tint buy[10001]; // i개를 구매하는데 필요한 값\n\tD[0] = 0;\n\tbuy[0] = 10000;\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tcin >> buy[i];\n\t\tD[i] = -1;\n\t}\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tif (D[i] == -1 || D[i] > D[i - j] + buy[j])\n\t\t\t\tD[i] = D[i - j] + buy[j];\n\t\t}\n\t}\n\n\tcout << D[test] << endl;\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1956582414,"tx":41},"ni3ScMP3VaGaeIOQ/syncedContent":{"id":"ni3ScMP3VaGaeIOQ/syncedContent","type":"syncedContent","historyData":{"-1956582414":{"id":"ni3ScMP3VaGaeIOQ/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 11052번 : 카드 구매하기 (+ 16194번) \"\ndate: 2021-12-29 14:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 다이나믹 프로그래밍\n---\n\n## 문제\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/백준11052.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 민규가 구매하려고 하는 카드의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)\n\n둘째 줄에는 P<sub>i</sub>가 P<sub>1</sub>부터 P<sub>N</sub>까지 순서대로 주어진다. (1 ≤ P<sub>i</sub>  ≤ 10,000)\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 민규가 카드 N개를 갖기 위해 지불해야 하는 금액의 최댓값을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n4\n1 5 6 7\n\n## 예제 출력 1\n10\n\n## 예제 입력 2\n5\n10 9 8 7 6 \n\n## 예제 출력 2\n50\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n다이나믹 프로그래밍으로 풀 수 있는 문제이다.\n먼저 우리가 풀어야할 문제를 식으로 나타내면 다음과 같다.\n<br><br><br>\n\n**D[N] = 카드 N개를 구매하는 최대비용**\n**i번째 카드팩은 i개의 카드를 담고 있고, 가격은 buy[i]원이다.**\nN개의 카드를 구매할때 카드팩은 N개가 담긴 카드팩까지 존재한다.\n<br><br><br>\n\n[ 카드팩 ] + [ 카드팩 ] + [ 카드팩 ] + [ 카드팩 ] = N개\n위와 같은 형태로 최대비용을 지불하는 카드팩의 형태가 존재할 때,\n하나의  카드팩에는 몇개의 카드가 존재하는지는 알 수 없다.\n\n<br><br><br>\n\n이때 맨 마지막 카드팩에 i개의 카드가 들어있다고 가정하면\n이전의 카드팩들에는 N-i개의 카드가 들어있다고 볼 수 있다.\n\n이를 점화식으로 나타내면 다음과같다.\n**D[N]  = D[N-i] + buy[i]**\n\n이를 코드로 구현하면 된다!\n\n\n\n<br><br><br><br><br><br>\n\n## 풀이1\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint D[1001]; // N개를 구매하는데 필요한 최대 비용\n\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test;\n\tcin >> test;\n\tint res = 0;\n\n\tint buy[10001]; // i개를 구매하는데 필요한 값\n\tD[0] = 0;\n\tbuy[0] = 0;\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tcin >> buy[i];\n\t}\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tD[i] = max(D[i], D[i - j] + buy[j]);\n\t\t}\n\t}\n\n\tcout << D[test] << endl;\n}\n```\n\n\n<br><br><br><br><br><br>\n\n<br><br><br><br><br><br>\n## 알아두기\n\n카드 N개를 구매하는데 필요한 **최대비용**을 구하는 문제였는데 그렇다면\n**최소비용**을 구하는 문제는 어떻게 풀 수 있을까?\n\n아주간단하다. 앞선 코드에서 **max**부분을 **min**으로 바꿔주기만 하면된다!\n\n```c++\n\tfor (int i = 1; i <= test; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tD[i] = min(D[i], D[i - j] + buy[j]);\n\t\t}\n\t}\n```\n<br><br><br>\n\n그러나 이대로 코드를 실행하게 되면 결과는 항상 0이 나온다.\n카드를 구매하는 비용은 0보다 크기 때문에, min의 결과는 항상 0이다.\n따라서 **배열의 초기값을 잘 설정해줄 필요가 있다!**\n\n```c++\n\tfor (int i = 1; i <= test; i++) {\n\t\tcin >> buy[i];\n\t\tD[i] = 1000 * 10000;\n\t}\n```\n<br><br><br>\n\n카드의 개수 N<=1,000 이고 카드팩의 가격 <=10,000이므로 위와같이 초기값을 설정한다.\n\n<br><br><br><br><br><br>\n\n또 다른 방법으로는 D[N]을 -1로 초기화 하는 방법도 있다.\n\n\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint D[1001]; // N개를 구매하는데 필요한 최대 비용\n\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test;\n\tcin >> test;\n\tint res = 0;\n\n\tint buy[10001]; // i개를 구매하는데 필요한 값\n\tD[0] = 0;\n\tbuy[0] = 10000;\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tcin >> buy[i];\n\t\tD[i] = -1;\n\t}\n\n\tfor (int i = 1; i <= test; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tif (D[i] == -1 || D[i] > D[i - j] + buy[j])\n\t\t\t\tD[i] = D[i - j] + buy[j];\n\t\t}\n\t}\n\n\tcout << D[test] << endl;\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1956582414}},"syncHistory":{"main":[-1956582414,null,null]},"v":1,"hash":1710111519463,"tx":41},"I9XIrcsCCqJCsXnW/content":{"id":"I9XIrcsCCqJCsXnW/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 3085번 : 사탕 게임 \"\ndate: 2021-09-24 01:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 브루트 포스\n---\n\n## 문제\n\n상근이는 어렸을 적에 \"봄보니 (Bomboni)\" 게임을 즐겨했다.\n\n가장 처음에 N×N크기에 사탕을 채워 놓는다. 사탕의 색은 모두 같지 않을 수도 있다. 상근이는 사탕의 색이 다른 인접한 두 칸을 고른다. 그 다음 고른 칸에 들어있는 사탕을 서로 교환한다. 이제, 모두 같은 색으로 이루어져 있는 가장 긴 연속 부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다.\n\n사탕이 채워진 상태가 주어졌을 때, 상근이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 보드의 크기 N이 주어진다. (3 ≤ N ≤ 50)\n\n다음 N개 줄에는 보드에 채워져 있는 사탕의 색상이 주어진다. 빨간색은 C, 파란색은 P, 초록색은 Z, 노란색은 Y로 주어진다.\n\n사탕의 색이 다른 인접한 두 칸이 존재하는 입력만 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 상근이가 먹을 수 있는 사탕의 최대 개수를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n3  \nCCP  \nCCP  \nPPC  \n\n## 예제 출력 1\n3\n\n## 예제 입력 2\n4  \nPPPP  \nCYZY  \nCCPY  \nPPCC  \n\n## 예제 출력 2\n4\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\nNxN 크기에 사탕을 넣고 색이 다른 인접한 두칸을 골라 서로 사탕을 교환한다. 모두 같은 색으로 이루어진 가장 긴 연속부분(열 또는 행)을 골라서 다 먹는데 그 최대 개수를 구하라는 문제이다. 시간 복잡도는 O(N^2)이고 N <=50이므로 전체 경우의 수가 몇개 안되니깐 브루트 포스를 이용해 풀 수 있다.\n\n먼저 현재 구성된 사탕의 배열에서 먹을 수 있는 가장 긴 사탕개수를 구하는 함수( NumCandy( ) )를 만들어 놓는다.\n\n그 다음 색깔이 서로 다른 두개의 사탕을 swap하고 가장 긴 사탕개수를 구하는 NumCandy를 실행시킨뒤 결과를 저장한다.\n\n그 다음 다시 원래대로 사탕을 swap하고 위의 과정을 반복한다.\n\n이때 행끼리의 swap과 열끼리의 swap을 구분해서 진행해준다.\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstring candy[50];\nint test;\nint result = 0;\n\nint NumCandy() {\n\tint result = 1;\n\tfor (int i = 0; i < test; i++) {\n\tint temp = 1;\n\t\tfor (int j = 1; j < test; j++) {\n\t\t\tif (candy[i][j - 1] == candy[i][j]) temp++;\n\t\t\telse {\n\t\t\t\tresult = max(temp, result);\n\t\t\t\ttemp = 1;\n\t\t\t}\n\t\t\tresult = max(temp, result);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < test; i++) {\n\t\tint temp = 1;\n\t\tfor (int j = 1; j < test; j++) {\n\t\t\tif (candy[j][i] == candy[j - 1][i]) temp++;\n\t\t\telse {\n\t\t\t\tresult = max(temp, result);\n\t\t\t\ttemp = 1;\n\t\t\t}\n\t\t}\n\t\tresult = max(temp, result);\n\t}\n\n\treturn result;\n}\n\nint main() {\n\tint cnt = 0;\n\tcin >> test;\n\n\tint result = 0;\n\n\tfor (int i = 0; i < test; i++) cin >> candy[i];\n\n\tfor (int i = 0; i < test; i++) {\n\t\tfor (int j = 1; j < test; j++) {\n\t\t\tswap(candy[i][j - 1], candy[i][j]);\n\t\t\tresult = max(result, NumCandy());\n\t\t\tswap(candy[i][j - 1], candy[i][j]);\n\n\t\t\tswap(candy[j][i], candy[j - 1][i]);\n\t\t\tresult = max(result, NumCandy());\n\t\t\tswap(candy[j][i], candy[j - 1][i]);\n\t\t}\n\t}\n\n\tcout << result << endl;\n\n\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1428815895,"tx":43},"I9XIrcsCCqJCsXnW/syncedContent":{"id":"I9XIrcsCCqJCsXnW/syncedContent","type":"syncedContent","historyData":{"1428815895":{"id":"I9XIrcsCCqJCsXnW/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 3085번 : 사탕 게임 \"\ndate: 2021-09-24 01:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 브루트 포스\n---\n\n## 문제\n\n상근이는 어렸을 적에 \"봄보니 (Bomboni)\" 게임을 즐겨했다.\n\n가장 처음에 N×N크기에 사탕을 채워 놓는다. 사탕의 색은 모두 같지 않을 수도 있다. 상근이는 사탕의 색이 다른 인접한 두 칸을 고른다. 그 다음 고른 칸에 들어있는 사탕을 서로 교환한다. 이제, 모두 같은 색으로 이루어져 있는 가장 긴 연속 부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다.\n\n사탕이 채워진 상태가 주어졌을 때, 상근이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 보드의 크기 N이 주어진다. (3 ≤ N ≤ 50)\n\n다음 N개 줄에는 보드에 채워져 있는 사탕의 색상이 주어진다. 빨간색은 C, 파란색은 P, 초록색은 Z, 노란색은 Y로 주어진다.\n\n사탕의 색이 다른 인접한 두 칸이 존재하는 입력만 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 상근이가 먹을 수 있는 사탕의 최대 개수를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n3  \nCCP  \nCCP  \nPPC  \n\n## 예제 출력 1\n3\n\n## 예제 입력 2\n4  \nPPPP  \nCYZY  \nCCPY  \nPPCC  \n\n## 예제 출력 2\n4\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\nNxN 크기에 사탕을 넣고 색이 다른 인접한 두칸을 골라 서로 사탕을 교환한다. 모두 같은 색으로 이루어진 가장 긴 연속부분(열 또는 행)을 골라서 다 먹는데 그 최대 개수를 구하라는 문제이다. 시간 복잡도는 O(N^2)이고 N <=50이므로 전체 경우의 수가 몇개 안되니깐 브루트 포스를 이용해 풀 수 있다.\n\n먼저 현재 구성된 사탕의 배열에서 먹을 수 있는 가장 긴 사탕개수를 구하는 함수( NumCandy( ) )를 만들어 놓는다.\n\n그 다음 색깔이 서로 다른 두개의 사탕을 swap하고 가장 긴 사탕개수를 구하는 NumCandy를 실행시킨뒤 결과를 저장한다.\n\n그 다음 다시 원래대로 사탕을 swap하고 위의 과정을 반복한다.\n\n이때 행끼리의 swap과 열끼리의 swap을 구분해서 진행해준다.\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstring candy[50];\nint test;\nint result = 0;\n\nint NumCandy() {\n\tint result = 1;\n\tfor (int i = 0; i < test; i++) {\n\tint temp = 1;\n\t\tfor (int j = 1; j < test; j++) {\n\t\t\tif (candy[i][j - 1] == candy[i][j]) temp++;\n\t\t\telse {\n\t\t\t\tresult = max(temp, result);\n\t\t\t\ttemp = 1;\n\t\t\t}\n\t\t\tresult = max(temp, result);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < test; i++) {\n\t\tint temp = 1;\n\t\tfor (int j = 1; j < test; j++) {\n\t\t\tif (candy[j][i] == candy[j - 1][i]) temp++;\n\t\t\telse {\n\t\t\t\tresult = max(temp, result);\n\t\t\t\ttemp = 1;\n\t\t\t}\n\t\t}\n\t\tresult = max(temp, result);\n\t}\n\n\treturn result;\n}\n\nint main() {\n\tint cnt = 0;\n\tcin >> test;\n\n\tint result = 0;\n\n\tfor (int i = 0; i < test; i++) cin >> candy[i];\n\n\tfor (int i = 0; i < test; i++) {\n\t\tfor (int j = 1; j < test; j++) {\n\t\t\tswap(candy[i][j - 1], candy[i][j]);\n\t\t\tresult = max(result, NumCandy());\n\t\t\tswap(candy[i][j - 1], candy[i][j]);\n\n\t\t\tswap(candy[j][i], candy[j - 1][i]);\n\t\t\tresult = max(result, NumCandy());\n\t\t\tswap(candy[j][i], candy[j - 1][i]);\n\t\t}\n\t}\n\n\tcout << result << endl;\n\n\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1428815895}},"syncHistory":{"main":[1428815895,null,null]},"v":1,"hash":1710111520910,"tx":43},"oPPKCabe4PCAuTpL/content":{"id":"oPPKCabe4PCAuTpL/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 11656번 : 접미사 배열\"\ndate: 2021-09-16 14:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 문자열\n---\n\n## 문제\n\n접미사 배열은 문자열 S의 모든 접미사를 사전순으로 정렬해 놓은 배열이다.\n\nbaekjoon의 접미사는 baekjoon, aekjoon, ekjoon, kjoon, joon, oon, on, n 으로 총 8가지가 있고, 이를 사전순으로 정렬하면, aekjoon, baekjoon, ekjoon, joon, kjoon, n, on, oon이 된다.\n\n문자열 S가 주어졌을 때, 모든 접미사를 사전순으로 정렬한 다음 출력하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 문자열 S가 주어진다. S는 알파벳 소문자로만 이루어져 있고, 길이는 1,000보다 작거나 같다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 S의 접미사를 사전순으로 한 줄에 하나씩 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\nbaekjoon\n\n## 예제 출력 1\naekjoon  \nbaekjoon  \nekjoon  \njoon  \nkjoon  \nn  \non  \noon  \n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing std::endl;\nusing std::cout;\nusing std::cin;\n\nint main() {\n\n\tstring str;\n\tcin >> str;\n\n\tvector <string> v;\n\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tv.push_back(str.substr(i,str.length()));\n\t}\n\n\tsort(v.begin(), v.end());\n\n\tfor (int i = 0; i < v.size(); i++) cout << v[i] << endl;\n\t\n\n\treturn 0;\n}\n```\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n문자열을 잘라줘야 하므로 string에 있는 substr을 이용해 잘라준다.\n\n오름차순으로 정렬하는것은 #include <algorithm>에 있는 sort를 사용한다.\n\n어렵지 않지만 기억해두기 위해 포스팅!\n","properties":"\n","discussions":{},"comments":{},"hash":-1560299687,"tx":45},"oPPKCabe4PCAuTpL/syncedContent":{"id":"oPPKCabe4PCAuTpL/syncedContent","type":"syncedContent","historyData":{"-1560299687":{"id":"oPPKCabe4PCAuTpL/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 11656번 : 접미사 배열\"\ndate: 2021-09-16 14:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 문자열\n---\n\n## 문제\n\n접미사 배열은 문자열 S의 모든 접미사를 사전순으로 정렬해 놓은 배열이다.\n\nbaekjoon의 접미사는 baekjoon, aekjoon, ekjoon, kjoon, joon, oon, on, n 으로 총 8가지가 있고, 이를 사전순으로 정렬하면, aekjoon, baekjoon, ekjoon, joon, kjoon, n, on, oon이 된다.\n\n문자열 S가 주어졌을 때, 모든 접미사를 사전순으로 정렬한 다음 출력하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 문자열 S가 주어진다. S는 알파벳 소문자로만 이루어져 있고, 길이는 1,000보다 작거나 같다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 S의 접미사를 사전순으로 한 줄에 하나씩 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\nbaekjoon\n\n## 예제 출력 1\naekjoon  \nbaekjoon  \nekjoon  \njoon  \nkjoon  \nn  \non  \noon  \n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing std::endl;\nusing std::cout;\nusing std::cin;\n\nint main() {\n\n\tstring str;\n\tcin >> str;\n\n\tvector <string> v;\n\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tv.push_back(str.substr(i,str.length()));\n\t}\n\n\tsort(v.begin(), v.end());\n\n\tfor (int i = 0; i < v.size(); i++) cout << v[i] << endl;\n\t\n\n\treturn 0;\n}\n```\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n문자열을 잘라줘야 하므로 string에 있는 substr을 이용해 잘라준다.\n\n오름차순으로 정렬하는것은 #include <algorithm>에 있는 sort를 사용한다.\n\n어렵지 않지만 기억해두기 위해 포스팅!\n","properties":"\n","discussions":{},"comments":{},"hash":-1560299687}},"syncHistory":{"main":[-1560299687,null,null]},"v":1,"hash":1710111522091,"tx":45},"3LsY0S6l92HdtfPP/content":{"id":"3LsY0S6l92HdtfPP/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 1406번 : 에디터\"\ndate: 2021-09-02 20:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 자료구조\n---\n\n## 문제\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/1406.png?raw=true)\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\nabcd  \n3  \nP x  \nL  \nP y  \n\n## 예제 출력 1\nabcdyx\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <stack>\n#include <list>\n\nusing namespace std;\nusing std::cout;\nusing std::cin;\n\nint main() {\n\n\tint num;\n\tstring str;\n\tcin >> str;\n\tcin >> num;\n\n\tlist <char> lt(str.begin(), str.end());\n\tauto cursor = lt.end();\n\t// list <char> :: iterator cursor = lt.end(); 이거를 auto로 줄여서 사용가능\n\n\tfor (int i = 0; i < num; i++) {\n\t\tchar temp;\n\t\tcin >> temp;\n\n\t\tif (temp == 'L') {\n\t\t\tif(cursor!=lt.begin()) cursor--;\n\t\t}\n\t\telse if (temp == 'D') {\n\t\t\tif(cursor!=lt.end()) cursor++;\n\t\t}\n\t\telse if (temp == 'B') {\n\t\t\tif (cursor != lt.begin()) cursor = lt.erase(--cursor); \n\t\t}\n\t\telse if (temp == 'P') {\n\t\t\tchar insertChar;\n\t\t\tcin >> insertChar;\n\t\t\tlt.insert(cursor, insertChar);\n\t\t}\n\t}\n\n\tfor (auto i = lt.begin(); i != lt.end(); i++) {\n\t\tcout << *i;\n\t}\n\n\treturn 0;\n}\n```\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n 백준 Stack 카테고리에 있던 문제라 Stack을 이용해 풀어보려 했지만 도저히 풀이가 생각나지 않아 Stack으로는 풀지 못했다. Stack 풀이를 찾아보니 Stack을 두개 만들어 상황에 따라 각각 push, pop을 해주는 풀이던데 별로 효율적으로 보이지 않았다.\n\n그다음 생각한 풀이는 **linked list**를 사용해서 커서를 자유자재로 변경해주는 것이였는데 본인은 C를 평소에 자주 사용했던 터라 linked list를 구현하기 위해선 일일히 코딩을 해야했다.\n\n근데 C++에는 **list**라는 **STL라이브러리**가 있다고해서 이를 활용해보았다.\n\n아직 list가 익숙치 않아 풀이를 어느정도 참고했기 때문에 다른 list 문제들을 좀 더 풀어봐야 겠다.\n","properties":"\n","discussions":{},"comments":{},"hash":-776426303,"tx":47},"3LsY0S6l92HdtfPP/syncedContent":{"id":"3LsY0S6l92HdtfPP/syncedContent","type":"syncedContent","historyData":{"-776426303":{"id":"3LsY0S6l92HdtfPP/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 1406번 : 에디터\"\ndate: 2021-09-02 20:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 자료구조\n---\n\n## 문제\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/1406.png?raw=true)\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\nabcd  \n3  \nP x  \nL  \nP y  \n\n## 예제 출력 1\nabcdyx\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <stack>\n#include <list>\n\nusing namespace std;\nusing std::cout;\nusing std::cin;\n\nint main() {\n\n\tint num;\n\tstring str;\n\tcin >> str;\n\tcin >> num;\n\n\tlist <char> lt(str.begin(), str.end());\n\tauto cursor = lt.end();\n\t// list <char> :: iterator cursor = lt.end(); 이거를 auto로 줄여서 사용가능\n\n\tfor (int i = 0; i < num; i++) {\n\t\tchar temp;\n\t\tcin >> temp;\n\n\t\tif (temp == 'L') {\n\t\t\tif(cursor!=lt.begin()) cursor--;\n\t\t}\n\t\telse if (temp == 'D') {\n\t\t\tif(cursor!=lt.end()) cursor++;\n\t\t}\n\t\telse if (temp == 'B') {\n\t\t\tif (cursor != lt.begin()) cursor = lt.erase(--cursor); \n\t\t}\n\t\telse if (temp == 'P') {\n\t\t\tchar insertChar;\n\t\t\tcin >> insertChar;\n\t\t\tlt.insert(cursor, insertChar);\n\t\t}\n\t}\n\n\tfor (auto i = lt.begin(); i != lt.end(); i++) {\n\t\tcout << *i;\n\t}\n\n\treturn 0;\n}\n```\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n 백준 Stack 카테고리에 있던 문제라 Stack을 이용해 풀어보려 했지만 도저히 풀이가 생각나지 않아 Stack으로는 풀지 못했다. Stack 풀이를 찾아보니 Stack을 두개 만들어 상황에 따라 각각 push, pop을 해주는 풀이던데 별로 효율적으로 보이지 않았다.\n\n그다음 생각한 풀이는 **linked list**를 사용해서 커서를 자유자재로 변경해주는 것이였는데 본인은 C를 평소에 자주 사용했던 터라 linked list를 구현하기 위해선 일일히 코딩을 해야했다.\n\n근데 C++에는 **list**라는 **STL라이브러리**가 있다고해서 이를 활용해보았다.\n\n아직 list가 익숙치 않아 풀이를 어느정도 참고했기 때문에 다른 list 문제들을 좀 더 풀어봐야 겠다.\n","properties":"\n","discussions":{},"comments":{},"hash":-776426303}},"syncHistory":{"main":[-776426303,null,null]},"v":1,"hash":1710111523461,"tx":47},"LEhxYp8G5u90fiYq/content":{"id":"LEhxYp8G5u90fiYq/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 10824번 : 네 수\"\ndate: 2021-09-16 02:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 문자열\n---\n\n## 문제\n네 자연수 A, B, C, D가 주어진다. 이때, A와 B를 붙인 수와 C와 D를 붙인 수의 합을 구하는 프로그램을 작성하시오.\n\n두 수 A와 B를 합치는 것은 A의 뒤에 B를 붙이는 것을 의미한다. 즉, 20과 30을 붙이면 2030이 된다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 네 자연수 A, B, C, D가 주어진다. (1 ≤ A, B, C, D ≤ 1,000,000)\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\nA와 B를 붙인 수와 C와 D를 붙인 수의 합을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n10 20 30 40\n\n## 예제 출력 1\n4060\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <string>\n\nusing namespace std;\nusing std::endl;\nusing std::cout;\nusing std::cin;\n\nint main() {\n\n\tstring str1, str2, str3, str4;\n\n\tcin >> str1 >> str2 >> str3 >> str4;\n\n\tstring temp1 = str1 + str2;\n\tstring temp2 = str3 + str4;\n\n\tlong long res1 = stoll(temp1);\n\tlong long res2 = stoll(temp2);\n\n\tcout << res1 + res2 << endl;\n\n\n\treturn 0;\n```\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n이전에도 비슷한 문제를 몇번 풀어본 경험이 있는데 C++로 바꾸면서 STL 포스팅도 좀 할 겸 글을 적어보려 한다.\n\n문제는 단순하다. 입력받은 수를 두개씩 묶어서 합친후 더하면된다.\n\n그러나 ( 1<= A,B,C,D <= 1,000,000 ) 의 범위를 가지므로 일반 숫자형으로는 해당 범위안에서 처리 할 수가없다. 커버할 수 있는 범위를 넘어서기 때문이다. 자료형마다 커버할 수 있는 범위는 아래 그림과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/자료형.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n따라서 문자열로 받은 뒤 문자열을 숫자로 바꿔주는 과정이 필요한데 여기선 String의 STL을 사용하면 간편하게 풀 수 있다.\n\n\n```c++\n\tlong long res1 = stoll(temp1);\n\tlong long res2 = stoll(temp2);\n```\n변환하려는 자료형에 맞게 **stoi, stol, stof, stoll** 등 다양하게 사용하면 된다.\n\n<br><br><br><br><br><br>\n\n참고로 숫자를 문자열로 변환할 때는 아래 코드를 응용하면 된다.\n```c++\nstring temp = to_string(자료형)\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1224890333,"tx":49},"LEhxYp8G5u90fiYq/syncedContent":{"id":"LEhxYp8G5u90fiYq/syncedContent","type":"syncedContent","historyData":{"-1224890333":{"id":"LEhxYp8G5u90fiYq/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 10824번 : 네 수\"\ndate: 2021-09-16 02:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 문자열\n---\n\n## 문제\n네 자연수 A, B, C, D가 주어진다. 이때, A와 B를 붙인 수와 C와 D를 붙인 수의 합을 구하는 프로그램을 작성하시오.\n\n두 수 A와 B를 합치는 것은 A의 뒤에 B를 붙이는 것을 의미한다. 즉, 20과 30을 붙이면 2030이 된다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 네 자연수 A, B, C, D가 주어진다. (1 ≤ A, B, C, D ≤ 1,000,000)\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\nA와 B를 붙인 수와 C와 D를 붙인 수의 합을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n10 20 30 40\n\n## 예제 출력 1\n4060\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <string>\n\nusing namespace std;\nusing std::endl;\nusing std::cout;\nusing std::cin;\n\nint main() {\n\n\tstring str1, str2, str3, str4;\n\n\tcin >> str1 >> str2 >> str3 >> str4;\n\n\tstring temp1 = str1 + str2;\n\tstring temp2 = str3 + str4;\n\n\tlong long res1 = stoll(temp1);\n\tlong long res2 = stoll(temp2);\n\n\tcout << res1 + res2 << endl;\n\n\n\treturn 0;\n```\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n이전에도 비슷한 문제를 몇번 풀어본 경험이 있는데 C++로 바꾸면서 STL 포스팅도 좀 할 겸 글을 적어보려 한다.\n\n문제는 단순하다. 입력받은 수를 두개씩 묶어서 합친후 더하면된다.\n\n그러나 ( 1<= A,B,C,D <= 1,000,000 ) 의 범위를 가지므로 일반 숫자형으로는 해당 범위안에서 처리 할 수가없다. 커버할 수 있는 범위를 넘어서기 때문이다. 자료형마다 커버할 수 있는 범위는 아래 그림과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/자료형.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n따라서 문자열로 받은 뒤 문자열을 숫자로 바꿔주는 과정이 필요한데 여기선 String의 STL을 사용하면 간편하게 풀 수 있다.\n\n\n```c++\n\tlong long res1 = stoll(temp1);\n\tlong long res2 = stoll(temp2);\n```\n변환하려는 자료형에 맞게 **stoi, stol, stof, stoll** 등 다양하게 사용하면 된다.\n\n<br><br><br><br><br><br>\n\n참고로 숫자를 문자열로 변환할 때는 아래 코드를 응용하면 된다.\n```c++\nstring temp = to_string(자료형)\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1224890333}},"syncHistory":{"main":[-1224890333,null,null]},"v":1,"hash":1710111524887,"tx":49},"IqjGfqqQQvpdMUmv/content":{"id":"IqjGfqqQQvpdMUmv/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 9093번 : 단어 뒤집기\"\ndate: 2021-09-01 20:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 자료구조\n---\n\n## 문제\n\n문장이 주어졌을 때, 단어를 모두 뒤집어서 출력하는 프로그램을 작성하시오. 단, 단어의 순서는 바꿀 수 없다. 단어는 영어 알파벳으로만 이루어져 있다.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 문장이 하나 주어진다. 단어의 길이는 최대 20, 문장의 길이는 최대 1000이다. 단어와 단어 사이에는 공백이 하나 있다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n각 테스트 케이스에 대해서, 입력으로 주어진 문장의 단어를 모두 뒤집어 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n2  \nI am happy today  \nWe want to win the first prize  \n\n## 예제 출력 1\nI ma yppah yadot  \neW tnaw ot niw eht tsrif ezirp  \n\n<br><br><br><br><br><br>\n\n\n## 풀이\n```c++\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\nusing std::cout;\nusing std::endl;\n\nint main() { \n\tint num;\n\tcin >> num;\n\tcin.ignore(); // 버퍼 비우기\n\n\tstack <char> st;\n\tstring str;\n\n\twhile (num--) {\n\t\tgetline(cin, str);\n\t\tstr += ' '; // 문자열 마지막에 일부러 붙여줌\n\n\t\tfor (int i = 0; i < str.size(); i++) {\n\t\t\t\n\t\t\tif (str[i] == ' ') {\n\t\t\t\twhile (!st.empty()) {\n\t\t\t\t\tcout << st.top();\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tcout << ' ';\n\t\t\t}\n\n\t\t\telse st.push(str[i]);\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n}\n```\n\n<br><br><br><br><br><br>\n\n\n## 알고리즘 [ 접근방법 ]\n\n#include <string> 함수에 내장된 함수들을 많이 활용해 볼 수 있는 문제이다.\n풀이 방법이 두가지정도로 보이는데 다음과 같다.\n1. stack을 활용한 선입후출 방식의 입출력\n2. reverse 함수를 활용해 일일히 뒤집기\n\n본인은 첫번째 stack을 활용해 문제를 풀이해 봤다.\n\n<br><br><br><br><br><br>\n\n**getline(cin,str)**을 활용해 띄어쓰기를 무시한 채 문자열을 한 줄씩 받아주고\n맨 마지막 단어에는 띄어쓰기를 하나씩 붙여준다. 그 이유는 for문에서 띄어쓰기를 기준으로 push & pop을 진행하기 때문에 맨 마지막 단어에도 띄어쓰기를 붙여주는 것이다.\n나머지는 stack에 문자열을 push 해주고 선입후출 방식으로 pop해주는 단순한 구조이다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":386497519,"tx":51},"IqjGfqqQQvpdMUmv/syncedContent":{"id":"IqjGfqqQQvpdMUmv/syncedContent","type":"syncedContent","historyData":{"386497519":{"id":"IqjGfqqQQvpdMUmv/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 9093번 : 단어 뒤집기\"\ndate: 2021-09-01 20:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 자료구조\n---\n\n## 문제\n\n문장이 주어졌을 때, 단어를 모두 뒤집어서 출력하는 프로그램을 작성하시오. 단, 단어의 순서는 바꿀 수 없다. 단어는 영어 알파벳으로만 이루어져 있다.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 문장이 하나 주어진다. 단어의 길이는 최대 20, 문장의 길이는 최대 1000이다. 단어와 단어 사이에는 공백이 하나 있다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n각 테스트 케이스에 대해서, 입력으로 주어진 문장의 단어를 모두 뒤집어 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n2  \nI am happy today  \nWe want to win the first prize  \n\n## 예제 출력 1\nI ma yppah yadot  \neW tnaw ot niw eht tsrif ezirp  \n\n<br><br><br><br><br><br>\n\n\n## 풀이\n```c++\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\nusing std::cout;\nusing std::endl;\n\nint main() { \n\tint num;\n\tcin >> num;\n\tcin.ignore(); // 버퍼 비우기\n\n\tstack <char> st;\n\tstring str;\n\n\twhile (num--) {\n\t\tgetline(cin, str);\n\t\tstr += ' '; // 문자열 마지막에 일부러 붙여줌\n\n\t\tfor (int i = 0; i < str.size(); i++) {\n\t\t\t\n\t\t\tif (str[i] == ' ') {\n\t\t\t\twhile (!st.empty()) {\n\t\t\t\t\tcout << st.top();\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tcout << ' ';\n\t\t\t}\n\n\t\t\telse st.push(str[i]);\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n}\n```\n\n<br><br><br><br><br><br>\n\n\n## 알고리즘 [ 접근방법 ]\n\n#include <string> 함수에 내장된 함수들을 많이 활용해 볼 수 있는 문제이다.\n풀이 방법이 두가지정도로 보이는데 다음과 같다.\n1. stack을 활용한 선입후출 방식의 입출력\n2. reverse 함수를 활용해 일일히 뒤집기\n\n본인은 첫번째 stack을 활용해 문제를 풀이해 봤다.\n\n<br><br><br><br><br><br>\n\n**getline(cin,str)**을 활용해 띄어쓰기를 무시한 채 문자열을 한 줄씩 받아주고\n맨 마지막 단어에는 띄어쓰기를 하나씩 붙여준다. 그 이유는 for문에서 띄어쓰기를 기준으로 push & pop을 진행하기 때문에 맨 마지막 단어에도 띄어쓰기를 붙여주는 것이다.\n나머지는 stack에 문자열을 push 해주고 선입후출 방식으로 pop해주는 단순한 구조이다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":386497519}},"syncHistory":{"main":[386497519,null,null]},"v":1,"hash":1710111525915,"tx":51},"QjUYHBSBdQAHLPXV/content":{"id":"QjUYHBSBdQAHLPXV/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 17298번 : 오큰수\"\ndate: 2021-09-06 02:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 자료구조\n---\n\n## 문제\n크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.\n\n예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub> (1 ≤ A<sub>i</sub> ≤ 1,000,000)이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n4  \n3 5 2 7  \n\n## 예제 출력 1\n5 7 7 -1\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\nusing std::endl;\nusing std::cin;\nusing std::cout;\n\nint main() {\n\t\n\tint test;\n\tint temp = 0;\n\tcin >> test;\n\tstack <int> st;\n\tvector <int> arr(test), ans(test,-1);\n\n\tfor (int i = 0; i < test; i++) {\n\t\tcin >> arr[i];\n\t}\n\n\tfor (int i = 0; i < test; i++) {\n\t\twhile (!st.empty() && arr[st.top()] < arr[i]) {\n\t\t\tans[st.top()] = arr[i];\n\t\t\tst.pop();\n\t\t}\n\t\tst.push(i);\n\t}\n\n\tfor (int i = 0; i < test; i++) cout << ans[i] << \" \";\n\n\t\n\treturn 0;\n}\n```\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n처음에는 단순히 배열을 이용해 값끼리 비교해서 출력을 해보려 했지만\n이 방법은 시간 초과라는 결과를 초래할 것 같아 버렸다.\n\n그다음은 Queue를 이용해 선입후출 구조를 활용해보려 했지만 답이 나오지 않았다.\n\n결국 한시간정도 고민 끝에 방법을 찾지 못해 구글링을 하게 되었다.\n\n답은 **Stack**과 **Vector**를 활용하는 것이였다.\n\n하나의 벡터에는 입력받은 값을 넣어주고 다른 하나의 벡터에는 결과를 입력한다.\n\n**스택에는 입력받은 벡터의 Index를 넣어준다.**\nIndex를 활용한 문제를 몇번 풀어봤지만 여기서 활용할거라고는 생각을 못했다.\n\n스택의 top과 배열의 값을 비교해주면서 ans에 오큰수를 넣어준다.\n\n<br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":2001068146,"tx":53},"QjUYHBSBdQAHLPXV/syncedContent":{"id":"QjUYHBSBdQAHLPXV/syncedContent","type":"syncedContent","historyData":{"2001068146":{"id":"QjUYHBSBdQAHLPXV/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 17298번 : 오큰수\"\ndate: 2021-09-06 02:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 자료구조\n---\n\n## 문제\n크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.\n\n예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub> (1 ≤ A<sub>i</sub> ≤ 1,000,000)이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n4  \n3 5 2 7  \n\n## 예제 출력 1\n5 7 7 -1\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\nusing std::endl;\nusing std::cin;\nusing std::cout;\n\nint main() {\n\t\n\tint test;\n\tint temp = 0;\n\tcin >> test;\n\tstack <int> st;\n\tvector <int> arr(test), ans(test,-1);\n\n\tfor (int i = 0; i < test; i++) {\n\t\tcin >> arr[i];\n\t}\n\n\tfor (int i = 0; i < test; i++) {\n\t\twhile (!st.empty() && arr[st.top()] < arr[i]) {\n\t\t\tans[st.top()] = arr[i];\n\t\t\tst.pop();\n\t\t}\n\t\tst.push(i);\n\t}\n\n\tfor (int i = 0; i < test; i++) cout << ans[i] << \" \";\n\n\t\n\treturn 0;\n}\n```\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n처음에는 단순히 배열을 이용해 값끼리 비교해서 출력을 해보려 했지만\n이 방법은 시간 초과라는 결과를 초래할 것 같아 버렸다.\n\n그다음은 Queue를 이용해 선입후출 구조를 활용해보려 했지만 답이 나오지 않았다.\n\n결국 한시간정도 고민 끝에 방법을 찾지 못해 구글링을 하게 되었다.\n\n답은 **Stack**과 **Vector**를 활용하는 것이였다.\n\n하나의 벡터에는 입력받은 값을 넣어주고 다른 하나의 벡터에는 결과를 입력한다.\n\n**스택에는 입력받은 벡터의 Index를 넣어준다.**\nIndex를 활용한 문제를 몇번 풀어봤지만 여기서 활용할거라고는 생각을 못했다.\n\n스택의 top과 배열의 값을 비교해주면서 ans에 오큰수를 넣어준다.\n\n<br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":2001068146}},"syncHistory":{"main":[2001068146,null,null]},"v":1,"hash":1710111526982,"tx":53},"sJA3I2YlEcsXd7KN/content":{"id":"sJA3I2YlEcsXd7KN/content","type":"content","text":"---\ntitle: \"[백준] 2292번 : 벌집\"\ndate: 2021-07-23 01:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n  \n\n## 문제\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B0%B1%EC%A4%802292.png?raw=true)\n\n위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.\n\n## 입력\n첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.\n## 출력\n입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.\n\n## 예제 입력 1\n13\n\n## 예제 출력 1\n3\n\n  \n\n## 풀이1\n\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main()\n{\n\n\tint num = 0;\n\tint res = 0;\n\tint n = 1;\n\n\tscanf(\"%d\", &num);\n\n\tif (num == 1) {\n\t\tprintf(\"%d\", num);\n\t\texit(0);\n\t}\n\n\tfor(int i=0;;i++){\n\t\tif (3 * n * n + 3 * n + 1 >= num) {\n\t\t\tres = n+1;\n\t\t\tbreak;\n\t\t}\n\t\t\tn++;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n\n```\n\n  \n  \n  \n\n## 알고리즘 [ 접근방법 ]\n바로 이전 포스팅인 손익분기점 문제와 비슷한 유형의 문제이다. 처음에 생각해낸 풀이 방법은 점화식을 이용한 방법이였다.  벌집모양에서 단계가 하나씩 높아질때 마다 벌집의 가장 큰 숫자를 구해보면 다음과 같다.\n\n> **1 &nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;61&nbsp;\t...**\n\n<br><br><br>\n이는 a<sub>1</sub>=1이고 계차가 6n인 계차수열이므로 이를 점화식으로 쓰면 다음과 같다.\n\n> **3n<sup>2</sup>+3n+1**\n\n<br><br><br>\n\n점화식을 이용해  **3n<sup>2</sup>+3n+1** 이 입력받은 숫자보다 클 때의 n값을 출력해주면 된다.\n```c\n\tfor(int i=0;;i++){\n\t\tif (3 * n * n + 3 * n + 1 >= num) {\n\t\t\tres = n+1;\n\t\t\tbreak;\n\t\t}\n\t\t\tn++;\n\t}\n```\n\n","properties":"\n","discussions":{},"comments":{},"hash":1561484369,"tx":55},"sJA3I2YlEcsXd7KN/syncedContent":{"id":"sJA3I2YlEcsXd7KN/syncedContent","type":"syncedContent","historyData":{"1561484369":{"id":"sJA3I2YlEcsXd7KN/content","type":"content","text":"---\ntitle: \"[백준] 2292번 : 벌집\"\ndate: 2021-07-23 01:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n  \n\n## 문제\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B0%B1%EC%A4%802292.png?raw=true)\n\n위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.\n\n## 입력\n첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.\n## 출력\n입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.\n\n## 예제 입력 1\n13\n\n## 예제 출력 1\n3\n\n  \n\n## 풀이1\n\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main()\n{\n\n\tint num = 0;\n\tint res = 0;\n\tint n = 1;\n\n\tscanf(\"%d\", &num);\n\n\tif (num == 1) {\n\t\tprintf(\"%d\", num);\n\t\texit(0);\n\t}\n\n\tfor(int i=0;;i++){\n\t\tif (3 * n * n + 3 * n + 1 >= num) {\n\t\t\tres = n+1;\n\t\t\tbreak;\n\t\t}\n\t\t\tn++;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n\n```\n\n  \n  \n  \n\n## 알고리즘 [ 접근방법 ]\n바로 이전 포스팅인 손익분기점 문제와 비슷한 유형의 문제이다. 처음에 생각해낸 풀이 방법은 점화식을 이용한 방법이였다.  벌집모양에서 단계가 하나씩 높아질때 마다 벌집의 가장 큰 숫자를 구해보면 다음과 같다.\n\n> **1 &nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;61&nbsp;\t...**\n\n<br><br><br>\n이는 a<sub>1</sub>=1이고 계차가 6n인 계차수열이므로 이를 점화식으로 쓰면 다음과 같다.\n\n> **3n<sup>2</sup>+3n+1**\n\n<br><br><br>\n\n점화식을 이용해  **3n<sup>2</sup>+3n+1** 이 입력받은 숫자보다 클 때의 n값을 출력해주면 된다.\n```c\n\tfor(int i=0;;i++){\n\t\tif (3 * n * n + 3 * n + 1 >= num) {\n\t\t\tres = n+1;\n\t\t\tbreak;\n\t\t}\n\t\t\tn++;\n\t}\n```\n\n","properties":"\n","discussions":{},"comments":{},"hash":1561484369}},"syncHistory":{"main":[1561484369,null,null]},"v":1,"hash":1710111528271,"tx":55},"tUKHjSE4AzMkDcu6/content":{"id":"tUKHjSE4AzMkDcu6/content","type":"content","text":"---\ntitle: \"[백준] 2775번 : 부녀회장이 될테야\"\ndate: 2021-07-23 01:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.\n\n이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.\n\n아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.\n\n## 입력\n첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다\n\n## 출력\n각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.\n\n## 예제 입력 1\n2\n1  \n3  \n2  \n3  \n\n## 예제 출력 1\n6  \n10  \n\n## 잘못된 풀이\n\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include  <stdio.h>\n\nint cal(int, int);\n\nint cal(int k, int n) {\n\tint res = 0;\n\tint count = 1;\n\n\tfor (int i = 0; i <= k; i++) {\n\t\tfor (int j = 1; j <= count; j++) {\n\t\t\tres += j;\n\t\t\tif (count > n) break;\n\t\t}\n\t\tcount++;\n\t}\n\treturn res;\n}\n\n\n\nint main() {\n\tint Test;\n\tint k = 0, n = 0;\n\n\tscanf(\"%d\", &Test);\n\n\tfor (int i = 0; i < Test; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tscanf(\"%d\", &n);\n\t\tint res = cal(k, n);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}\n```\n\n## 알고리즘 [ 접근방법 ]\n\n일단 첫번째 풀이는 틀렸다.. 처음에 문제풀이를 구상한 것은 다음과 같다.  <br><br>\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EA%B1%B4%EB%AC%BC.png?raw=true)\n<br>\n건물의 호수마다 들어가는 인원수를 그린 그림이다. 처음에는 2층까지만 생각을 해보고 규칙을 판단해서\n1부터 호수까지의 수를 계속해서 더하면 되겠다 생각했다. 즉 2층 4호를 예시로 보면 1 / 1+2 / 1+2+3 / 1+2+3+4 이런 규칙을 볼 수 있는 것처럼 다른 호수에도 똑같은 규칙을 적용해 코드를 짰다.\n<br><br>\n그러나 3층만 보더라도 위의 규칙이 적용 안되기 때문에 다른 규칙을 찾아야만 했다. 솔직히 못찾았다. 그래서 다른 사람의 풀이를 스윽 참고를 했는데 생각보다 간단한 규칙이였다.\n<br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include  <stdio.h>\n\nint cal(int, int);\n\nint cal(int k, int n) {\n\t\n\tint arr[15][15] = { 0, };\n\t\n\tfor (int i = 0; i < 15; i++) {\n\t\tarr[0][i] = i;\t// 0층의 i호에는 i명이 산다\n\t}\n\n\t// 바로 직전 방과 아래방을 합한값이 현재 방의 인원수이다\n\tfor (int i = 1; i < 15; i++) {\n\t\tfor (int j = 1; j < 15; j++) {\n\t\t\tarr[i][j] = arr[i - 1][j] + arr[i][j - 1];\n\t\t}\n\t}\n\n\treturn arr[k][n];\n}\n\n\n\nint main() {\n\tint Test;\n\tint k = 0, n = 0;\n\n\tscanf(\"%d\", &Test);\n\n\tfor (int i = 0; i < Test; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tscanf(\"%d\", &n);\n\t\tint res = cal(k, n);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}\n```\n\n<br>\n\n## 알고리즘 [ 접근방법 ]\n\n1_ 모든 호수의 인원수를 이중배열에 넣어주고 일단 0으로 초기화 시킨다.\n2_ 0층의 i호에는 i명이 산다고 했으므로 이를 정의한다.\n3_ **현재방의 인원수는 바로 직전호수방의 인원수 + 바로 아래방의 인원수** 임을 확인하고 이를 정의한다.\n```c\nfor (int i = 1; i < 15; i++) {\n\tfor (int j = 1; j < 15; j++) {\n\t\tarr[i][j] = arr[i - 1][j] + arr[i][j - 1];\n\t}\n}\n```\n<br><br><br>\n요즘은 수학공식을 사용하는 문제를 계속 풀어보고 있는데 확실히 문제마다의 규칙을 찾아내는것이 관건인것 같다. 앞선 벌집문제도 그렇고 이문제도 그렇고 코딩 자체는 어렵지 않지만 그 규칙을 알아내기가 가장 어려운것 같다. 문제를 많이 풀어보는 수 밖에...\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":83544872,"tx":57},"tUKHjSE4AzMkDcu6/syncedContent":{"id":"tUKHjSE4AzMkDcu6/syncedContent","type":"syncedContent","historyData":{"83544872":{"id":"tUKHjSE4AzMkDcu6/content","type":"content","text":"---\ntitle: \"[백준] 2775번 : 부녀회장이 될테야\"\ndate: 2021-07-23 01:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.\n\n이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.\n\n아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.\n\n## 입력\n첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다\n\n## 출력\n각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.\n\n## 예제 입력 1\n2\n1  \n3  \n2  \n3  \n\n## 예제 출력 1\n6  \n10  \n\n## 잘못된 풀이\n\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include  <stdio.h>\n\nint cal(int, int);\n\nint cal(int k, int n) {\n\tint res = 0;\n\tint count = 1;\n\n\tfor (int i = 0; i <= k; i++) {\n\t\tfor (int j = 1; j <= count; j++) {\n\t\t\tres += j;\n\t\t\tif (count > n) break;\n\t\t}\n\t\tcount++;\n\t}\n\treturn res;\n}\n\n\n\nint main() {\n\tint Test;\n\tint k = 0, n = 0;\n\n\tscanf(\"%d\", &Test);\n\n\tfor (int i = 0; i < Test; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tscanf(\"%d\", &n);\n\t\tint res = cal(k, n);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}\n```\n\n## 알고리즘 [ 접근방법 ]\n\n일단 첫번째 풀이는 틀렸다.. 처음에 문제풀이를 구상한 것은 다음과 같다.  <br><br>\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EA%B1%B4%EB%AC%BC.png?raw=true)\n<br>\n건물의 호수마다 들어가는 인원수를 그린 그림이다. 처음에는 2층까지만 생각을 해보고 규칙을 판단해서\n1부터 호수까지의 수를 계속해서 더하면 되겠다 생각했다. 즉 2층 4호를 예시로 보면 1 / 1+2 / 1+2+3 / 1+2+3+4 이런 규칙을 볼 수 있는 것처럼 다른 호수에도 똑같은 규칙을 적용해 코드를 짰다.\n<br><br>\n그러나 3층만 보더라도 위의 규칙이 적용 안되기 때문에 다른 규칙을 찾아야만 했다. 솔직히 못찾았다. 그래서 다른 사람의 풀이를 스윽 참고를 했는데 생각보다 간단한 규칙이였다.\n<br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include  <stdio.h>\n\nint cal(int, int);\n\nint cal(int k, int n) {\n\t\n\tint arr[15][15] = { 0, };\n\t\n\tfor (int i = 0; i < 15; i++) {\n\t\tarr[0][i] = i;\t// 0층의 i호에는 i명이 산다\n\t}\n\n\t// 바로 직전 방과 아래방을 합한값이 현재 방의 인원수이다\n\tfor (int i = 1; i < 15; i++) {\n\t\tfor (int j = 1; j < 15; j++) {\n\t\t\tarr[i][j] = arr[i - 1][j] + arr[i][j - 1];\n\t\t}\n\t}\n\n\treturn arr[k][n];\n}\n\n\n\nint main() {\n\tint Test;\n\tint k = 0, n = 0;\n\n\tscanf(\"%d\", &Test);\n\n\tfor (int i = 0; i < Test; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tscanf(\"%d\", &n);\n\t\tint res = cal(k, n);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}\n```\n\n<br>\n\n## 알고리즘 [ 접근방법 ]\n\n1_ 모든 호수의 인원수를 이중배열에 넣어주고 일단 0으로 초기화 시킨다.\n2_ 0층의 i호에는 i명이 산다고 했으므로 이를 정의한다.\n3_ **현재방의 인원수는 바로 직전호수방의 인원수 + 바로 아래방의 인원수** 임을 확인하고 이를 정의한다.\n```c\nfor (int i = 1; i < 15; i++) {\n\tfor (int j = 1; j < 15; j++) {\n\t\tarr[i][j] = arr[i - 1][j] + arr[i][j - 1];\n\t}\n}\n```\n<br><br><br>\n요즘은 수학공식을 사용하는 문제를 계속 풀어보고 있는데 확실히 문제마다의 규칙을 찾아내는것이 관건인것 같다. 앞선 벌집문제도 그렇고 이문제도 그렇고 코딩 자체는 어렵지 않지만 그 규칙을 알아내기가 가장 어려운것 같다. 문제를 많이 풀어보는 수 밖에...\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":83544872}},"syncHistory":{"main":[83544872,null,null]},"v":1,"hash":1710111529504,"tx":57},"ybpPTUQRubuccvNK/content":{"id":"ybpPTUQRubuccvNK/content","type":"content","text":"---\ntitle: \"[백준] 1712번 : 손익분기점\"\ndate: 2021-07-19 23:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.\n\n예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.\n\n노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.\n\nA, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. **A, B, C는 21억 이하의 자연수이다**.\n\n## 출력\n\n첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.\n\n## 예제 입력 1\n1000 70 170\n\n## 예제 출력 1\n11\n\n## 예제 입력 2\n2100000000 9 10\n\n## 예제 출력 2\n2100000001\n\n## 풀이1\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n\t\n\tdouble A = 0, B = 0, C = 0;\n\tint N = 0;\n\tdouble temp = 0;\n\n\tscanf(\"%lf %lf %lf\", &A, &B, &C);\n\ttemp = A / (C - B);\n\n\twhile (1) { \n\t\tif (C - B <= 0) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (N >temp) {\n\t\t\tprintf(\"%d\\n\", N);\n\t\t\tbreak;\n\t\t}\n\n\t\tN++;\n\t}\n}\n```\n\n\n\n## 알고리즘 [ 접근방법 ]\n\n문제를 보자마자 떠오른 풀이 방법은 **while문**을 활용해야겠다는 생각이였다.  손익분기점을 넘길 때 까지 while문을 반복한다면 N값을 쉽게 찾을 수 있을것이라 생각했고 실제로 올바른 결과가 출력되었다. \n\n그러나 한가지 간과한 사실이 있었다. <br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B0%B1%EC%A4%801712%EB%B2%88.png?raw=true)\n\n해당 문제는 **시간 제한**이 일반적인 문제보다 적은 0.35초였고 while문을 사용한다면 **시간 초과**라는 결과가 도출되었다. <br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B0%B1%EC%A4%801712%EB%B2%88%EC%8B%9C%EA%B0%84%EC%B4%88%EA%B3%BC.png?raw=true)\n\n```c\n    while (1) { \n    \tif (C - B <= 0) {\n    \t\tprintf(\"-1\\n\");\n    \t\tbreak;\n    \t}\n    \n    \tif (N >temp) {\n    \t\tprintf(\"%d\\n\", N);\n    \t\tbreak;\n    \t}\n    \n    \tN++;\n    }\n```\n위의 코드에서 **A=210,000,000 / B=9 / C=10** 이라고 주어진다면 while문이 **21억번** 실행되므로 **시간초과**라는 결과가 나타나는 것이다. 따라서 이를 해결하기 위해서는 반복문을 사용하는것 보다는 단순 부등식을 이용해 연산하는 편이 좋다.\n\n## 풀이2\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n\n\tdouble A = 0, B = 0, C = 0;\n\tint N = 0;\n\tdouble temp = 0;\n\tint res = 0;\n\n\tscanf(\"%lf %lf %lf\", &A, &B, &C);\n\ttemp = A / (C - B);\n\n\tif (C - B <= 0) { // 손익분기점이 존재하지 않는 경우\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t}\n\n\tres = temp + 1; // 손익분기점 계산\n\n\tprintf(\"%d\", res);\n}\n```\n## 알고리즘 [ 접근방법 ]\n\n먼저 손익분기점을 계산한 값을 temp에 입력해준뒤에 이에 +1을 해주는 방식을 선택하면 런타임을 훨씬 단축시켜 문제의 정답과 부합하게 만들 수 있다.\n\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-850581845,"tx":59},"ybpPTUQRubuccvNK/syncedContent":{"id":"ybpPTUQRubuccvNK/syncedContent","type":"syncedContent","historyData":{"-850581845":{"id":"ybpPTUQRubuccvNK/content","type":"content","text":"---\ntitle: \"[백준] 1712번 : 손익분기점\"\ndate: 2021-07-19 23:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.\n\n예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.\n\n노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.\n\nA, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. **A, B, C는 21억 이하의 자연수이다**.\n\n## 출력\n\n첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.\n\n## 예제 입력 1\n1000 70 170\n\n## 예제 출력 1\n11\n\n## 예제 입력 2\n2100000000 9 10\n\n## 예제 출력 2\n2100000001\n\n## 풀이1\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n\t\n\tdouble A = 0, B = 0, C = 0;\n\tint N = 0;\n\tdouble temp = 0;\n\n\tscanf(\"%lf %lf %lf\", &A, &B, &C);\n\ttemp = A / (C - B);\n\n\twhile (1) { \n\t\tif (C - B <= 0) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (N >temp) {\n\t\t\tprintf(\"%d\\n\", N);\n\t\t\tbreak;\n\t\t}\n\n\t\tN++;\n\t}\n}\n```\n\n\n\n## 알고리즘 [ 접근방법 ]\n\n문제를 보자마자 떠오른 풀이 방법은 **while문**을 활용해야겠다는 생각이였다.  손익분기점을 넘길 때 까지 while문을 반복한다면 N값을 쉽게 찾을 수 있을것이라 생각했고 실제로 올바른 결과가 출력되었다. \n\n그러나 한가지 간과한 사실이 있었다. <br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B0%B1%EC%A4%801712%EB%B2%88.png?raw=true)\n\n해당 문제는 **시간 제한**이 일반적인 문제보다 적은 0.35초였고 while문을 사용한다면 **시간 초과**라는 결과가 도출되었다. <br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B0%B1%EC%A4%801712%EB%B2%88%EC%8B%9C%EA%B0%84%EC%B4%88%EA%B3%BC.png?raw=true)\n\n```c\n    while (1) { \n    \tif (C - B <= 0) {\n    \t\tprintf(\"-1\\n\");\n    \t\tbreak;\n    \t}\n    \n    \tif (N >temp) {\n    \t\tprintf(\"%d\\n\", N);\n    \t\tbreak;\n    \t}\n    \n    \tN++;\n    }\n```\n위의 코드에서 **A=210,000,000 / B=9 / C=10** 이라고 주어진다면 while문이 **21억번** 실행되므로 **시간초과**라는 결과가 나타나는 것이다. 따라서 이를 해결하기 위해서는 반복문을 사용하는것 보다는 단순 부등식을 이용해 연산하는 편이 좋다.\n\n## 풀이2\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n\n\tdouble A = 0, B = 0, C = 0;\n\tint N = 0;\n\tdouble temp = 0;\n\tint res = 0;\n\n\tscanf(\"%lf %lf %lf\", &A, &B, &C);\n\ttemp = A / (C - B);\n\n\tif (C - B <= 0) { // 손익분기점이 존재하지 않는 경우\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t}\n\n\tres = temp + 1; // 손익분기점 계산\n\n\tprintf(\"%d\", res);\n}\n```\n## 알고리즘 [ 접근방법 ]\n\n먼저 손익분기점을 계산한 값을 temp에 입력해준뒤에 이에 +1을 해주는 방식을 선택하면 런타임을 훨씬 단축시켜 문제의 정답과 부합하게 만들 수 있다.\n\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-850581845}},"syncHistory":{"main":[-850581845,null,null]},"v":1,"hash":1710111530892,"tx":59},"If5aQIxmIA2QnlwG/content":{"id":"If5aQIxmIA2QnlwG/content","type":"content","text":"---\ntitle: \"[백준] 10757번 : 큰수 A+B\"\ndate: 2021-07-28 20:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n## 문제\n두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n\n## 입력\n첫째 줄에 A와 B가 주어진다. (0 < A,B < 10<sup>10000</sup>)\n\n## 출력\n첫째 줄에 A+B를 출력한다.\n\n## 예제 입력 \n9223372036854775807 9223372036854775808\n\n## 예제 출력 \n18446744073709551615\n\n\n## 알고리즘 [ 접근방법 ]\n\n파이썬이나 자바같은 다른 언어를 사용해 풀었다면 굉장히 쉽게 풀 수 있는 문제이지만 내 주력언어인 C언어로는 상당히 생각할게 많은 문제였다. 문제에서 입력받는 A,B의 범위를 0 < A,B < 10<sup>10000</sup> 로 설정했는데 C에서는 범위가 가장 넓은 자료형인 long long 마저도 +-10<sup>19</sup> 까지만 커버가 가능하기 때문에 일반적인 숫자 자료형으로는 값을 입력받을 수 없다.\n<br><br>\n\n이때문에 숫자를 문자형으로 입력받고 아스키코드를 활용하는 방식으로 문제풀이를 구상했다. \n\n<br><br>\n\n10<sup>1</sup>은 두자리, 10<sup>2</sup>은 세자리 ... 이므로 10<sup>10000</sup>은 10001자리수 숫자를 의미한다. 따라서 이를 담을 수 있는 크기의 문자열을 설정해 주었다. 이때 10001자리수를 담기 위해서는 배열의 크기는 하나 더 큰 10002로 설정해줘야 한다. res는 최종 결과를 담을 문자열이다.\n```c\nchar arr1[10002] = { 0 }, arr2[10002] = { 0 }, res[10002] = { 0 };\n```\n\n<br><br>\n\n보통 덧셈을 할때는 일의자리 부터 더한다음 합이 10이 넘어가면 다음자리에 1을 더해주는 방식으로 진행되는데 이를 구현하기 위해 문자열을 뒤집어주는 reverse함수를 만들었다.\n```c\nvoid reverse(char *arr, int len) {\n\tchar temp;\n\n\tfor (int i = 0; i < len / 2; i++) {\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[len - 1 - i];\n\t\tarr[len - 1 - i] = temp;\n\t}\n}\n```\n그리 어려운 코드는 아니지만 reverse함수는 어디에서나 쉽게 활용될 수 있으므로 기억해두는게 좋다.\n\n<br><br>\n\n다음으로 덧셈은 for문을 돌면서 자리마다 더해질 텐데 for문을 몇번 돌려야 할지 결정하는 기준은 입력받은 문자열의 자리수이다. 더 긴 자리수 만큼 for문이 실행되어야 하므로 이를 결정하기 위해 두 문자열중 어떤게 더 긴 문자열인지 판별하고 이를 저장해준다.\n```c\nint len1 = strlen(arr1);\nint len2 = strlen(arr2);\n\nint len = len1 > len2 ? len1 : len2;\n```\n\n<br><br>\n다음으로 이 문제의 핵심 부분이라고 볼 수 있는 덧셈 파트이다. 문자를 숫자로바꾸기 위해 각 자리수에서 '0'을 빼준뒤 더하는것을 기본으로 한다.\n이때 두 수의 합이 10보다 크거나 같게되는 경우 다음 자리수에 1을 더해줘야 하므로 carry라는 변수를 하나 사용한다.\n```c\nsum = arr1[i] - '0' + arr2[i] - '0' + carry;\n```\n```c\nif (sum > 9) carry = 1;\n\t\telse carry = 0;\n```\n\n<br><br>\n\n그다음 숫자로 바뀐 해당 문자를 다시 문자로 바꿔주기 위해 '0'을 더해주고 res에 저장한다.\n```c\nres[i] = sum % 10 + '0';\n```\n\n<br><br>\n\n여기서 한가지 예외처리를 해줄것이 있는데 바로 두 문자열의 자리수가 다른경우이다. 다음 이미지를 보면 이해가 빠를 것이다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%8D%A7%EC%85%88.jpg?raw=true)\n\n12345 + 1234를 하는 과정인데 reverse함수 처리하면 그림의 아래 부분과 같다. 이렇게 되면 배열 4번째에서 1과 null값을 더하게 된다. \n그런데 위의 sum코드에서 각 숫자마다 '0'을 빼줬으므로 이런경우 sum이 음수가 된다. ( null의 ASCII값 : 0 , '0'의 ASCII값 : 48 )\n\n>  '1' - '0' + null - '0'  \n>  // 49 - 48 + 0 - 48로 음수가 된다.\n\n<br><br>\n\n따라서  sum이 음수일 경우 '0'을 더해주는 예외처리를 해준다.\n```c\nwhile (sum < 0) sum += '0';\n```\n\n<br><br>\n\n한가지 예외처리가 또있다. 가장 큰 자리수의 합이 10이 넘을 경우 배열의 마지막에 1을 추가해줘야만 한다.\n```c\nif (carry == 1) res[len] = '1';\n```\n\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid reverse(char*, int);\n\nvoid reverse(char *arr, int len) {\n\tchar temp;\n\n\tfor (int i = 0; i < len / 2; i++) {\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[len - 1 - i];\n\t\tarr[len - 1 - i] = temp;\n\t}\n}\n\nint main() {\n\tchar arr1[10002] = { 0 }, arr2[10002] = { 0 }, res[10002] = { 0 };\n\tint sum = 0, carry = 0;\n\n\tscanf(\"%s %s\", arr1, arr2);\n\n\tint len1 = strlen(arr1);\n\tint len2 = strlen(arr2);\n\n\tint len = len1 > len2 ? len1 : len2;\n\n\treverse(arr1, len1);\n\treverse(arr2, len2);\n\n\tfor (int i = 0; i < len; i++) {\n\t\tsum = arr1[i] - '0' + arr2[i] - '0' + carry;\n\n\t\twhile (sum < 0) sum += '0';\n\n\t\tif (sum > 9) carry = 1;\n\t\telse carry = 0;\n\n\t\tres[i] = sum % 10 + '0';\n\t}\n\n\tif (carry == 1) res[len] = '1';\n\n\treverse(res, strlen(res));\n\n\tprintf(\"%s\\n\", res);\n\n\treturn 0;\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":553285820,"tx":61},"If5aQIxmIA2QnlwG/syncedContent":{"id":"If5aQIxmIA2QnlwG/syncedContent","type":"syncedContent","historyData":{"553285820":{"id":"If5aQIxmIA2QnlwG/content","type":"content","text":"---\ntitle: \"[백준] 10757번 : 큰수 A+B\"\ndate: 2021-07-28 20:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n## 문제\n두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n\n## 입력\n첫째 줄에 A와 B가 주어진다. (0 < A,B < 10<sup>10000</sup>)\n\n## 출력\n첫째 줄에 A+B를 출력한다.\n\n## 예제 입력 \n9223372036854775807 9223372036854775808\n\n## 예제 출력 \n18446744073709551615\n\n\n## 알고리즘 [ 접근방법 ]\n\n파이썬이나 자바같은 다른 언어를 사용해 풀었다면 굉장히 쉽게 풀 수 있는 문제이지만 내 주력언어인 C언어로는 상당히 생각할게 많은 문제였다. 문제에서 입력받는 A,B의 범위를 0 < A,B < 10<sup>10000</sup> 로 설정했는데 C에서는 범위가 가장 넓은 자료형인 long long 마저도 +-10<sup>19</sup> 까지만 커버가 가능하기 때문에 일반적인 숫자 자료형으로는 값을 입력받을 수 없다.\n<br><br>\n\n이때문에 숫자를 문자형으로 입력받고 아스키코드를 활용하는 방식으로 문제풀이를 구상했다. \n\n<br><br>\n\n10<sup>1</sup>은 두자리, 10<sup>2</sup>은 세자리 ... 이므로 10<sup>10000</sup>은 10001자리수 숫자를 의미한다. 따라서 이를 담을 수 있는 크기의 문자열을 설정해 주었다. 이때 10001자리수를 담기 위해서는 배열의 크기는 하나 더 큰 10002로 설정해줘야 한다. res는 최종 결과를 담을 문자열이다.\n```c\nchar arr1[10002] = { 0 }, arr2[10002] = { 0 }, res[10002] = { 0 };\n```\n\n<br><br>\n\n보통 덧셈을 할때는 일의자리 부터 더한다음 합이 10이 넘어가면 다음자리에 1을 더해주는 방식으로 진행되는데 이를 구현하기 위해 문자열을 뒤집어주는 reverse함수를 만들었다.\n```c\nvoid reverse(char *arr, int len) {\n\tchar temp;\n\n\tfor (int i = 0; i < len / 2; i++) {\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[len - 1 - i];\n\t\tarr[len - 1 - i] = temp;\n\t}\n}\n```\n그리 어려운 코드는 아니지만 reverse함수는 어디에서나 쉽게 활용될 수 있으므로 기억해두는게 좋다.\n\n<br><br>\n\n다음으로 덧셈은 for문을 돌면서 자리마다 더해질 텐데 for문을 몇번 돌려야 할지 결정하는 기준은 입력받은 문자열의 자리수이다. 더 긴 자리수 만큼 for문이 실행되어야 하므로 이를 결정하기 위해 두 문자열중 어떤게 더 긴 문자열인지 판별하고 이를 저장해준다.\n```c\nint len1 = strlen(arr1);\nint len2 = strlen(arr2);\n\nint len = len1 > len2 ? len1 : len2;\n```\n\n<br><br>\n다음으로 이 문제의 핵심 부분이라고 볼 수 있는 덧셈 파트이다. 문자를 숫자로바꾸기 위해 각 자리수에서 '0'을 빼준뒤 더하는것을 기본으로 한다.\n이때 두 수의 합이 10보다 크거나 같게되는 경우 다음 자리수에 1을 더해줘야 하므로 carry라는 변수를 하나 사용한다.\n```c\nsum = arr1[i] - '0' + arr2[i] - '0' + carry;\n```\n```c\nif (sum > 9) carry = 1;\n\t\telse carry = 0;\n```\n\n<br><br>\n\n그다음 숫자로 바뀐 해당 문자를 다시 문자로 바꿔주기 위해 '0'을 더해주고 res에 저장한다.\n```c\nres[i] = sum % 10 + '0';\n```\n\n<br><br>\n\n여기서 한가지 예외처리를 해줄것이 있는데 바로 두 문자열의 자리수가 다른경우이다. 다음 이미지를 보면 이해가 빠를 것이다.\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%8D%A7%EC%85%88.jpg?raw=true)\n\n12345 + 1234를 하는 과정인데 reverse함수 처리하면 그림의 아래 부분과 같다. 이렇게 되면 배열 4번째에서 1과 null값을 더하게 된다. \n그런데 위의 sum코드에서 각 숫자마다 '0'을 빼줬으므로 이런경우 sum이 음수가 된다. ( null의 ASCII값 : 0 , '0'의 ASCII값 : 48 )\n\n>  '1' - '0' + null - '0'  \n>  // 49 - 48 + 0 - 48로 음수가 된다.\n\n<br><br>\n\n따라서  sum이 음수일 경우 '0'을 더해주는 예외처리를 해준다.\n```c\nwhile (sum < 0) sum += '0';\n```\n\n<br><br>\n\n한가지 예외처리가 또있다. 가장 큰 자리수의 합이 10이 넘을 경우 배열의 마지막에 1을 추가해줘야만 한다.\n```c\nif (carry == 1) res[len] = '1';\n```\n\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid reverse(char*, int);\n\nvoid reverse(char *arr, int len) {\n\tchar temp;\n\n\tfor (int i = 0; i < len / 2; i++) {\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[len - 1 - i];\n\t\tarr[len - 1 - i] = temp;\n\t}\n}\n\nint main() {\n\tchar arr1[10002] = { 0 }, arr2[10002] = { 0 }, res[10002] = { 0 };\n\tint sum = 0, carry = 0;\n\n\tscanf(\"%s %s\", arr1, arr2);\n\n\tint len1 = strlen(arr1);\n\tint len2 = strlen(arr2);\n\n\tint len = len1 > len2 ? len1 : len2;\n\n\treverse(arr1, len1);\n\treverse(arr2, len2);\n\n\tfor (int i = 0; i < len; i++) {\n\t\tsum = arr1[i] - '0' + arr2[i] - '0' + carry;\n\n\t\twhile (sum < 0) sum += '0';\n\n\t\tif (sum > 9) carry = 1;\n\t\telse carry = 0;\n\n\t\tres[i] = sum % 10 + '0';\n\t}\n\n\tif (carry == 1) res[len] = '1';\n\n\treverse(res, strlen(res));\n\n\tprintf(\"%s\\n\", res);\n\n\treturn 0;\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":553285820}},"syncHistory":{"main":[553285820,null,null]},"v":1,"hash":1710111532143,"tx":61},"3MlAcPk2jd146ZWA/content":{"id":"3MlAcPk2jd146ZWA/content","type":"content","text":"---\ntitle: \"[백준] 2581번 : 소수\"\ndate: 2021-07-29 17:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n## 문제\n\n자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.\n\n  \n\n예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.\n\n  \n\nM과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.\n\n  \n\n단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n60\n\n100\n\n  \n\n## 예제 출력 1\n\n620\n\n61\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 2\n\n64\n\n65\n\n  \n\n## 예제 출력 2\n\n-1\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 알고리즘 [ 접근방법 ]\n\n  \n\nM이상 N이하의 자연수 중 소수인 것을 모두 골라 소수의 합과 최솟값을 찾는 문제이다. **소수인지 아닌지 판별하는 것**과 **최소값을 저장하는것** 두가지 정도가 핵심이라고 볼 수 있다.\n\n<br><br><br><br><br><br>\n\n  \n\n**소수판별법① : 일일히 비교하기**\n\n소수는 1과 자기자신만을 약수로 가지는 수이므로 for문을 이용해 2부터 자기자신의 수 이전까지 비교하는 방법이 있다. 일반적으로 크기가 작은 수가 소수인지 아닌지 판별할 때 사용하면 좋다.\n\n  \n\n```c\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include  <stdio.h>\n\nint  main() {\n\nint test = 0;\n\nint num = 0;\n\nint count = 0;\n\n  \n\nscanf(\"%d\",&test);\n\ncount = test; // 입력된 모든 수가 소수라고 설정하고 소수가 아닌경우 하나씩 빼주기 위함\n\nfor (int i = 0; i < test; i++) {\n\nscanf(\"%d\", &num);\n\nfor (int i = 2; i < num; i++) {\n\n// 소수가 아닌경우\n\nif (num % i == 0) {\n\ncount--;\n\nbreak;\n\n}\n\n}\n\n// 1은 소수가 아니므로 예외처리\n\nif (num == 1) {\n\ncount--;\n\n}\n\n}\n\nprintf(\"%d\", count);\n\n  \n\nreturn 0;\n\n}\n\n```\n\n  \n\n위의 코드를 이용해 소수판별을 할 경우 효율이 굉장히 떨어질 수 있다. num이 굉장히 큰 수, 예를들면 10,000,000이라고 하면 for문을 99,999,98번 돌아야 하므로 굉장히 오랜 처리 시간이 필요하다. 처리 시간을 단축시키기 위해 소수를 판별하는 또다른 방법이 있는데 바로 **제곱근**을 활용하는 것이다.\n\n  \n\n<br><br><br><br><br><br>\n\n  \n  \n\n**소수판별법② : 제곱근 활용하기**\n\n  \n\n>  **N의 약수는 무조건 sqrt(N)의 범위에 존재한다.**\n\n  \n\n18을 예시로 들어보면,\n\n18의 약수는 1, 2, 3, 6, 9, 18이고,\n\n18은 1 x 18 / 2 x 9 / 3 x 6 / √18 x √18 / 6 x 3 / 9 x 2 / 18 x 1 처럼 √18을 중심으로 대칭구조를 가진다. 따라서 소수를 판별할때 ①처럼 처음부터 끝까지 비교할 것이 아니라 **주어진 수의 제곱근** 까지만 비교를 해주면 소요시간을 훨씬 줄일 수 있다!\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 풀이\n\n```c\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include  <stdio.h>\n\n#include  <math.h>\n\n  \n\nint  main() {\n\n  \n\nint m = 0, n = 0;\n\ndouble num = 0.0;\n\nint count = 0, sum = 0;\n\nint min = 10001;\n\n  \n\nscanf(\"%d\", &m);\n\nscanf(\"%d\", &n);\n\n  \n  \n\nfor (int i = m; i <= n; i++) {\n\nnum = sqrt(i);\n\nfor (int j = 2; j <= num; j++) {\n\n// 소수가아닌경우\n\nif (i % j == 0) {\n\ncount++;\n\nbreak;\n\n}\n\n}\n\n// 소수인경우\n\nif (count == 0 && i!=1) {\n\nsum += i;\n\nif (i < min && i!=1) min = i;\n\n}\n\ncount = 0;\n\n}\n\n  \n  \n\n// 소수가 없는경우\n\nif (sum == 0) printf(\"-1\");\n\nelse {\n\nprintf(\"%d\\n\", sum);\n\nprintf(\"%d\\n\", min);\n\n}\n\n  \n\nreturn 0;\n\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1590520298,"tx":63},"3MlAcPk2jd146ZWA/syncedContent":{"id":"3MlAcPk2jd146ZWA/syncedContent","type":"syncedContent","historyData":{"1590520298":{"id":"3MlAcPk2jd146ZWA/content","type":"content","text":"---\ntitle: \"[백준] 2581번 : 소수\"\ndate: 2021-07-29 17:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n## 문제\n\n자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.\n\n  \n\n예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.\n\n  \n\nM과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.\n\n  \n\n단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n60\n\n100\n\n  \n\n## 예제 출력 1\n\n620\n\n61\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 2\n\n64\n\n65\n\n  \n\n## 예제 출력 2\n\n-1\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 알고리즘 [ 접근방법 ]\n\n  \n\nM이상 N이하의 자연수 중 소수인 것을 모두 골라 소수의 합과 최솟값을 찾는 문제이다. **소수인지 아닌지 판별하는 것**과 **최소값을 저장하는것** 두가지 정도가 핵심이라고 볼 수 있다.\n\n<br><br><br><br><br><br>\n\n  \n\n**소수판별법① : 일일히 비교하기**\n\n소수는 1과 자기자신만을 약수로 가지는 수이므로 for문을 이용해 2부터 자기자신의 수 이전까지 비교하는 방법이 있다. 일반적으로 크기가 작은 수가 소수인지 아닌지 판별할 때 사용하면 좋다.\n\n  \n\n```c\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include  <stdio.h>\n\nint  main() {\n\nint test = 0;\n\nint num = 0;\n\nint count = 0;\n\n  \n\nscanf(\"%d\",&test);\n\ncount = test; // 입력된 모든 수가 소수라고 설정하고 소수가 아닌경우 하나씩 빼주기 위함\n\nfor (int i = 0; i < test; i++) {\n\nscanf(\"%d\", &num);\n\nfor (int i = 2; i < num; i++) {\n\n// 소수가 아닌경우\n\nif (num % i == 0) {\n\ncount--;\n\nbreak;\n\n}\n\n}\n\n// 1은 소수가 아니므로 예외처리\n\nif (num == 1) {\n\ncount--;\n\n}\n\n}\n\nprintf(\"%d\", count);\n\n  \n\nreturn 0;\n\n}\n\n```\n\n  \n\n위의 코드를 이용해 소수판별을 할 경우 효율이 굉장히 떨어질 수 있다. num이 굉장히 큰 수, 예를들면 10,000,000이라고 하면 for문을 99,999,98번 돌아야 하므로 굉장히 오랜 처리 시간이 필요하다. 처리 시간을 단축시키기 위해 소수를 판별하는 또다른 방법이 있는데 바로 **제곱근**을 활용하는 것이다.\n\n  \n\n<br><br><br><br><br><br>\n\n  \n  \n\n**소수판별법② : 제곱근 활용하기**\n\n  \n\n>  **N의 약수는 무조건 sqrt(N)의 범위에 존재한다.**\n\n  \n\n18을 예시로 들어보면,\n\n18의 약수는 1, 2, 3, 6, 9, 18이고,\n\n18은 1 x 18 / 2 x 9 / 3 x 6 / √18 x √18 / 6 x 3 / 9 x 2 / 18 x 1 처럼 √18을 중심으로 대칭구조를 가진다. 따라서 소수를 판별할때 ①처럼 처음부터 끝까지 비교할 것이 아니라 **주어진 수의 제곱근** 까지만 비교를 해주면 소요시간을 훨씬 줄일 수 있다!\n\n  \n\n<br><br><br><br><br><br>\n\n  \n\n## 풀이\n\n```c\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include  <stdio.h>\n\n#include  <math.h>\n\n  \n\nint  main() {\n\n  \n\nint m = 0, n = 0;\n\ndouble num = 0.0;\n\nint count = 0, sum = 0;\n\nint min = 10001;\n\n  \n\nscanf(\"%d\", &m);\n\nscanf(\"%d\", &n);\n\n  \n  \n\nfor (int i = m; i <= n; i++) {\n\nnum = sqrt(i);\n\nfor (int j = 2; j <= num; j++) {\n\n// 소수가아닌경우\n\nif (i % j == 0) {\n\ncount++;\n\nbreak;\n\n}\n\n}\n\n// 소수인경우\n\nif (count == 0 && i!=1) {\n\nsum += i;\n\nif (i < min && i!=1) min = i;\n\n}\n\ncount = 0;\n\n}\n\n  \n  \n\n// 소수가 없는경우\n\nif (sum == 0) printf(\"-1\");\n\nelse {\n\nprintf(\"%d\\n\", sum);\n\nprintf(\"%d\\n\", min);\n\n}\n\n  \n\nreturn 0;\n\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1590520298}},"syncHistory":{"main":[1590520298,null,null]},"v":1,"hash":1710111533313,"tx":63},"p9UokYwup7mYh1M9/content":{"id":"p9UokYwup7mYh1M9/content","type":"content","text":"---\ntitle: \"[백준] 9020번 : 골드바흐의 추측 \"\ndate: 2021-07-31 18:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n\n1보다 큰 자연수 중에서 1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다. 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다. 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.\n\n골드바흐의 추측은 유명한 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다. 이러한 수를 골드바흐 수라고 한다. 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. 예를 들면, 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5, 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다. 10000보다 작거나 같은 모든 짝수 n에 대한 골드바흐 파티션은 존재한다.\n\n2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다. 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n3  \n8  \n10  \n16  \n  \n\n## 예제 출력 1\n\n3 5  \n5 5  \n5 11\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n수학적 센스가 필요한 문제였다. 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 골드바흐의 추측을 어떻게 하면 코딩으로 풀어 낼 수 있을까 고민이 필요했다. 나는 처음에 4단계 정도를 구상하고 시작했다.\n\n1. **주어진 수를 반으로 나눈다.**\n2. **반으로 나눈수를 각각 +1, -1을 해준다**\n3. **+1, -1해준수가 소수인지 아닌지를 판별한다.**\n4. **소수라면 출력 / 아니라면 2번과정부터 다시 반복한다.** \n\n결과론적으로 보면 내가 처음에 구상한 단계는 거의 맞아 떨어졌다. \n\n<br><br><br><br><br><br>\n\n먼저 소수를 판별하는 코드는 함수처리를 해줬다.\n```c\nint isPrime(int num) {\n\tdouble temp = sqrt(num);\n\tint count = 0;\n\n\tfor (int i = 2; i <= temp; i++) {\n\t\tif (num % i == 0) {\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && num!=1) return 1;\n\telse return 0;\n\n\tcount = 0;\n}\n```\n앞선 포스팅이나 다른 문제들에서도 많이 사용한 제곱근을 활용한 소수판별법 코드이다. 구체적인 설명은 생략하겠다.\n\n<br><br><br><br><br><br>\n\n다음으로 1,2단계 코드를 보면 다음과같다.\n```c\nint div2 = 0;\nint temp1 = 0, temp2 = 0;\n\ndiv2 = n / 2;\t\t// 처음주어진 수를 2로 나눈다\ntemp1 = div2 + 1;\t// 2로 나뉜수에서 +1을한다\ntemp2 = n - temp1;\t// 처음주어진 수에서 temp1을 뺀다.\n```\n문제에서  **''골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다''** 라고 제시 되었기 때문에 차이가 가장 작은것을 먼저 계산하기 위해 절반을 나눈값을 기준으로 그 차이를 점점 벌려나가는 생각을 했다.\n\n<br><br><br><br><br><br>\n\n다음으로 소수인지 아닌지 판별하는것은 if문과 함수를 같이 활용했다.\n```c\nif (isPrime(temp1) && isPrime(temp2)) {\n\tprintf(\"%d %d\\n\", temp2, temp1);\n\tbreak;\n}\n```\nisPrime은 소수일경우 1을 반환하도록 만들어놨으므로 if조건문과 논리연산자를 활용하여 소수인경우 이를 출력하도록 짰다.\n\n<br><br><br><br><br><br>\n\n마지막으로 한가지 예외처리를 해줄 것이 있었는데,\n애초에 2로 나눈 값이 처음부터 소수인 경우이다.\n```c\nif (isPrime(div2)) {\n\tprintf(\"%d %d\\n\", div2, div2);\n\tbreak;\n}\n```\n이는 처음 문제 구상단계에서는 생각하지 못했는데 컴파일을 하고 값을 입력해주다가 오류가 발생해 눈치챘다.\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <math.h>\n\nint isPrime(int);\n\nint isPrime(int num) {\n\tdouble temp = sqrt(num);\n\tint count = 0;\n\n\tfor (int i = 2; i <= temp; i++) {\n\t\tif (num % i == 0) {\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && num!=1) return 1;\n\telse return 0;\n\n\tcount = 0;\n}\n\n\nint main() {\n\n\tint num = 0, n = 0;\n\tint div2 = 0;\n\tint temp1 = 0, temp2 = 0;\n\n\tscanf(\"%d\", &num);\n\n\tfor (int i = 0; i < num; i++) {\n\t\tscanf(\"%d\", &n);\n\t\tdiv2 = n / 2;\n\t\ttemp1 = div2 + 1;\n\t\ttemp2 = n - temp1;\n\n\t\twhile (1) {\n\t\t\tif (isPrime(div2)) {\n\t\t\t\tprintf(\"%d %d\\n\", div2, div2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isPrime(temp1) && isPrime(temp2)) {\n\t\t\t\tprintf(\"%d %d\\n\", temp2, temp1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemp1++;\n\t\t\t\ttemp2--;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-619782640,"tx":65},"p9UokYwup7mYh1M9/syncedContent":{"id":"p9UokYwup7mYh1M9/syncedContent","type":"syncedContent","historyData":{"-619782640":{"id":"p9UokYwup7mYh1M9/content","type":"content","text":"---\ntitle: \"[백준] 9020번 : 골드바흐의 추측 \"\ndate: 2021-07-31 18:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n\n1보다 큰 자연수 중에서 1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다. 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다. 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.\n\n골드바흐의 추측은 유명한 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다. 이러한 수를 골드바흐 수라고 한다. 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. 예를 들면, 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5, 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다. 10000보다 작거나 같은 모든 짝수 n에 대한 골드바흐 파티션은 존재한다.\n\n2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다. 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n3  \n8  \n10  \n16  \n  \n\n## 예제 출력 1\n\n3 5  \n5 5  \n5 11\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n수학적 센스가 필요한 문제였다. 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 골드바흐의 추측을 어떻게 하면 코딩으로 풀어 낼 수 있을까 고민이 필요했다. 나는 처음에 4단계 정도를 구상하고 시작했다.\n\n1. **주어진 수를 반으로 나눈다.**\n2. **반으로 나눈수를 각각 +1, -1을 해준다**\n3. **+1, -1해준수가 소수인지 아닌지를 판별한다.**\n4. **소수라면 출력 / 아니라면 2번과정부터 다시 반복한다.** \n\n결과론적으로 보면 내가 처음에 구상한 단계는 거의 맞아 떨어졌다. \n\n<br><br><br><br><br><br>\n\n먼저 소수를 판별하는 코드는 함수처리를 해줬다.\n```c\nint isPrime(int num) {\n\tdouble temp = sqrt(num);\n\tint count = 0;\n\n\tfor (int i = 2; i <= temp; i++) {\n\t\tif (num % i == 0) {\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && num!=1) return 1;\n\telse return 0;\n\n\tcount = 0;\n}\n```\n앞선 포스팅이나 다른 문제들에서도 많이 사용한 제곱근을 활용한 소수판별법 코드이다. 구체적인 설명은 생략하겠다.\n\n<br><br><br><br><br><br>\n\n다음으로 1,2단계 코드를 보면 다음과같다.\n```c\nint div2 = 0;\nint temp1 = 0, temp2 = 0;\n\ndiv2 = n / 2;\t\t// 처음주어진 수를 2로 나눈다\ntemp1 = div2 + 1;\t// 2로 나뉜수에서 +1을한다\ntemp2 = n - temp1;\t// 처음주어진 수에서 temp1을 뺀다.\n```\n문제에서  **''골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다''** 라고 제시 되었기 때문에 차이가 가장 작은것을 먼저 계산하기 위해 절반을 나눈값을 기준으로 그 차이를 점점 벌려나가는 생각을 했다.\n\n<br><br><br><br><br><br>\n\n다음으로 소수인지 아닌지 판별하는것은 if문과 함수를 같이 활용했다.\n```c\nif (isPrime(temp1) && isPrime(temp2)) {\n\tprintf(\"%d %d\\n\", temp2, temp1);\n\tbreak;\n}\n```\nisPrime은 소수일경우 1을 반환하도록 만들어놨으므로 if조건문과 논리연산자를 활용하여 소수인경우 이를 출력하도록 짰다.\n\n<br><br><br><br><br><br>\n\n마지막으로 한가지 예외처리를 해줄 것이 있었는데,\n애초에 2로 나눈 값이 처음부터 소수인 경우이다.\n```c\nif (isPrime(div2)) {\n\tprintf(\"%d %d\\n\", div2, div2);\n\tbreak;\n}\n```\n이는 처음 문제 구상단계에서는 생각하지 못했는데 컴파일을 하고 값을 입력해주다가 오류가 발생해 눈치챘다.\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <math.h>\n\nint isPrime(int);\n\nint isPrime(int num) {\n\tdouble temp = sqrt(num);\n\tint count = 0;\n\n\tfor (int i = 2; i <= temp; i++) {\n\t\tif (num % i == 0) {\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && num!=1) return 1;\n\telse return 0;\n\n\tcount = 0;\n}\n\n\nint main() {\n\n\tint num = 0, n = 0;\n\tint div2 = 0;\n\tint temp1 = 0, temp2 = 0;\n\n\tscanf(\"%d\", &num);\n\n\tfor (int i = 0; i < num; i++) {\n\t\tscanf(\"%d\", &n);\n\t\tdiv2 = n / 2;\n\t\ttemp1 = div2 + 1;\n\t\ttemp2 = n - temp1;\n\n\t\twhile (1) {\n\t\t\tif (isPrime(div2)) {\n\t\t\t\tprintf(\"%d %d\\n\", div2, div2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isPrime(temp1) && isPrime(temp2)) {\n\t\t\t\tprintf(\"%d %d\\n\", temp2, temp1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemp1++;\n\t\t\t\ttemp2--;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-619782640}},"syncHistory":{"main":[-619782640,null,null]},"v":1,"hash":1710111534363,"tx":65},"pDeZuAQGE7zRuhXc/content":{"id":"pDeZuAQGE7zRuhXc/content","type":"content","text":"---\ntitle: \"[백준] 1152번 : 단어의 개수 출력\"\ndate: 2021-07-19 01:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n\n## 입력\n\n첫 줄에 영어 대소문자와 띄어쓰기로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 띄어쓰기 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열의 앞과 뒤에는 공백이 있을 수도 있다.\n  \n\n## 출력\n\n첫째 줄에 단어의 개수를 출력한다.\n\n## 예제 입력 1\nThe Curious Case of Benjamin Button\n\n## 예제 출력 1\n6\n\n## 풀이\n```c\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    #include <string.h>\n    \n    int main() {\n    \tchar str[1000001];\n    \tint space = 0,num=0;\n    \tint i = 0;\n\n    \tgets(str);\n    \n    \twhile (str[i] != '\\0') {\n    \t\tif (str[i] == ' ') space++;\n    \t\ti++;\n    \t}\n    \n    \tnum = space + 1;\n    \n    \tif (str[0] == ' ') {\n    \t\tnum--;\n    \t}\n    \tif (str[strlen(str) - 1] == ' ') {\n    \t\tnum--;\n    \t}\n    \t\n    \tprintf(\"%d\", num);\n    \n    \treturn 0;\n    }\n```\n\n## 알고리즘 [ 접근방법 ]\n\n문제를 보자마자 공백 개수를 구한뒤에 +1을 해주면 되겠다라고 쉽게 생각했다. 단! 몇가지 예외처리가 필요하므로 이를 알아보자.\n\n**1.  scanf는 공백이 포함된 문자열을 제대로 읽어올 수 없다.**\n\nscanf는 문자열을 읽어올 때 공백 이전까지만 받아올 수 있으므로 scanf대신 **gets**을 사용해서 문자열을 읽어온다.\n\n **2. 공백으로 시작하는 문자열 / 공백으로 끝나는 문자열은 예외처리!**\n```c\nif (str[0] == ' ') num--;\n\nif (str[strlen(str) - 1] == ' ') num--;\n```\t\n\n","properties":"\n","discussions":{},"comments":{},"hash":-657495354,"tx":67},"pDeZuAQGE7zRuhXc/syncedContent":{"id":"pDeZuAQGE7zRuhXc/syncedContent","type":"syncedContent","historyData":{"-657495354":{"id":"pDeZuAQGE7zRuhXc/content","type":"content","text":"---\ntitle: \"[백준] 1152번 : 단어의 개수 출력\"\ndate: 2021-07-19 01:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n\n## 입력\n\n첫 줄에 영어 대소문자와 띄어쓰기로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 띄어쓰기 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열의 앞과 뒤에는 공백이 있을 수도 있다.\n  \n\n## 출력\n\n첫째 줄에 단어의 개수를 출력한다.\n\n## 예제 입력 1\nThe Curious Case of Benjamin Button\n\n## 예제 출력 1\n6\n\n## 풀이\n```c\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    #include <string.h>\n    \n    int main() {\n    \tchar str[1000001];\n    \tint space = 0,num=0;\n    \tint i = 0;\n\n    \tgets(str);\n    \n    \twhile (str[i] != '\\0') {\n    \t\tif (str[i] == ' ') space++;\n    \t\ti++;\n    \t}\n    \n    \tnum = space + 1;\n    \n    \tif (str[0] == ' ') {\n    \t\tnum--;\n    \t}\n    \tif (str[strlen(str) - 1] == ' ') {\n    \t\tnum--;\n    \t}\n    \t\n    \tprintf(\"%d\", num);\n    \n    \treturn 0;\n    }\n```\n\n## 알고리즘 [ 접근방법 ]\n\n문제를 보자마자 공백 개수를 구한뒤에 +1을 해주면 되겠다라고 쉽게 생각했다. 단! 몇가지 예외처리가 필요하므로 이를 알아보자.\n\n**1.  scanf는 공백이 포함된 문자열을 제대로 읽어올 수 없다.**\n\nscanf는 문자열을 읽어올 때 공백 이전까지만 받아올 수 있으므로 scanf대신 **gets**을 사용해서 문자열을 읽어온다.\n\n **2. 공백으로 시작하는 문자열 / 공백으로 끝나는 문자열은 예외처리!**\n```c\nif (str[0] == ' ') num--;\n\nif (str[strlen(str) - 1] == ' ') num--;\n```\t\n\n","properties":"\n","discussions":{},"comments":{},"hash":-657495354}},"syncHistory":{"main":[-657495354,null,null]},"v":1,"hash":1710111535701,"tx":67},"7MH9EXPbwlEyua1N/content":{"id":"7MH9EXPbwlEyua1N/content","type":"content","text":"---\ntitle: \"[백준] 1436번 : 영화감독 숌 \"\ndate: 2021-08-09 17:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 브루트 포스\n---\n\n## 문제\n\n666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.\n\n하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.\n\n종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.\n\n따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.\n\n숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n2\n## 예제 출력 1\n\n1666\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n브루트 포스를 활용한 알고리즘 문제이다. 1부터 모든 경우의 수를 다 계산해줘야만 한다. 666이 연속한 경우가 있냐 없냐를 판단할 필요가 있다.\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main() {\n\tint n = 0;\n\tint count = 0;\n\tint num = 0;\n\tint temp = 0;\n\n\tscanf(\"%d\", &n);\n\n\twhile (1) {\n\t\tnum++;\n\t\ttemp = num;\n\n\t\twhile (temp != 0) {\n\t\t\tif (temp % 1000 == 666) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse temp /= 10;\n\t\t}\n\t\tif (count == n) {\n\t\t\tprintf(\"%d\", num);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1765659518,"tx":69},"7MH9EXPbwlEyua1N/syncedContent":{"id":"7MH9EXPbwlEyua1N/syncedContent","type":"syncedContent","historyData":{"1765659518":{"id":"7MH9EXPbwlEyua1N/content","type":"content","text":"---\ntitle: \"[백준] 1436번 : 영화감독 숌 \"\ndate: 2021-08-09 17:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 브루트 포스\n---\n\n## 문제\n\n666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.\n\n하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.\n\n종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.\n\n따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.\n\n숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n2\n## 예제 출력 1\n\n1666\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n브루트 포스를 활용한 알고리즘 문제이다. 1부터 모든 경우의 수를 다 계산해줘야만 한다. 666이 연속한 경우가 있냐 없냐를 판단할 필요가 있다.\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main() {\n\tint n = 0;\n\tint count = 0;\n\tint num = 0;\n\tint temp = 0;\n\n\tscanf(\"%d\", &n);\n\n\twhile (1) {\n\t\tnum++;\n\t\ttemp = num;\n\n\t\twhile (temp != 0) {\n\t\t\tif (temp % 1000 == 666) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse temp /= 10;\n\t\t}\n\t\tif (count == n) {\n\t\t\tprintf(\"%d\", num);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1765659518}},"syncHistory":{"main":[1765659518,null,null]},"v":1,"hash":1710111537177,"tx":69},"4VlIZeIFebGuQ7Yr/content":{"id":"4VlIZeIFebGuQ7Yr/content","type":"content","text":"---\ntitle: \"[백준] 1157번 : 가장 많이 사용된 알파벳 출력하기\"\ndate: 2021-07-18 23:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.\n\n## 입력\n\n첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.\n  \n\n## 출력\n\n첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.\n\n## 예제 입력 1\nMississipi\n\n## 예제 출력 1\n?\n## 예제 입력 2\nzZa\n\n## 예제 출력 2\nZ\n\n## 풀이\n```c\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    #include <string.h>\n    \n    int main() {\n    \t\n\tchar str[1000001];\n\tint alpha[26] = { 0, };\n\tint max = 0,count=0;\n\tint flag = 0;\n\n\tscanf(\"%s\", str);\n\n\tfor (int i = 'a'; i <= 'z'; i++) {\n\t\tfor (int j = 0; j < strlen(str); j++) {\n\t\t\tif (str[j] == i) {\n\t\t\t\talpha[i-'a']++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 'A'; i <= 'Z'; i++) {\n\t\tfor (int j = 0; j < strlen(str); j++) {\n\t\t\tif (str[j] == i) {\n\t\t\t\talpha[i - 'A']++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (alpha[i] > max) {\n\t\t\tmax = alpha[i];\n\t\t\tflag = i;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (alpha[i] == max) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count > 1) {\n\t\tprintf(\"?\\n\");\n\t}\n\telse printf(\"%c\", 'A' + flag);\n\n\treturn 0;\n\n}\n```\n\n\n\n\n## 알고리즘 [ 접근방법 ]\n\n**문자열**과 **ASCII코드**를 적절히 활용해 풀 수 있는 문제이다. for문을 여러번 활용해 입력된 알파벳을 숫자형 배열과 비교하여 값을 조절한다.\n<br>\n### [ Key Point 1] \n```c\n\n    alpha[i-'a']++; // i-'a'를 함으로써 배열의 0번째 부터 값이 입력되도록 함\n    \n    alpha[i -  'A']++; // 대문자도 마찬가지\n\n```\n\n**ASCII코드**를 활용해 배열의 **인덱스를 변형**하는건 많이 사용되므로 기억할 필요가 있어보인다.\n<br>\n\n### [ Key Point 2] \n```c\nfor (int i = 0; i < 26; i++) {\n\t\tif (alpha[i] > max) {\n\t\t\tmax = alpha[i];\n\t\t\tflag = i;\n\t\t}\n\t}\n```\n위의 for문은 입력된 알파벳중 가장 많이 입력된 알파벳을 찾기 위한 코드인데 `flag = i` 가 가장 중요하다. 이후에 가장 많이 입력된 알파벳을 출력하기 위해 `flag=i` 를 사용해 해당 알파벳의 인덱스를 기억하는 역할을 한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1348316954,"tx":71},"4VlIZeIFebGuQ7Yr/syncedContent":{"id":"4VlIZeIFebGuQ7Yr/syncedContent","type":"syncedContent","historyData":{"-1348316954":{"id":"4VlIZeIFebGuQ7Yr/content","type":"content","text":"---\ntitle: \"[백준] 1157번 : 가장 많이 사용된 알파벳 출력하기\"\ndate: 2021-07-18 23:00:00 -0400\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.\n\n## 입력\n\n첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.\n  \n\n## 출력\n\n첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.\n\n## 예제 입력 1\nMississipi\n\n## 예제 출력 1\n?\n## 예제 입력 2\nzZa\n\n## 예제 출력 2\nZ\n\n## 풀이\n```c\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    #include <string.h>\n    \n    int main() {\n    \t\n\tchar str[1000001];\n\tint alpha[26] = { 0, };\n\tint max = 0,count=0;\n\tint flag = 0;\n\n\tscanf(\"%s\", str);\n\n\tfor (int i = 'a'; i <= 'z'; i++) {\n\t\tfor (int j = 0; j < strlen(str); j++) {\n\t\t\tif (str[j] == i) {\n\t\t\t\talpha[i-'a']++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 'A'; i <= 'Z'; i++) {\n\t\tfor (int j = 0; j < strlen(str); j++) {\n\t\t\tif (str[j] == i) {\n\t\t\t\talpha[i - 'A']++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (alpha[i] > max) {\n\t\t\tmax = alpha[i];\n\t\t\tflag = i;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (alpha[i] == max) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count > 1) {\n\t\tprintf(\"?\\n\");\n\t}\n\telse printf(\"%c\", 'A' + flag);\n\n\treturn 0;\n\n}\n```\n\n\n\n\n## 알고리즘 [ 접근방법 ]\n\n**문자열**과 **ASCII코드**를 적절히 활용해 풀 수 있는 문제이다. for문을 여러번 활용해 입력된 알파벳을 숫자형 배열과 비교하여 값을 조절한다.\n<br>\n### [ Key Point 1] \n```c\n\n    alpha[i-'a']++; // i-'a'를 함으로써 배열의 0번째 부터 값이 입력되도록 함\n    \n    alpha[i -  'A']++; // 대문자도 마찬가지\n\n```\n\n**ASCII코드**를 활용해 배열의 **인덱스를 변형**하는건 많이 사용되므로 기억할 필요가 있어보인다.\n<br>\n\n### [ Key Point 2] \n```c\nfor (int i = 0; i < 26; i++) {\n\t\tif (alpha[i] > max) {\n\t\t\tmax = alpha[i];\n\t\t\tflag = i;\n\t\t}\n\t}\n```\n위의 for문은 입력된 알파벳중 가장 많이 입력된 알파벳을 찾기 위한 코드인데 `flag = i` 가 가장 중요하다. 이후에 가장 많이 입력된 알파벳을 출력하기 위해 `flag=i` 를 사용해 해당 알파벳의 인덱스를 기억하는 역할을 한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1348316954}},"syncHistory":{"main":[-1348316954,null,null]},"v":1,"hash":1710111538330,"tx":71},"tyTfzmPd7F6kUOPq/content":{"id":"tyTfzmPd7F6kUOPq/content","type":"content","text":"---\ntitle: \"[백준] 11729번 : 하노이 탑 이동 순서 \"\ndate: 2021-08-02 20:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n\n세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n\n1.  한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.\n2.  쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.\n\n이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.\n\n아래 그림은 원판이 5개인 경우의 예시이다.\n<br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/11729.png?raw=true)\n\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 옮긴 횟수 K를 출력한다.\n\n두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n3\n\n## 예제 출력 1\n\n7\n1 3  \n1 2  \n3 2  \n1 3  \n2 1  \n2 3  \n1 3  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n굉장히 유명한 하노이의 탑 문제이다.\n\n바로 이전 포스팅인 별찍기 - 10 에서도 사용한 원리처럼 재귀를 통해 '가장 작은 단위'가 될 때 까지 재귀호출을 하고 가장 작은 단위가 호출되면 그때부터 return을 해주면 된다.\n\n<br><br><br><br><br><br>\n\n일반적으로 하노이 탑 원판 이동 횟수 공식은 2<sup>n</sup>-1로 잘 알려져 있으므로 이에 대한 자세한 설명은 이미지를 첨부하겠다.\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/하노이.jpg?raw=true)\n위의 점화식에 따라 N개의 원판을 이동시키는 횟수는 2<sup>N</sup>-1이다.\n\n점화식 유도공식은 실제 코드를 짜는데에도 거의 대부분의 아이디어를 제공하는데 이름 그림으로 설명하면 다음과 같다.\n<br><br><br><br><br><br><br>\n\n**N개의 원판이 있다고 가정하자.** <br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%ED%95%98%EB%85%B8%EC%9D%B41.png?raw=true)\n\n<br><br><br><br><br><br>\n\n**#1) 가장 큰 원판을 C로 옮기기 위해서는 n-1개의 원판이 A에서 B로 이동해야 한다.**\nA에서 B로 가는 것을 Hanoi함수라고 하면 n-1번 반복한다는 의미이다.\n이때, 이동 횟수는 Hanoi(n-1)이다.\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%ED%95%98%EB%85%B8%EC%9D%B42.png?raw=true)\n\n<br><br><br><br><br><br>\n\n**#2) A에 있는 가장 큰 원판을 C로 옮긴다.** <br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%ED%95%98%EB%85%B8%EC%9D%B43.png?raw=true)\n이때 이동횟수는 1회이다.\n\n<br><br><br><br><br><br><br>\n\n**#3) B에 있는 n-1개의 원판을 C로 이동한다.**\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%ED%95%98%EB%85%B8%EC%9D%B44.png?raw=true)\n앞서 1단계에서 A에서 B로 n-1개의 원판이 이동하는 횟수가 Hanoi(n-1)이였으므로 같은 원리로 B에서 C로 n-1개의 원판이 이동하는 횟수는 Hanoi(n-1)이 된다. \n\n<br><br><br><br><br><br>\n\n위의 원리를 이용하면 재귀 알고리즘을 작성할 수 있다. \n일단 재귀를 통해 가장 작은 단위로 들어가면,\n**&nbsp;&nbsp;&nbsp;&nbsp;A에서 B로 원판을 이동하는 경우의\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A에서 B로 원판을 이동하는 경우의\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A에서 B로 원판을 이동하는 경우의**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**...**\n이렇게 계속 A에서 B로 이동하는 함수를 재귀호출하여 이동해야 할 원판이 1개가 되면 그때 A에서 B로 이동했다는 것을 출력한 뒤 함수를 리턴하면 된다.\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <math.h>\n\nvoid Hanoi(int N, int start, int mid, int to) {\n\n\t// 이동할 원반의 수가 1개라면?\n\tif (N == 1) {\n\t\tprintf(\"%d %d\\n\", start, to);\n\t\treturn;\n\t}\n\n\tHanoi(N - 1, start, to, mid);\n\tHanoi(1, start,mid, to);\n\tHanoi(N - 1, mid, start, to);\n\n}\n\n\n\nint main() {\n\n\tint n = 0;\n\n\tscanf(\"%d\", &n);\n\n\tint res = pow(2, n) - 1;\n\n\tprintf(\"%d\\n\", res);\n\tHanoi(n, 1, 2, 3);\n\n\treturn 0;\n}\n```\n\n","properties":"\n","discussions":{},"comments":{},"hash":-640983991,"tx":73},"tyTfzmPd7F6kUOPq/syncedContent":{"id":"tyTfzmPd7F6kUOPq/syncedContent","type":"syncedContent","historyData":{"-640983991":{"id":"tyTfzmPd7F6kUOPq/content","type":"content","text":"---\ntitle: \"[백준] 11729번 : 하노이 탑 이동 순서 \"\ndate: 2021-08-02 20:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n\n세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n\n1.  한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.\n2.  쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.\n\n이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.\n\n아래 그림은 원판이 5개인 경우의 예시이다.\n<br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/11729.png?raw=true)\n\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 옮긴 횟수 K를 출력한다.\n\n두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n3\n\n## 예제 출력 1\n\n7\n1 3  \n1 2  \n3 2  \n1 3  \n2 1  \n2 3  \n1 3  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n굉장히 유명한 하노이의 탑 문제이다.\n\n바로 이전 포스팅인 별찍기 - 10 에서도 사용한 원리처럼 재귀를 통해 '가장 작은 단위'가 될 때 까지 재귀호출을 하고 가장 작은 단위가 호출되면 그때부터 return을 해주면 된다.\n\n<br><br><br><br><br><br>\n\n일반적으로 하노이 탑 원판 이동 횟수 공식은 2<sup>n</sup>-1로 잘 알려져 있으므로 이에 대한 자세한 설명은 이미지를 첨부하겠다.\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/하노이.jpg?raw=true)\n위의 점화식에 따라 N개의 원판을 이동시키는 횟수는 2<sup>N</sup>-1이다.\n\n점화식 유도공식은 실제 코드를 짜는데에도 거의 대부분의 아이디어를 제공하는데 이름 그림으로 설명하면 다음과 같다.\n<br><br><br><br><br><br><br>\n\n**N개의 원판이 있다고 가정하자.** <br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%ED%95%98%EB%85%B8%EC%9D%B41.png?raw=true)\n\n<br><br><br><br><br><br>\n\n**#1) 가장 큰 원판을 C로 옮기기 위해서는 n-1개의 원판이 A에서 B로 이동해야 한다.**\nA에서 B로 가는 것을 Hanoi함수라고 하면 n-1번 반복한다는 의미이다.\n이때, 이동 횟수는 Hanoi(n-1)이다.\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%ED%95%98%EB%85%B8%EC%9D%B42.png?raw=true)\n\n<br><br><br><br><br><br>\n\n**#2) A에 있는 가장 큰 원판을 C로 옮긴다.** <br>\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%ED%95%98%EB%85%B8%EC%9D%B43.png?raw=true)\n이때 이동횟수는 1회이다.\n\n<br><br><br><br><br><br><br>\n\n**#3) B에 있는 n-1개의 원판을 C로 이동한다.**\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%ED%95%98%EB%85%B8%EC%9D%B44.png?raw=true)\n앞서 1단계에서 A에서 B로 n-1개의 원판이 이동하는 횟수가 Hanoi(n-1)이였으므로 같은 원리로 B에서 C로 n-1개의 원판이 이동하는 횟수는 Hanoi(n-1)이 된다. \n\n<br><br><br><br><br><br>\n\n위의 원리를 이용하면 재귀 알고리즘을 작성할 수 있다. \n일단 재귀를 통해 가장 작은 단위로 들어가면,\n**&nbsp;&nbsp;&nbsp;&nbsp;A에서 B로 원판을 이동하는 경우의\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A에서 B로 원판을 이동하는 경우의\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A에서 B로 원판을 이동하는 경우의**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**...**\n이렇게 계속 A에서 B로 이동하는 함수를 재귀호출하여 이동해야 할 원판이 1개가 되면 그때 A에서 B로 이동했다는 것을 출력한 뒤 함수를 리턴하면 된다.\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <math.h>\n\nvoid Hanoi(int N, int start, int mid, int to) {\n\n\t// 이동할 원반의 수가 1개라면?\n\tif (N == 1) {\n\t\tprintf(\"%d %d\\n\", start, to);\n\t\treturn;\n\t}\n\n\tHanoi(N - 1, start, to, mid);\n\tHanoi(1, start,mid, to);\n\tHanoi(N - 1, mid, start, to);\n\n}\n\n\n\nint main() {\n\n\tint n = 0;\n\n\tscanf(\"%d\", &n);\n\n\tint res = pow(2, n) - 1;\n\n\tprintf(\"%d\\n\", res);\n\tHanoi(n, 1, 2, 3);\n\n\treturn 0;\n}\n```\n\n","properties":"\n","discussions":{},"comments":{},"hash":-640983991}},"syncHistory":{"main":[-640983991,null,null]},"v":1,"hash":1710111539644,"tx":73},"KvfIbjNY2ObhRnU0/content":{"id":"KvfIbjNY2ObhRnU0/content","type":"content","text":"\n---\n\ntitle: \"[백준] 8958번 : strlen\"\n\ndate: 2021-07-14 19:00:00 -0400\n\ncategories:\n\n- Algorithm\n\ntags:\n\n- 백준\n\n- 알고리즘\n\n- 단계별 풀어보기\n\n---\n## 문제\nN개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.\n  \n\n## 출력\n\n입력으로 주어진 숫자 N개의 합을 출력한다.\n\n \n## 예제 입력 1\n25\n7000000000000000000000000\n\n## 예제 출력 1\n7\n\n## 알고리즘 [ 접근방법 ]\n\n언뜻 보면 굉장히 쉬운 문제이다. 단순히 입력받은 숫자의 자리수 합을 출력하면 되지만 한가지 함정이 있다. **예제 입력1**을 보면 25자리 숫자를 입력받아 7000000000000000000000000을 입력한다. 이런 경우 일반적인 정수 자료형으로는 해당 숫자를 입력 받을 수 없다.\n\n### [ 자료형 종류 ]\n\n\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EC%9E%90%EB%A3%8C%ED%98%95.png?raw=true)\n\n정수형 중 가장 범위가 넓은 **long long** 자료형도 약 +-10<sup>19</sup> 까지만 커버가 가능하기 때문에 20자리가 넘어갈 경우 입력받을 수 없다.\n\n따라서 이런 경우에는 숫자로 입력받을 것이 아니라 문자형으로 입력을 받아야만 한다.\n\n이때 문자를 배열에 입력을 받고 문자 하나하나를 분리하여 연산을 하는 과정이 필요한데 이는 **아스키코드**를 활용해 해결할 수 있다.\n\n### [ 아스키 코드표 ]\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/ASCII.png?raw=true)\n\n## 풀이\n\n```c\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    \n    int main() {\n    \tint n;\n    \tchar str[200];\n    \tint sum = 0, i = 0;\n    \n    \tscanf(\"%d\", &n);\n    \tscanf(\"%s\", str);\n    \n    \tfor (int i = 0; i < n; i++) {\n    \t\tsum += (str[i] - '0');\n    \t}\n    \t\n    \tprintf(\"%d\", sum);\n    }\n```\n입력받은 문자에서 '0'을 빼주면, 예를들어 123을 입력했을때  \n'1' - '0' = 49 - 48 = 1\n\n'2' - '0' = 50 - 48 = 2\n\n'3' - '0' = 51 - 48 = 3 이 되므로\n각 자리의 합을 쉽게 구할 수 있다!\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1388318610,"tx":75},"KvfIbjNY2ObhRnU0/syncedContent":{"id":"KvfIbjNY2ObhRnU0/syncedContent","type":"syncedContent","historyData":{"1388318610":{"id":"KvfIbjNY2ObhRnU0/content","type":"content","text":"\n---\n\ntitle: \"[백준] 8958번 : strlen\"\n\ndate: 2021-07-14 19:00:00 -0400\n\ncategories:\n\n- Algorithm\n\ntags:\n\n- 백준\n\n- 알고리즘\n\n- 단계별 풀어보기\n\n---\n## 문제\nN개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.\n  \n\n## 출력\n\n입력으로 주어진 숫자 N개의 합을 출력한다.\n\n \n## 예제 입력 1\n25\n7000000000000000000000000\n\n## 예제 출력 1\n7\n\n## 알고리즘 [ 접근방법 ]\n\n언뜻 보면 굉장히 쉬운 문제이다. 단순히 입력받은 숫자의 자리수 합을 출력하면 되지만 한가지 함정이 있다. **예제 입력1**을 보면 25자리 숫자를 입력받아 7000000000000000000000000을 입력한다. 이런 경우 일반적인 정수 자료형으로는 해당 숫자를 입력 받을 수 없다.\n\n### [ 자료형 종류 ]\n\n\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EC%9E%90%EB%A3%8C%ED%98%95.png?raw=true)\n\n정수형 중 가장 범위가 넓은 **long long** 자료형도 약 +-10<sup>19</sup> 까지만 커버가 가능하기 때문에 20자리가 넘어갈 경우 입력받을 수 없다.\n\n따라서 이런 경우에는 숫자로 입력받을 것이 아니라 문자형으로 입력을 받아야만 한다.\n\n이때 문자를 배열에 입력을 받고 문자 하나하나를 분리하여 연산을 하는 과정이 필요한데 이는 **아스키코드**를 활용해 해결할 수 있다.\n\n### [ 아스키 코드표 ]\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/ASCII.png?raw=true)\n\n## 풀이\n\n```c\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    \n    int main() {\n    \tint n;\n    \tchar str[200];\n    \tint sum = 0, i = 0;\n    \n    \tscanf(\"%d\", &n);\n    \tscanf(\"%s\", str);\n    \n    \tfor (int i = 0; i < n; i++) {\n    \t\tsum += (str[i] - '0');\n    \t}\n    \t\n    \tprintf(\"%d\", sum);\n    }\n```\n입력받은 문자에서 '0'을 빼주면, 예를들어 123을 입력했을때  \n'1' - '0' = 49 - 48 = 1\n\n'2' - '0' = 50 - 48 = 2\n\n'3' - '0' = 51 - 48 = 3 이 되므로\n각 자리의 합을 쉽게 구할 수 있다!\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1388318610}},"syncHistory":{"main":[1388318610,null,null]},"v":1,"hash":1710111540644,"tx":75},"zwQGgTuOeVYHa8VM/content":{"id":"zwQGgTuOeVYHa8VM/content","type":"content","text":"---\ntitle: \"[백준] 2751번 : 수 정렬하기 2 \"\ndate: 2021-08-10 17:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\nN개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5  \n5  \n4  \n3  \n2  \n1  \n\n## 예제 출력 1\n1  \n2  \n3  \n4  \n5  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n단순 오름차순 정렬문제이지만 N의 범위가 1<=N<=1,000,000 으로 설정되어 있으므로 N을 배열에 넣기에는 너무 크다. 따라서 이중포문을 활용한 단순한 **bubble sort**로는 풀 수 없다. 이는 **Divide and Conquer** 방식을 활용한 **Merge Sort**로 풀어야 한다. **Merge Sort**에 대한 자세한 설명은 추후에 다른 게시물을 통해 업로드 후 링크를 걸어두겠다.\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n// 배열을 합치기 위한 함수\nvoid merge(int* arr, int left, int mid, int right) {\n\n\tint* temp = (int*)malloc(sizeof(int) * (right - left + 1));\n\tint i = left;\n\tint j = mid + 1;\n\tint k = 0;\n\n\twhile (i <= mid && j <= right) {\n\t\tif (arr[i] <= arr[j]) temp[k++] = arr[i++];\n\t\telse temp[k++] = arr[j++];\n\t}\n\n\twhile (i <= mid) temp[k++] = arr[i++];\n\n\twhile (j <= right) temp[k++] = arr[j++];\n\n\ti = left;\n\tk = 0;\n\n\twhile (i <= right) arr[i++] = temp[k++];\n\n\tfree(temp);\n}\n\nvoid mergeSort(int* arr, int left, int right) {\n\tif (left < right) {\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(arr, left, mid);\n\t\tmergeSort(arr, mid + 1, right);\n\t\tmerge(arr, left, mid, right);\n\t}\n}\n\n\nint main() {\n\tint n = 0;\n\tscanf(\"%d\", &n);\n\n\tint* pArr = (int*)malloc(sizeof(int) * n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &pArr[i]);\n\t}\n\n\t// 배열 시작부터 끝까지 mergesort실행\n\tmergeSort(pArr, 0, n - 1);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", pArr[i]);\n\t}\n\n\tfree(pArr);\n\treturn 0;\n}\n```\n\n","properties":"\n","discussions":{},"comments":{},"hash":2108309747,"tx":77},"zwQGgTuOeVYHa8VM/syncedContent":{"id":"zwQGgTuOeVYHa8VM/syncedContent","type":"syncedContent","historyData":{"2108309747":{"id":"zwQGgTuOeVYHa8VM/content","type":"content","text":"---\ntitle: \"[백준] 2751번 : 수 정렬하기 2 \"\ndate: 2021-08-10 17:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\nN개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5  \n5  \n4  \n3  \n2  \n1  \n\n## 예제 출력 1\n1  \n2  \n3  \n4  \n5  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n단순 오름차순 정렬문제이지만 N의 범위가 1<=N<=1,000,000 으로 설정되어 있으므로 N을 배열에 넣기에는 너무 크다. 따라서 이중포문을 활용한 단순한 **bubble sort**로는 풀 수 없다. 이는 **Divide and Conquer** 방식을 활용한 **Merge Sort**로 풀어야 한다. **Merge Sort**에 대한 자세한 설명은 추후에 다른 게시물을 통해 업로드 후 링크를 걸어두겠다.\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n// 배열을 합치기 위한 함수\nvoid merge(int* arr, int left, int mid, int right) {\n\n\tint* temp = (int*)malloc(sizeof(int) * (right - left + 1));\n\tint i = left;\n\tint j = mid + 1;\n\tint k = 0;\n\n\twhile (i <= mid && j <= right) {\n\t\tif (arr[i] <= arr[j]) temp[k++] = arr[i++];\n\t\telse temp[k++] = arr[j++];\n\t}\n\n\twhile (i <= mid) temp[k++] = arr[i++];\n\n\twhile (j <= right) temp[k++] = arr[j++];\n\n\ti = left;\n\tk = 0;\n\n\twhile (i <= right) arr[i++] = temp[k++];\n\n\tfree(temp);\n}\n\nvoid mergeSort(int* arr, int left, int right) {\n\tif (left < right) {\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(arr, left, mid);\n\t\tmergeSort(arr, mid + 1, right);\n\t\tmerge(arr, left, mid, right);\n\t}\n}\n\n\nint main() {\n\tint n = 0;\n\tscanf(\"%d\", &n);\n\n\tint* pArr = (int*)malloc(sizeof(int) * n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &pArr[i]);\n\t}\n\n\t// 배열 시작부터 끝까지 mergesort실행\n\tmergeSort(pArr, 0, n - 1);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", pArr[i]);\n\t}\n\n\tfree(pArr);\n\treturn 0;\n}\n```\n\n","properties":"\n","discussions":{},"comments":{},"hash":2108309747}},"syncHistory":{"main":[2108309747,null,null]},"v":1,"hash":1710111541763,"tx":77},"S7I9qtkAaIcuOTIm/content":{"id":"S7I9qtkAaIcuOTIm/content","type":"content","text":"---\ntitle: \"[백준] [C] 10814번 : 나이순 정렬\"\ndate: 2021-08-19 04:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\n온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)\n\n둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n3  \n21 Junkyu  \n21 Dohyun  \n20 Sunyoung  \n\n## 예제 출력 1\n20 Sunyoung  \n21 Junkyu  \n21 Dohyun  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n**qsort**를 사용하는 간단한 문제이지만 반복적으로 숙달 시키기 위해 풀어본 문제이다.\n**qsort는 진짜 신이다.**\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint age;\n\tchar name[100];\n}info;\n\nint compare(const void* a, const void* b) {\n\tinfo* first = (info*)a;\n\tinfo* second = (info*)b;\n\n\tif (first->age < second->age) return -1;\n\telse if (first->age > second->age) return 1;\n\n\treturn 0;\n}\n\nint main() {\n\tint n = 0;\n\tscanf(\"%d\", &n);\n\n\tinfo* list = (info*)malloc(sizeof(info) * n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &list[i].age, &list[i].name);\n\t}\n\n\tqsort(list, n, sizeof(list[0]), compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %s\\n\", list[i].age, list[i].name);\n\t}\n}\n```\n\n## 꿀팁\n**[ qsort에 사용하는 compare함수 ]**\n오름차순으로 구현하고 싶을 때는 큰 수부터 **1,0,-1**의 값을 반환하도록 해주면 된다.\n내림차순으로 구현하고 싶을 때는 작은 수부터 **-1,0,1**의 값을 반환하도록 해주면 된다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1236696749,"tx":79},"S7I9qtkAaIcuOTIm/syncedContent":{"id":"S7I9qtkAaIcuOTIm/syncedContent","type":"syncedContent","historyData":{"-1236696749":{"id":"S7I9qtkAaIcuOTIm/content","type":"content","text":"---\ntitle: \"[백준] [C] 10814번 : 나이순 정렬\"\ndate: 2021-08-19 04:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\n온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)\n\n둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n3  \n21 Junkyu  \n21 Dohyun  \n20 Sunyoung  \n\n## 예제 출력 1\n20 Sunyoung  \n21 Junkyu  \n21 Dohyun  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n**qsort**를 사용하는 간단한 문제이지만 반복적으로 숙달 시키기 위해 풀어본 문제이다.\n**qsort는 진짜 신이다.**\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint age;\n\tchar name[100];\n}info;\n\nint compare(const void* a, const void* b) {\n\tinfo* first = (info*)a;\n\tinfo* second = (info*)b;\n\n\tif (first->age < second->age) return -1;\n\telse if (first->age > second->age) return 1;\n\n\treturn 0;\n}\n\nint main() {\n\tint n = 0;\n\tscanf(\"%d\", &n);\n\n\tinfo* list = (info*)malloc(sizeof(info) * n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &list[i].age, &list[i].name);\n\t}\n\n\tqsort(list, n, sizeof(list[0]), compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %s\\n\", list[i].age, list[i].name);\n\t}\n}\n```\n\n## 꿀팁\n**[ qsort에 사용하는 compare함수 ]**\n오름차순으로 구현하고 싶을 때는 큰 수부터 **1,0,-1**의 값을 반환하도록 해주면 된다.\n내림차순으로 구현하고 싶을 때는 작은 수부터 **-1,0,1**의 값을 반환하도록 해주면 된다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1236696749}},"syncHistory":{"main":[-1236696749,null,null]},"v":1,"hash":1710111542845,"tx":79},"ysh4WSkm4ITJnEGN/content":{"id":"ysh4WSkm4ITJnEGN/content","type":"content","text":"\n---\n\ntitle: \"[백준] 8958번 : strlen\"\n\ndate: 2021-07-14 00:00:00 -0400\n\ncategories:\n\n- Algorithm\n\ntags:\n\n- 백준\n\n- 알고리즘\n\n- 단계별 풀어보기\n\n---\n\n  \n\n## 문제\n\n  \n\n\"OOXXOXXOOO\"와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.\n\n  \n\n\"OOXXOXXOOO\"의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.\n\n  \n\nOX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.\n\n  \n  \n\n## 입력\n\n  \n\n첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.\n\n  \n\n## 출력\n\n  \n\n각 테스트 케이스마다 점수를 출력한다.\n\n  \n\n## 예제 입력\n\n5\n\nOOXXOXXOOO\n\nOOXXOOXXOO\n\nOXOXOXOXOXOXOX\n\nOOOOOOOOOO\n\nOOOOXOOOOXOOOOX\n\n  \n\n## 예제 출력\n\n  \n\n10\n\n9\n\n7\n\n55\n\n30\n\n  \n\n## 알고리즘 [ 접근방법 ]\n\n테스트 케이스의 개수는 입력받지만 각 문자열의 길이는 주어지지 않은 경우이다.\n\n  \n\n문자열의 길이를 알기위해서는 **strlen함수**를 사용해야만 한다.\n\n  \n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/strlen.png?raw=true)\n\n  \n\n## 풀이\n\n  \n\n```c\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include  <stdio.h>\n\n#include  <string.h>\n\nint  main() {\n\nint test;\n\nchar res[100];\n\nint sum = 0;\n\nint score = 0;\n\nscanf(\"%d\", &test);\n\nfor (int i = 0; i < test; i++) {\n\nsum = 0;\n\nscore = 1;\n\nscanf(\"%s\", &res);\n\nfor (int j = 0; j < strlen(res); j++) {\n\nif (res[j] == 'O') {\n\nsum += score;\n\nscore++;\n\n}\n\nelse score = 1;\n\n}\n\nprintf(\"%d\\n\", sum);\n\n}\n\nreturn 0;\n\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":989794151,"tx":81},"ysh4WSkm4ITJnEGN/syncedContent":{"id":"ysh4WSkm4ITJnEGN/syncedContent","type":"syncedContent","historyData":{"989794151":{"id":"ysh4WSkm4ITJnEGN/content","type":"content","text":"\n---\n\ntitle: \"[백준] 8958번 : strlen\"\n\ndate: 2021-07-14 00:00:00 -0400\n\ncategories:\n\n- Algorithm\n\ntags:\n\n- 백준\n\n- 알고리즘\n\n- 단계별 풀어보기\n\n---\n\n  \n\n## 문제\n\n  \n\n\"OOXXOXXOOO\"와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.\n\n  \n\n\"OOXXOXXOOO\"의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.\n\n  \n\nOX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.\n\n  \n  \n\n## 입력\n\n  \n\n첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.\n\n  \n\n## 출력\n\n  \n\n각 테스트 케이스마다 점수를 출력한다.\n\n  \n\n## 예제 입력\n\n5\n\nOOXXOXXOOO\n\nOOXXOOXXOO\n\nOXOXOXOXOXOXOX\n\nOOOOOOOOOO\n\nOOOOXOOOOXOOOOX\n\n  \n\n## 예제 출력\n\n  \n\n10\n\n9\n\n7\n\n55\n\n30\n\n  \n\n## 알고리즘 [ 접근방법 ]\n\n테스트 케이스의 개수는 입력받지만 각 문자열의 길이는 주어지지 않은 경우이다.\n\n  \n\n문자열의 길이를 알기위해서는 **strlen함수**를 사용해야만 한다.\n\n  \n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/strlen.png?raw=true)\n\n  \n\n## 풀이\n\n  \n\n```c\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include  <stdio.h>\n\n#include  <string.h>\n\nint  main() {\n\nint test;\n\nchar res[100];\n\nint sum = 0;\n\nint score = 0;\n\nscanf(\"%d\", &test);\n\nfor (int i = 0; i < test; i++) {\n\nsum = 0;\n\nscore = 1;\n\nscanf(\"%s\", &res);\n\nfor (int j = 0; j < strlen(res); j++) {\n\nif (res[j] == 'O') {\n\nsum += score;\n\nscore++;\n\n}\n\nelse score = 1;\n\n}\n\nprintf(\"%d\\n\", sum);\n\n}\n\nreturn 0;\n\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":989794151}},"syncHistory":{"main":[989794151,null,null]},"v":1,"hash":1710111544041,"tx":81},"dsPZqXB2XwSOXmhf/content":{"id":"dsPZqXB2XwSOXmhf/content","type":"content","text":"---\ntitle: \"[백준] [C] 11650번 : 좌표 정렬하기\"\ndate: 2021-08-17 22:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\n2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 x<sub>i</sub>와 y<sub>i</sub>가 주어진다. (-100,000 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5\n3 4  \n1 1  \n1 -1  \n2 2  \n3 3  \n\n## 예제 출력 1\n1 -1  \n1 1  \n2 2  \n3 3  \n3 4  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n앞서 포스팅한 문제들을 복합적으로 고려해 풀이를 해야만 하는 문제이다.\n**Bubble Sort**는 너무 효율이 떨어지고 문제에 주어진 시간제한을 맞출 수 없기 때문에 배제하고 **Merge Sort**를 사용 할 수 있는데 **Merge Sort**는 코드가 너무 복잡하고 매번 일일히 구현하기에는 어려움이 있다. 이를 해결 해줄 수 있는 아주 간단한 내장 Sorting 라이브러리를 발견했는데 바로 **qsort** 함수이다. **qsort**를 사용하면 바로 해결되는 문제이므로 따로 풀이는 하지않고 코드에 주석으로 남겨놓겠다.\n\n<br><br><br><br><br><br>\n\n**qsort ( = Quick Sort )** 의 코드 구성이나 작동 원리는 따로 알고리즘 파트에 포스팅을 해놓을 테니 이를 참고하길 바란다.\n해당 링크 : \n\n<br><br><br><br><br><br>\n\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n// x,y 좌표를 표현하기 위한 구조체 설정\ntypedef struct {\n\tint x;\n\tint y;\n}coord;\n\n// qsort 함수를 사용하기위한 비교 함수\nint compare(const void* a, const void* b) {\n\tcoord* num1 = (coord*)a;   // void 포인터를 coord 포인터로 변환한 뒤 역참조하여 값을 가져옴\n\tcoord* num2 = (coord*)b;   // void 포인터를 coord 포인터로 변환한 뒤 역참조하여 값을 가져옴\n\n\tif (num1->x < num2->x) return -1;\n\telse if (num1->x > num2->x) return 1;\n\telse {\n\t\tif (num1->y < num2->y) return -1;\n\t\telse return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint num = 0;\n\tcoord* list;\n\n\tscanf(\"%d\", &num);\n\tlist = (coord*)malloc(sizeof(coord) * num);\n\n\tfor (int i = 0; i < num; i++) {\n\t\tscanf(\"%d %d\", &list[i].x, &list[i].y);\n\t}\n\n\tqsort(list, num, sizeof(list[0]), compare);\n\t\n\n\tfor (int i = 0; i < num; i++) {\n\t\tprintf(\"%d %d\\n\", list[i].x,list[i].y);\n\t}\n\n\treturn 0;\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1858242666,"tx":83},"dsPZqXB2XwSOXmhf/syncedContent":{"id":"dsPZqXB2XwSOXmhf/syncedContent","type":"syncedContent","historyData":{"1858242666":{"id":"dsPZqXB2XwSOXmhf/content","type":"content","text":"---\ntitle: \"[백준] [C] 11650번 : 좌표 정렬하기\"\ndate: 2021-08-17 22:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\n2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 x<sub>i</sub>와 y<sub>i</sub>가 주어진다. (-100,000 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5\n3 4  \n1 1  \n1 -1  \n2 2  \n3 3  \n\n## 예제 출력 1\n1 -1  \n1 1  \n2 2  \n3 3  \n3 4  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n앞서 포스팅한 문제들을 복합적으로 고려해 풀이를 해야만 하는 문제이다.\n**Bubble Sort**는 너무 효율이 떨어지고 문제에 주어진 시간제한을 맞출 수 없기 때문에 배제하고 **Merge Sort**를 사용 할 수 있는데 **Merge Sort**는 코드가 너무 복잡하고 매번 일일히 구현하기에는 어려움이 있다. 이를 해결 해줄 수 있는 아주 간단한 내장 Sorting 라이브러리를 발견했는데 바로 **qsort** 함수이다. **qsort**를 사용하면 바로 해결되는 문제이므로 따로 풀이는 하지않고 코드에 주석으로 남겨놓겠다.\n\n<br><br><br><br><br><br>\n\n**qsort ( = Quick Sort )** 의 코드 구성이나 작동 원리는 따로 알고리즘 파트에 포스팅을 해놓을 테니 이를 참고하길 바란다.\n해당 링크 : \n\n<br><br><br><br><br><br>\n\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n// x,y 좌표를 표현하기 위한 구조체 설정\ntypedef struct {\n\tint x;\n\tint y;\n}coord;\n\n// qsort 함수를 사용하기위한 비교 함수\nint compare(const void* a, const void* b) {\n\tcoord* num1 = (coord*)a;   // void 포인터를 coord 포인터로 변환한 뒤 역참조하여 값을 가져옴\n\tcoord* num2 = (coord*)b;   // void 포인터를 coord 포인터로 변환한 뒤 역참조하여 값을 가져옴\n\n\tif (num1->x < num2->x) return -1;\n\telse if (num1->x > num2->x) return 1;\n\telse {\n\t\tif (num1->y < num2->y) return -1;\n\t\telse return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint num = 0;\n\tcoord* list;\n\n\tscanf(\"%d\", &num);\n\tlist = (coord*)malloc(sizeof(coord) * num);\n\n\tfor (int i = 0; i < num; i++) {\n\t\tscanf(\"%d %d\", &list[i].x, &list[i].y);\n\t}\n\n\tqsort(list, num, sizeof(list[0]), compare);\n\t\n\n\tfor (int i = 0; i < num; i++) {\n\t\tprintf(\"%d %d\\n\", list[i].x,list[i].y);\n\t}\n\n\treturn 0;\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1858242666}},"syncHistory":{"main":[1858242666,null,null]},"v":1,"hash":1710111545043,"tx":83},"Zd6WgSyDwAy0BrDK/content":{"id":"Zd6WgSyDwAy0BrDK/content","type":"content","text":"## 문제\n\n두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n\n\n## 입력\n입력은 여러 개의 테스트 케이스로 이루어져 있다.\n\n각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)\n\n## 출력\n\n각 테스트 케이스마다 A+B를 출력한다.  \n\n## 알고리즘 [ 접근방법 ]\n\n앞서 포스팅한 [백준 10950번](https://idkim97.github.io/algorithm/%EB%B0%B1%EC%A4%8010950%EB%B2%88/) 문제와 동일한 문제지만 **테스트 케이스의 개수가 주어지지 않은 경우**이다.\n\n이때 우리는 **EOF(End Of File)**을 활용해야만 한다.\n\n**EOF**는 C언어에서 파일의 끝을 표현하기 위해 정의해 놓은 상수이며 **-1**의 값을 가진다.\n\n실제 코드에서는 어떻게 활용되는지 살펴보자.\n\n\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    \n    int main() {\n    \tint a, b;\n    \n    \twhile (scanf(\"%d %d\", &a, &b)!=EOF) {\n    \t\t\n    \t\tprintf(\"%d\\n\", a + b);\n    \t}\n    \treturn 0;\n    }\n\n보통 알고리즘 문제를 풀 때 테스트 케이스의 개수가 주어지지 않은 경우 많이 활용되므로 꼭 기억해 두도록 하자!\n","properties":"\n","discussions":{},"comments":{},"hash":-253091378,"tx":85},"Zd6WgSyDwAy0BrDK/syncedContent":{"id":"Zd6WgSyDwAy0BrDK/syncedContent","type":"syncedContent","historyData":{"-253091378":{"id":"Zd6WgSyDwAy0BrDK/content","type":"content","text":"## 문제\n\n두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n\n\n## 입력\n입력은 여러 개의 테스트 케이스로 이루어져 있다.\n\n각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)\n\n## 출력\n\n각 테스트 케이스마다 A+B를 출력한다.  \n\n## 알고리즘 [ 접근방법 ]\n\n앞서 포스팅한 [백준 10950번](https://idkim97.github.io/algorithm/%EB%B0%B1%EC%A4%8010950%EB%B2%88/) 문제와 동일한 문제지만 **테스트 케이스의 개수가 주어지지 않은 경우**이다.\n\n이때 우리는 **EOF(End Of File)**을 활용해야만 한다.\n\n**EOF**는 C언어에서 파일의 끝을 표현하기 위해 정의해 놓은 상수이며 **-1**의 값을 가진다.\n\n실제 코드에서는 어떻게 활용되는지 살펴보자.\n\n\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    \n    int main() {\n    \tint a, b;\n    \n    \twhile (scanf(\"%d %d\", &a, &b)!=EOF) {\n    \t\t\n    \t\tprintf(\"%d\\n\", a + b);\n    \t}\n    \treturn 0;\n    }\n\n보통 알고리즘 문제를 풀 때 테스트 케이스의 개수가 주어지지 않은 경우 많이 활용되므로 꼭 기억해 두도록 하자!\n","properties":"\n","discussions":{},"comments":{},"hash":-253091378}},"syncHistory":{"main":[-253091378,null,null]},"v":1,"hash":1710111546270,"tx":85},"mqHezxUzK3yVL3FH/content":{"id":"mqHezxUzK3yVL3FH/content","type":"content","text":"---\ntitle: \"[백준] [C] 11651번 : 좌표 정렬하기2\"\ndate: 2021-08-19 00:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\n2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 x<sub>i</sub>와 y<sub>i</sub>가 주어진다. (-100,000 ≤ x<sub>i</sub>,y<sub>i</sub> ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5  \n0 4  \n1 2  \n1 -1  \n2 2  \n3 3  \n\n## 예제 출력 1\n1 -1  \n1 2  \n2 2  \n3 3  \n0 4  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n바로 이전 포스팅인 [11650번 : 좌표 정렬하기](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%8011650%EB%B2%88/) 와 거의 동일한 문제로 **qsort**를 사용해주면 되는 간단한 문제이다. 다만 이번 문제는 y를 기준으로 값을 정렬하기 때문에 **qsort** 내장 함수를 사용하기 위한 또다른 함수인 **compare**함수만 약간 수정해주면 된다.\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint x;\n\tint y;\n}coord;\n\nint compare(const void* a, const void* b) {\n\tcoord* num1 = (coord*)a;\n\tcoord* num2 = (coord*)b;\n\n\tif (num1->y < num2->y) return -1;\n\telse if (num1->y > num2->y) return 1;\n\telse {\n\t\tif (num1->x < num2->x) return -1;\n\t\telse return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint n = 0;\n\tcoord* list;\n\n\tscanf(\"%d\", &n);\n\tlist = (coord*)malloc(sizeof(coord) * n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &list[i].x,&list[i].y);\n\t}\n\n\tqsort(list, n, sizeof(list[0]),compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d\\n\", list[i].x, list[i].y);\n\t}\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1611565356,"tx":87},"mqHezxUzK3yVL3FH/syncedContent":{"id":"mqHezxUzK3yVL3FH/syncedContent","type":"syncedContent","historyData":{"-1611565356":{"id":"mqHezxUzK3yVL3FH/content","type":"content","text":"---\ntitle: \"[백준] [C] 11651번 : 좌표 정렬하기2\"\ndate: 2021-08-19 00:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\n2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 x<sub>i</sub>와 y<sub>i</sub>가 주어진다. (-100,000 ≤ x<sub>i</sub>,y<sub>i</sub> ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5  \n0 4  \n1 2  \n1 -1  \n2 2  \n3 3  \n\n## 예제 출력 1\n1 -1  \n1 2  \n2 2  \n3 3  \n0 4  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n바로 이전 포스팅인 [11650번 : 좌표 정렬하기](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%8011650%EB%B2%88/) 와 거의 동일한 문제로 **qsort**를 사용해주면 되는 간단한 문제이다. 다만 이번 문제는 y를 기준으로 값을 정렬하기 때문에 **qsort** 내장 함수를 사용하기 위한 또다른 함수인 **compare**함수만 약간 수정해주면 된다.\n\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint x;\n\tint y;\n}coord;\n\nint compare(const void* a, const void* b) {\n\tcoord* num1 = (coord*)a;\n\tcoord* num2 = (coord*)b;\n\n\tif (num1->y < num2->y) return -1;\n\telse if (num1->y > num2->y) return 1;\n\telse {\n\t\tif (num1->x < num2->x) return -1;\n\t\telse return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint n = 0;\n\tcoord* list;\n\n\tscanf(\"%d\", &n);\n\tlist = (coord*)malloc(sizeof(coord) * n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &list[i].x,&list[i].y);\n\t}\n\n\tqsort(list, n, sizeof(list[0]),compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d\\n\", list[i].x, list[i].y);\n\t}\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1611565356}},"syncHistory":{"main":[-1611565356,null,null]},"v":1,"hash":1710111547435,"tx":87},"YRBZD8HJuJFWJ7Aj/content":{"id":"YRBZD8HJuJFWJ7Aj/content","type":"content","text":"---\ntitle: \"[백준] 11653번 : 소인수분해\"\ndate: 2021-07-29 23:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n\n정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.\n \n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\nN의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n72\n\n  \n\n## 예제 출력 1\n\n2  \n2  \n2  \n3  \n3  \n  \n\n<br><br><br><br><br><br>\n\n\n## 풀이 1 : 가장 단순한 풀이\n\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <math.h>\n\n\nint main() {\n\n\tint n;\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 2; i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tprintf(\"%d\\n\", i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n<br><br><br><br><br><br>\n\n\n## 알고리즘 [ 접근방법 ]\n\nwhile문을 이용한 기본적인 소인수 분해이다.\n\n```c\nwhile (n % i == 0) { // n이 소수일때\n\tn /= i;\n\tprintf(\"%d\\n\", i);\n}\n```\nn이 소수인경우에 실행되게 함으로써 소수로 나누어 떨어질때마다 이를 출력해준다.  그러나 한가지 **처리속도** 면에서 아쉬운 점이 보인다. \n```c\nfor  (int i =  2; i <= n; i++)\n```\nfor문을 2부터 n까지 전부 돌리기 때문에 비효율 적이다. 이를 해결하기 위해 **제곱근**을 활용한 풀이로 다시 풀어보았다.\n\n\n<br><br><br><br><br><br>\n\n\n## 풀이2 : 제곱근을 활용한 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tdouble temp = sqrt(n);\n\n\tfor (int i = 2; i <= temp; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tprintf(\"%d\\n\", i);\n\t\t}\n\t}\n\n\tif (n != 1) printf(\"%d\\n\", n);\n\n\treturn 0;\n}\n```\n\n<br><br><br><br><br><br>\n\n\n## 알고리즘 [ 접근방법 ]\n\n```c\ndouble temp = sqrt(n);\n\nfor (int i = 2; i <= temp; i++){\n```\n\ntemp라는 변수를 하나 설정해 n의 제곱근을 대입해주고 for문을 temp까지만 돌아가도록 설정했다. 제곱근까지만 돌려도 괜찮은 이유는 이전 포스팅인 [[백준] 2581번 : 소수](https://idkim97.github.io/algorithm/%EB%B0%B1%EC%A4%802581%EB%B2%88/)에 설명해놨으므로 이를 참고하길 바란다.\n\n<br><br><br><br><br><br>\n\n그리고! 한가지 **예외처리**를 꼭 해줘야만 하는 부분이 있다. 사실 이부분 때문에 이 문제를 포스팅한다고 봐도 된다. \n```c\nif (n != 1) printf(\"%d\\n\", n);\n```\nn이 1이 아닐때 n을 출력하는 코드인데 이는 제곱근을 사용했기 때문에 넣어줘여만 하는 코드이다. for문이 i=2부터 temp까지 돌아가게 되는데,\n**만약 n이 6이라고 하면 i=2부터 √6(≒2.xx)까지 for문이 돌아가므로 i=2일때 한번만 for문이 돌아가 6의 소수인 3이 포함되지 않는다.** \n이런 경우의 예외처리를 위해 위의 코드를 반드시 넣어줘야 한다.\n","properties":"\n","discussions":{},"comments":{},"hash":890688502,"tx":89},"YRBZD8HJuJFWJ7Aj/syncedContent":{"id":"YRBZD8HJuJFWJ7Aj/syncedContent","type":"syncedContent","historyData":{"890688502":{"id":"YRBZD8HJuJFWJ7Aj/content","type":"content","text":"---\ntitle: \"[백준] 11653번 : 소인수분해\"\ndate: 2021-07-29 23:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n\n정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.\n \n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\nN의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n72\n\n  \n\n## 예제 출력 1\n\n2  \n2  \n2  \n3  \n3  \n  \n\n<br><br><br><br><br><br>\n\n\n## 풀이 1 : 가장 단순한 풀이\n\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <math.h>\n\n\nint main() {\n\n\tint n;\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 2; i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tprintf(\"%d\\n\", i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n<br><br><br><br><br><br>\n\n\n## 알고리즘 [ 접근방법 ]\n\nwhile문을 이용한 기본적인 소인수 분해이다.\n\n```c\nwhile (n % i == 0) { // n이 소수일때\n\tn /= i;\n\tprintf(\"%d\\n\", i);\n}\n```\nn이 소수인경우에 실행되게 함으로써 소수로 나누어 떨어질때마다 이를 출력해준다.  그러나 한가지 **처리속도** 면에서 아쉬운 점이 보인다. \n```c\nfor  (int i =  2; i <= n; i++)\n```\nfor문을 2부터 n까지 전부 돌리기 때문에 비효율 적이다. 이를 해결하기 위해 **제곱근**을 활용한 풀이로 다시 풀어보았다.\n\n\n<br><br><br><br><br><br>\n\n\n## 풀이2 : 제곱근을 활용한 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tdouble temp = sqrt(n);\n\n\tfor (int i = 2; i <= temp; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tprintf(\"%d\\n\", i);\n\t\t}\n\t}\n\n\tif (n != 1) printf(\"%d\\n\", n);\n\n\treturn 0;\n}\n```\n\n<br><br><br><br><br><br>\n\n\n## 알고리즘 [ 접근방법 ]\n\n```c\ndouble temp = sqrt(n);\n\nfor (int i = 2; i <= temp; i++){\n```\n\ntemp라는 변수를 하나 설정해 n의 제곱근을 대입해주고 for문을 temp까지만 돌아가도록 설정했다. 제곱근까지만 돌려도 괜찮은 이유는 이전 포스팅인 [[백준] 2581번 : 소수](https://idkim97.github.io/algorithm/%EB%B0%B1%EC%A4%802581%EB%B2%88/)에 설명해놨으므로 이를 참고하길 바란다.\n\n<br><br><br><br><br><br>\n\n그리고! 한가지 **예외처리**를 꼭 해줘야만 하는 부분이 있다. 사실 이부분 때문에 이 문제를 포스팅한다고 봐도 된다. \n```c\nif (n != 1) printf(\"%d\\n\", n);\n```\nn이 1이 아닐때 n을 출력하는 코드인데 이는 제곱근을 사용했기 때문에 넣어줘여만 하는 코드이다. for문이 i=2부터 temp까지 돌아가게 되는데,\n**만약 n이 6이라고 하면 i=2부터 √6(≒2.xx)까지 for문이 돌아가므로 i=2일때 한번만 for문이 돌아가 6의 소수인 3이 포함되지 않는다.** \n이런 경우의 예외처리를 위해 위의 코드를 반드시 넣어줘야 한다.\n","properties":"\n","discussions":{},"comments":{},"hash":890688502}},"syncHistory":{"main":[890688502,null,null]},"v":1,"hash":1710111548496,"tx":89},"31JAF1na3LcScLsv/content":{"id":"31JAF1na3LcScLsv/content","type":"content","text":"---\ntitle: \"[백준] 3053번 :  택시 기하학 ( 파이 ) \"\ndate: 2021-07-31 18:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/3053.PNG?raw=true)\n\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\t// 파이를 사용하기 위해 정의해줌\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n\n\tint r = 0;\n\tdouble res1 = 0,res2=0;\n\n\tscanf(\"%d\", &r);\n\n\tres1 = pow(r, 2) * M_PI;\t// 파이값\n\tres2 = pow(r, 2) * 2;\n\n\tprintf(\"%lf\\n\", res1);\n\tprintf(\"%lf\\n\", res2);\n\n\treturn 0;\n}\n```\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n굉장히 쉬운 문제이지만 C언어에서 정확한 파이값을 가져오기 위한 정의를 기록하기 위해 포스팅한다. 파이를 사용하기 위해선 두가지 정의가 필요하다.\n\n```c\n#define _USE_MATH_DEFINES   \n#include <math.h>\n```\n\n위의 코드를 순서대로 적어주면 **M_PI**를 사용할 수 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":-2039959105,"tx":91},"31JAF1na3LcScLsv/syncedContent":{"id":"31JAF1na3LcScLsv/syncedContent","type":"syncedContent","historyData":{"-2039959105":{"id":"31JAF1na3LcScLsv/content","type":"content","text":"---\ntitle: \"[백준] 3053번 :  택시 기하학 ( 파이 ) \"\ndate: 2021-07-31 18:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/3053.PNG?raw=true)\n\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\t// 파이를 사용하기 위해 정의해줌\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n\n\tint r = 0;\n\tdouble res1 = 0,res2=0;\n\n\tscanf(\"%d\", &r);\n\n\tres1 = pow(r, 2) * M_PI;\t// 파이값\n\tres2 = pow(r, 2) * 2;\n\n\tprintf(\"%lf\\n\", res1);\n\tprintf(\"%lf\\n\", res2);\n\n\treturn 0;\n}\n```\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n굉장히 쉬운 문제이지만 C언어에서 정확한 파이값을 가져오기 위한 정의를 기록하기 위해 포스팅한다. 파이를 사용하기 위해선 두가지 정의가 필요하다.\n\n```c\n#define _USE_MATH_DEFINES   \n#include <math.h>\n```\n\n위의 코드를 순서대로 적어주면 **M_PI**를 사용할 수 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":-2039959105}},"syncHistory":{"main":[-2039959105,null,null]},"v":1,"hash":1710111549704,"tx":91},"EAHxuW5JgATJ3mo2/content":{"id":"EAHxuW5JgATJ3mo2/content","type":"content","text":"## 문제\n\n두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n\n\n## 입력\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.\n\n각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)\n\n## 출력\n\n각 테스트 케이스마다 A+B를 출력한다.  \n\n## 알고리즘 [ 접근방법 ]\n\n단순하게 값을 두개 입력받아 그 합을 출력하는 문제이다.\n\n다만, 배열을 사용하는데 있어서 **컴파일 오류**가 여러번 발생해 이를 설명해보려고 한다.\n\n![백준 10950번 런타임 에러](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B0%B1%EC%A4%8010950%EB%B2%88.png)\n\n발생한 에러는 **런타임 에러(OutOfBounds)** 이다.\n\n흔히 **Array**를 사용할 때 많이 발생하는 오류인데 선언된 배열의 값을 넘어서까지 값을 입력할 때 발생하는 오류이다.\n\n긴 설명 필요없이 바로 코드를 통해 오류를 살펴보자\n\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    \n    int main() {\n\n\tint n;\n\tint A[5], B[5]; // 배열의 크기가 너무 작음\n\tint res[5] = { 0, }; // 배열의 크기가 너무 작음\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &A[i], &B[i]);\n\t\tres[i] = A[i] + B[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\",res[i]);\n\t}\n\n\n\t\n\treturn 0;\n\n    }\n\n배열을 선언할 때 전부 5개의 값을 가질 수 있도록 선언을 해놨는데 5개 이상의 값을 입력받아야 할 경우에는 **런타임 에러(OutOfBounds)**가 발생 하게 된다.\n\n따라서 이를 예방하기 위해서는 적당히 충분한 정도의 배열의 크기를 설정하는 것이 좋다.\n\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n\n    int main() {\n\n\tint n;\n\tint A[1000], B[1000];\n\tint res[1000] = { 0, };\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &A[i], &B[i]);\n\t\tres[i] = A[i] + B[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\",res[i]);\n\t}\n\n\n\t\n\treturn 0;\n\n    }\n\n<br>\n\n***\n\n**++ 추가풀이**\n배열을 사용하지 않고 **while문**을 사용하면 컴파일 에러를 예방할 수 있다.\n\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    \n    int main() {\n    \tint t;\n    \tscanf(\"%d\", &t);\n    \tint a, b;\n    \twhile (t--) {\n    \t\tscanf(\"%d %d\", &a, &b);\n    \t\tprintf(\"%d\\n\", a + b);\n    \t}\n    \treturn 0;\n    }\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1419097415,"tx":93},"EAHxuW5JgATJ3mo2/syncedContent":{"id":"EAHxuW5JgATJ3mo2/syncedContent","type":"syncedContent","historyData":{"-1419097415":{"id":"EAHxuW5JgATJ3mo2/content","type":"content","text":"## 문제\n\n두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n\n\n## 입력\n\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.\n\n각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)\n\n## 출력\n\n각 테스트 케이스마다 A+B를 출력한다.  \n\n## 알고리즘 [ 접근방법 ]\n\n단순하게 값을 두개 입력받아 그 합을 출력하는 문제이다.\n\n다만, 배열을 사용하는데 있어서 **컴파일 오류**가 여러번 발생해 이를 설명해보려고 한다.\n\n![백준 10950번 런타임 에러](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B0%B1%EC%A4%8010950%EB%B2%88.png)\n\n발생한 에러는 **런타임 에러(OutOfBounds)** 이다.\n\n흔히 **Array**를 사용할 때 많이 발생하는 오류인데 선언된 배열의 값을 넘어서까지 값을 입력할 때 발생하는 오류이다.\n\n긴 설명 필요없이 바로 코드를 통해 오류를 살펴보자\n\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    \n    int main() {\n\n\tint n;\n\tint A[5], B[5]; // 배열의 크기가 너무 작음\n\tint res[5] = { 0, }; // 배열의 크기가 너무 작음\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &A[i], &B[i]);\n\t\tres[i] = A[i] + B[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\",res[i]);\n\t}\n\n\n\t\n\treturn 0;\n\n    }\n\n배열을 선언할 때 전부 5개의 값을 가질 수 있도록 선언을 해놨는데 5개 이상의 값을 입력받아야 할 경우에는 **런타임 에러(OutOfBounds)**가 발생 하게 된다.\n\n따라서 이를 예방하기 위해서는 적당히 충분한 정도의 배열의 크기를 설정하는 것이 좋다.\n\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n\n    int main() {\n\n\tint n;\n\tint A[1000], B[1000];\n\tint res[1000] = { 0, };\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &A[i], &B[i]);\n\t\tres[i] = A[i] + B[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\",res[i]);\n\t}\n\n\n\t\n\treturn 0;\n\n    }\n\n<br>\n\n***\n\n**++ 추가풀이**\n배열을 사용하지 않고 **while문**을 사용하면 컴파일 에러를 예방할 수 있다.\n\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    \n    int main() {\n    \tint t;\n    \tscanf(\"%d\", &t);\n    \tint a, b;\n    \twhile (t--) {\n    \t\tscanf(\"%d %d\", &a, &b);\n    \t\tprintf(\"%d\\n\", a + b);\n    \t}\n    \treturn 0;\n    }\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1419097415}},"syncHistory":{"main":[-1419097415,null,null]},"v":1,"hash":1710111551179,"tx":93},"aae7rBzpuqHuDhqC/content":{"id":"aae7rBzpuqHuDhqC/content","type":"content","text":"---\ntitle: \"[백준] 2798번 : 블랙잭 \"\ndate: 2021-08-03 20:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 브루트 포스\n---\n\n## 문제\n카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.\n\n한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.\n\n김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.\n\n이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.\n\nN장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.\n\n합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n5 21  \n5 6 7 8 9  \n\n## 예제 출력 1\n\n21\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n세장의 카드의 합이 M보다 작으면서 그중 최대값을 찾는 문제이다. 모든 경우의 수를 찾아야하는 **브루트 포스** 문제이다. 내가 처음에 생각했던 풀이 방법은 다음과 같다.\n\n**1. 모든 카드를 오름차순으로 정렬한다.\n2. 정렬된 수를 순서대로 3개씩 더하고 그 결과를 배열에 넣는다.\n3. 그 중 결과가 M보다 작은수를 출력한다.**\n\n맨 처음에는 이렇게 구상을 하고 문제를 풀어갔다. \n```c\n\t// 오름차순 정렬\n\t//for (int i = 0; i < N; i++) {\n\t//\tfor (int j = i + 1; j < N; j++) {\n\t//\t\tif (card[i] < card[j]) {\n\t//\t\t\ttemp = card[j];\n\t//\t\t\tcard[j] = card[i];\n\t//\t\t\tcard[i] = temp;\n\t//\t\t}\n\t//\t}\n\t//}\n```\n실제로 오름차순으로 정렬하는 코드까지 짜서 실행을 해봤지만 오답이였다. 이렇게 문제를 풀면 연속된 수끼리만 계산이 되고 연속되지 않은 수끼리는 연산이 되지 않기 때문이다.\n\n예를들어 N=5, M=21 / 10 &nbsp;8&nbsp; 6 &nbsp;4 &nbsp;2 가 입력되면 실제 답은 10 + 8 + 2 이지만 처음 구상한 방식의 답은 8 + 6 + 4가 나온다.\n\n<br><br><br><br><br><br>\n\n이 때문에 방법을 바꿔서,\n주어진 모든 수에서 3개를 뽑아 이를 더한 결과 중 M보다 작으며 최대인 수를 찾기로 결정했다. 이를 위해선 삼중 for문을 사용해야 했는데 예전부터 삼중 for문은 사용하지 않는게 좋다라고 학교에서 배웠던(?) 기억이 있어서 좀 꺼려졌지만 결과적으로는 삼중for문을 통해 간단하게 풀 수 있었다. \n\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main() {\n\n\tint N = 0, M = 0;\n\tint card[200] = { 0, };\n\tint sum[165000] = { 0, };\n\tint p = 0;\n\tint max = 0;\n\n\tscanf(\"%d %d\", &N, &M);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &card[i]);\n\t}\n\n\tfor (int i = 0; i < N-2; i++) {\n\t\tfor (int j = i+1; j < N-1; j++) {\n\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\tsum[p] = card[i] + card[j] + card[k];\n\t\t\t\tif (max < sum[p] && sum[p] <= M) {\n\t\t\t\t\tmax = sum[p];\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", max);\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":434379459,"tx":95},"aae7rBzpuqHuDhqC/syncedContent":{"id":"aae7rBzpuqHuDhqC/syncedContent","type":"syncedContent","historyData":{"434379459":{"id":"aae7rBzpuqHuDhqC/content","type":"content","text":"---\ntitle: \"[백준] 2798번 : 블랙잭 \"\ndate: 2021-08-03 20:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 브루트 포스\n---\n\n## 문제\n카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.\n\n한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.\n\n김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.\n\n이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.\n\nN장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.\n\n합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n5 21  \n5 6 7 8 9  \n\n## 예제 출력 1\n\n21\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n세장의 카드의 합이 M보다 작으면서 그중 최대값을 찾는 문제이다. 모든 경우의 수를 찾아야하는 **브루트 포스** 문제이다. 내가 처음에 생각했던 풀이 방법은 다음과 같다.\n\n**1. 모든 카드를 오름차순으로 정렬한다.\n2. 정렬된 수를 순서대로 3개씩 더하고 그 결과를 배열에 넣는다.\n3. 그 중 결과가 M보다 작은수를 출력한다.**\n\n맨 처음에는 이렇게 구상을 하고 문제를 풀어갔다. \n```c\n\t// 오름차순 정렬\n\t//for (int i = 0; i < N; i++) {\n\t//\tfor (int j = i + 1; j < N; j++) {\n\t//\t\tif (card[i] < card[j]) {\n\t//\t\t\ttemp = card[j];\n\t//\t\t\tcard[j] = card[i];\n\t//\t\t\tcard[i] = temp;\n\t//\t\t}\n\t//\t}\n\t//}\n```\n실제로 오름차순으로 정렬하는 코드까지 짜서 실행을 해봤지만 오답이였다. 이렇게 문제를 풀면 연속된 수끼리만 계산이 되고 연속되지 않은 수끼리는 연산이 되지 않기 때문이다.\n\n예를들어 N=5, M=21 / 10 &nbsp;8&nbsp; 6 &nbsp;4 &nbsp;2 가 입력되면 실제 답은 10 + 8 + 2 이지만 처음 구상한 방식의 답은 8 + 6 + 4가 나온다.\n\n<br><br><br><br><br><br>\n\n이 때문에 방법을 바꿔서,\n주어진 모든 수에서 3개를 뽑아 이를 더한 결과 중 M보다 작으며 최대인 수를 찾기로 결정했다. 이를 위해선 삼중 for문을 사용해야 했는데 예전부터 삼중 for문은 사용하지 않는게 좋다라고 학교에서 배웠던(?) 기억이 있어서 좀 꺼려졌지만 결과적으로는 삼중for문을 통해 간단하게 풀 수 있었다. \n\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main() {\n\n\tint N = 0, M = 0;\n\tint card[200] = { 0, };\n\tint sum[165000] = { 0, };\n\tint p = 0;\n\tint max = 0;\n\n\tscanf(\"%d %d\", &N, &M);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &card[i]);\n\t}\n\n\tfor (int i = 0; i < N-2; i++) {\n\t\tfor (int j = i+1; j < N-1; j++) {\n\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\tsum[p] = card[i] + card[j] + card[k];\n\t\t\t\tif (max < sum[p] && sum[p] <= M) {\n\t\t\t\t\tmax = sum[p];\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", max);\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":434379459}},"syncHistory":{"main":[434379459,null,null]},"v":1,"hash":1710111552397,"tx":95},"nfsPiciyqnl9eDk3/content":{"id":"nfsPiciyqnl9eDk3/content","type":"content","text":"---\ntitle: \"[백준] [C] 10989번 : 수 정렬하기 3 \"\ndate: 2021-08-13 06:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\nN개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n10  \n5  \n2  \n3  \n1  \n4  \n2  \n3  \n5  \n1  \n7  \n\n## 예제 출력 1\n1  \n1  \n2  \n2  \n3  \n3  \n4  \n5  \n5  \n7  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n앞선 포스팅 [수 정렬하기 2](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%802751%EB%B2%88/) 와 동일한 문제이지만 문제 조건이 조금 다른 문제이다. **메모리 제한이 8MB**로 현저히 적기 때문에 **Bubble Sort**나 **Merge Sort**를 사용하게 되면 **메모리 초과**로 오답이라고 나온다. 그러나 이번 문제는 입력받는 수가 10,000보다 작거나 같은 자연수라는 새로운 조건이 있으므로 **counting** 방식을 사용해 풀 수 있다.\n\n<br><br><br><br><br><br>\n\n먼저 수를 입력 받고 입력받은 수에 해당하는 인덱스에 +1을 해준다.\n```c\nfor (int i = 0; i < n; i++) {\n\t\tint temp = 0;\n\t\tscanf(\"%d\", &temp);\n\t\tcount[temp]++;\n\t}\n```\n예를들어 5를 입력받으면 count[5]++가 되어,\ncount={0,0,0,0,1,0,0,0...}와 같은 구조가 되는것이다.\n\n<br><br><br><br><br><br>\n\n이어서 for문을 이용해 이를 출력해주면 된다! 단 같은수가 여러번 입력 받은 경우를 처리해주기 위해 이중for문을 사용해야한다.\n```c\nfor (int i = 0; i < 10001; i++) {\n\t\tfor (int j = 0; j < count[i]; j++) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t}\n\t}\n```\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main() {\n\tint n = 0;\n\tint count[10001] = { 0, };\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint temp = 0;\n\t\tscanf(\"%d\", &temp);\n\t\tcount[temp]++;\n\t}\n\n\tfor (int i = 0; i < 10001; i++) {\n\t\tfor (int j = 0; j < count[i]; j++) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t}\n\t}\n}\n\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1994882972,"tx":97},"nfsPiciyqnl9eDk3/syncedContent":{"id":"nfsPiciyqnl9eDk3/syncedContent","type":"syncedContent","historyData":{"-1994882972":{"id":"nfsPiciyqnl9eDk3/content","type":"content","text":"---\ntitle: \"[백준] [C] 10989번 : 수 정렬하기 3 \"\ndate: 2021-08-13 06:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n- 정렬\n---\n\n## 문제\n\nN개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n10  \n5  \n2  \n3  \n1  \n4  \n2  \n3  \n5  \n1  \n7  \n\n## 예제 출력 1\n1  \n1  \n2  \n2  \n3  \n3  \n4  \n5  \n5  \n7  \n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n앞선 포스팅 [수 정렬하기 2](https://idkim97.github.io/%EB%B0%B1%EC%A4%80/%EB%B0%B1%EC%A4%802751%EB%B2%88/) 와 동일한 문제이지만 문제 조건이 조금 다른 문제이다. **메모리 제한이 8MB**로 현저히 적기 때문에 **Bubble Sort**나 **Merge Sort**를 사용하게 되면 **메모리 초과**로 오답이라고 나온다. 그러나 이번 문제는 입력받는 수가 10,000보다 작거나 같은 자연수라는 새로운 조건이 있으므로 **counting** 방식을 사용해 풀 수 있다.\n\n<br><br><br><br><br><br>\n\n먼저 수를 입력 받고 입력받은 수에 해당하는 인덱스에 +1을 해준다.\n```c\nfor (int i = 0; i < n; i++) {\n\t\tint temp = 0;\n\t\tscanf(\"%d\", &temp);\n\t\tcount[temp]++;\n\t}\n```\n예를들어 5를 입력받으면 count[5]++가 되어,\ncount={0,0,0,0,1,0,0,0...}와 같은 구조가 되는것이다.\n\n<br><br><br><br><br><br>\n\n이어서 for문을 이용해 이를 출력해주면 된다! 단 같은수가 여러번 입력 받은 경우를 처리해주기 위해 이중for문을 사용해야한다.\n```c\nfor (int i = 0; i < 10001; i++) {\n\t\tfor (int j = 0; j < count[i]; j++) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t}\n\t}\n```\n<br><br><br><br><br><br>\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main() {\n\tint n = 0;\n\tint count[10001] = { 0, };\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint temp = 0;\n\t\tscanf(\"%d\", &temp);\n\t\tcount[temp]++;\n\t}\n\n\tfor (int i = 0; i < 10001; i++) {\n\t\tfor (int j = 0; j < count[i]; j++) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t}\n\t}\n}\n\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1994882972}},"syncHistory":{"main":[-1994882972,null,null]},"v":1,"hash":1710111553657,"tx":97},"CP6FQYPqjeJhYtSB/content":{"id":"CP6FQYPqjeJhYtSB/content","type":"content","text":"---\ntitle: \"[백준] 2447번 : 별 찍기 -10 \"\ndate: 2021-08-01 20:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n\n재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.\n\n크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.\n\nN이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k < 8이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄부터 N번째 줄까지 별을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n27\n  \n\n## 예제 출력 1\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B3%84.png?raw=true)\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n결론부터 말하면 내힘으로는 못풀었다. 재귀함수를 어떻게 활용해야 할지 감은 잡았지만 디테일한 부분을 생각해내지 못했다.. 처음에는 이중 for문을 활용해 3x3형태의 별을 출력한 뒤 가운데 구멍을 뚫고 for문에서 재귀함수를 활용해보려고 했는데 가운데 구멍을 뚫는 부분에 어떤 코드가 들어가야 할지 감이 안잡혔다.\n\n그래서 구글링을 통해 가장 쉽고 간결하게 짜인 코드를 찾아봤는데 솔직히 아직도 잘 이해가 안간다.. 학교에서 알고리즘을 배울 때도 재귀함수는 진짜 이해가 안갔는데 역시나 어렵다..\n\n자료를 찾아보니 재귀 + 분할정복(Divide and Conquer) 문제라고 하는데 좀더 알고리즘 공부를 한뒤 다시 풀어봐야 할 것 같다.\n\n출처 : https://cryptosalamander.tistory.com/38\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n\nvoid star(int i, int j, int test) {\n\n\tif ((i / test) % 3 == 1 && (j / test) % 3 == 1) printf(\" \");\n\telse {\n\t\tif (test / 3 == 0) printf(\"*\");\n\t\telse star(i, j, test / 3);\n\t}\n}\n\n\n\nint main() {\n\tint num = 0;\n\n\tscanf(\"%d\", &num);\n\n\tfor (int i = 0; i < num; i++) {\n\t\tfor (int j = 0; j < num; j++) {\n\t\t\tstar(i, j, num);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":985038043,"tx":99},"CP6FQYPqjeJhYtSB/syncedContent":{"id":"CP6FQYPqjeJhYtSB/syncedContent","type":"syncedContent","historyData":{"985038043":{"id":"CP6FQYPqjeJhYtSB/content","type":"content","text":"---\ntitle: \"[백준] 2447번 : 별 찍기 -10 \"\ndate: 2021-08-01 20:00:00\ncategories:\n- Algorithm\ntags:\n- 백준\n- 알고리즘\n- 단계별 풀어보기\n---\n\n## 문제\n\n재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.\n\n크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.\n\nN이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k < 8이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄부터 N번째 줄까지 별을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n\n27\n  \n\n## 예제 출력 1\n\n![enter image description here](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EB%B3%84.png?raw=true)\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n\n결론부터 말하면 내힘으로는 못풀었다. 재귀함수를 어떻게 활용해야 할지 감은 잡았지만 디테일한 부분을 생각해내지 못했다.. 처음에는 이중 for문을 활용해 3x3형태의 별을 출력한 뒤 가운데 구멍을 뚫고 for문에서 재귀함수를 활용해보려고 했는데 가운데 구멍을 뚫는 부분에 어떤 코드가 들어가야 할지 감이 안잡혔다.\n\n그래서 구글링을 통해 가장 쉽고 간결하게 짜인 코드를 찾아봤는데 솔직히 아직도 잘 이해가 안간다.. 학교에서 알고리즘을 배울 때도 재귀함수는 진짜 이해가 안갔는데 역시나 어렵다..\n\n자료를 찾아보니 재귀 + 분할정복(Divide and Conquer) 문제라고 하는데 좀더 알고리즘 공부를 한뒤 다시 풀어봐야 할 것 같다.\n\n출처 : https://cryptosalamander.tistory.com/38\n\n## 풀이\n```c\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n\nvoid star(int i, int j, int test) {\n\n\tif ((i / test) % 3 == 1 && (j / test) % 3 == 1) printf(\" \");\n\telse {\n\t\tif (test / 3 == 0) printf(\"*\");\n\t\telse star(i, j, test / 3);\n\t}\n}\n\n\n\nint main() {\n\tint num = 0;\n\n\tscanf(\"%d\", &num);\n\n\tfor (int i = 0; i < num; i++) {\n\t\tfor (int j = 0; j < num; j++) {\n\t\t\tstar(i, j, num);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":985038043}},"syncHistory":{"main":[985038043,null,null]},"v":1,"hash":1710111555012,"tx":99},"XB8qeLyuDIPE5NtZ/content":{"id":"XB8qeLyuDIPE5NtZ/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 9012번 : 괄호\"\ndate: 2021-09-01 23:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 자료구조\n---\n\n## 문제\n\n괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “( ( ) ) ( )”와 “( ( ( ) ) )” 는 VPS 이지만 “( ( ) (”, “( ( ) ) ( ) ) )” , 그리고 “( ( )” 는 모두 VPS 가 아닌 문자열이다.\n\n여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n6  \n( ( ) ) ( ) )    \n( ( ( ( ) ( ) ) ( )  \n( ( ) ( ) ) ( ( ( ) ) )  \n( ( ( ) ( ) ( ( ) ) ) ( ( ( ( ) ) ) ) ( )  \n( ) ( ) ( ) ( ) ( ( ) ( ) ( ) ) ( )  \n( ( ) ( ( ( ) ) ( ) (  \n\n## 예제 출력 1\nNO  \nNO  \nYES  \nNO  \nYES  \nNO  \n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\nusing std::cout;\nusing std::endl;\n\nint main() {\n\tint num = 0;\n\tcin >> num;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tstack <char> st;\n\t\tstring str;\n\t\tcin >> str;\n\t\tint len = (int)str.length(); // 문자열의 길이 저장\n\n\t\tfor (int j = 0; j < len; j++) {\n\t\t\tif (st.empty() || str[j] == '(') st.push(str[j]);\n\t\t\telse if (st.top() == '(') st.pop();\n\t\t}\n\t\tif (st.empty()) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}\n```\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n**문자열**과 **Stack**을 활용하는 문제이다.\n문자열을 입력받고 '('와 일치하는 경우 **push**\n그렇지 않고 ')'인 경우 **pop**을 해주면 된다.\n\n최종적으로 **stack**이 비어있는 경우 YES를\n아닌경우 NO를 출력해주면 된다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1534283329,"tx":101},"XB8qeLyuDIPE5NtZ/syncedContent":{"id":"XB8qeLyuDIPE5NtZ/syncedContent","type":"syncedContent","historyData":{"-1534283329":{"id":"XB8qeLyuDIPE5NtZ/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 9012번 : 괄호\"\ndate: 2021-09-01 23:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 자료구조\n---\n\n## 문제\n\n괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “( ( ) ) ( )”와 “( ( ( ) ) )” 는 VPS 이지만 “( ( ) (”, “( ( ) ) ( ) ) )” , 그리고 “( ( )” 는 모두 VPS 가 아닌 문자열이다.\n\n여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n6  \n( ( ) ) ( ) )    \n( ( ( ( ) ( ) ) ( )  \n( ( ) ( ) ) ( ( ( ) ) )  \n( ( ( ) ( ) ( ( ) ) ) ( ( ( ( ) ) ) ) ( )  \n( ) ( ) ( ) ( ) ( ( ) ( ) ( ) ) ( )  \n( ( ) ( ( ( ) ) ( ) (  \n\n## 예제 출력 1\nNO  \nNO  \nYES  \nNO  \nYES  \nNO  \n\n<br><br><br><br><br><br>\n\n## 풀이\n```c++\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\nusing std::cout;\nusing std::endl;\n\nint main() {\n\tint num = 0;\n\tcin >> num;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tstack <char> st;\n\t\tstring str;\n\t\tcin >> str;\n\t\tint len = (int)str.length(); // 문자열의 길이 저장\n\n\t\tfor (int j = 0; j < len; j++) {\n\t\t\tif (st.empty() || str[j] == '(') st.push(str[j]);\n\t\t\telse if (st.top() == '(') st.pop();\n\t\t}\n\t\tif (st.empty()) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}\n```\n\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근방법 ]\n**문자열**과 **Stack**을 활용하는 문제이다.\n문자열을 입력받고 '('와 일치하는 경우 **push**\n그렇지 않고 ')'인 경우 **pop**을 해주면 된다.\n\n최종적으로 **stack**이 비어있는 경우 YES를\n아닌경우 NO를 출력해주면 된다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1534283329}},"syncHistory":{"main":[-1534283329,null,null]},"v":1,"hash":1710111556070,"tx":101},"mnof4lJop1YAYqO6/content":{"id":"mnof4lJop1YAYqO6/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 14500번 : 테트로미노\"\ndate: 2022-01-21 01:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 브루트 포스\n---\n\n## 문제\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/14500.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)\n\n둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5 5  \n1 2 3 4 5  \n5 4 3 2 1  \n2 3 4 5 6  \n6 5 4 3 2  \n1 2 1 2 1  \n\n## 예제 출력 1\n19\n\n## 예제 입력 2\n4 5  \n1 2 3 4 5  \n1 2 3 4 5  \n1 2 3 4 5  \n1 2 3 4 5  \n\n## 예제 출력 2\n20\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n아주아주 성가신 브루트 포스 문제이다.\n\n놓을 수 있는 테트리스 도형의 종류는 5가지이고 회전이나 대칭이 가능하다 했으므로 총 가능한 테트리스 도형은 19종류이다.\n\n이때 N(세로크기)<=4이고 M(가로크기)<=500 이므로 테트리스를 놓을수 있는 공간은 총 4x500=2000개가 된다.\n\n대충 테트리스 종류 19가지 x 놓을수 있는 공간 2000 만 해도 큰 수가 아니므로 모든 경우의 수를 다 해보는 브루트 포스 문제라는 것을 유추할 수 있다.\n\n이제 남은건 단순 구현이다.\n\n가능한 19가지 경우를 전부 for문에 넣어주면 된다.\n\n## 풀이\n\n```c++\n#include <iostream>\n\n\nusing namespace std;\nint tet[501][501];\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint n;\n\tint m;\n\n\tcin >> n;\n\tcin >> m;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tcin >> tet[i][j];\n\t\t}\n\t}\n\tint max = 0;\n\tint temp = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (j <= m - 3) { // ㅡㅡㅡㅡ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i][j + 2] + tet[i][j + 3];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 3) { // 일자\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 2][j] + tet[i + 3][j];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 1) { // ㅁ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i + 1][j] + tet[i + 1][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // └\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 2][j] + tet[i + 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\n\t\t\tif (i <= n - 1 && j <= m - 2) { // ┌\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i][j + 2] + tet[i + 1][j];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // ┐\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i + 1][j + 1] + tet[i + 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 2 && j <= m - 2) { // ┘\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i][j + 2] + tet[i - 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 3 && j <= m - 1) { // ┘\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i - 1][j + 1] + tet[i - 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 2) { // ┐\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i][j + 2] + tet[i + 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // ┌\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 2][j] + tet[i][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 2) { // ㄴ\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 1][j + 1] + tet[i + 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // └┐\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 1][j + 1] + tet[i + 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 2 && j <= m - 1) { // \n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i - 1][j + 1] + tet[i - 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 3 && j <= m - 1) { // ┌┘\n\t\t\t\ttemp = tet[i][j] + tet[i - 1][j] + tet[i - 1][j + 1] + tet[i - 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 1) { // ㄱㄴ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i + 1][j + 1] + tet[i + 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 2 && j <= m - 1) { // ㅗ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i - 1][j + 1] + tet[i][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // ㅏ\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 1][j + 1] + tet[i + 2][j];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 2) { // ㅜ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i + 1][j + 1] + tet[i][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 2 && i <= n - 1 && j <= m - 1) { // ㅓ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i - 1][j + 1] + tet[i + 1][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << max << endl;\n\n}\n```\n\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1875244452,"tx":103},"mnof4lJop1YAYqO6/syncedContent":{"id":"mnof4lJop1YAYqO6/syncedContent","type":"syncedContent","historyData":{"1875244452":{"id":"mnof4lJop1YAYqO6/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 14500번 : 테트로미노\"\ndate: 2022-01-21 01:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 브루트 포스\n---\n\n## 문제\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/14500.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)\n\n둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n\n첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5 5  \n1 2 3 4 5  \n5 4 3 2 1  \n2 3 4 5 6  \n6 5 4 3 2  \n1 2 1 2 1  \n\n## 예제 출력 1\n19\n\n## 예제 입력 2\n4 5  \n1 2 3 4 5  \n1 2 3 4 5  \n1 2 3 4 5  \n1 2 3 4 5  \n\n## 예제 출력 2\n20\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n아주아주 성가신 브루트 포스 문제이다.\n\n놓을 수 있는 테트리스 도형의 종류는 5가지이고 회전이나 대칭이 가능하다 했으므로 총 가능한 테트리스 도형은 19종류이다.\n\n이때 N(세로크기)<=4이고 M(가로크기)<=500 이므로 테트리스를 놓을수 있는 공간은 총 4x500=2000개가 된다.\n\n대충 테트리스 종류 19가지 x 놓을수 있는 공간 2000 만 해도 큰 수가 아니므로 모든 경우의 수를 다 해보는 브루트 포스 문제라는 것을 유추할 수 있다.\n\n이제 남은건 단순 구현이다.\n\n가능한 19가지 경우를 전부 for문에 넣어주면 된다.\n\n## 풀이\n\n```c++\n#include <iostream>\n\n\nusing namespace std;\nint tet[501][501];\n\nint main() {\n\t// cin의 연산시간을 scanf만큼 줄여주기 위한 코드 2줄\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint n;\n\tint m;\n\n\tcin >> n;\n\tcin >> m;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tcin >> tet[i][j];\n\t\t}\n\t}\n\tint max = 0;\n\tint temp = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (j <= m - 3) { // ㅡㅡㅡㅡ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i][j + 2] + tet[i][j + 3];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 3) { // 일자\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 2][j] + tet[i + 3][j];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 1) { // ㅁ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i + 1][j] + tet[i + 1][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // └\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 2][j] + tet[i + 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\n\t\t\tif (i <= n - 1 && j <= m - 2) { // ┌\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i][j + 2] + tet[i + 1][j];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // ┐\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i + 1][j + 1] + tet[i + 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 2 && j <= m - 2) { // ┘\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i][j + 2] + tet[i - 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 3 && j <= m - 1) { // ┘\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i - 1][j + 1] + tet[i - 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 2) { // ┐\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i][j + 2] + tet[i + 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // ┌\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 2][j] + tet[i][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 2) { // ㄴ\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 1][j + 1] + tet[i + 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // └┐\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 1][j + 1] + tet[i + 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 2 && j <= m - 1) { // \n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i - 1][j + 1] + tet[i - 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 3 && j <= m - 1) { // ┌┘\n\t\t\t\ttemp = tet[i][j] + tet[i - 1][j] + tet[i - 1][j + 1] + tet[i - 2][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 1) { // ㄱㄴ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i + 1][j + 1] + tet[i + 1][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 2 && j <= m - 1) { // ㅗ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i - 1][j + 1] + tet[i][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 2 && j <= m - 1) { // ㅏ\n\t\t\t\ttemp = tet[i][j] + tet[i + 1][j] + tet[i + 1][j + 1] + tet[i + 2][j];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i <= n - 1 && j <= m - 2) { // ㅜ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i + 1][j + 1] + tet[i][j + 2];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t\tif (i >= 2 && i <= n - 1 && j <= m - 1) { // ㅓ\n\t\t\t\ttemp = tet[i][j] + tet[i][j + 1] + tet[i - 1][j + 1] + tet[i + 1][j + 1];\n\t\t\t\tif (max < temp) max = temp;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << max << endl;\n\n}\n```\n\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1875244452}},"syncHistory":{"main":[1875244452,null,null]},"v":1,"hash":1710111557483,"tx":103},"27FCLunQqiKehP51/content":{"id":"27FCLunQqiKehP51/content","type":"content","text":"---\ntitle: \"[자료구조] 그래프(DFS,BFS) \"\ndate: 2022-02-19 02:00:00\ncategories:\n- 자료구조\ntags:\n- 알고리즘\n- 자료구조\n- 그래프\n---\n\n# 그래프\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph.png?raw=true\">\n</p>\n\n\n - **그래프**는 자료구조의 일종이다.\n -  **정점** ( Node, Vertex ) 과 **간선**(Edge)으로 이루어져 있다.\n -  **G=(V,E)**로 나타낸다.\n -  **차수**는 정점과 연결되어 있는 간선의 개수를 의미한다.\n\n<br><br><br><br><br><br>\n\n# 그래프의 표현\n<hr>\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph1.jpg?raw=true\">\n</p>\n\n- 위와같은 그래프는 정점이 6개, 간선이 8개있다.\n- 정점 : { 1, 2, 3, 4, 5, 6 }\n- 간선 : { (1,2), (1,5), (2,3), (2,4), (2,5), (3,4), (4,5), (4,6) }\n\n<br><br><br>\n\n## 인접행렬\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph2.jpg?raw=true\">\n</p>\n\n- 인접행렬은 정점의 개수를 V라고 했을 때, V x V 크기의 2차원 배열을 사용한다.\n- A[i][j] = 1 ( i->j 간선이 있을때 ), 0 (없을때) \n- 2차원 배열로 나타낸 A[i][j]\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph6.jpg?raw=true\">\n</p>\n\n<br><br><br>\n\n## 인접 리스트\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph2.jpg?raw=true\">\n</p>\n\n- 리스트를 이용해서 구현한다. \n- A[i] = i와 연결된 정점을 리스트로 포함하고 있다.\n- 리스트는 크기를 동적으로 변경할 수 있어야 한다.\n- 링크드 리스트나 길이를 동적으로 변경할 수 있는 배열을 사용한다.\n- C++에서는 vector를 사용하면 된다.\n- 예시\nA[1] &nbsp;2&nbsp; 5  \nA[2] &nbsp;1&nbsp; 3&nbsp; 4&nbsp; 5  \nA[3] &nbsp;2&nbsp; 4  \nA[4] &nbsp;3&nbsp; 5&nbsp; 2&nbsp; 6  \nA[5] &nbsp;1&nbsp; 2&nbsp; 4  \nA[6] &nbsp;4   \n\n<br><br><br>\n\n## 간선 리스트\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph4.jpg?raw=true\">\n</p>\n\n- 간선을 모두 저장하고 있는 배열\n- 각 간선의 앞 정점을 기준으로 개수를 센다\n- 예시\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph5.jpg?raw=true\">\n</p>\n","properties":"\n","discussions":{},"comments":{},"hash":-1860652716,"tx":105},"27FCLunQqiKehP51/syncedContent":{"id":"27FCLunQqiKehP51/syncedContent","type":"syncedContent","historyData":{"-1860652716":{"id":"27FCLunQqiKehP51/content","type":"content","text":"---\ntitle: \"[자료구조] 그래프(DFS,BFS) \"\ndate: 2022-02-19 02:00:00\ncategories:\n- 자료구조\ntags:\n- 알고리즘\n- 자료구조\n- 그래프\n---\n\n# 그래프\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph.png?raw=true\">\n</p>\n\n\n - **그래프**는 자료구조의 일종이다.\n -  **정점** ( Node, Vertex ) 과 **간선**(Edge)으로 이루어져 있다.\n -  **G=(V,E)**로 나타낸다.\n -  **차수**는 정점과 연결되어 있는 간선의 개수를 의미한다.\n\n<br><br><br><br><br><br>\n\n# 그래프의 표현\n<hr>\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph1.jpg?raw=true\">\n</p>\n\n- 위와같은 그래프는 정점이 6개, 간선이 8개있다.\n- 정점 : { 1, 2, 3, 4, 5, 6 }\n- 간선 : { (1,2), (1,5), (2,3), (2,4), (2,5), (3,4), (4,5), (4,6) }\n\n<br><br><br>\n\n## 인접행렬\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph2.jpg?raw=true\">\n</p>\n\n- 인접행렬은 정점의 개수를 V라고 했을 때, V x V 크기의 2차원 배열을 사용한다.\n- A[i][j] = 1 ( i->j 간선이 있을때 ), 0 (없을때) \n- 2차원 배열로 나타낸 A[i][j]\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph6.jpg?raw=true\">\n</p>\n\n<br><br><br>\n\n## 인접 리스트\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph2.jpg?raw=true\">\n</p>\n\n- 리스트를 이용해서 구현한다. \n- A[i] = i와 연결된 정점을 리스트로 포함하고 있다.\n- 리스트는 크기를 동적으로 변경할 수 있어야 한다.\n- 링크드 리스트나 길이를 동적으로 변경할 수 있는 배열을 사용한다.\n- C++에서는 vector를 사용하면 된다.\n- 예시\nA[1] &nbsp;2&nbsp; 5  \nA[2] &nbsp;1&nbsp; 3&nbsp; 4&nbsp; 5  \nA[3] &nbsp;2&nbsp; 4  \nA[4] &nbsp;3&nbsp; 5&nbsp; 2&nbsp; 6  \nA[5] &nbsp;1&nbsp; 2&nbsp; 4  \nA[6] &nbsp;4   \n\n<br><br><br>\n\n## 간선 리스트\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph4.jpg?raw=true\">\n</p>\n\n- 간선을 모두 저장하고 있는 배열\n- 각 간선의 앞 정점을 기준으로 개수를 센다\n- 예시\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/graph5.jpg?raw=true\">\n</p>\n","properties":"\n","discussions":{},"comments":{},"hash":-1860652716}},"syncHistory":{"main":[-1860652716,null,null]},"v":1,"hash":1710111558641,"tx":105},"31ixuwejQY1ahmSf/content":{"id":"31ixuwejQY1ahmSf/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 13023번 :  ABCDE \"\ndate: 2022-02-20 22:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 그래프\n---\n\n## 문제\n\n\nBOJ 알고리즘 캠프에는 총 N명이 참가하고 있다. 사람들은 0번부터 N-1번으로 번호가 매겨져 있고, 일부 사람들은 친구이다.\n\n오늘은 다음과 같은 친구 관계를 가진 사람 A, B, C, D, E가 존재하는지 구해보려고 한다.\n\n-   A는 B와 친구다.\n-   B는 C와 친구다.\n-   C는 D와 친구다.\n-   D는 E와 친구다.\n\n위와 같은 친구 관계가 존재하는지 안하는지 구하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 사람의 수 N (5 ≤ N ≤ 2000)과 친구 관계의 수 M (1 ≤ M ≤ 2000)이 주어진다.\n\n둘째 줄부터 M개의 줄에는 정수 a와 b가 주어지며, a와 b가 친구라는 뜻이다. (0 ≤ a, b ≤ N-1, a ≠ b) 같은 친구 관계가 두 번 이상 주어지는 경우는 없다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n문제의 조건에 맞는 A, B, C, D, E가 존재하면 1을 없으면 0을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5 4  \n0 1  \n1 2  \n2 3  \n3 4  \n\n## 예제 출력 1\n1\n\n## 예제 입력 2\n8 8  \n1 7  \n3 7  \n4 7  \n3 4  \n4 6  \n3 5  \n0 4  \n2 7  \n\n## 예제 출력 2\n1\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n그래프를 이용해 풀 수 있는 기본적인 문제이다. DFS방식으로도 풀이 할 수 있지만 그래프 구현을 연습해보기 위한 문제풀이를 해보았다.\n\n인접행렬, 인접리스트, 간선리스트 모두를 활용한 문제풀이를 살펴보자.\n\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool a[2000][2000]; // 인접행렬\nvector <int> g[2000]; // 인접리스트\nvector <pair<int, int>> edges;  // 간선리스트\n\n\nint main() {\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tcin >> from >> to;\n\n\t\tedges.push_back({ from, to }); // 간선리스트 만들기 ... etc) edges[0] = 0 1  , edges[1] = 1 2\n\t\tedges.push_back({ to, from }); // 간선리스트 만들기\n\n\t\ta[from][to] = a[to][from] = true; // 인접행렬 만들기 ... etc) 연결되어있으면 1 아니면 0\n\n\t\tg[from].push_back(to); // 인접리스트 만들기 ... etc) g[0] 1  , g[1] 0 2 \n\t\tg[to].push_back(from); // 인접리스트 만들기\n\t}\n\n\tm *= 2;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\n\t\t\t// A->B\n\t\t\tint A = edges[i].first;\n\t\t\tint B = edges[i].second;\n\n\t\t\t// C->D\n\t\t\tint C = edges[j].first;\n\t\t\tint D = edges[j].second;\n\n\t\t\tif (A == B || B == C || C == D || A == C || A == D || B == D) continue;\n\n\t\t\t// B->C\n\t\t\tif (!a[B][C]) continue;\n\n\t\t\tfor (int E : g[D]) {\n\t\t\t\tif (A == E || B == E || C == E || D == E) continue;\n\t\t\t\tcout << 1 << \"\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << 0 << endl;\n\treturn 0;\n\n}\n\n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-2006659413,"tx":107},"31ixuwejQY1ahmSf/syncedContent":{"id":"31ixuwejQY1ahmSf/syncedContent","type":"syncedContent","historyData":{"-2006659413":{"id":"31ixuwejQY1ahmSf/content","type":"content","text":"---\ntitle: \"[백준] [C/C++] 13023번 :  ABCDE \"\ndate: 2022-02-20 22:00:00\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 그래프\n---\n\n## 문제\n\n\nBOJ 알고리즘 캠프에는 총 N명이 참가하고 있다. 사람들은 0번부터 N-1번으로 번호가 매겨져 있고, 일부 사람들은 친구이다.\n\n오늘은 다음과 같은 친구 관계를 가진 사람 A, B, C, D, E가 존재하는지 구해보려고 한다.\n\n-   A는 B와 친구다.\n-   B는 C와 친구다.\n-   C는 D와 친구다.\n-   D는 E와 친구다.\n\n위와 같은 친구 관계가 존재하는지 안하는지 구하는 프로그램을 작성하시오.\n\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n첫째 줄에 사람의 수 N (5 ≤ N ≤ 2000)과 친구 관계의 수 M (1 ≤ M ≤ 2000)이 주어진다.\n\n둘째 줄부터 M개의 줄에는 정수 a와 b가 주어지며, a와 b가 친구라는 뜻이다. (0 ≤ a, b ≤ N-1, a ≠ b) 같은 친구 관계가 두 번 이상 주어지는 경우는 없다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n문제의 조건에 맞는 A, B, C, D, E가 존재하면 1을 없으면 0을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n5 4  \n0 1  \n1 2  \n2 3  \n3 4  \n\n## 예제 출력 1\n1\n\n## 예제 입력 2\n8 8  \n1 7  \n3 7  \n4 7  \n3 4  \n4 6  \n3 5  \n0 4  \n2 7  \n\n## 예제 출력 2\n1\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n그래프를 이용해 풀 수 있는 기본적인 문제이다. DFS방식으로도 풀이 할 수 있지만 그래프 구현을 연습해보기 위한 문제풀이를 해보았다.\n\n인접행렬, 인접리스트, 간선리스트 모두를 활용한 문제풀이를 살펴보자.\n\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool a[2000][2000]; // 인접행렬\nvector <int> g[2000]; // 인접리스트\nvector <pair<int, int>> edges;  // 간선리스트\n\n\nint main() {\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tcin >> from >> to;\n\n\t\tedges.push_back({ from, to }); // 간선리스트 만들기 ... etc) edges[0] = 0 1  , edges[1] = 1 2\n\t\tedges.push_back({ to, from }); // 간선리스트 만들기\n\n\t\ta[from][to] = a[to][from] = true; // 인접행렬 만들기 ... etc) 연결되어있으면 1 아니면 0\n\n\t\tg[from].push_back(to); // 인접리스트 만들기 ... etc) g[0] 1  , g[1] 0 2 \n\t\tg[to].push_back(from); // 인접리스트 만들기\n\t}\n\n\tm *= 2;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\n\t\t\t// A->B\n\t\t\tint A = edges[i].first;\n\t\t\tint B = edges[i].second;\n\n\t\t\t// C->D\n\t\t\tint C = edges[j].first;\n\t\t\tint D = edges[j].second;\n\n\t\t\tif (A == B || B == C || C == D || A == C || A == D || B == D) continue;\n\n\t\t\t// B->C\n\t\t\tif (!a[B][C]) continue;\n\n\t\t\tfor (int E : g[D]) {\n\t\t\t\tif (A == E || B == E || C == E || D == E) continue;\n\t\t\t\tcout << 1 << \"\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << 0 << endl;\n\treturn 0;\n\n}\n\n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-2006659413}},"syncHistory":{"main":[-2006659413,null,null]},"v":1,"hash":1710111559730,"tx":107},"jFo1UfZG6pqBFoBN/content":{"id":"jFo1UfZG6pqBFoBN/content","type":"content","text":"---\npermalink: /2022-04-11-스프링 입문_프로젝트 환경설정/\ntitle: \"[스프링부트] [JAVA] [입문] 1. 프로젝트 생성 및 환경설정\"\ndate: 2022-04-11 20:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n\n## Spring Boot 프로젝트 생성\n웹개발을 하기위해 가장 많이 사용되는 **Spring Boot**를 공부해보고자 한다.  \n공부하기에 앞서 필요한 여러가지 환경설정과 설치파일을 준비해보자.\n<br><br><br><br><br><br>\n\n**< 사전 준비물 >** \n - Java 11설치 \n - IDE : IntelliJ 또는 Eclipse ( 해당 포스트는 IntelliJ를 사용한다 )\n\n<br><br><br><br><br><br>\n\n**스프링 부트 스타터 사이트로 이동하여 스프링 프로젝트 생성**\n[https://start.spring.io/](https://start.spring.io/)\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring_1.png?raw=true\">\n</p>\n\n - Project : **Gradle Project** ( 요즘에는 거의 Gradle을 사용 )\n - Spring Boot : **2.6.6** \n - Group : 보통 기업에서는 기업 도메인을 적는데 우리는 아무거나 적어도 된다\n - Artifact : 프로젝트명을 적어주면 된다\n - Name, Description, Package name : 알아서 적어주면 된다.\n - **Dependencies : Spring Web, Thymeleaf**\n \n <BR>\n \n\n>  **[참고]**  \n>   **Spring Web**은 **웹프로젝트**를 만들기 위한 라이브러리 이다.  \n>  **Thymeleaf**는 **html**을 만들어주는 **템플릿 엔진**이다. 프로젝트 마다 여러 종류를 사용할 수 있지만 여기서는 Thymeleaf를 쓰겠다.\n>  Spring Boot 버전은 업그레이드 됨에 따라 변경될 수 있다. SNAPSHOT이나 M1 같은 미정식 버전을 제외하고 사용하면 된다.\n\n<br>\n\n이렇게 스프링 프로젝트를 세팅 한 뒤에 원하는 폴더에 생성해주면 된다.\n\n<br>\n\n이후 **IntelliJ**에서 생성한 스프링 프로젝트를 실행해주면 된다.\n\n<br><br><br><br><br><br>\n\n\n## 생성된 코드 확인\n ### build.gradle\n <br>\n \n ```java\n // 필요한 플러그인을 땡겨오는 용도\n plugins {  \n  id 'org.springframework.boot' version '2.6.6'  \n  id 'io.spring.dependency-management' version '1.0.11.RELEASE'  \n  id 'java'  \n}  \n  \ngroup = 'hello'  \nversion = '0.0.1-SNAPSHOT'  \nsourceCompatibility = '11'   // Java 11\n  \nrepositories {  \n  mavenCentral()  \n}  \n  \n// 처음에 Dependecies 가져온것들\ndependencies {  \n  implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'  \n  implementation 'org.springframework.boot:spring-boot-starter-web'  \n  testImplementation 'org.springframework.boot:spring-boot-starter-test'  \n}  \n  \ntasks.named('test') {  \n  useJUnitPlatform()  \n}\n```\n\n - 스프링 부트 메인 실행 후 동작을 확인할 수 있다. \n - IntelliJ자체에서도 확인가능하지만 로컬환경에서 확인이 가능하다.\n - \n   http://localhost:8080\n\n<br><br><br>\n\n\n### **HelloSpringApplication.java**\n\n```java\npackage hello.hellospring;  \n  \nimport org.springframework.boot.SpringApplication;  \nimport org.springframework.boot.autoconfigure.SpringBootApplication;  \n  \n@SpringBootApplication  \npublic class HelloSpringApplication {  \n  \n   // HelloSpringApplication 클래스를 실행시키는 코드  \n  public static void main(String[] args) {  \n      SpringApplication.run(HelloSpringApplication.class, args);  \n  }  \n  \n}\n```\n\n위의 코드가 main 자바 파일이다. 이를 실행시킨뒤 로컬 서버에 접근하면 메인페이지를 볼 수 있다.\n\n<br><br><br><br>\n**실행결과** ( http://localhost:8080 )\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring3.png?raw=true\">\n</p>\n기본설정 그대로 실행했을때는 위와 같은 화면이 나왔다면 성공!\n\n<br><br><br><br><br><br>\n\n### ※ IntelliJ 대신 자바로 직접 실행하기 (참고)\n\n - 현재 IntelliJ는 Gradle을 통해서 실행하는 것이 기본설정인데, 이는 실행속도가 느리다. 그래서 자바로 바로 실행\n   할 수 있도록 설정을 변경해주는 것이 좋다!\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring2.png?raw=true\">\n</p>\n\n - Setting -> Build,Execution,Deployment -> Build Tools -> Gradle\n - Build and run using : Gradle -> IntelliJ IDEA\n - Run tests using : Gradle -> IntelliJ IDEA\n\n\n<br><br><br><br><br><br>\n\n## View 환경설정\n\n### Welcome Page 만들기\n\n이제 메인페이지를 만들어서 띄워보자! html을 이용하여 간단하게 만들어보았다.\n파일경로는 `main/resources/static` 에 넣어주면 되는데 이곳에 html파일을 넣어주면 **자동으로 Welcome Page로 지정해준다**.\n<br><br><br>\n\n`resources/static/index.html`\n```html\n<!DOCTYPE HTML>  \n<html>  \n<head>  \n <title>Hello</title>  \n <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />  \n</head>  \n<body>  \nHello  \n<a href=\"/hello\">hello</a>  \n</body>  \n</html>\n```\n<br><br><br>\n**결과화면**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring4.png?raw=true\">\n</p>\n이런 결과화면이 나온다면 성공이다!\n\n<br><br><br><br><br><br>\n\n### Controller 와 View\n웹페이지의 컨트롤러를 만들기 위해 `main/java/hello.spring` 위치에 controller라는 폴더를 하나 생성해주고 `HelloController.java`라는 파일을 하나 만들어 준다.\n\n<br>\n\n`/HelloController.java`\n```java\npackage hello.hellospring.controller;  \n  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.GetMapping;  \n  \n@Controller  \npublic class HelloController {  \n\n  // 웹어플리케이션에 '/hello'라고 들어오면 Mapping된 메소드를 호출해준다.\n  // 여기서는 index.html에 hello라는 단어의 하이퍼링크를 /hello로 달아줬기때문에 hello링크를 클릭했을 때를 말한다.\n    @GetMapping(\"hello\")  \n    public String hello(Model model){  \n        model.addAttribute(\"data\",\"hello!!\");  \n return \"hello\";  \n // 컨트롤러에서 리턴값으로 문자를 반환하면 viewResolver가 화면을 찾아서 처리한다.  \n // resources:templates/ +{ViewName} + .html  }  \n}\n```\n- `@GetMapping(\"hello\")` 의 의미는 **localhost:8080/hello** 요청이 들어오면 아래의 함수를 실행하라고 해석할 수 있다.\n- `model.addAttribute(\"data\", \"hello\")` 에서 **data는 key값**이고 **hello!!는 value**를 의미한다.\n - Controller에서 리턴값으로 반환된 문자 hello는 좀 뜬금없게 느껴지는데 이는 스프링에서 `src/main/resources`의 `templates`에서 `hello`라는 이름의 View를 찾아서 반환해준다는 뜻이다.\n - `resources:templates/ +{ViewName} + .html`\n   \n\n<br><br><br>\n`resources/templates/hello.html`\n```html\n<!DOCTYPE HTML>  \n<html xmlns:th=\"http://www.thymeleaf.org\"> <!-- thymeleaf 문법을 쓸수 있도록 넣어줌 -->  \n<head>  \n <title>Hello</title>  \n <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />  \n</head>  \n<body>  \n<!-- 여기서 data는 controller의 model의 key값 -->  \n<!-- th는 thymeleaf의 문법 -->  \n<p th:text=\"'안녕하세요. ' + ${data}\" >안녕하세요. 손님</p>  \n</body>  \n</html>\n```\n\n<br><br>\n\nController에서 hello를 return했으므로 hello.html을 작성해봤는데\n```html\n<p th:text=\"'안녕하세요. ' + ${data}\" >안녕하세요. 손님</p>\n```\n여기서 `${data}` 는 `HelloController.java`의 모델에서 사용한 value값을 가져오는데\n\n```java\npublic String hello(Model model){  \n        model.addAttribute(\"data\",\"hello!!\");  \n return \"hello\";  \n ```\n key값 data의 value인 \"hello!\"를 반환한다.\n\n<br><br><br>\n\n### 동작 환경\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring5.png?raw=true\">\n</p>\n\n1. 컨트롤러에서 return \"hello\"를 한다.\n2. `resources/templates/hello.html` 을 찾아가서 렌더링을 한다\n3. 이때 찾는 과정은 viewResolver가 자동으로 해준다.\n4. 기본 매핑경로는 `resources/templates/{ViewName}.html` 이다.\n\n<br><br><br><br><br><br>\n\n여기까지 스프링부트 입문 - 프로젝트 생성 및 환경설정 포스팅을 마친다.\n","properties":"\n","discussions":{},"comments":{},"hash":-10034513,"tx":109},"jFo1UfZG6pqBFoBN/syncedContent":{"id":"jFo1UfZG6pqBFoBN/syncedContent","type":"syncedContent","historyData":{"-10034513":{"id":"jFo1UfZG6pqBFoBN/content","type":"content","text":"---\npermalink: /2022-04-11-스프링 입문_프로젝트 환경설정/\ntitle: \"[스프링부트] [JAVA] [입문] 1. 프로젝트 생성 및 환경설정\"\ndate: 2022-04-11 20:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n\n## Spring Boot 프로젝트 생성\n웹개발을 하기위해 가장 많이 사용되는 **Spring Boot**를 공부해보고자 한다.  \n공부하기에 앞서 필요한 여러가지 환경설정과 설치파일을 준비해보자.\n<br><br><br><br><br><br>\n\n**< 사전 준비물 >** \n - Java 11설치 \n - IDE : IntelliJ 또는 Eclipse ( 해당 포스트는 IntelliJ를 사용한다 )\n\n<br><br><br><br><br><br>\n\n**스프링 부트 스타터 사이트로 이동하여 스프링 프로젝트 생성**\n[https://start.spring.io/](https://start.spring.io/)\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring_1.png?raw=true\">\n</p>\n\n - Project : **Gradle Project** ( 요즘에는 거의 Gradle을 사용 )\n - Spring Boot : **2.6.6** \n - Group : 보통 기업에서는 기업 도메인을 적는데 우리는 아무거나 적어도 된다\n - Artifact : 프로젝트명을 적어주면 된다\n - Name, Description, Package name : 알아서 적어주면 된다.\n - **Dependencies : Spring Web, Thymeleaf**\n \n <BR>\n \n\n>  **[참고]**  \n>   **Spring Web**은 **웹프로젝트**를 만들기 위한 라이브러리 이다.  \n>  **Thymeleaf**는 **html**을 만들어주는 **템플릿 엔진**이다. 프로젝트 마다 여러 종류를 사용할 수 있지만 여기서는 Thymeleaf를 쓰겠다.\n>  Spring Boot 버전은 업그레이드 됨에 따라 변경될 수 있다. SNAPSHOT이나 M1 같은 미정식 버전을 제외하고 사용하면 된다.\n\n<br>\n\n이렇게 스프링 프로젝트를 세팅 한 뒤에 원하는 폴더에 생성해주면 된다.\n\n<br>\n\n이후 **IntelliJ**에서 생성한 스프링 프로젝트를 실행해주면 된다.\n\n<br><br><br><br><br><br>\n\n\n## 생성된 코드 확인\n ### build.gradle\n <br>\n \n ```java\n // 필요한 플러그인을 땡겨오는 용도\n plugins {  \n  id 'org.springframework.boot' version '2.6.6'  \n  id 'io.spring.dependency-management' version '1.0.11.RELEASE'  \n  id 'java'  \n}  \n  \ngroup = 'hello'  \nversion = '0.0.1-SNAPSHOT'  \nsourceCompatibility = '11'   // Java 11\n  \nrepositories {  \n  mavenCentral()  \n}  \n  \n// 처음에 Dependecies 가져온것들\ndependencies {  \n  implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'  \n  implementation 'org.springframework.boot:spring-boot-starter-web'  \n  testImplementation 'org.springframework.boot:spring-boot-starter-test'  \n}  \n  \ntasks.named('test') {  \n  useJUnitPlatform()  \n}\n```\n\n - 스프링 부트 메인 실행 후 동작을 확인할 수 있다. \n - IntelliJ자체에서도 확인가능하지만 로컬환경에서 확인이 가능하다.\n - \n   http://localhost:8080\n\n<br><br><br>\n\n\n### **HelloSpringApplication.java**\n\n```java\npackage hello.hellospring;  \n  \nimport org.springframework.boot.SpringApplication;  \nimport org.springframework.boot.autoconfigure.SpringBootApplication;  \n  \n@SpringBootApplication  \npublic class HelloSpringApplication {  \n  \n   // HelloSpringApplication 클래스를 실행시키는 코드  \n  public static void main(String[] args) {  \n      SpringApplication.run(HelloSpringApplication.class, args);  \n  }  \n  \n}\n```\n\n위의 코드가 main 자바 파일이다. 이를 실행시킨뒤 로컬 서버에 접근하면 메인페이지를 볼 수 있다.\n\n<br><br><br><br>\n**실행결과** ( http://localhost:8080 )\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring3.png?raw=true\">\n</p>\n기본설정 그대로 실행했을때는 위와 같은 화면이 나왔다면 성공!\n\n<br><br><br><br><br><br>\n\n### ※ IntelliJ 대신 자바로 직접 실행하기 (참고)\n\n - 현재 IntelliJ는 Gradle을 통해서 실행하는 것이 기본설정인데, 이는 실행속도가 느리다. 그래서 자바로 바로 실행\n   할 수 있도록 설정을 변경해주는 것이 좋다!\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring2.png?raw=true\">\n</p>\n\n - Setting -> Build,Execution,Deployment -> Build Tools -> Gradle\n - Build and run using : Gradle -> IntelliJ IDEA\n - Run tests using : Gradle -> IntelliJ IDEA\n\n\n<br><br><br><br><br><br>\n\n## View 환경설정\n\n### Welcome Page 만들기\n\n이제 메인페이지를 만들어서 띄워보자! html을 이용하여 간단하게 만들어보았다.\n파일경로는 `main/resources/static` 에 넣어주면 되는데 이곳에 html파일을 넣어주면 **자동으로 Welcome Page로 지정해준다**.\n<br><br><br>\n\n`resources/static/index.html`\n```html\n<!DOCTYPE HTML>  \n<html>  \n<head>  \n <title>Hello</title>  \n <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />  \n</head>  \n<body>  \nHello  \n<a href=\"/hello\">hello</a>  \n</body>  \n</html>\n```\n<br><br><br>\n**결과화면**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring4.png?raw=true\">\n</p>\n이런 결과화면이 나온다면 성공이다!\n\n<br><br><br><br><br><br>\n\n### Controller 와 View\n웹페이지의 컨트롤러를 만들기 위해 `main/java/hello.spring` 위치에 controller라는 폴더를 하나 생성해주고 `HelloController.java`라는 파일을 하나 만들어 준다.\n\n<br>\n\n`/HelloController.java`\n```java\npackage hello.hellospring.controller;  \n  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.GetMapping;  \n  \n@Controller  \npublic class HelloController {  \n\n  // 웹어플리케이션에 '/hello'라고 들어오면 Mapping된 메소드를 호출해준다.\n  // 여기서는 index.html에 hello라는 단어의 하이퍼링크를 /hello로 달아줬기때문에 hello링크를 클릭했을 때를 말한다.\n    @GetMapping(\"hello\")  \n    public String hello(Model model){  \n        model.addAttribute(\"data\",\"hello!!\");  \n return \"hello\";  \n // 컨트롤러에서 리턴값으로 문자를 반환하면 viewResolver가 화면을 찾아서 처리한다.  \n // resources:templates/ +{ViewName} + .html  }  \n}\n```\n- `@GetMapping(\"hello\")` 의 의미는 **localhost:8080/hello** 요청이 들어오면 아래의 함수를 실행하라고 해석할 수 있다.\n- `model.addAttribute(\"data\", \"hello\")` 에서 **data는 key값**이고 **hello!!는 value**를 의미한다.\n - Controller에서 리턴값으로 반환된 문자 hello는 좀 뜬금없게 느껴지는데 이는 스프링에서 `src/main/resources`의 `templates`에서 `hello`라는 이름의 View를 찾아서 반환해준다는 뜻이다.\n - `resources:templates/ +{ViewName} + .html`\n   \n\n<br><br><br>\n`resources/templates/hello.html`\n```html\n<!DOCTYPE HTML>  \n<html xmlns:th=\"http://www.thymeleaf.org\"> <!-- thymeleaf 문법을 쓸수 있도록 넣어줌 -->  \n<head>  \n <title>Hello</title>  \n <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />  \n</head>  \n<body>  \n<!-- 여기서 data는 controller의 model의 key값 -->  \n<!-- th는 thymeleaf의 문법 -->  \n<p th:text=\"'안녕하세요. ' + ${data}\" >안녕하세요. 손님</p>  \n</body>  \n</html>\n```\n\n<br><br>\n\nController에서 hello를 return했으므로 hello.html을 작성해봤는데\n```html\n<p th:text=\"'안녕하세요. ' + ${data}\" >안녕하세요. 손님</p>\n```\n여기서 `${data}` 는 `HelloController.java`의 모델에서 사용한 value값을 가져오는데\n\n```java\npublic String hello(Model model){  \n        model.addAttribute(\"data\",\"hello!!\");  \n return \"hello\";  \n ```\n key값 data의 value인 \"hello!\"를 반환한다.\n\n<br><br><br>\n\n### 동작 환경\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring5.png?raw=true\">\n</p>\n\n1. 컨트롤러에서 return \"hello\"를 한다.\n2. `resources/templates/hello.html` 을 찾아가서 렌더링을 한다\n3. 이때 찾는 과정은 viewResolver가 자동으로 해준다.\n4. 기본 매핑경로는 `resources/templates/{ViewName}.html` 이다.\n\n<br><br><br><br><br><br>\n\n여기까지 스프링부트 입문 - 프로젝트 생성 및 환경설정 포스팅을 마친다.\n","properties":"\n","discussions":{},"comments":{},"hash":-10034513}},"syncHistory":{"main":[-10034513,null,null]},"v":1,"hash":1710111561019,"tx":109},"nXXCz6aLiQ6QA2QE/content":{"id":"nXXCz6aLiQ6QA2QE/content","type":"content","text":"---\npermalink: /2022-04-19-백준_14502번/\ntitle: \"[백준] [C/C++] 14502번 : 연구소\"\ndate: 2022-04-19 20:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"백준 14502\"\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 브루트 포스\n- BFS\n---\n\n## 문제\n\n\n\n인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.\n\n연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.\n\n일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.\n\n예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.\n\n2 0 0 0 1 1 0  \n0 0 1 0 1 2 0  \n0 1 1 0 1 0 0  \n0 1 0 0 0 0 0  \n0 0 0 0 0 1 1  \n0 1 0 0 0 0 0  \n0 1 0 0 0 0 0  \n\n이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.\n\n2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.\n\n2 1 0 0 1 1 0  \n1 0 1 0 1 2 0  \n0 1 1 0 1 0 0  \n0 1 0 0 0 1 0  \n0 0 0 0 0 1 1  \n0 1 0 0 0 0 0  \n0 1 0 0 0 0 0  \n\n바이러스가 퍼진 뒤의 모습은 아래와 같아진다.\n\n2 1 0 0 1 1 2  \n1 0 1 0 1 2 2  \n0 1 1 0 1 2 2  \n0 1 0 0 0 1 2  \n0 0 0 0 0 1 1  \n0 1 0 0 0 0 0  \n0 1 0 0 0 0 0  \n\n벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.\n\n연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n\n첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)\n\n둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.\n\n빈 칸의 개수는 3개 이상이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n7 7  \n2 0 0 0 1 1 0  \n0 0 1 0 1 2 0  \n0 1 1 0 1 0 0  \n0 1 0 0 0 0 0  \n0 0 0 0 0 1 1  \n0 1 0 0 0 0 0  \n0 1 0 0 0 0 0  \n\n## 예제 출력 1\n27\n\n## 예제 입력 2\n4 6  \n0 0 0 0 0 0  \n1 0 0 0 0 2  \n1 1 1 0 0 2  \n0 0 0 0 0 2  \n\n## 예제 출력 2\n9\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n나는 **BFS**와 **브루트포스**를 이용하여 접근했다. \n안전 영역 크기의 최댓값을 구하는 문제인데 이는 곧 **바이러스 영역 크기의 최솟값을 구하는 문제**와 같다. 최솟값을 구하는 문제이므로 BFS를 사용해야겠다 라고 접근했고, 지도의 가로 세로 크기가 3<=N,M<=8 이므로 **범위가 작아 브루트 포스를 사용**해도 시간초과가 나지 않을것 같았다.\n\n<br><br><br>\n\n구체적인 문제 풀이 과정은 다음과 같다.\n1. 지도 arr[i][j]를 입력 받는다.\n2. arr[i][j]가 0일때, 기존의 지도를 복사한 temp를 만든다.\n3. 임의의 벽 3개를 세워준다.\n4. 벽 3개가 세워진다면 BFS를 돌려서 최댓값을 계속 갱신시킨다.\n\n**※ temp를 만들어주는 이유는 벽3개를 세워서 최댓값을 구했을 때, 만일 이 값이 실제 정답이 아니라면, 그 다음 벽을 또 3개 세워서 똑같은 과정을 진행해줘야 하기 때문에 기존의 지도는 유지할 필요가 있어서 반드시 복사 된 temp가 필요하다!**\n<br><br><br><br><br><br>\n\n**[복사 코드]**\n```c++\nfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (arr[i][j] == 0) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t// 지도 복사\n\t\t\t\t\t\ttemp[i][j] = arr[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 벽을 세워줌\n\t\t\t\ttemp[i][j] = 1;\n\t\t\t\t// 다음 벽을 세우기 위한 함수 wall\n\t\t\t\twall(1);\n\t\t\t\t// 벽을 다시 허물어줌\n\t\t\t\ttemp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n```\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, m;\nint arr[10][10];\nint temp[10][10];\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,1,0,-1 };\nint cnt = 0;\nint res;\n\n\nvoid bfs() {\n\n\tint after[10][10];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tafter[i][j] = temp[i][j];\n\t\t}\n\t}\n\tqueue <pair<int,int>> q;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (after[i][j] == 2) {\n\t\t\t\tq.push(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n\t\t\t\tif (after[nx][ny] == 0) {\n\t\t\t\t\tafter[nx][ny] = 2;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (after[i][j] == 0) {\n\t\t\t\tempty++;\n\t\t\t}\n\t\t}\n\t}\n\n\tres = max(res, empty);\n}\n\nvoid wall(int cnt) {\n\tif (cnt == 3) {\n\t\tbfs();\n\t\treturn;\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (temp[i][j] == 0) {\n\t\t\t\t\ttemp[i][j] = 1;\n\t\t\t\t\twall(cnt + 1);\n\t\t\t\t\ttemp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> arr[i][j];\n\t\t}\n\t}\n\n\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (arr[i][j] == 0) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\ttemp[i][j] = arr[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttemp[i][j] = 1;\n\t\t\t\twall(1);\n\t\t\t\ttemp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1670452376,"tx":111},"nXXCz6aLiQ6QA2QE/syncedContent":{"id":"nXXCz6aLiQ6QA2QE/syncedContent","type":"syncedContent","historyData":{"1670452376":{"id":"nXXCz6aLiQ6QA2QE/content","type":"content","text":"---\npermalink: /2022-04-19-백준_14502번/\ntitle: \"[백준] [C/C++] 14502번 : 연구소\"\ndate: 2022-04-19 20:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"백준 14502\"\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 브루트 포스\n- BFS\n---\n\n## 문제\n\n\n\n인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.\n\n연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.\n\n일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.\n\n예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.\n\n2 0 0 0 1 1 0  \n0 0 1 0 1 2 0  \n0 1 1 0 1 0 0  \n0 1 0 0 0 0 0  \n0 0 0 0 0 1 1  \n0 1 0 0 0 0 0  \n0 1 0 0 0 0 0  \n\n이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.\n\n2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.\n\n2 1 0 0 1 1 0  \n1 0 1 0 1 2 0  \n0 1 1 0 1 0 0  \n0 1 0 0 0 1 0  \n0 0 0 0 0 1 1  \n0 1 0 0 0 0 0  \n0 1 0 0 0 0 0  \n\n바이러스가 퍼진 뒤의 모습은 아래와 같아진다.\n\n2 1 0 0 1 1 2  \n1 0 1 0 1 2 2  \n0 1 1 0 1 2 2  \n0 1 0 0 0 1 2  \n0 0 0 0 0 1 1  \n0 1 0 0 0 0 0  \n0 1 0 0 0 0 0  \n\n벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.\n\n연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n\n\n\n첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)\n\n둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.\n\n빈 칸의 개수는 3개 이상이다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n7 7  \n2 0 0 0 1 1 0  \n0 0 1 0 1 2 0  \n0 1 1 0 1 0 0  \n0 1 0 0 0 0 0  \n0 0 0 0 0 1 1  \n0 1 0 0 0 0 0  \n0 1 0 0 0 0 0  \n\n## 예제 출력 1\n27\n\n## 예제 입력 2\n4 6  \n0 0 0 0 0 0  \n1 0 0 0 0 2  \n1 1 1 0 0 2  \n0 0 0 0 0 2  \n\n## 예제 출력 2\n9\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n나는 **BFS**와 **브루트포스**를 이용하여 접근했다. \n안전 영역 크기의 최댓값을 구하는 문제인데 이는 곧 **바이러스 영역 크기의 최솟값을 구하는 문제**와 같다. 최솟값을 구하는 문제이므로 BFS를 사용해야겠다 라고 접근했고, 지도의 가로 세로 크기가 3<=N,M<=8 이므로 **범위가 작아 브루트 포스를 사용**해도 시간초과가 나지 않을것 같았다.\n\n<br><br><br>\n\n구체적인 문제 풀이 과정은 다음과 같다.\n1. 지도 arr[i][j]를 입력 받는다.\n2. arr[i][j]가 0일때, 기존의 지도를 복사한 temp를 만든다.\n3. 임의의 벽 3개를 세워준다.\n4. 벽 3개가 세워진다면 BFS를 돌려서 최댓값을 계속 갱신시킨다.\n\n**※ temp를 만들어주는 이유는 벽3개를 세워서 최댓값을 구했을 때, 만일 이 값이 실제 정답이 아니라면, 그 다음 벽을 또 3개 세워서 똑같은 과정을 진행해줘야 하기 때문에 기존의 지도는 유지할 필요가 있어서 반드시 복사 된 temp가 필요하다!**\n<br><br><br><br><br><br>\n\n**[복사 코드]**\n```c++\nfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (arr[i][j] == 0) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t// 지도 복사\n\t\t\t\t\t\ttemp[i][j] = arr[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 벽을 세워줌\n\t\t\t\ttemp[i][j] = 1;\n\t\t\t\t// 다음 벽을 세우기 위한 함수 wall\n\t\t\t\twall(1);\n\t\t\t\t// 벽을 다시 허물어줌\n\t\t\t\ttemp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n```\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, m;\nint arr[10][10];\nint temp[10][10];\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,1,0,-1 };\nint cnt = 0;\nint res;\n\n\nvoid bfs() {\n\n\tint after[10][10];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tafter[i][j] = temp[i][j];\n\t\t}\n\t}\n\tqueue <pair<int,int>> q;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (after[i][j] == 2) {\n\t\t\t\tq.push(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n\t\t\t\tif (after[nx][ny] == 0) {\n\t\t\t\t\tafter[nx][ny] = 2;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint empty = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (after[i][j] == 0) {\n\t\t\t\tempty++;\n\t\t\t}\n\t\t}\n\t}\n\n\tres = max(res, empty);\n}\n\nvoid wall(int cnt) {\n\tif (cnt == 3) {\n\t\tbfs();\n\t\treturn;\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (temp[i][j] == 0) {\n\t\t\t\t\ttemp[i][j] = 1;\n\t\t\t\t\twall(cnt + 1);\n\t\t\t\t\ttemp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> arr[i][j];\n\t\t}\n\t}\n\n\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (arr[i][j] == 0) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\ttemp[i][j] = arr[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttemp[i][j] = 1;\n\t\t\t\twall(1);\n\t\t\t\ttemp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1670452376}},"syncHistory":{"main":[1670452376,null,null]},"v":1,"hash":1710111562072,"tx":111},"VifWnBgyL1lMo6QC/content":{"id":"VifWnBgyL1lMo6QC/content","type":"content","text":"# JSP Bulletin WebPage\n\n> JSP 개발환경에 기반하여 JDK, Eclipse, Tomcat을 활용해 게시판 기능을 가진 웹페이지 입니다.\n\n## 사용 예제\n**[ 메인페이지 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/jsp1.png?raw=true\">\n</p>\n\n**[ 회원가입 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/jsp3.png?raw=true\">\n</p>\n\n**[ 로그인 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/jsp4.png?raw=true\">\n</p>\n\n**[ 글쓰기 페이지 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/jsp2.png?raw=true\">\n</p>\n\n## 설치 방법\n**개발환경**\n\n> JAVA 버전 : JDK1.8.0  \n> 서버 : Tomcat 8.5.14  \n> Eclipse IDE for Enterprise and Web Developers - 2021.12  \n> DB : MySQL 5.7.18  \n\n**개발 환경이 모두 갖춰진 뒤에는 로컬 환경에서 바로 실행 가능합니다!**\n\n\n## 설명\n- **게시판 웹 페이지 :** **JSP**를 활용한 간단한 게시판 웹페이지를 제작해봤습니다. **MYSQL**을 이용해 DB를 처리했고 디자인 템플릿으로는 **부트스트랩**을 사용했습니다. **회원가입, 로그인** 기능이 구현되었고 회원정보에 기반하여 게시판에 게시글을 작성할 수 있습니다. 또한 게시글에 대한 **수정, 삭제**도 가능합니다!\n- **보안** :  **Cross-site scripting** 공격에 대한 대비 장치가 마련되어 있습니다! **SQL Injection**에 대한 방어로 **Prepared Statement** 구문을 사용했습니다!\n- **로컬 환경** : 본인의 로컬환경에서 실행 할 수 있습니다. 서버를 열고 https:// localhost:8080 에 접속하면 웹페이지를 바로 확인할 수 있습니다.\n\n## 보안\n**크로스 사이트 스크립팅 공격 보안**\n```html\n<tbody>\n\t<tr>\n\t\t<td style = \"width : 20%;\">글 제목</td>\n\t\t<td colspan=\"2\"><%= bbs.getBbsTitle().replaceAll(\" \",\"&nbsp;\").replaceAll(\"<\",\"&lt;\").replaceAll(\">\",\"&gt;\").replaceAll(\"\\n\",\"<br>\") %></td>\n\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>작성자</td>\n\t\t\t\t\t<td colspan=\"2\"><%= bbs.getUserID() %></td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>작성일자</td>\n\t\t\t\t\t<td colspan=\"2\"><%= bbs.getBbsDate().substring(0,11) + bbs.getBbsDate().substring(11,13)+\"시\"+bbs.getBbsDate().substring(14,16)+\"분\" %></td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>내용</td>\n\t\t\t\t\t\t<td colspan=\"2\" style=\"min-height: 200px;  text-align  : Left;\"><%= bbs.getBbsContent().replaceAll(\" \",\"&nbsp;\").replaceAll(\"<\",\"&lt;\").replaceAll(\">\",\"&gt;\").replaceAll(\"\\n\",\"<br>\") %></td>\n\t\t\t\t</tr>\t\n</tbody>\t\t\n```\n특수문자를 따로 처리하는 코드를 삽입하여 크로스 사이트 스크립팅 공격에 대한 대비를 함.\n\n<br><br><br>\n\n**SQL Injection 공격에 대한 보안**\n\n```java\n// 회원가입 정보 가져오기\n\tpublic int join(User user) {\n\t\tString SQL = \"INSERT INTO USER VALUES (?, ?, ?, ?, ?)\";\n\t\ttry {\n\t\t\tpstmt = conn.prepareStatement(SQL);\n\t\t\tpstmt.setString(1, user.getUserID());\n\t\t\tpstmt.setString(2, user.getUserPassword());\n\t\t\tpstmt.setString(3, user.getUserName());\n\t\t\tpstmt.setString(4, user.getUserGender());\n\t\t\tpstmt.setString(5, user.getUserEmail());\n\t\t\treturn pstmt.executeUpdate();\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1; // 데이터베이스 오류\n\t\t\n\t}\n```\n**Prepared Statement** 구문을 사용하여 바인딩 변수를 사용한 SQL 공격 쿼리를 입력할지라도 SQL인젝션 공격에 안전하게 구현함!\n","properties":"\n","discussions":{},"comments":{},"hash":-2103000658,"tx":113},"VifWnBgyL1lMo6QC/syncedContent":{"id":"VifWnBgyL1lMo6QC/syncedContent","type":"syncedContent","historyData":{"-2103000658":{"id":"VifWnBgyL1lMo6QC/content","type":"content","text":"# JSP Bulletin WebPage\n\n> JSP 개발환경에 기반하여 JDK, Eclipse, Tomcat을 활용해 게시판 기능을 가진 웹페이지 입니다.\n\n## 사용 예제\n**[ 메인페이지 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/jsp1.png?raw=true\">\n</p>\n\n**[ 회원가입 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/jsp3.png?raw=true\">\n</p>\n\n**[ 로그인 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/jsp4.png?raw=true\">\n</p>\n\n**[ 글쓰기 페이지 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/jsp2.png?raw=true\">\n</p>\n\n## 설치 방법\n**개발환경**\n\n> JAVA 버전 : JDK1.8.0  \n> 서버 : Tomcat 8.5.14  \n> Eclipse IDE for Enterprise and Web Developers - 2021.12  \n> DB : MySQL 5.7.18  \n\n**개발 환경이 모두 갖춰진 뒤에는 로컬 환경에서 바로 실행 가능합니다!**\n\n\n## 설명\n- **게시판 웹 페이지 :** **JSP**를 활용한 간단한 게시판 웹페이지를 제작해봤습니다. **MYSQL**을 이용해 DB를 처리했고 디자인 템플릿으로는 **부트스트랩**을 사용했습니다. **회원가입, 로그인** 기능이 구현되었고 회원정보에 기반하여 게시판에 게시글을 작성할 수 있습니다. 또한 게시글에 대한 **수정, 삭제**도 가능합니다!\n- **보안** :  **Cross-site scripting** 공격에 대한 대비 장치가 마련되어 있습니다! **SQL Injection**에 대한 방어로 **Prepared Statement** 구문을 사용했습니다!\n- **로컬 환경** : 본인의 로컬환경에서 실행 할 수 있습니다. 서버를 열고 https:// localhost:8080 에 접속하면 웹페이지를 바로 확인할 수 있습니다.\n\n## 보안\n**크로스 사이트 스크립팅 공격 보안**\n```html\n<tbody>\n\t<tr>\n\t\t<td style = \"width : 20%;\">글 제목</td>\n\t\t<td colspan=\"2\"><%= bbs.getBbsTitle().replaceAll(\" \",\"&nbsp;\").replaceAll(\"<\",\"&lt;\").replaceAll(\">\",\"&gt;\").replaceAll(\"\\n\",\"<br>\") %></td>\n\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>작성자</td>\n\t\t\t\t\t<td colspan=\"2\"><%= bbs.getUserID() %></td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>작성일자</td>\n\t\t\t\t\t<td colspan=\"2\"><%= bbs.getBbsDate().substring(0,11) + bbs.getBbsDate().substring(11,13)+\"시\"+bbs.getBbsDate().substring(14,16)+\"분\" %></td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>내용</td>\n\t\t\t\t\t\t<td colspan=\"2\" style=\"min-height: 200px;  text-align  : Left;\"><%= bbs.getBbsContent().replaceAll(\" \",\"&nbsp;\").replaceAll(\"<\",\"&lt;\").replaceAll(\">\",\"&gt;\").replaceAll(\"\\n\",\"<br>\") %></td>\n\t\t\t\t</tr>\t\n</tbody>\t\t\n```\n특수문자를 따로 처리하는 코드를 삽입하여 크로스 사이트 스크립팅 공격에 대한 대비를 함.\n\n<br><br><br>\n\n**SQL Injection 공격에 대한 보안**\n\n```java\n// 회원가입 정보 가져오기\n\tpublic int join(User user) {\n\t\tString SQL = \"INSERT INTO USER VALUES (?, ?, ?, ?, ?)\";\n\t\ttry {\n\t\t\tpstmt = conn.prepareStatement(SQL);\n\t\t\tpstmt.setString(1, user.getUserID());\n\t\t\tpstmt.setString(2, user.getUserPassword());\n\t\t\tpstmt.setString(3, user.getUserName());\n\t\t\tpstmt.setString(4, user.getUserGender());\n\t\t\tpstmt.setString(5, user.getUserEmail());\n\t\t\treturn pstmt.executeUpdate();\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1; // 데이터베이스 오류\n\t\t\n\t}\n```\n**Prepared Statement** 구문을 사용하여 바인딩 변수를 사용한 SQL 공격 쿼리를 입력할지라도 SQL인젝션 공격에 안전하게 구현함!\n","properties":"\n","discussions":{},"comments":{},"hash":-2103000658}},"syncHistory":{"main":[-2103000658,null,null]},"v":1,"hash":1710111563250,"tx":113},"rCaBeFyH6dZGb5Ou/content":{"id":"rCaBeFyH6dZGb5Ou/content","type":"content","text":"\n# Messenger ( Socket Programming )\n\n> 간단한 온라인 메신저 프로그램입니다.  \n> Multi-thread를 이용하여 여러명의 사용자가 동시에 메세지를 주고받을 수 있고  \n> Client-Server 구조에 기반한 소켓 프로그래밍을 사용했습니다.  \n> 회원가입, 로그인, 아이디-비밀번호 찾기, 날씨 확인 등의 기능이 구현되었습니다.\n\n## 전체 구조도\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger1.png?raw=true\">\n</p>\n\n- Connection : Socket을 이용한 연결\n- Login&Register : 서버DB를 이용해 ID와PW 및 개인정보 기록\n- Manage User Data : 로그인 성공시 서버-클라이언트 간 정보 공유\n- Chatting : multi-thread를 이용하여 1대1 채팅 & 1대多 채팅 가능\n- Open Data API : API를 가져와 당일 날씨 확인가능\n\n## Table of Contents\n- **회원가입**\n\t- ID, PW, Nickname, 이메일, 생년월일, 전화번호, 홈페이지 정보 입력 후 DB에 저장\n\n- **로그인**\n\t- DB에 저장된 회원정보와 일치 할 시 로그인 가능\n\n- **ID/PW 찾기**\n\t- DB에 저장된 회원정보를 기반으로 ID/PW 찾기 가능\n\n- **회원정보수정**\n\n- **사용자 검색**\n\t- 메신저를 이용중인 다른 사용자 검색 가능\n\n- **사용자 친구 추가**\n\n- **일대일 채팅**\n\n- **일대多 채팅**\n\t- 오픈채팅 형식으로 여러명과 동시에 채팅 가능\n\n- **날씨 확인**\n\t- 날씨 확인 API를 사용하여 그날의 날씨 확인 가능\n\n## 사용 예시\n**[ 서버 연동시 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger3.png?raw=true\">\n</p>\n<br>\n\n**[ 로그인 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger4.png?raw=true\">\n</p>\n<br>\n\n**[ 회원가입 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger2.png?raw=true\">\n</p>\n<br>\n\n**[ 회원가입 조건 미충족시 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger5.png?raw=true\">\n</p>\n<br>\n\n\n**[ 비밀번호 찾기 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger6.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅창 기본 화면 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger7.png?raw=true\">\n</p>\n<br>\n\n**[ 사용자 검색 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger8.png?raw=true\">\n</p>\n<br>\n\n**[ 정보 변경 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger8.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅 - 1대1 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger9.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅 - 1대1 ] (2)**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger10.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅 - 1대多 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger11.png?raw=true\">\n</p>\n<br>\n\n**[ 날씨 확인 API ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger12.png?raw=true\">\n</p>\n<br>\n\n\n## 설치 방법\n**개발환경**\n\n> JAVA 버전 : 17.0.2  \n> 서버 : Client-Server, Socket Programming  \n> Eclipse IDE for Enterprise and Web Developers - 2021.12  \n> DB : MySQL-connector-java-8.0.22  \n\n**개발 환경이 모두 갖춰진 뒤에는 로컬 환경에서 바로 실행 가능합니다!**  \n**단, DB연동을 위해 MySQL-connector-java-8.0.22를 프로젝트 외부 라이브러리에 등록해줘야 합니다.**\n\n\n## 설명\n- **메신저 :** 중형 규모의 네트워크 메신저 프로그램입니다. 접속 및 회원가입 /수정, 로그인, 사용자/친구관리, 1대1채팅방, 1대多채팅방, 공공데이터 API 기능이 구현되어 있습니다. \n- **Multi-Thread** :  멀티 쓰레드를 사용하여 한번에 여러명과 채팅을 할 수 있습니다.\n- **DBMS** : DBMS(JDBC)를 이용하여 사용자 정보 관리를 할 수 있습니다.\n- **API** : 오늘의 날씨를 확인할 수 있는 공공데이터 API를 사용했습니다.\n\n## 보안\n**암호화 ( Encrypt ) 복호화 ( Decrypt)**\n```java\nprivate final static String HEX = \"0123456789ABCDEF\";\n    private final static String key = \"AABBCCDDEERRFF\";\n    \n    public static String encrypt(String cleartext) throws Exception\n    {\n        String seed = key;\n    \tbyte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result); \n    }\n\n    public static String decrypt(String encrypted) throws Exception\n    {\n        String seed = key;\n    \tbyte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\tprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception\n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception\n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n```\n문자열로 받은 사용자의 비밀번호를 암호화 하는 코드의 일부이다. 회원가입 시 입력받은 비밀번호를 **AES알고리즘**을 이용하여 암호화 하였다. \n\n## API\n\n**공공데이터 포털 : 기상청_동네예보 조회서비스**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger13.png?raw=true\">\n</p>\n\n","properties":"\n","discussions":{},"comments":{},"hash":694047141,"tx":115},"rCaBeFyH6dZGb5Ou/syncedContent":{"id":"rCaBeFyH6dZGb5Ou/syncedContent","type":"syncedContent","historyData":{"694047141":{"id":"rCaBeFyH6dZGb5Ou/content","type":"content","text":"\n# Messenger ( Socket Programming )\n\n> 간단한 온라인 메신저 프로그램입니다.  \n> Multi-thread를 이용하여 여러명의 사용자가 동시에 메세지를 주고받을 수 있고  \n> Client-Server 구조에 기반한 소켓 프로그래밍을 사용했습니다.  \n> 회원가입, 로그인, 아이디-비밀번호 찾기, 날씨 확인 등의 기능이 구현되었습니다.\n\n## 전체 구조도\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger1.png?raw=true\">\n</p>\n\n- Connection : Socket을 이용한 연결\n- Login&Register : 서버DB를 이용해 ID와PW 및 개인정보 기록\n- Manage User Data : 로그인 성공시 서버-클라이언트 간 정보 공유\n- Chatting : multi-thread를 이용하여 1대1 채팅 & 1대多 채팅 가능\n- Open Data API : API를 가져와 당일 날씨 확인가능\n\n## Table of Contents\n- **회원가입**\n\t- ID, PW, Nickname, 이메일, 생년월일, 전화번호, 홈페이지 정보 입력 후 DB에 저장\n\n- **로그인**\n\t- DB에 저장된 회원정보와 일치 할 시 로그인 가능\n\n- **ID/PW 찾기**\n\t- DB에 저장된 회원정보를 기반으로 ID/PW 찾기 가능\n\n- **회원정보수정**\n\n- **사용자 검색**\n\t- 메신저를 이용중인 다른 사용자 검색 가능\n\n- **사용자 친구 추가**\n\n- **일대일 채팅**\n\n- **일대多 채팅**\n\t- 오픈채팅 형식으로 여러명과 동시에 채팅 가능\n\n- **날씨 확인**\n\t- 날씨 확인 API를 사용하여 그날의 날씨 확인 가능\n\n## 사용 예시\n**[ 서버 연동시 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger3.png?raw=true\">\n</p>\n<br>\n\n**[ 로그인 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger4.png?raw=true\">\n</p>\n<br>\n\n**[ 회원가입 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger2.png?raw=true\">\n</p>\n<br>\n\n**[ 회원가입 조건 미충족시 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger5.png?raw=true\">\n</p>\n<br>\n\n\n**[ 비밀번호 찾기 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger6.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅창 기본 화면 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger7.png?raw=true\">\n</p>\n<br>\n\n**[ 사용자 검색 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger8.png?raw=true\">\n</p>\n<br>\n\n**[ 정보 변경 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger8.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅 - 1대1 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger9.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅 - 1대1 ] (2)**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger10.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅 - 1대多 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger11.png?raw=true\">\n</p>\n<br>\n\n**[ 날씨 확인 API ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger12.png?raw=true\">\n</p>\n<br>\n\n\n## 설치 방법\n**개발환경**\n\n> JAVA 버전 : 17.0.2  \n> 서버 : Client-Server, Socket Programming  \n> Eclipse IDE for Enterprise and Web Developers - 2021.12  \n> DB : MySQL-connector-java-8.0.22  \n\n**개발 환경이 모두 갖춰진 뒤에는 로컬 환경에서 바로 실행 가능합니다!**  \n**단, DB연동을 위해 MySQL-connector-java-8.0.22를 프로젝트 외부 라이브러리에 등록해줘야 합니다.**\n\n\n## 설명\n- **메신저 :** 중형 규모의 네트워크 메신저 프로그램입니다. 접속 및 회원가입 /수정, 로그인, 사용자/친구관리, 1대1채팅방, 1대多채팅방, 공공데이터 API 기능이 구현되어 있습니다. \n- **Multi-Thread** :  멀티 쓰레드를 사용하여 한번에 여러명과 채팅을 할 수 있습니다.\n- **DBMS** : DBMS(JDBC)를 이용하여 사용자 정보 관리를 할 수 있습니다.\n- **API** : 오늘의 날씨를 확인할 수 있는 공공데이터 API를 사용했습니다.\n\n## 보안\n**암호화 ( Encrypt ) 복호화 ( Decrypt)**\n```java\nprivate final static String HEX = \"0123456789ABCDEF\";\n    private final static String key = \"AABBCCDDEERRFF\";\n    \n    public static String encrypt(String cleartext) throws Exception\n    {\n        String seed = key;\n    \tbyte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result); \n    }\n\n    public static String decrypt(String encrypted) throws Exception\n    {\n        String seed = key;\n    \tbyte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\tprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception\n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception\n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n```\n문자열로 받은 사용자의 비밀번호를 암호화 하는 코드의 일부이다. 회원가입 시 입력받은 비밀번호를 **AES알고리즘**을 이용하여 암호화 하였다. \n\n## API\n\n**공공데이터 포털 : 기상청_동네예보 조회서비스**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/messenger13.png?raw=true\">\n</p>\n\n","properties":"\n","discussions":{},"comments":{},"hash":694047141}},"syncHistory":{"main":[694047141,null,null]},"v":1,"hash":1710111564767,"tx":115},"RhDb97gjgmCAcjXo/content":{"id":"RhDb97gjgmCAcjXo/content","type":"content","text":"# Camptact \n\n> 가천대학교 교내 사용자를 위한 안드로이드 랜덤채팅 어플리케이션입니다. 가천대학교 재학생임이 증명된 사용자 중 랜덤으로 매칭하여 채팅을 나눌 수 있습니다. 뿐만 아니라 게시판 기능이 탑재돼있어 정보글을 공유 할 수도 있습니다.\n\n\n\n## Table of Contents\n- **사용자 인증**\n\t- 가천대학교 이메일을 통해 가천대학교 재학생임을 인증 후 사용가능합니다.\n\n- **게시판**\n\t- DB에 저장된 회원정보를 기반으로 ID/PW 찾기 가능\n\n- **광고**\n\t- 구글 애드센스를 이용한 수익창출\n\n- **채팅**\n\t- 다른 사용자중 랜덤으로 매칭하여 1대1 채팅 가능\n\n- **사진전송 & 신고기능**\n\t- 채팅 중 사진전송이 가능하며 부적절한 채팅시 신고 가능\n\n- **회원탈퇴**\n\t- 어플 불필요시 회원탈퇴 가능\n\n\n## 사용 예시\n**[ 초기 사용안내 화면 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact2.png?raw=true\">\n</p>\n<br>\n\n**[ 사용자 인증 화면 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact1.png?raw=true\">\n</p>\n<br>\n\n**[ 이미 가입된 계정일 시 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact3.png?raw=true\">\n</p>\n<br>\n\n**[ 메인화면 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact4.png?raw=true\">\n</p>\n<br>\n\n\n**[ 랜덤채팅 매칭 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact5.png?raw=true\">\n</p>\n<br>\n\n**[ 사진 전송 & 신고하기 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact6.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅목록 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact7.png?raw=true\">\n</p>\n<br>\n\n**[ 게시판 글쓰기 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact8.png?raw=true\">\n</p>\n<br>\n\n**[ 설정 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact9.png?raw=true\">\n</p>\n<br>\n\n\n\n## 설치 방법\n**개발환경**\n\n> Android Studio\n> JAVA 버전 : JDK 1.8.0_332\n> Server & DB : Firebase Realtime Database\n> 테스트 환경 : Samsung GalaxyS10\n\n\n\n## 설명\n- **사용자 인증 :** 가천대학교 이메일을 가진 사람만이 회원가입이 가능하며 이메일 입력시 해당 메일주소로 본인인증 메일을 전송해 가입을 할 수 있습니다. \n- **랜덤채팅** :  어플 실시간 사용자 중 랜덤으로 매칭을 해 채팅할 수 있습니다. \n- **사진전송 & 신고** : 채팅을 나누며 사진전송이 가능하고 부적절 유저를 신고할 수 있습니다.\n- **DB** : Firebase와 연동하여 유저의 정보를 저장합니다. 추가적으로 신고된 유저를 DB를 통해 확인하여 관리자가 이를 확인 할 수 있습니다.\n- **게시판** : 자유롭게 게시글을 남겨 정보를 공유할 수 있습니다.\n\n## 사용자 인증\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact11.png?raw=true\">\n</p>\n<br>\n\n가천대학교 이메일 입력시 해당 메일 주소로 본인인증 메일이 전송됩니다. \n**캠택트 로그인** 텍스트 클릭시 해당 메일 주소가 Firebase로 전달되고 가천대학교 이메일 주소와 일치 할 시 본인인증이 완료됩니다.\n\n아래 JAVA파일에서 해당 코드를 확인할 수 있습니다.\n    [main/java/io.camtact.android/presenter/AuthPresenter.java](https://github.com/idkim97/Camptact/blob/main/app/src/main/java/io/camtact/android/presenter/AuthPresenter.java)\n\n\n\n## 랜덤채팅\n\n**[랜덤채팅 함수]**\n```java\n@Override  \npublic void searchRandomUser() {  \n    // Bind to LocalService  \n  if(!isBound) {  \n        Intent intent = new Intent(context, MatchService.class);  \n  context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);  \n  }  \n  \n    if(!isThreadRunning) {  \n        runTimeCheck();  \n  }  \n    matchModel.deleteOldChatRoom();  \n}\n```\n\n인증이 완료된 어플 사용자 중 랜덤으로 함수를 돌려 채팅을 매칭시켜줍니다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact10.png?raw=true\">\n</p>\n<br>\n\n\"랜덤채팅 시작하기\" 버튼을 누르면 매칭이 시작되며 로딩창이 뜨고 매칭 완료시 채팅방으로 자동 이동합니다. \n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":864004048,"tx":117},"RhDb97gjgmCAcjXo/syncedContent":{"id":"RhDb97gjgmCAcjXo/syncedContent","type":"syncedContent","historyData":{"864004048":{"id":"RhDb97gjgmCAcjXo/content","type":"content","text":"# Camptact \n\n> 가천대학교 교내 사용자를 위한 안드로이드 랜덤채팅 어플리케이션입니다. 가천대학교 재학생임이 증명된 사용자 중 랜덤으로 매칭하여 채팅을 나눌 수 있습니다. 뿐만 아니라 게시판 기능이 탑재돼있어 정보글을 공유 할 수도 있습니다.\n\n\n\n## Table of Contents\n- **사용자 인증**\n\t- 가천대학교 이메일을 통해 가천대학교 재학생임을 인증 후 사용가능합니다.\n\n- **게시판**\n\t- DB에 저장된 회원정보를 기반으로 ID/PW 찾기 가능\n\n- **광고**\n\t- 구글 애드센스를 이용한 수익창출\n\n- **채팅**\n\t- 다른 사용자중 랜덤으로 매칭하여 1대1 채팅 가능\n\n- **사진전송 & 신고기능**\n\t- 채팅 중 사진전송이 가능하며 부적절한 채팅시 신고 가능\n\n- **회원탈퇴**\n\t- 어플 불필요시 회원탈퇴 가능\n\n\n## 사용 예시\n**[ 초기 사용안내 화면 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact2.png?raw=true\">\n</p>\n<br>\n\n**[ 사용자 인증 화면 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact1.png?raw=true\">\n</p>\n<br>\n\n**[ 이미 가입된 계정일 시 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact3.png?raw=true\">\n</p>\n<br>\n\n**[ 메인화면 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact4.png?raw=true\">\n</p>\n<br>\n\n\n**[ 랜덤채팅 매칭 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact5.png?raw=true\">\n</p>\n<br>\n\n**[ 사진 전송 & 신고하기 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact6.png?raw=true\">\n</p>\n<br>\n\n**[ 채팅목록 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact7.png?raw=true\">\n</p>\n<br>\n\n**[ 게시판 글쓰기 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact8.png?raw=true\">\n</p>\n<br>\n\n**[ 설정 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact9.png?raw=true\">\n</p>\n<br>\n\n\n\n## 설치 방법\n**개발환경**\n\n> Android Studio\n> JAVA 버전 : JDK 1.8.0_332\n> Server & DB : Firebase Realtime Database\n> 테스트 환경 : Samsung GalaxyS10\n\n\n\n## 설명\n- **사용자 인증 :** 가천대학교 이메일을 가진 사람만이 회원가입이 가능하며 이메일 입력시 해당 메일주소로 본인인증 메일을 전송해 가입을 할 수 있습니다. \n- **랜덤채팅** :  어플 실시간 사용자 중 랜덤으로 매칭을 해 채팅할 수 있습니다. \n- **사진전송 & 신고** : 채팅을 나누며 사진전송이 가능하고 부적절 유저를 신고할 수 있습니다.\n- **DB** : Firebase와 연동하여 유저의 정보를 저장합니다. 추가적으로 신고된 유저를 DB를 통해 확인하여 관리자가 이를 확인 할 수 있습니다.\n- **게시판** : 자유롭게 게시글을 남겨 정보를 공유할 수 있습니다.\n\n## 사용자 인증\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact11.png?raw=true\">\n</p>\n<br>\n\n가천대학교 이메일 입력시 해당 메일 주소로 본인인증 메일이 전송됩니다. \n**캠택트 로그인** 텍스트 클릭시 해당 메일 주소가 Firebase로 전달되고 가천대학교 이메일 주소와 일치 할 시 본인인증이 완료됩니다.\n\n아래 JAVA파일에서 해당 코드를 확인할 수 있습니다.\n    [main/java/io.camtact.android/presenter/AuthPresenter.java](https://github.com/idkim97/Camptact/blob/main/app/src/main/java/io/camtact/android/presenter/AuthPresenter.java)\n\n\n\n## 랜덤채팅\n\n**[랜덤채팅 함수]**\n```java\n@Override  \npublic void searchRandomUser() {  \n    // Bind to LocalService  \n  if(!isBound) {  \n        Intent intent = new Intent(context, MatchService.class);  \n  context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);  \n  }  \n  \n    if(!isThreadRunning) {  \n        runTimeCheck();  \n  }  \n    matchModel.deleteOldChatRoom();  \n}\n```\n\n인증이 완료된 어플 사용자 중 랜덤으로 함수를 돌려 채팅을 매칭시켜줍니다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/camtact10.png?raw=true\">\n</p>\n<br>\n\n\"랜덤채팅 시작하기\" 버튼을 누르면 매칭이 시작되며 로딩창이 뜨고 매칭 완료시 채팅방으로 자동 이동합니다. \n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":864004048}},"syncHistory":{"main":[864004048,null,null]},"v":1,"hash":1710111565905,"tx":117},"PV7SRqnI3929RHIh/content":{"id":"PV7SRqnI3929RHIh/content","type":"content","text":"---\npermalink: /2022-05-01-MobiSys`21 OESense 논문 리뷰/\npublished : true\ntitle: \"[RA] [논문리뷰] 1. OESense 논문 리뷰 준비 \"\ndate: 2022-05-01 06:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"OESense\"\ncategories:\n- RA\ntags:\n- 논문리뷰\n- OESense\n---\n\n## 나의 첫번째 세미나 논문리뷰\nRA 연구실에 들어가 받은 나의 두번째 과제였다. 내가 들어간 연구실은 Intelligent networking & Computing을 주로 다루는 연구실이고, 무선 네트워킹 관련된 연구를 하고있다. 교수님께서 내주신 논문 리뷰 과제는 **OESense: Employing Occlusion Effect for In-ear Human Sensing** 이라는 논문인데, 이를 읽어보고 관련내용을 공부하고 연합세미나 자리에서 발표를 해야했다.\n\n솔직히 과제를 받은 처음에는 되게 막막한 감정이 컸다. 영어에 자신이 없는건 아니였지만 논문이 전부 영어로 쓰여있고, 접해보지도 못한 주제의 논문이였기에 하나부터 열까지 찾아보고 공부해야 했고, 다른 교수님들도 계신 자리에서 진행해야 하는 발표였기에 많이 떨렸다.\n\n부끄럽지만 나의 첫번째 세미나 논문리뷰 과정을 써보려고 한다. 굉장히 흥미로운 경험이였고 논문리뷰를 하면서 여러가지 배운점이 많았기에 공유해보도록 하겠다!\n<br><br><br><br><br><br> \n      \n\n\n## 논문 간단 소개\n### Motive\n- 무선 이어버드는 단순 엔터네이너적 요소 ( 음악감상, 통화, 영상시청 ) 로 이용되는 것에 그치지 않고 인간의 건강정보와 움직임 정보를 탐지하는데 까지 영역을 확장하고 있다.\n\n- 기존 무선 이어버드에 탑재된 마이크, 가속도계를 사용하여 인간의 동작을 탐지할 수도 있지만, 음악이 재생된 경우 혹은 동작이 작은 경우 기존 이어버드를 통해 동작을 탐지하는데는 어려움이 있다.\n\n- 이어버드를 사용해 더 정확한 **인간 동작 탐지**를 위해 이 논문에서 새로 제시한 개념은 바로 **OESense**이다.\n<br><br><br>\n\n### Introduction\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/OE1.png?raw=true\">\n</p>\n\n**OESense** ( Mic + Occlusion Effect ) 란 이어버드의 **마이크**와 **폐쇄효과**를 결합한 형태의 새로운 이어버드이다. **폐쇄효과는 저주파를 강화시켜 신호를 증폭시키는 효과**를 일으키는데 이를 활용하여 기존 이어버드로는 탐지하기 어려운 **작은동작을 쉽게 탐지**하게 해주고 **주변 노이즈를 제거**할 수 있다.\n\n<br><br><br>\n\n### Application\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/OE2.png?raw=true\">\n</p>\n\n크게 3가지 동작에 대해서 OESense 성능 실험을 진행하고 이를 기존의 이어버드와 비교하여 OESense의 성능을 보인다.\n\n<br><br><br>\n\n논문은 전체적으로는 이런 구조를 보이고 있다. 이어버드를 이용해 인간 동작 탐지를 하는데에 어려움이 존재하고 이를 보완하기 위해 폐쇄효과를 활용한 새로운 형태의 이어버드인 OESense를 제시한다. 폐쇄효과는 저주파 증폭, 노이즈 제거 등의 현상을 일으키기 때문에 상대적으로 작은 동작을 잘 탐지할 수 있고 주변 소음에 방해를 받지 않는다. \n\n<br><br><br><br><br><br>\n\n## 논문 공부를 위한 사전 준비\n\n### 일단 읽자!\n사실 무엇을 먼저 준비해야 할지 몰랐다.. ㅋㅋ 일단 논문부터 읽어보자! 라는 마음가짐으로 논문을 켜고 내 부족한 영어실력을 채워줄 구글번역기를 준비했다..! Introduction, Motivation, Overview.. 천천히 전부 읽어나갔다. 어느정도 이해할 수 있는 정도였지만 완벽하게 이해하기에는 어렵다는 생각이 들었다. 처음보는 개념이였고 폐쇄효과? 라는게 도저히 이해가 안갔다. 그래서 논문을 직접 작성한 컨퍼런스를 찾아봤고 관련 발표 영상을 찾을 수 있었다...!\n\n[https://www.youtube.com/watch?v=RNR1KJtGiaI](https://www.youtube.com/watch?v=RNR1KJtGiaI)\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/OE3.png?raw=true\">\n</p>\n\n논문에 대해서 깊이있게 소개한 영상은 아니였지만 논문이 말하고자 하는바, 전체적인 흐름을 파악하는데 정말 많은 도움이 됐다. 확실히 논문 작성자가 직접 연구한 내용을 발표한 영상이다보니 이해가 잘 되었다. 이 영상을 몇번이나 돌려봤는지 모를정도로 많이 봤던것 같다.. ㅎㅎ\n\n<br><br><br>\n\n### Occlusion Effect ( 폐쇄효과 ) \n이 논문에서 정말 중요한 개념 이였다. OESense 라는 개념이 이어버드 + 폐쇄효과 였기때문에 폐쇄효과가 무엇인지, 어떤 현상인지 정확하게 알 필요가 있었다. \n\n[https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hihearing&logNo=221338808785](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hihearing&logNo=221338808785)\n\n생각보다 논문주제와 전혀 관련없는 블로그에서 폐쇄효과에 대한 감을 잡았다.. ㅋㅋ 보청기 관련 블로그인데 보청기를 착용하면 본인 목소리가 울려서 들리는 현상이 발생할 때가 있는데 이게 폐쇄효과라는 것이다. \n좀더 그 원리에 대해 자세하게 보자.\n1. 성대 혹은 체내에서 생성된 소리나 진동이 공기를 통해서 전달되는게 아니라 뼈와 외이도를 통해 고막에 전달.\n2. 이 때문에 고막의 stiffness가 증가\n3. 이는 저주파수의 임피던스를 증가시켜 저주파수를 증폭\n\n대략 이런 원리인데, 보청기 사용자 입장에서는 폐쇄효과가 저주파수를 증폭시켜 본인의 목소리를 울리기 때문에 사용에 불편을 주는 부작용의 원인인데, 논문에서는 이를 역이용하여 **저주파수 (= 동작이 작은 움직임 )의 증폭**을 통해 **동작이 작은 움직임을 더 잘 탐지**하고 **노이즈를 제거**할 수 있게끔 사용한다는게 굉장히 흥미로웠다.\n\n<br><br><br>\n\n### 수집한 데이터 분석을 위한 Evaluation\n\n논문에서는 수집된 데이터 분석을 위해 머신러닝을 사용했다. Classifier로는 SVM, Logistic Regression, KNN, Decision Tree, Random Forest 가 있고 모델링이 끝난 데이터는 Confusion Matrix, Precision, Recall 등을 이용해 Evaluation을 진행한다.\n\n머신러닝 관련해서는 학부 공부를 통해 알고 있고 관련 포스팅도 올라와있기 때문에 링크를 걸어두겠다!\n\n[https://idkim97.github.io/categories/#machine-learning](https://idkim97.github.io/categories/#machine-learning)\n\n<br><br><br><br><br><br>\n\n이정도면 논문 리뷰를 위한 사전준비는 끝났다! 다음 포스팅에서는 구체적인 논문 설명과 발표준비 과정을 업로드 하겠다.\n","properties":"\n","discussions":{},"comments":{},"hash":618744251,"tx":119},"PV7SRqnI3929RHIh/syncedContent":{"id":"PV7SRqnI3929RHIh/syncedContent","type":"syncedContent","historyData":{"618744251":{"id":"PV7SRqnI3929RHIh/content","type":"content","text":"---\npermalink: /2022-05-01-MobiSys`21 OESense 논문 리뷰/\npublished : true\ntitle: \"[RA] [논문리뷰] 1. OESense 논문 리뷰 준비 \"\ndate: 2022-05-01 06:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"OESense\"\ncategories:\n- RA\ntags:\n- 논문리뷰\n- OESense\n---\n\n## 나의 첫번째 세미나 논문리뷰\nRA 연구실에 들어가 받은 나의 두번째 과제였다. 내가 들어간 연구실은 Intelligent networking & Computing을 주로 다루는 연구실이고, 무선 네트워킹 관련된 연구를 하고있다. 교수님께서 내주신 논문 리뷰 과제는 **OESense: Employing Occlusion Effect for In-ear Human Sensing** 이라는 논문인데, 이를 읽어보고 관련내용을 공부하고 연합세미나 자리에서 발표를 해야했다.\n\n솔직히 과제를 받은 처음에는 되게 막막한 감정이 컸다. 영어에 자신이 없는건 아니였지만 논문이 전부 영어로 쓰여있고, 접해보지도 못한 주제의 논문이였기에 하나부터 열까지 찾아보고 공부해야 했고, 다른 교수님들도 계신 자리에서 진행해야 하는 발표였기에 많이 떨렸다.\n\n부끄럽지만 나의 첫번째 세미나 논문리뷰 과정을 써보려고 한다. 굉장히 흥미로운 경험이였고 논문리뷰를 하면서 여러가지 배운점이 많았기에 공유해보도록 하겠다!\n<br><br><br><br><br><br> \n      \n\n\n## 논문 간단 소개\n### Motive\n- 무선 이어버드는 단순 엔터네이너적 요소 ( 음악감상, 통화, 영상시청 ) 로 이용되는 것에 그치지 않고 인간의 건강정보와 움직임 정보를 탐지하는데 까지 영역을 확장하고 있다.\n\n- 기존 무선 이어버드에 탑재된 마이크, 가속도계를 사용하여 인간의 동작을 탐지할 수도 있지만, 음악이 재생된 경우 혹은 동작이 작은 경우 기존 이어버드를 통해 동작을 탐지하는데는 어려움이 있다.\n\n- 이어버드를 사용해 더 정확한 **인간 동작 탐지**를 위해 이 논문에서 새로 제시한 개념은 바로 **OESense**이다.\n<br><br><br>\n\n### Introduction\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/OE1.png?raw=true\">\n</p>\n\n**OESense** ( Mic + Occlusion Effect ) 란 이어버드의 **마이크**와 **폐쇄효과**를 결합한 형태의 새로운 이어버드이다. **폐쇄효과는 저주파를 강화시켜 신호를 증폭시키는 효과**를 일으키는데 이를 활용하여 기존 이어버드로는 탐지하기 어려운 **작은동작을 쉽게 탐지**하게 해주고 **주변 노이즈를 제거**할 수 있다.\n\n<br><br><br>\n\n### Application\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/OE2.png?raw=true\">\n</p>\n\n크게 3가지 동작에 대해서 OESense 성능 실험을 진행하고 이를 기존의 이어버드와 비교하여 OESense의 성능을 보인다.\n\n<br><br><br>\n\n논문은 전체적으로는 이런 구조를 보이고 있다. 이어버드를 이용해 인간 동작 탐지를 하는데에 어려움이 존재하고 이를 보완하기 위해 폐쇄효과를 활용한 새로운 형태의 이어버드인 OESense를 제시한다. 폐쇄효과는 저주파 증폭, 노이즈 제거 등의 현상을 일으키기 때문에 상대적으로 작은 동작을 잘 탐지할 수 있고 주변 소음에 방해를 받지 않는다. \n\n<br><br><br><br><br><br>\n\n## 논문 공부를 위한 사전 준비\n\n### 일단 읽자!\n사실 무엇을 먼저 준비해야 할지 몰랐다.. ㅋㅋ 일단 논문부터 읽어보자! 라는 마음가짐으로 논문을 켜고 내 부족한 영어실력을 채워줄 구글번역기를 준비했다..! Introduction, Motivation, Overview.. 천천히 전부 읽어나갔다. 어느정도 이해할 수 있는 정도였지만 완벽하게 이해하기에는 어렵다는 생각이 들었다. 처음보는 개념이였고 폐쇄효과? 라는게 도저히 이해가 안갔다. 그래서 논문을 직접 작성한 컨퍼런스를 찾아봤고 관련 발표 영상을 찾을 수 있었다...!\n\n[https://www.youtube.com/watch?v=RNR1KJtGiaI](https://www.youtube.com/watch?v=RNR1KJtGiaI)\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/OE3.png?raw=true\">\n</p>\n\n논문에 대해서 깊이있게 소개한 영상은 아니였지만 논문이 말하고자 하는바, 전체적인 흐름을 파악하는데 정말 많은 도움이 됐다. 확실히 논문 작성자가 직접 연구한 내용을 발표한 영상이다보니 이해가 잘 되었다. 이 영상을 몇번이나 돌려봤는지 모를정도로 많이 봤던것 같다.. ㅎㅎ\n\n<br><br><br>\n\n### Occlusion Effect ( 폐쇄효과 ) \n이 논문에서 정말 중요한 개념 이였다. OESense 라는 개념이 이어버드 + 폐쇄효과 였기때문에 폐쇄효과가 무엇인지, 어떤 현상인지 정확하게 알 필요가 있었다. \n\n[https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hihearing&logNo=221338808785](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hihearing&logNo=221338808785)\n\n생각보다 논문주제와 전혀 관련없는 블로그에서 폐쇄효과에 대한 감을 잡았다.. ㅋㅋ 보청기 관련 블로그인데 보청기를 착용하면 본인 목소리가 울려서 들리는 현상이 발생할 때가 있는데 이게 폐쇄효과라는 것이다. \n좀더 그 원리에 대해 자세하게 보자.\n1. 성대 혹은 체내에서 생성된 소리나 진동이 공기를 통해서 전달되는게 아니라 뼈와 외이도를 통해 고막에 전달.\n2. 이 때문에 고막의 stiffness가 증가\n3. 이는 저주파수의 임피던스를 증가시켜 저주파수를 증폭\n\n대략 이런 원리인데, 보청기 사용자 입장에서는 폐쇄효과가 저주파수를 증폭시켜 본인의 목소리를 울리기 때문에 사용에 불편을 주는 부작용의 원인인데, 논문에서는 이를 역이용하여 **저주파수 (= 동작이 작은 움직임 )의 증폭**을 통해 **동작이 작은 움직임을 더 잘 탐지**하고 **노이즈를 제거**할 수 있게끔 사용한다는게 굉장히 흥미로웠다.\n\n<br><br><br>\n\n### 수집한 데이터 분석을 위한 Evaluation\n\n논문에서는 수집된 데이터 분석을 위해 머신러닝을 사용했다. Classifier로는 SVM, Logistic Regression, KNN, Decision Tree, Random Forest 가 있고 모델링이 끝난 데이터는 Confusion Matrix, Precision, Recall 등을 이용해 Evaluation을 진행한다.\n\n머신러닝 관련해서는 학부 공부를 통해 알고 있고 관련 포스팅도 올라와있기 때문에 링크를 걸어두겠다!\n\n[https://idkim97.github.io/categories/#machine-learning](https://idkim97.github.io/categories/#machine-learning)\n\n<br><br><br><br><br><br>\n\n이정도면 논문 리뷰를 위한 사전준비는 끝났다! 다음 포스팅에서는 구체적인 논문 설명과 발표준비 과정을 업로드 하겠다.\n","properties":"\n","discussions":{},"comments":{},"hash":618744251}},"syncHistory":{"main":[618744251,null,null]},"v":1,"hash":1710111567159,"tx":119},"jfgRCpZEYsDIHUmY/content":{"id":"jfgRCpZEYsDIHUmY/content","type":"content","text":"---\npermalink: /2022-05-10-백준_2206번/\npublished : true\ntitle: \"[백준] [C/C++] [★] 2206번 : 벽 부수고 이동하기\"\ndate: 2022-05-10 04:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"백준 2206\"\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- BFS\n---\n\n## 문제\nN×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.\n\n만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.\n\n한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.\n\n맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n6 4  \n0100  \n1110  \n1000  \n0000  \n0111  \n0000  \n\n## 예제 출력 1\n15\n\n## 예제 입력 2\n4 4  \n0111  \n1111  \n1111  \n1110  \n\n## 예제 출력 2\n-1\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n어렵다 어려워.. 도저히 모르겠어서 레퍼런스를 찾아보고 풀었다.. 좀더 실력을 키워야 풀 수 있을 것 같다.\n일단 **BFS**로 접근해야 할 것은 분명했다. 다만 벽을 뚫는 경우와 안뚫는 경우를 나눠줄 필요가 있었기에 이를 처리하기 위한 새로운 방법이 필요했다.\n\n<br><br><br>\n\n풀이하면서 몰랐던 요소를 몇가지 먼저 기록해두겠다.\n1. **이중 pair 문법**\n2. **테스트케이스 배열에 띄어쓰기가 없는 경우**\n\n<br><br><br>\n\n\n\n1. 벽을 뚫는 경우와 안뚫는 경우를 구분짓기 위해 3중배열을 사용했는데 이를 queue에 넣기위해서는 pair를 두번 써야만 했다. 근데 정확한 문법이 헷갈려서 좀 헤맸다. 이중 pair를 쓸때는 다음과 같은 문법으로 쓰자!\n\n> **queue <pair<pair<자료형,자료형>,자료형>**\n\n2. 이건 제발좀 기억하자. 테스트 케이스 배열에 띄어쓰기 없이 입력되어 있는 경우 cin >> 으로 받으면 오류가 생긴다. 반드시 scanf를 사용하여 입력받자!!\n\n<br><br><br>\n\n나머지는 일반적인 BFS 풀이 방식으로 풀어주면 된다..\n아직 멀었다 더 연습하자\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint n, m;\nint arr[1001][1001];\nint visit[1001][1001][2]; // 최단거리값\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,1,0,-1 };\n\nint bfs() {\n\tqueue <pair<pair<int, int>, int>> q; // x좌표, y좌표, 벽뚫 유무\n\tq.push({ { 1,1 }, 0 });\n\tvisit[1][1][0] = 1;\n\twhile (!q.empty()) {\n\t\tint x = q.front().first.first;\n\t\tint y = q.front().first.second;\n\t\tint wall = q.front().second;\n\t\tq.pop();\n\n\t\tif (x == n && y == m) return visit[x][y][wall];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (nx >= 1 && nx <= n && ny >= 1 && ny <= m) {\n\t\t\t\t// 벽이 없고 아직 방문하지 않은 경우\n\t\t\t\tif (arr[nx][ny] == 0 && visit[nx][ny][wall] == 0) {\n\t\t\t\t\tvisit[nx][ny][wall] = visit[x][y][wall] + 1;\n\t\t\t\t\tq.push({ { nx,ny }, wall });\n\t\t\t\t}\n\n\t\t\t\t// 벽이 있고 아직 벽을 뚫지 않은 경우\n\t\t\t\tif (arr[nx][ny] == 1 && wall == 0) {\n\t\t\t\t\tvisit[nx][ny][wall + 1] = visit[x][y][wall] + 1;\n\t\t\t\t\tq.push({ {nx,ny}, wall + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%1d\", &arr[i][j]);\n\t\t}\n\t}\n\n\tcout << bfs() << endl;\n\n\t\n\n}\n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1299799938,"tx":121},"jfgRCpZEYsDIHUmY/syncedContent":{"id":"jfgRCpZEYsDIHUmY/syncedContent","type":"syncedContent","historyData":{"-1299799938":{"id":"jfgRCpZEYsDIHUmY/content","type":"content","text":"---\npermalink: /2022-05-10-백준_2206번/\npublished : true\ntitle: \"[백준] [C/C++] [★] 2206번 : 벽 부수고 이동하기\"\ndate: 2022-05-10 04:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"백준 2206\"\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- BFS\n---\n\n## 문제\nN×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.\n\n만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.\n\n한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.\n\n맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n6 4  \n0100  \n1110  \n1000  \n0000  \n0111  \n0000  \n\n## 예제 출력 1\n15\n\n## 예제 입력 2\n4 4  \n0111  \n1111  \n1111  \n1110  \n\n## 예제 출력 2\n-1\n<br><br><br><br><br><br>\n\n## 알고리즘 [ 접근 방법 ]\n\n어렵다 어려워.. 도저히 모르겠어서 레퍼런스를 찾아보고 풀었다.. 좀더 실력을 키워야 풀 수 있을 것 같다.\n일단 **BFS**로 접근해야 할 것은 분명했다. 다만 벽을 뚫는 경우와 안뚫는 경우를 나눠줄 필요가 있었기에 이를 처리하기 위한 새로운 방법이 필요했다.\n\n<br><br><br>\n\n풀이하면서 몰랐던 요소를 몇가지 먼저 기록해두겠다.\n1. **이중 pair 문법**\n2. **테스트케이스 배열에 띄어쓰기가 없는 경우**\n\n<br><br><br>\n\n\n\n1. 벽을 뚫는 경우와 안뚫는 경우를 구분짓기 위해 3중배열을 사용했는데 이를 queue에 넣기위해서는 pair를 두번 써야만 했다. 근데 정확한 문법이 헷갈려서 좀 헤맸다. 이중 pair를 쓸때는 다음과 같은 문법으로 쓰자!\n\n> **queue <pair<pair<자료형,자료형>,자료형>**\n\n2. 이건 제발좀 기억하자. 테스트 케이스 배열에 띄어쓰기 없이 입력되어 있는 경우 cin >> 으로 받으면 오류가 생긴다. 반드시 scanf를 사용하여 입력받자!!\n\n<br><br><br>\n\n나머지는 일반적인 BFS 풀이 방식으로 풀어주면 된다..\n아직 멀었다 더 연습하자\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint n, m;\nint arr[1001][1001];\nint visit[1001][1001][2]; // 최단거리값\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,1,0,-1 };\n\nint bfs() {\n\tqueue <pair<pair<int, int>, int>> q; // x좌표, y좌표, 벽뚫 유무\n\tq.push({ { 1,1 }, 0 });\n\tvisit[1][1][0] = 1;\n\twhile (!q.empty()) {\n\t\tint x = q.front().first.first;\n\t\tint y = q.front().first.second;\n\t\tint wall = q.front().second;\n\t\tq.pop();\n\n\t\tif (x == n && y == m) return visit[x][y][wall];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (nx >= 1 && nx <= n && ny >= 1 && ny <= m) {\n\t\t\t\t// 벽이 없고 아직 방문하지 않은 경우\n\t\t\t\tif (arr[nx][ny] == 0 && visit[nx][ny][wall] == 0) {\n\t\t\t\t\tvisit[nx][ny][wall] = visit[x][y][wall] + 1;\n\t\t\t\t\tq.push({ { nx,ny }, wall });\n\t\t\t\t}\n\n\t\t\t\t// 벽이 있고 아직 벽을 뚫지 않은 경우\n\t\t\t\tif (arr[nx][ny] == 1 && wall == 0) {\n\t\t\t\t\tvisit[nx][ny][wall + 1] = visit[x][y][wall] + 1;\n\t\t\t\t\tq.push({ {nx,ny}, wall + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%1d\", &arr[i][j]);\n\t\t}\n\t}\n\n\tcout << bfs() << endl;\n\n\t\n\n}\n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1299799938}},"syncHistory":{"main":[-1299799938,null,null]},"v":1,"hash":1710111568434,"tx":121},"d9OhY4avzY2oqiLM/content":{"id":"d9OhY4avzY2oqiLM/content","type":"content","text":"---\npermalink: /2022-05-11-백준_10816번/\npublished : true\ntitle: \"[백준] [C/C++] [★] 10816번 : 숫자 카드2\"\ndate: 2022-05-11 21:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"백준 10816\"\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 이분 탐색\n---\n\n## 문제\n\n숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.\n\n셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n10  \n6 3 2 10 10 10 -10 -10 7 3  \n8  \n10 9 -5 2 3 4 5 -10  \n\n## 예제 출력 1\n3 0 0 1 2 0 0 2  \n\n\n## 알고리즘 [ 접근 방법 ]\n정렬 + 이분탐색 문제이다. \n\n[백준 10815번 : 숫자 카드](https://www.acmicpc.net/problem/10815) 문제를 풀고 바로 풀어보았다. 앞선 숫자 카드 문제와 거의 동일한 방식으로 먼저 풀어보고 코드를 일부만 수정해서 풀이 해봤다.\n\n기존문제는 단순히 카드를 가지고 있는지 아닌지 유무만 판단하면 됐지만, 이번 문제는 카드를 가지고 있다면 몇개가지고 있는지 까지 판단할 필요가 있었다. \n\n처음에는 이분 탐색으로 카드를 나눈뒤에 카드를 가지고 있는게 확인 된다면 인덱스값에 +1 혹은 -1을 반복해서 적용한 뒤 몇장의 카드를 가지고 있는지 확인할 수 있게 해봤는데 시간 초과가 발생했다.\n\n주어진 조건이 카드가 최대 500,000장 까지 존재할 수 있어서 이중 반복문을 사용한다면 O(N^2)의 시간복잡도가 발생하기 때문인것 같다.\n\n결국 레퍼런스를 참고했더니 새로운 컨테이너를 사용해서 푸는 문제였다.\n\n<br><br><br>\n\n**lower_bound**\n\n- 찾으려는 **key 값보다 같거나 큰 숫자**가 **배열 혹은 벡터의 몇 번째에서 처음 등장**하는지 찾기 위함\n- **사용 조건** : 배열 혹은 벡터가 **오름차순 정렬** 되어있어야함.\n- **반환** : **처음 등장한 위치의 인덱스값**을 반환한다\n- 배열 : ```lower_bound(arr,arr+n,k)``` (n : 찾으려는 배열크기, k : 찾으려는 숫자)\n- 벡터 : ```lower_bound(arr.begin(),arr.end(),k)```\n\n\n<br><br><br>\n\n**upper_bound**\n\n- 찾으려는 **key값을 초과하는 숫자**가 **몇번째에서 처음 등장**하는지 찾기 위함\n- 사용 조건 : 배열 혹은 벡터가 **오름차순 정렬** 되어있어야함.\n- 반환 : **key를 처음으로 초과하는 숫자가 나오는 위치**의 인덱스 값을 반환한다.\n- - 배열 : ```upper_bound(arr,arr+n,k)``` (n : 찾으려는 배열크기, k : 찾으려는 숫자)\n- 벡터 : ```upper_bound(arr.begin(),arr.end(),k)```\n\n<br><br><br><br><br><br>\n\n\n## 풀이 (시간초과)\n```c++\n#include <iostream>\n#include <algorithm>\n#define MAX 500000\n\nusing namespace std;\n\nint n, m;\nint num[MAX + 1];\nint check[MAX + 1];\nint res[MAX + 1];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> num[i];\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> check[i];\n\t}\n\n\tsort(num, num + n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint left = 0;\n\t\tint right = n - 1;\n\t\tint mid = (left + right) / 2;\n\t\twhile (left <= right) {\n\t\t\tif (check[i] == num[mid]) {\n\t\t\t\tres[i]++;\n\t\t\t\tint temp = mid;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (check[i] == num[temp+1]) {\n\t\t\t\t\t\tres[i]++;\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\ttemp = mid;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (check[i] == num[temp-1]) {\n\t\t\t\t\t\tres[i]++;\n\t\t\t\t\t\ttemp--;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (check[i] > num[mid]) {\n\t\t\t\tleft = mid + 1;\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t}\n\t\t\telse if (check[i] < num[mid]) {\n\t\t\t\tright = mid - 1;\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) cout << res[i] << \" \";\n}\n```\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <algorithm>\n#define MAX 500000\nusing namespace std;\n\nint n, m;\nint num[MAX + 1];\nint check[MAX + 1];\nint res[MAX + 1];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> num[i];\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> check[i];\n\t}\n\n\tsort(num, num + n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tauto u = upper_bound(num, num + n, check[i]);\n\t\tauto l = lower_bound(num, num + n, check[i]);\n\t\tres[i] = u - l;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcout << res[i] << \" \";\n\t}\n}\n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1313762306,"tx":123},"d9OhY4avzY2oqiLM/syncedContent":{"id":"d9OhY4avzY2oqiLM/syncedContent","type":"syncedContent","historyData":{"1313762306":{"id":"d9OhY4avzY2oqiLM/content","type":"content","text":"---\npermalink: /2022-05-11-백준_10816번/\npublished : true\ntitle: \"[백준] [C/C++] [★] 10816번 : 숫자 카드2\"\ndate: 2022-05-11 21:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"백준 10816\"\ncategories:\n- 백준\ntags:\n- 백준\n- 알고리즘\n- 이분 탐색\n---\n\n## 문제\n\n숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.\n<br><br><br><br><br><br>\n\n  \n\n## 입력\n첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.\n\n셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 출력\n첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.\n\n<br><br><br><br><br><br>\n\n  \n\n## 예제 입력 1\n10  \n6 3 2 10 10 10 -10 -10 7 3  \n8  \n10 9 -5 2 3 4 5 -10  \n\n## 예제 출력 1\n3 0 0 1 2 0 0 2  \n\n\n## 알고리즘 [ 접근 방법 ]\n정렬 + 이분탐색 문제이다. \n\n[백준 10815번 : 숫자 카드](https://www.acmicpc.net/problem/10815) 문제를 풀고 바로 풀어보았다. 앞선 숫자 카드 문제와 거의 동일한 방식으로 먼저 풀어보고 코드를 일부만 수정해서 풀이 해봤다.\n\n기존문제는 단순히 카드를 가지고 있는지 아닌지 유무만 판단하면 됐지만, 이번 문제는 카드를 가지고 있다면 몇개가지고 있는지 까지 판단할 필요가 있었다. \n\n처음에는 이분 탐색으로 카드를 나눈뒤에 카드를 가지고 있는게 확인 된다면 인덱스값에 +1 혹은 -1을 반복해서 적용한 뒤 몇장의 카드를 가지고 있는지 확인할 수 있게 해봤는데 시간 초과가 발생했다.\n\n주어진 조건이 카드가 최대 500,000장 까지 존재할 수 있어서 이중 반복문을 사용한다면 O(N^2)의 시간복잡도가 발생하기 때문인것 같다.\n\n결국 레퍼런스를 참고했더니 새로운 컨테이너를 사용해서 푸는 문제였다.\n\n<br><br><br>\n\n**lower_bound**\n\n- 찾으려는 **key 값보다 같거나 큰 숫자**가 **배열 혹은 벡터의 몇 번째에서 처음 등장**하는지 찾기 위함\n- **사용 조건** : 배열 혹은 벡터가 **오름차순 정렬** 되어있어야함.\n- **반환** : **처음 등장한 위치의 인덱스값**을 반환한다\n- 배열 : ```lower_bound(arr,arr+n,k)``` (n : 찾으려는 배열크기, k : 찾으려는 숫자)\n- 벡터 : ```lower_bound(arr.begin(),arr.end(),k)```\n\n\n<br><br><br>\n\n**upper_bound**\n\n- 찾으려는 **key값을 초과하는 숫자**가 **몇번째에서 처음 등장**하는지 찾기 위함\n- 사용 조건 : 배열 혹은 벡터가 **오름차순 정렬** 되어있어야함.\n- 반환 : **key를 처음으로 초과하는 숫자가 나오는 위치**의 인덱스 값을 반환한다.\n- - 배열 : ```upper_bound(arr,arr+n,k)``` (n : 찾으려는 배열크기, k : 찾으려는 숫자)\n- 벡터 : ```upper_bound(arr.begin(),arr.end(),k)```\n\n<br><br><br><br><br><br>\n\n\n## 풀이 (시간초과)\n```c++\n#include <iostream>\n#include <algorithm>\n#define MAX 500000\n\nusing namespace std;\n\nint n, m;\nint num[MAX + 1];\nint check[MAX + 1];\nint res[MAX + 1];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> num[i];\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> check[i];\n\t}\n\n\tsort(num, num + n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint left = 0;\n\t\tint right = n - 1;\n\t\tint mid = (left + right) / 2;\n\t\twhile (left <= right) {\n\t\t\tif (check[i] == num[mid]) {\n\t\t\t\tres[i]++;\n\t\t\t\tint temp = mid;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (check[i] == num[temp+1]) {\n\t\t\t\t\t\tres[i]++;\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\ttemp = mid;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (check[i] == num[temp-1]) {\n\t\t\t\t\t\tres[i]++;\n\t\t\t\t\t\ttemp--;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (check[i] > num[mid]) {\n\t\t\t\tleft = mid + 1;\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t}\n\t\t\telse if (check[i] < num[mid]) {\n\t\t\t\tright = mid - 1;\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) cout << res[i] << \" \";\n}\n```\n\n<br><br><br><br><br><br>\n\n## 풀이\n\n```c++\n#include <iostream>\n#include <algorithm>\n#define MAX 500000\nusing namespace std;\n\nint n, m;\nint num[MAX + 1];\nint check[MAX + 1];\nint res[MAX + 1];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> num[i];\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> check[i];\n\t}\n\n\tsort(num, num + n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tauto u = upper_bound(num, num + n, check[i]);\n\t\tauto l = lower_bound(num, num + n, check[i]);\n\t\tres[i] = u - l;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcout << res[i] << \" \";\n\t}\n}\n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1313762306}},"syncHistory":{"main":[1313762306,null,null]},"v":1,"hash":1710111569779,"tx":123},"wmLsksMuEWVovfap/content":{"id":"wmLsksMuEWVovfap/content","type":"content","text":"---\npermalink: /2022-05-13-스프링 입문_정적컨텐츠/\ntitle: \"[스프링부트] [JAVA] [입문] 2.1 정적컨텐츠\"\ndate: 2022-05-13 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\nSpring으로 웹을 개발한다는 건 크게 3가지 정도로 나눌 수 있다.\n\n> 첫번째로 **정적 컨텐츠**  \n> 두번째로 **MVC와 템플릿엔진**  \n> 세번째로 **API**  \n\n오늘은 **정적 컨텐츠**에 대해 알아보고 공부해보도록 하겠다!\n<br><br><br><br><br><br>\n\n## 정적 컨텐츠\n- 정적 컨텐츠는 말 그대로 멈춰있는 웹 페이지를 말한다. \n- 우리가 작성한 html 파일을 그대로 사용자에게 전달해줘서 보여준다.\n- 서버에서 별 다른 작업 없이 html 파일을 그대로 전달해준다.\n- Spring boot에서는 static resource에 대한 기본 매핑 설정과 커스텀을 지원해준다.\n- Spring Boot의 [관련 레퍼런스 참고](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content)\n\n<br><br><br>\n\n**[```resources/static/hello-static.html```]**\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n    <title>static content</title>\n\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n</head>\n\t<body>\n\t\t정적 컨텐츠 입니다.\n\t</body>\n</html>\n```\n\n<br><br><br>\n**실행**  \nhttp://localhost:8080/hello-static.html\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/static1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n### 정적 컨텐츠 동작 환경\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/static2.png?raw=true\">\n</p>\n\n1. 웹브라우저에 http://localhost:8080/hello-static.html 을 입력한다. ( 일반적으로는 hello-static.html 자리에 본인의 파일명을 넣어주면 된다)\n2. **내장 톰켓 서버**에서 요청을 받는다.\n3. 스프링에서는 먼저 **관련 컨트롤러** (hello-static)가 존재하는지 확인한다.\n4. 관련 컨트롤러가 없으므로 ```resources/static/hello-static.html``` 에 접근해서 파일을 가져온다.\n5. ```hello-static.html```을 웹 브라우저에 띄워준다!\n\n<br><br><br><br><br><br>\n\n여기까지 **[스프링부트] [JAVA] [입문] 2. 정적컨텐츠** 포스팅을 마치겠습니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-843394477,"tx":125},"ATRuUFMbG6IBvDuO/content":{"id":"ATRuUFMbG6IBvDuO/content","type":"content","text":"---\npermalink: /2022-05-18-스프링 입문_MVC/\ntitle: \"[스프링부트] [JAVA] [입문] 2.2 MVC와 템플릿 엔진\"\ndate: 2022-05-14 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><Br>\n\nSpring으로 웹을 개발한다는 건 크게 3가지 정도로 나눌 수 있다.\n\n> 첫번째로 [**정적 컨텐츠**](https://idkim97.github.io/2022-05-13-%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%9E%85%EB%AC%B8_%EC%A0%95%EC%A0%81%EC%BB%A8%ED%85%90%EC%B8%A0/)  \n> 두번째로 **MVC와 템플릿엔진**  \n> 세번째로 **API**  \n\n오늘은 **MVC**에 대해 간단하게 알아보고 공부해보도록 하겠다!\n<br><br><br>\n\n## Model 이란?\n- **Model**은 HashMap 형태를 갖고 있으며 **<key,value>** 값을 가지고 있습니다.\n- ```addAttribute()```와 같은 기능을 통해 **모델에 원하는 key,value 값을** 주어 **View에 데이터를 전달**할 수 있습니다.\n- Controller의 메서드에 Model이라는 타입을 파라미터로 지정할 수 있습니다.\n\n<br><br><br><br><br><br>\n\n## View란?\n- View는 그냥 사용자가 보는 화면이라고 생각하면 편하다\n- Model에 필요한 데이터를 담아서 Controller에 전달하면 Spring에서는 viewResolver를 통해 템플릿 엔진 처리를 한 뒤 html로 변환하여 웹 브라우저에 보여준다.\n\n<br><br><br><br><br><br>\n\n\n## Controller란?\n- 컨트롤러는 사용자의 요청이 진입하는 지점이라고 볼 수 있다.\n- 요청에 따라 어떤 처리를 할지 결정해주는데, 컨트롤러는 결정만 해주고 실직적인 처리는 서비스(Layered Architecture)에서 담당한다.\n- 사용자에게 View를 응답으로 보내준다!\n\n<br><br><br><br><br><br>\n\n## MVC를 이용한 실제 동작과정\n\n[ ```HelloController``` ]\n\n```java\n@GetMapping(\"hello-mvc\")\n    public String helloMvc(@RequestParam(\"name\") String name, Model model){\n        model.addAttribute(\"name\",name); // \"name\"은 key, name은 파라미터의 String name\n        return \"hello-template\";\n    }\n```\n\n\n- 컨트롤러에서 @GetMapping을 통해 url설정을 해주고, 메소드에 **@RequestParam(\"name\")** 을 통해 name이라는 파라미터를 받도록 설정하고 String name과 Model 변수를 선언했습니다. \n- 그리고 model의 key값을 name으로 받고, String name을 넣어줬습니다.\n- return은 hello-template.html로 설정했습니다.\n\n<br><br><br>\n\n[ ```hello-template.html``` ]\n\n\n```html\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<p th:text=\"'hello ' + ${name}\">hello! empty</p>\n</body></html>\n```\n\n- hello-template에서는 기본적으로 서버에서 어떤 작동없이, 즉 RequestParam(\"name\")을 넘겨받지 못한다면 ```hello! empty``` 를 출력합니다.\n- name에 값이 들어온다면 ```hello [name]``` 이 출력됩니다.\n\n<br><br><br>\n\n[ ```name에 값을 받지 않은 경우```] \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc1.png?raw=true\">\n</p>\n\n<br><br><br>\n그런데 helloMVC 메소드는 RequestParam(\"name\")을 파라미터로 갖고 있기 때문에 name을 받지 못한 경우 오류가 발생합니다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc2.png?raw=true\">\n</p>\n\n- 분명 ```localhost:8080/hello-mvc``` 를 제대로 입력했는데 오류가 납니다.\n- 해결방법은 생각보다 간단합니다.\n\n<br><br><br>\n\n## @RequestParam\n\n**[ name = Spring HAHA 로 설정 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc3.png?raw=true\">\n</p>\n\n- ```localhost:8080/hello-string``` 뒤에 ```?name=[name의 value]``` 을 입력해주면 끝입니다!\n- 위 그림에서는 ```?name=Spring HAHA``` 를 입력했기 때문에 **helloSpring HAHA** 라는 문자가 출력되었습니다.\n\n<br><br><br>\n\n**[ name = spring!!!!! 로 설정 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc4.png?raw=true\">\n</p>\n\n- 이 그림에서는 ```?name=spring!!!!!``` 을 입력했기 때문에 **hello spring!!!!!** 라는 문자가 출력되었습니다.\n- 위 두 그림 모두에서 name에 값을 넣어줬더니 화면에 name이 그대로 출력된것을 볼 수 있습니다.\n\n```html \n<p th:text=\"'hello ' + ${name}\">hello! empty</p>\n```\n\n- ```hello-template.html``` 에서 넣어준 위 코드 때문에 화면에는 ***hello***  ***+ [name]*** 이 출력된다고 볼 수 있습니다.\n\n\n<br><br><br><br><br><br>\n\n## MVC 동작 환경\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc6.png?raw=true\">\n</p>\n\n- 웹브라우저에서 ```localhost:8080/hello-mvc``` 를 넘겨준다.\n- 내장 톰켓 서버에서 넘겨받은 주소를 스프링에 던져준다.\n- ```hello-mvc``` 가 매핑되어 있는 **helloController**에서 이를 받고 ```hello-template.html``` 을 return해준다.\n- 이때 **@RequestParam** 으로 받은 name을 모델에 같이 전달해준다. ( 여기서는 name = spring 으로 설정 )\n- 이를 받은 viewResolver가 view를 찾아주고 템플릿엔진을 연결해준다.\n- 이를 웹브라우저에 다시 보내서 화면에 띄워준다!\n\n<br><br><br><br><br><br>\n\n여기까지 **[스프링부트] [JAVA] [입문] 3. MVC와 템플릿 엔진** 포스팅을 마치겠습니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-806935517,"tx":127},"ATRuUFMbG6IBvDuO/syncedContent":{"id":"ATRuUFMbG6IBvDuO/syncedContent","type":"syncedContent","historyData":{"-806935517":{"id":"ATRuUFMbG6IBvDuO/content","type":"content","text":"---\npermalink: /2022-05-18-스프링 입문_MVC/\ntitle: \"[스프링부트] [JAVA] [입문] 2.2 MVC와 템플릿 엔진\"\ndate: 2022-05-14 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><Br>\n\nSpring으로 웹을 개발한다는 건 크게 3가지 정도로 나눌 수 있다.\n\n> 첫번째로 [**정적 컨텐츠**](https://idkim97.github.io/2022-05-13-%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%9E%85%EB%AC%B8_%EC%A0%95%EC%A0%81%EC%BB%A8%ED%85%90%EC%B8%A0/)  \n> 두번째로 **MVC와 템플릿엔진**  \n> 세번째로 **API**  \n\n오늘은 **MVC**에 대해 간단하게 알아보고 공부해보도록 하겠다!\n<br><br><br>\n\n## Model 이란?\n- **Model**은 HashMap 형태를 갖고 있으며 **<key,value>** 값을 가지고 있습니다.\n- ```addAttribute()```와 같은 기능을 통해 **모델에 원하는 key,value 값을** 주어 **View에 데이터를 전달**할 수 있습니다.\n- Controller의 메서드에 Model이라는 타입을 파라미터로 지정할 수 있습니다.\n\n<br><br><br><br><br><br>\n\n## View란?\n- View는 그냥 사용자가 보는 화면이라고 생각하면 편하다\n- Model에 필요한 데이터를 담아서 Controller에 전달하면 Spring에서는 viewResolver를 통해 템플릿 엔진 처리를 한 뒤 html로 변환하여 웹 브라우저에 보여준다.\n\n<br><br><br><br><br><br>\n\n\n## Controller란?\n- 컨트롤러는 사용자의 요청이 진입하는 지점이라고 볼 수 있다.\n- 요청에 따라 어떤 처리를 할지 결정해주는데, 컨트롤러는 결정만 해주고 실직적인 처리는 서비스(Layered Architecture)에서 담당한다.\n- 사용자에게 View를 응답으로 보내준다!\n\n<br><br><br><br><br><br>\n\n## MVC를 이용한 실제 동작과정\n\n[ ```HelloController``` ]\n\n```java\n@GetMapping(\"hello-mvc\")\n    public String helloMvc(@RequestParam(\"name\") String name, Model model){\n        model.addAttribute(\"name\",name); // \"name\"은 key, name은 파라미터의 String name\n        return \"hello-template\";\n    }\n```\n\n\n- 컨트롤러에서 @GetMapping을 통해 url설정을 해주고, 메소드에 **@RequestParam(\"name\")** 을 통해 name이라는 파라미터를 받도록 설정하고 String name과 Model 변수를 선언했습니다. \n- 그리고 model의 key값을 name으로 받고, String name을 넣어줬습니다.\n- return은 hello-template.html로 설정했습니다.\n\n<br><br><br>\n\n[ ```hello-template.html``` ]\n\n\n```html\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<p th:text=\"'hello ' + ${name}\">hello! empty</p>\n</body></html>\n```\n\n- hello-template에서는 기본적으로 서버에서 어떤 작동없이, 즉 RequestParam(\"name\")을 넘겨받지 못한다면 ```hello! empty``` 를 출력합니다.\n- name에 값이 들어온다면 ```hello [name]``` 이 출력됩니다.\n\n<br><br><br>\n\n[ ```name에 값을 받지 않은 경우```] \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc1.png?raw=true\">\n</p>\n\n<br><br><br>\n그런데 helloMVC 메소드는 RequestParam(\"name\")을 파라미터로 갖고 있기 때문에 name을 받지 못한 경우 오류가 발생합니다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc2.png?raw=true\">\n</p>\n\n- 분명 ```localhost:8080/hello-mvc``` 를 제대로 입력했는데 오류가 납니다.\n- 해결방법은 생각보다 간단합니다.\n\n<br><br><br>\n\n## @RequestParam\n\n**[ name = Spring HAHA 로 설정 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc3.png?raw=true\">\n</p>\n\n- ```localhost:8080/hello-string``` 뒤에 ```?name=[name의 value]``` 을 입력해주면 끝입니다!\n- 위 그림에서는 ```?name=Spring HAHA``` 를 입력했기 때문에 **helloSpring HAHA** 라는 문자가 출력되었습니다.\n\n<br><br><br>\n\n**[ name = spring!!!!! 로 설정 ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc4.png?raw=true\">\n</p>\n\n- 이 그림에서는 ```?name=spring!!!!!``` 을 입력했기 때문에 **hello spring!!!!!** 라는 문자가 출력되었습니다.\n- 위 두 그림 모두에서 name에 값을 넣어줬더니 화면에 name이 그대로 출력된것을 볼 수 있습니다.\n\n```html \n<p th:text=\"'hello ' + ${name}\">hello! empty</p>\n```\n\n- ```hello-template.html``` 에서 넣어준 위 코드 때문에 화면에는 ***hello***  ***+ [name]*** 이 출력된다고 볼 수 있습니다.\n\n\n<br><br><br><br><br><br>\n\n## MVC 동작 환경\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mvc6.png?raw=true\">\n</p>\n\n- 웹브라우저에서 ```localhost:8080/hello-mvc``` 를 넘겨준다.\n- 내장 톰켓 서버에서 넘겨받은 주소를 스프링에 던져준다.\n- ```hello-mvc``` 가 매핑되어 있는 **helloController**에서 이를 받고 ```hello-template.html``` 을 return해준다.\n- 이때 **@RequestParam** 으로 받은 name을 모델에 같이 전달해준다. ( 여기서는 name = spring 으로 설정 )\n- 이를 받은 viewResolver가 view를 찾아주고 템플릿엔진을 연결해준다.\n- 이를 웹브라우저에 다시 보내서 화면에 띄워준다!\n\n<br><br><br><br><br><br>\n\n여기까지 **[스프링부트] [JAVA] [입문] 3. MVC와 템플릿 엔진** 포스팅을 마치겠습니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-806935517}},"syncHistory":{"main":[-806935517,null,null]},"v":1,"hash":1710111572239,"tx":127},"CVoMq6D4LAjPbCG5/content":{"id":"CVoMq6D4LAjPbCG5/content","type":"content","text":"---\npermalink: /2022-05-18-스프링 입문_API/\ntitle: \"[스프링부트] [JAVA] [입문] 2.3 API : @ResponseBody\"\ndate: 2022-05-15 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><br>\n\nSpring으로 웹을 개발한다는 건 크게 3가지 정도로 나눌 수 있다.\n\n> 첫번째로 [**정적 컨텐츠**](https://idkim97.github.io/2022-05-13-%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%9E%85%EB%AC%B8_%EC%A0%95%EC%A0%81%EC%BB%A8%ED%85%90%EC%B8%A0/)  \n> 두번째로 [**MVC와 템플릿엔진**](https://idkim97.github.io/2022-05-18-%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%9E%85%EB%AC%B8_MVC/)  \n> 세번째로 **API**  \n\n오늘은 **API**에 대해 간단하게 알아보고 공부해보도록 하겠다!\n<br><br><br><br><br><br>\n\n## @ResponseBody\n\n우리가 일반적으로 컨트롤러를 만들어 사용할 때, viewResolver에 의해 return 값으로 반환하는 문자열은 view 페이지를 의미한다.\n\n```java\n@Controller\npublic class HelloController {\n    @GetMapping(\"hello\")\n    public String hello(Model model) {\n        model.addAttribute(\"data\", \"hello!!\");\n        return \"hello\";\n    }\n}\n```\n위 코드에서는 hello 라는 페이지를 return 하는것이다.\n\n<br><br><br><br><br><br>\n\n## @ResponseBody 문자 반환\n\n그런데 만약 View페이지가 아닌 문자열 그대로를 return하고 싶은경우에는 **```@ResponseBody```** 를 사용하면 된다.\n\n```java\n@GetMapping(\"hello-string\")\n    @ResponseBody\n    public String helloString(@RequestParam(\"name\") String name){\n        return \"hello\" + name;\n    }\n```\n**@ResponseBody** 어노테이션을 달아준 코드이다.\n\n<br><br><br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/api1.png?raw=true\">\n</p>\n**name=Spring HAHA** 라고 지정하고 실행을 하면 return 값인 **helloSpring HAHA** 가 그대로 출력되는것을 볼 수 있다.\n\n<br><br><br>\n\n- **@ResponseBody 를 사용하면 viewResolver 를 사용하지 않는다.**  \n- **대신 HTTP의 BODY에 문자내용을 직접 반환 한다.**  \n\n<br><br><br><br><br><br>\n\n## @ResponseBody 객체 반환\n\n```java\n@GetMapping(\"hello-api\")\n    @ResponseBody\n    public Hello helloApi(@RequestParam(\"name\") String name){\n        // json 방식으로 key-value값을 전달\n        // 최근에는 거의 json방식을 많이 사용\n        Hello hello = new Hello();\n        hello.setName(name);\n        return hello;\n    }\n\n\t// 객체생성\n    static class Hello{\n        private String name;\n\n        // getter setter 단축키 : Alt+Insert\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n```\n\n<br><br><br>\n **결과 :** **[```localhost:8080/hello-api?name=Spring HAHA```]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/api2.png?raw=true\">\n</p>\n\n@ResponseBody 태그를 사용해서 객체를 담아준뒤 반환해준 결과이다.\n객체를 반환하면 **json** 방식으로 값을 반환해주는데 **<key,value>** 구조라고 생각하면 된다. \n**최근에는 거의 json 방식을 사용해서 객체를 반환한다!!**\n\n<br><br><br><br><br><br>\n\n## ResponseBody 동작 환경\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/api3.png?raw=true\">\n</p>\n\n- 컨트롤러에서 viewResolver 대신에 **HttpMessageConverter** 가 동작한다.\n- 기본 문자 처리 : ```StringHttpMessageConverter```\n- 기본 객체 처리 : ```MappingJackson2HttpMessageConverter```\n- byte 처리 등등 기타 여러 HttpMessageConverter 가 기본으로 등록되어 있다.\n- 일단 이런게 있다 정도만 알아두고 넘어가자!\n\n\n<br><br><br><br><br><br>\n\n여기까지 **[스프링부트] [JAVA] [입문] 4. API** 포스팅을 마치겠습니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-935658516,"tx":129},"CVoMq6D4LAjPbCG5/syncedContent":{"id":"CVoMq6D4LAjPbCG5/syncedContent","type":"syncedContent","historyData":{"-935658516":{"id":"CVoMq6D4LAjPbCG5/content","type":"content","text":"---\npermalink: /2022-05-18-스프링 입문_API/\ntitle: \"[스프링부트] [JAVA] [입문] 2.3 API : @ResponseBody\"\ndate: 2022-05-15 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><br>\n\nSpring으로 웹을 개발한다는 건 크게 3가지 정도로 나눌 수 있다.\n\n> 첫번째로 [**정적 컨텐츠**](https://idkim97.github.io/2022-05-13-%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%9E%85%EB%AC%B8_%EC%A0%95%EC%A0%81%EC%BB%A8%ED%85%90%EC%B8%A0/)  \n> 두번째로 [**MVC와 템플릿엔진**](https://idkim97.github.io/2022-05-18-%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%9E%85%EB%AC%B8_MVC/)  \n> 세번째로 **API**  \n\n오늘은 **API**에 대해 간단하게 알아보고 공부해보도록 하겠다!\n<br><br><br><br><br><br>\n\n## @ResponseBody\n\n우리가 일반적으로 컨트롤러를 만들어 사용할 때, viewResolver에 의해 return 값으로 반환하는 문자열은 view 페이지를 의미한다.\n\n```java\n@Controller\npublic class HelloController {\n    @GetMapping(\"hello\")\n    public String hello(Model model) {\n        model.addAttribute(\"data\", \"hello!!\");\n        return \"hello\";\n    }\n}\n```\n위 코드에서는 hello 라는 페이지를 return 하는것이다.\n\n<br><br><br><br><br><br>\n\n## @ResponseBody 문자 반환\n\n그런데 만약 View페이지가 아닌 문자열 그대로를 return하고 싶은경우에는 **```@ResponseBody```** 를 사용하면 된다.\n\n```java\n@GetMapping(\"hello-string\")\n    @ResponseBody\n    public String helloString(@RequestParam(\"name\") String name){\n        return \"hello\" + name;\n    }\n```\n**@ResponseBody** 어노테이션을 달아준 코드이다.\n\n<br><br><br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/api1.png?raw=true\">\n</p>\n**name=Spring HAHA** 라고 지정하고 실행을 하면 return 값인 **helloSpring HAHA** 가 그대로 출력되는것을 볼 수 있다.\n\n<br><br><br>\n\n- **@ResponseBody 를 사용하면 viewResolver 를 사용하지 않는다.**  \n- **대신 HTTP의 BODY에 문자내용을 직접 반환 한다.**  \n\n<br><br><br><br><br><br>\n\n## @ResponseBody 객체 반환\n\n```java\n@GetMapping(\"hello-api\")\n    @ResponseBody\n    public Hello helloApi(@RequestParam(\"name\") String name){\n        // json 방식으로 key-value값을 전달\n        // 최근에는 거의 json방식을 많이 사용\n        Hello hello = new Hello();\n        hello.setName(name);\n        return hello;\n    }\n\n\t// 객체생성\n    static class Hello{\n        private String name;\n\n        // getter setter 단축키 : Alt+Insert\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n```\n\n<br><br><br>\n **결과 :** **[```localhost:8080/hello-api?name=Spring HAHA```]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/api2.png?raw=true\">\n</p>\n\n@ResponseBody 태그를 사용해서 객체를 담아준뒤 반환해준 결과이다.\n객체를 반환하면 **json** 방식으로 값을 반환해주는데 **<key,value>** 구조라고 생각하면 된다. \n**최근에는 거의 json 방식을 사용해서 객체를 반환한다!!**\n\n<br><br><br><br><br><br>\n\n## ResponseBody 동작 환경\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/api3.png?raw=true\">\n</p>\n\n- 컨트롤러에서 viewResolver 대신에 **HttpMessageConverter** 가 동작한다.\n- 기본 문자 처리 : ```StringHttpMessageConverter```\n- 기본 객체 처리 : ```MappingJackson2HttpMessageConverter```\n- byte 처리 등등 기타 여러 HttpMessageConverter 가 기본으로 등록되어 있다.\n- 일단 이런게 있다 정도만 알아두고 넘어가자!\n\n\n<br><br><br><br><br><br>\n\n여기까지 **[스프링부트] [JAVA] [입문] 4. API** 포스팅을 마치겠습니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-935658516}},"syncHistory":{"main":[-935658516,null,null]},"v":1,"hash":1710111573444,"tx":129},"1N5zQwL2CvCdrU9B/content":{"id":"1N5zQwL2CvCdrU9B/content","type":"content","text":"# Studium\n> Studium is study helper program that using Drowsiness Detection and OpenPose with gif files.  \nTo prevent drowsiness when studying we add gaming point using stickers and motion estimate.  \nWe hope this program will help you concentrate on studies Not perfect now.\n\n\n<br><br><br>\n## Table of Contents\n- **Drowsiness Detection**\n\t- Using the EAR algorithm\n\t- Detect when your eyes are closed for a certain amount of time\n\t- Alerts you when drowsiness is detected\n\n- **Timer**\n\t-   Play timer with drowsiness detection\n\t- Study time can be checked\n\n- **PyQT Widget**\n\t- Play widget when drowsiness is detected\n\t- Can be deleted by clicking on the widget\n\t-   A type of activity for waking up from drowsiness\n\n<br><br><br>\n\n\n\n\n## How to install\n**Development Environment**\n\n> Python version : Python 3.9\n> Opencv_python_4.5.5.64\n> PyQT5_5.15.4\n> PyQTDesigner_5.14.1\n\n**※ You have to use WebCam for Studium**\n\n<br><br><br>\n\n## Example of Use\n\n**[ Main Screen ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/studium1.png?raw=true\">\n</p>\n\n\n<br><br><br>\n\n**[ Timer ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/studium2.png?raw=true\">\n</p>\n\n<br><br><br>\n\n\n**[ Drowsiness Detection ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/studium3.png?raw=true\">\n</p>\n\n<br><br><br>\n\n**[ Widget ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/studium4.png?raw=true\">\n</p>\n\n\n\n<br><br><br>\n\n## Team Member Role\n- 201735818 김연수 ( [https://github.com/idkim97](https://github.com/idkim97) )\n- 201835493 이승규 ( [https://github.com/vbnm134678](https://github.com/idkim97) )\n\n","properties":"\n","discussions":{},"comments":{},"hash":-993497552,"tx":131},"1N5zQwL2CvCdrU9B/syncedContent":{"id":"1N5zQwL2CvCdrU9B/syncedContent","type":"syncedContent","historyData":{"-993497552":{"id":"1N5zQwL2CvCdrU9B/content","type":"content","text":"# Studium\n> Studium is study helper program that using Drowsiness Detection and OpenPose with gif files.  \nTo prevent drowsiness when studying we add gaming point using stickers and motion estimate.  \nWe hope this program will help you concentrate on studies Not perfect now.\n\n\n<br><br><br>\n## Table of Contents\n- **Drowsiness Detection**\n\t- Using the EAR algorithm\n\t- Detect when your eyes are closed for a certain amount of time\n\t- Alerts you when drowsiness is detected\n\n- **Timer**\n\t-   Play timer with drowsiness detection\n\t- Study time can be checked\n\n- **PyQT Widget**\n\t- Play widget when drowsiness is detected\n\t- Can be deleted by clicking on the widget\n\t-   A type of activity for waking up from drowsiness\n\n<br><br><br>\n\n\n\n\n## How to install\n**Development Environment**\n\n> Python version : Python 3.9\n> Opencv_python_4.5.5.64\n> PyQT5_5.15.4\n> PyQTDesigner_5.14.1\n\n**※ You have to use WebCam for Studium**\n\n<br><br><br>\n\n## Example of Use\n\n**[ Main Screen ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/studium1.png?raw=true\">\n</p>\n\n\n<br><br><br>\n\n**[ Timer ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/studium2.png?raw=true\">\n</p>\n\n<br><br><br>\n\n\n**[ Drowsiness Detection ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/studium3.png?raw=true\">\n</p>\n\n<br><br><br>\n\n**[ Widget ]**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/studium4.png?raw=true\">\n</p>\n\n\n\n<br><br><br>\n\n## Team Member Role\n- 201735818 김연수 ( [https://github.com/idkim97](https://github.com/idkim97) )\n- 201835493 이승규 ( [https://github.com/vbnm134678](https://github.com/idkim97) )\n\n","properties":"\n","discussions":{},"comments":{},"hash":-993497552}},"syncHistory":{"main":[-993497552,null,null]},"v":1,"hash":1710111574326,"tx":131},"JbeDoZUm857e8fdL/content":{"id":"JbeDoZUm857e8fdL/content","type":"content","text":"---\npermalink: /2022-05-31-프로그래머스_위장/\npublished : true\ntitle: \"[프로그래머스] [C/C++] [★] 위장\"\ndate: 2022-05-11 21:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"프로그래머스_위장\"\ncategories:\n- 프로그래머스\ntags:\n- 프로그래머스\n- 알고리즘\n- 문자열\n- Hash\n- Map\n---\n\n## 문제\n\n스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n\n\n| 종류 | 이름 |\n|--|--|\n| 얼굴 | 동그란 안경, 검정 선글라스 |\n|상의\t|파란색 티셔츠|\n|  하의|  청바지|\n|겉옷 |긴 코트 |\n\n\n스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.\n<br><br><br><br><br><br>\n\n## 제한사항\n-   clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.\n-   스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.\n-   같은 이름을 가진 의상은 존재하지 않습니다.\n-   clothes의 모든 원소는 문자열로 이루어져 있습니다.\n-   모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 '_' 로만 이루어져 있습니다.\n-   스파이는 하루에 최소 한 개의 의상은 입습니다.\n\n  <br><br><br><br><br><br>\n\n\n## 입출력 예 설명 \n**예제 #1**\nheadgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.\n\n```\n1. yellow_hat\n2. blue_sunglasses\n3. green_turban\n4. yellow_hat + blue_sunglasses\n5. green_turban + blue_sunglasses\n```\n\n<br><br><br>\n\n**예제 #2**  \nface에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.\n```\n1. crow_mask\n2. blue_sunglasses\n3. smoky_makeup\n```\n\n\n  \n\n\n<br><br><br><br><br><br>\n\n\n## 알고리즘 [ 접근 방법 ]\n\n**Map + 범위기반 for문**을 활용한 문제이다.\n문제를 보자마자 이번 라인 인턴 코딩테스트에서 본 문제와 거의 흡사하다는 사실을 알았다.\n이거 풀어보고 코테봤으면 바로 풀었을텐데.. 하는 아쉬움이 많이 남는다. 바로 풀어보자!\n<br><br><br>\n\n**Map은 Key-value pair를 가지고 중복을 허용하지 않으며 자동으로 오름차순 정렬이 된다.**\n\n<br><br><br>\n이를 활용해 종류별 옷의 개수를 세어준 뒤 조합의 개수를 세어주기만 하면 된다.\n예를 들어 상의가 셔츠, 맨투맨, 나시 3가지가 있는 경우 \n\n> 셔츠  \n> 맨투맨  \n> 나시  \n> 아무것도 안입는 경우  \n\n이렇게 총 4가지로 나누어 고려해주면 된다.\n\n\n\n<br><br><br><br><br><br>\n\n\n## 풀이\n```c++\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n// 종류별 의상이 몇개인지 파악\n\n// 의상 종류가 3가지다\n// 안입는 경우 + 1가지만 입는경우 + 2가지만 입는경우 + 3가지 다입는경우\n// 의상 종류가 n가지다\n// 안입는 경우 + 1가지만 입는경우 + 2가지만 입는경우 + .. + n가지 입는경우\n\nint solution(vector<vector<string>> clothes) {\n    int answer = 1;\n    \n    // map은 key-value pair를 가지고 오름차순 정렬됨, 중복 허용 x\n    map <string,int> list;\n    \n    for(int i=0;i<clothes.size();i++){\n        list[clothes[i][1]]++;\n    }\n    \n    for (auto it : list){\n        answer *= (it.second+1);\n    }\n    answer -=1;\n    \n    return answer;\n}\n```\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1535631988,"tx":133},"fklYIJyOheHqvfTa/content":{"id":"fklYIJyOheHqvfTa/content","type":"content","text":"---\npermalink: /2022-06-02-Map/\npublished : true\ntitle: \"[C++] [STL] Map \"\ndate: 2022-06-02 07:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Map 과 Unordered_map\"\ncategories:\n- STL\ntags:\n- C++\n- STL\n- Map\n- Unordered Map\n---\n\n## Goal\n\n> Map과 Unordered Map에 대해서 알아본다.\n> Map과 Unordered Map의 사용방법\n> Map과 Unordered Map의 구현\n\n<br><br><br><br><br><br>\n\n## Map이란?\n\n- Map은 각 노드가 key-value 쌍으로 이루어진 트리이다.\n- first,second가 있는 pair 객체로 저장된다.\n- 검색, 삽입, 삭제가 O(logn)인 레드블랙트리로 구성됐다.\n\n\n<br><br><br><br><br><br>\n\n## Map 특징\n- 내부에서 자동으로 **오름차순 정렬** 된다.\n- **중복을 허용하지 않는다.**\n- **범위기반 for문**과 같이 사용되는 경우가 많다.\n\n<br><br><br><br><br><br>\n\n## Map 사용방법\n\n1) 헤더 포함\n```#include <map>``` 을 포함해야 합니다.\n\n<br><br><br>\n\n2) map 선언\nmap의 기본구조는  ```map <key type, value type> 이름``` 입니다.\n<br><br><br>\n3) 정렬\nmap은 기본적으로 **key값을 기준**으로 **오름차순 정렬** 합니다.\n**내림차순 정렬**을 원하는 경우 ```map<key,value,greater> m;``` 으로 선언해주면 됩니다.\n\n<br><br>\n\n### Value값을 기준으로 정렬하고 싶은 경우 !!!\n\n1) **map을 vector로 이동**  \n```c++\nvector<pair<string,int>> vec(m.begin(),m.end());\n```\n\n2) **비교 함수 작성 ( 오름차순 )**  \n```c++\nbool cmp(const pair<string,int> &a, const pair<string,int> &b){\n\treturn a.second < b.second;\n}\n```\n\n3) **vector를 second(value) 기준으로 정렬**\n```c++\nbool cmp(const pair<string,int> &a, const pair<string,int> &b){\n\treturn a.second < b.second;\n}\n\nmap<string,int> m;\nvector<pair<string,int>> vec(m.begin(),m.end());\n\nsort(vec.begin(),vec.end(),cmp);\n```\n\n<br><br><br>\n\n4. Map에 데이터 삽입\nmap은 중복을 허용하지 않으므로 insert를 수행할 때, key가 중복되면 insert를 수행하지 않습니다. \n```c++\nm.insert({\"student\",50});\n```\n\n<br><br><br>\n\n5. 범위기반 반복문\nmap은 key나 value값에 문자열이 들어가는 경우가 많아 범위기반 반복문과 같이 자주 사용됩니다.\n```c++\nfor(auto it : m){\n\tif (it.second > max) {\n                max = it.second;\n                genre = it.first;\n            }\n}\n```\n\n\n<br> <br> <br><br> <br> <br>\n\n## Map 실제 사용 예제\n```c++\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nvector<int> solution(vector<string> genres, vector<int> plays) {\n    vector<int> answer;\n    map <string, int> music; // 장르별 재생횟수 저장\n    map <string, map<int, int>> mlist; // 장르별 무슨노래가 몇번 들렸는지\n\n    for (int i = 0; i < genres.size(); i++) {\n\n        music[genres[i]] += plays[i];\n        mlist[genres[i]][i] = plays[i];\n    }\n\n    while (music.size() > 0) {\n        int max = 0;\n        string genre = \"\";\n        for (auto mu : music) {\n            if (mu.second > max) {\n                max = mu.second;\n                genre = mu.first;\n            }\n        }\n\n        for (int i = 0; i < 2; i++) {\n            int val = 0;\n            int idx = -1;\n            for (auto ml : mlist[genre]) {\n                if (ml.second > val) {\n                    val = ml.second;\n                    idx = ml.first;\n                }\n            }\n            if (idx == -1) break;\n\n            answer.push_back(idx);\n            mlist[genre].erase(idx);\n        }\n        music.erase(genre);\n    }\n    return answer;\n}\n```\n\n<br> <br> <br><br> <br> <br>\n\n## unordered_map\n- hash-table 기반의 hash 컨테이너 이다.\n- 따라서 **정렬하지 않은 map** 이라고 생각하면 쉽다.\n- ```#include <unordered_map>``` 의 헤더를 포함해야 한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-2042661254,"tx":135},"fklYIJyOheHqvfTa/syncedContent":{"id":"fklYIJyOheHqvfTa/syncedContent","type":"syncedContent","historyData":{"-2042661254":{"id":"fklYIJyOheHqvfTa/content","type":"content","text":"---\npermalink: /2022-06-02-Map/\npublished : true\ntitle: \"[C++] [STL] Map \"\ndate: 2022-06-02 07:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Map 과 Unordered_map\"\ncategories:\n- STL\ntags:\n- C++\n- STL\n- Map\n- Unordered Map\n---\n\n## Goal\n\n> Map과 Unordered Map에 대해서 알아본다.\n> Map과 Unordered Map의 사용방법\n> Map과 Unordered Map의 구현\n\n<br><br><br><br><br><br>\n\n## Map이란?\n\n- Map은 각 노드가 key-value 쌍으로 이루어진 트리이다.\n- first,second가 있는 pair 객체로 저장된다.\n- 검색, 삽입, 삭제가 O(logn)인 레드블랙트리로 구성됐다.\n\n\n<br><br><br><br><br><br>\n\n## Map 특징\n- 내부에서 자동으로 **오름차순 정렬** 된다.\n- **중복을 허용하지 않는다.**\n- **범위기반 for문**과 같이 사용되는 경우가 많다.\n\n<br><br><br><br><br><br>\n\n## Map 사용방법\n\n1) 헤더 포함\n```#include <map>``` 을 포함해야 합니다.\n\n<br><br><br>\n\n2) map 선언\nmap의 기본구조는  ```map <key type, value type> 이름``` 입니다.\n<br><br><br>\n3) 정렬\nmap은 기본적으로 **key값을 기준**으로 **오름차순 정렬** 합니다.\n**내림차순 정렬**을 원하는 경우 ```map<key,value,greater> m;``` 으로 선언해주면 됩니다.\n\n<br><br>\n\n### Value값을 기준으로 정렬하고 싶은 경우 !!!\n\n1) **map을 vector로 이동**  \n```c++\nvector<pair<string,int>> vec(m.begin(),m.end());\n```\n\n2) **비교 함수 작성 ( 오름차순 )**  \n```c++\nbool cmp(const pair<string,int> &a, const pair<string,int> &b){\n\treturn a.second < b.second;\n}\n```\n\n3) **vector를 second(value) 기준으로 정렬**\n```c++\nbool cmp(const pair<string,int> &a, const pair<string,int> &b){\n\treturn a.second < b.second;\n}\n\nmap<string,int> m;\nvector<pair<string,int>> vec(m.begin(),m.end());\n\nsort(vec.begin(),vec.end(),cmp);\n```\n\n<br><br><br>\n\n4. Map에 데이터 삽입\nmap은 중복을 허용하지 않으므로 insert를 수행할 때, key가 중복되면 insert를 수행하지 않습니다. \n```c++\nm.insert({\"student\",50});\n```\n\n<br><br><br>\n\n5. 범위기반 반복문\nmap은 key나 value값에 문자열이 들어가는 경우가 많아 범위기반 반복문과 같이 자주 사용됩니다.\n```c++\nfor(auto it : m){\n\tif (it.second > max) {\n                max = it.second;\n                genre = it.first;\n            }\n}\n```\n\n\n<br> <br> <br><br> <br> <br>\n\n## Map 실제 사용 예제\n```c++\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nvector<int> solution(vector<string> genres, vector<int> plays) {\n    vector<int> answer;\n    map <string, int> music; // 장르별 재생횟수 저장\n    map <string, map<int, int>> mlist; // 장르별 무슨노래가 몇번 들렸는지\n\n    for (int i = 0; i < genres.size(); i++) {\n\n        music[genres[i]] += plays[i];\n        mlist[genres[i]][i] = plays[i];\n    }\n\n    while (music.size() > 0) {\n        int max = 0;\n        string genre = \"\";\n        for (auto mu : music) {\n            if (mu.second > max) {\n                max = mu.second;\n                genre = mu.first;\n            }\n        }\n\n        for (int i = 0; i < 2; i++) {\n            int val = 0;\n            int idx = -1;\n            for (auto ml : mlist[genre]) {\n                if (ml.second > val) {\n                    val = ml.second;\n                    idx = ml.first;\n                }\n            }\n            if (idx == -1) break;\n\n            answer.push_back(idx);\n            mlist[genre].erase(idx);\n        }\n        music.erase(genre);\n    }\n    return answer;\n}\n```\n\n<br> <br> <br><br> <br> <br>\n\n## unordered_map\n- hash-table 기반의 hash 컨테이너 이다.\n- 따라서 **정렬하지 않은 map** 이라고 생각하면 쉽다.\n- ```#include <unordered_map>``` 의 헤더를 포함해야 한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-2042661254}},"syncHistory":{"main":[-2042661254,null,null]},"v":1,"hash":1710111576465,"tx":135},"9TTmPv43PVpNQndV/content":{"id":"9TTmPv43PVpNQndV/content","type":"content","text":"---\npermalink: /2022-08-07-1주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 1. 첫번째 회사생활 \"\ndate: 2022-08-07 22:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"첫번째 회사생활\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n<br><br><br>\n\n\n## 0.\n많은걸 배우고 소중한 경험이다 싶으면 기록을 하고 싶은 생각이 들곤한다. 인생 첫번째 회사생활을 시작하게 되면서 여기서 보고 배운걸 기록해 놓고 싶다는 생각이 강하게들었다...! 그래서 인턴생활을 하면서 몸으로 부딪히고 깨닫는걸 블로그에 하나하나 기록해보고자 한다. 잘 할 수 있겠지...? 😢\n\n<br><br><br><br>\n\n## 1.\n나는 백엔드 개발자를 꿈꾸는 사람이다. 지금은 클라우드 프로젝트 팀에 소속되어 있고 회사 분위기나 기본적인 직무를 배우면서 교육을 받고 있다. 전에 다른 회사 경험이 아예 없어서 떨리고 무섭기도 하다.. 😪 근데 팀원분들도 되게 많이 도와주시고 챙겨주셔서 긴장감이 조금 줄어들긴 했다..! 일 할때 인간관계가 되게 중요하다고 하는데 우리팀은 너무너무 좋은것 같다. 정말 다행이야..\n\n1일차에는 기본적인 회사소개와 부서 구성도를 교육받았고, 실무에서 사용하는 자체 프레임워크 사용법을 익혔다. 특이하게도 Polymer를 사용해서 UI를 제작하던데 처음다뤄보는 툴이라 공부를 계속 해봐야겠다. 그런데 내일 오후에 교육받은 내용에 대한 질의응답을 팀장님과 진행한다고 한다. 아직 많이 미흡한데.. 열심히 해봐야겠다..!\n\n\n<br><br><br><br>\n\n## 2.\n오늘은 정말 머리를 한대 띵 맞은것 같고, 큰 깨달음이 온 날이였다. 팀장님께 그간 진행한 교육내용을 발표하고 질의응답을 갖는 시간이였는데, 내가 시간내에 완수를 하지 못했다. HTTP 404 관련 오류가 발생했고, 이를 잡지 못했는데 나때문에 회의가 그자리에서 마무리되고 발표도 진행못한채 끝났다.\n\n백엔드 개발자를 희망하지만 이정도 오류도 잡지 못한다면 더이상의 회의는 의미가 없다고 하셨다.. 맞는 말이다. 오히려 너무 맞는 말이라서 화가 나지도 않았고 감사했다. 내 수준이 어느정도 인지, 내가 공부해 나가야할 방향이 어딘지 생각해 볼 수 있게 됐다.\n\n오늘부터 다시 시작하는 마음으로 기본기부터 다져보려고 한다. 객체지향부터 차근차근 공부해보자..! 열심히 해서 좋은 개발자가 되어야지!\n\n<br><br><br><br>\n\n## 3.\n멘토님과 같이 객체지향부터 개념을 밟아가기로 했다. 단순히 정의만 외우는게 아니라 그 속에 담긴 뜻을 이해하고 실무에서는 어떻게 적용시킬지 생각하면서 공부를 했다. \n\n객체지향의 4대 특징이라고 불리는 추상화, 캡슐화(정보은닉), 상속, 다형성의 개념과 실무에서 적용시키는 방법, 자바 빈 구조를 다시 공부했다. 분명 알고있던 개념이였지만, 멘토님께서 질문을 던지시면 선뜻 대답하기 힘들었다.\n\n간단한 계산기를 만들어보면서 4개의 특징을 최대한 녹일 수 있도록 코드를 짜보라고 하셔서 코드를 짜고, 피드백을 받고를 반복했다. 확실히 개념이 머리에 잘 박히는것 같다..!\n\n<br><br><br><br>\n\n## 4.\n자바의 인터페이스, 추상클래스를 학습했다. 전부 알고 있는 개념이지만 다시 설명을 듣고 자료를 찾아가면서 공부를 하니 좀 더 확실하게 체화 되고 있다. 점점 재미가 붙는 듯 하다. 회사 생활도 어느정도 익숙해지는것 같아 다행이다. 다만 약간 힘든건, 잠이 부족하다는정도..? 아직까진 출근하는게 재밌고 (물론 퇴근이 더 재밌음) 할만 하다. 내가 성장 할 수 있는 밑거름이라고 생각해서 그런가보다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":-2025598851,"tx":137},"9TTmPv43PVpNQndV/syncedContent":{"id":"9TTmPv43PVpNQndV/syncedContent","type":"syncedContent","historyData":{"-2025598851":{"id":"9TTmPv43PVpNQndV/content","type":"content","text":"---\npermalink: /2022-08-07-1주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 1. 첫번째 회사생활 \"\ndate: 2022-08-07 22:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"첫번째 회사생활\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n<br><br><br>\n\n\n## 0.\n많은걸 배우고 소중한 경험이다 싶으면 기록을 하고 싶은 생각이 들곤한다. 인생 첫번째 회사생활을 시작하게 되면서 여기서 보고 배운걸 기록해 놓고 싶다는 생각이 강하게들었다...! 그래서 인턴생활을 하면서 몸으로 부딪히고 깨닫는걸 블로그에 하나하나 기록해보고자 한다. 잘 할 수 있겠지...? 😢\n\n<br><br><br><br>\n\n## 1.\n나는 백엔드 개발자를 꿈꾸는 사람이다. 지금은 클라우드 프로젝트 팀에 소속되어 있고 회사 분위기나 기본적인 직무를 배우면서 교육을 받고 있다. 전에 다른 회사 경험이 아예 없어서 떨리고 무섭기도 하다.. 😪 근데 팀원분들도 되게 많이 도와주시고 챙겨주셔서 긴장감이 조금 줄어들긴 했다..! 일 할때 인간관계가 되게 중요하다고 하는데 우리팀은 너무너무 좋은것 같다. 정말 다행이야..\n\n1일차에는 기본적인 회사소개와 부서 구성도를 교육받았고, 실무에서 사용하는 자체 프레임워크 사용법을 익혔다. 특이하게도 Polymer를 사용해서 UI를 제작하던데 처음다뤄보는 툴이라 공부를 계속 해봐야겠다. 그런데 내일 오후에 교육받은 내용에 대한 질의응답을 팀장님과 진행한다고 한다. 아직 많이 미흡한데.. 열심히 해봐야겠다..!\n\n\n<br><br><br><br>\n\n## 2.\n오늘은 정말 머리를 한대 띵 맞은것 같고, 큰 깨달음이 온 날이였다. 팀장님께 그간 진행한 교육내용을 발표하고 질의응답을 갖는 시간이였는데, 내가 시간내에 완수를 하지 못했다. HTTP 404 관련 오류가 발생했고, 이를 잡지 못했는데 나때문에 회의가 그자리에서 마무리되고 발표도 진행못한채 끝났다.\n\n백엔드 개발자를 희망하지만 이정도 오류도 잡지 못한다면 더이상의 회의는 의미가 없다고 하셨다.. 맞는 말이다. 오히려 너무 맞는 말이라서 화가 나지도 않았고 감사했다. 내 수준이 어느정도 인지, 내가 공부해 나가야할 방향이 어딘지 생각해 볼 수 있게 됐다.\n\n오늘부터 다시 시작하는 마음으로 기본기부터 다져보려고 한다. 객체지향부터 차근차근 공부해보자..! 열심히 해서 좋은 개발자가 되어야지!\n\n<br><br><br><br>\n\n## 3.\n멘토님과 같이 객체지향부터 개념을 밟아가기로 했다. 단순히 정의만 외우는게 아니라 그 속에 담긴 뜻을 이해하고 실무에서는 어떻게 적용시킬지 생각하면서 공부를 했다. \n\n객체지향의 4대 특징이라고 불리는 추상화, 캡슐화(정보은닉), 상속, 다형성의 개념과 실무에서 적용시키는 방법, 자바 빈 구조를 다시 공부했다. 분명 알고있던 개념이였지만, 멘토님께서 질문을 던지시면 선뜻 대답하기 힘들었다.\n\n간단한 계산기를 만들어보면서 4개의 특징을 최대한 녹일 수 있도록 코드를 짜보라고 하셔서 코드를 짜고, 피드백을 받고를 반복했다. 확실히 개념이 머리에 잘 박히는것 같다..!\n\n<br><br><br><br>\n\n## 4.\n자바의 인터페이스, 추상클래스를 학습했다. 전부 알고 있는 개념이지만 다시 설명을 듣고 자료를 찾아가면서 공부를 하니 좀 더 확실하게 체화 되고 있다. 점점 재미가 붙는 듯 하다. 회사 생활도 어느정도 익숙해지는것 같아 다행이다. 다만 약간 힘든건, 잠이 부족하다는정도..? 아직까진 출근하는게 재밌고 (물론 퇴근이 더 재밌음) 할만 하다. 내가 성장 할 수 있는 밑거름이라고 생각해서 그런가보다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":-2025598851}},"syncHistory":{"main":[-2025598851,null,null]},"v":1,"hash":1710111577615,"tx":137},"QBAJWTNeLD7raJPY/content":{"id":"QBAJWTNeLD7raJPY/content","type":"content","text":"---\npermalink: /2022-08-12-2주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 2. 적응기 \"\ndate: 2022-08-12 20:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"적응기\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n<br><br><br>\n\n\n## 5. 😁\n오늘은 담당 멘토님께서 휴가를 가셔서 나랑 동기인턴이랑 하루종일 계산기 코드를 만졌다. 객체지향의 4대 특징과 Has-a 개념, Is-a 개념을 적용시켜 계산기를 만드는 토이(?)프로젝트다. 몇일동안 같은 코드를 계속 수정,보완하면서 고쳐나가는걸 얼마만에 하는지 모르겠는데 생각보다 너무 도움이 된다. \n\n오늘 계속 고민한 문제를 끄적여보겠다.. Is-a개념을 적용시키기 위해 클래스끼리 상속을 사용했는데, 전체적인 구조는 계산->결과출력->결과값 이런 상속구조를 띄고있다. 나는 main에서 계산, 결과출력, 결과값에 해당하는 클래스의 객체를 각각 만들고, 결과값을 최종적으로 저장한 뒤에 결과출력 객체를 사용해 결과값에 접근해서 결과를 보이려고 했는데, 계속 이상한 값이 나왔다. 분명 결과값은 제대로 저장이 됐는데, 결과출력-> 결과값 이렇게 접근하니 오류가 났다. 그래서 고민x1000000번 하다가 아예 처음 계산한 클래스에 접근을 먼저해서 계산->결과출력-> 결과값 이렇게 값에 접근하니깐 정답이 출력됐다.\n\n지금 이 문제에 대한 내 예상은 의존구조를 가질때 최하층 클래스부터 차근차근 상위 클래스로 접근하면서 값을 가져와야만 제대로 가져올수 있는것으로 보이는데 여쭤볼 수 있는 분이 없어서 내일 멘토님께 제대로 여쭤보려고 한다.. 뭐 아무튼 내 나름대로의 결과는 얻었으니 굉장히 만족한다..!\n\n<br><br><br><br>\n\n## 6. 😂\n오늘은 살짝 이슈가 있었다. 비가 엄청많이 와서 출근시간에 혼동이 있어가지구.. 허허 아무튼! 오늘은 어제 짜던 계산기를 마저 짰는데 아직 부족한점이 많았다. 변수를 public으로 선언한것부터 ( 정보은닉이 안됨) 생각없이 super를 사용하고.. 멘토님께 여러 피드백을 들었다. \n\n이후에 인터페이스와 추상클래스를 사용해서 계산기를 또 만들어봤는데, 기존에는 그냥 인터페이스 만들어서 메소드 넣고 implement해서 쓰고 추상클래스 만들어서 오버라이딩해서 쓰고 이런식으로 그냥 썼는데 그 본질을 모르고 썼었더라면 오늘 드디어 우리가 왜 인터페이스와 추상클래스를 쓰는건지 그 의미를 어느정도 깨달았다. \n\n인터페이스나 추상클래스에 선언된 추상메소드는 상속받은 클래스에서 반드시 재정의 해줘야하는데 이런 불편함을 줄이고 사용자마다 필요한 기능을 다르게 정의하기 위해 **추상클래스에 새로운 클래스를 선언하고 여기에 인터페이스를 상속받아 사용하는 방식을 배웠다.⚡** 이게 진짜 지리더만;\n\n<br><br><br><br>\n\n## 7. 😊\n어제 까지 인터페이스, 추상클래스를 사용해서 계산기를 만드는 코드를 계속 작성했고 오늘은 디자인 패턴을 학습하고 적용시키는 과제를 받았다! 디자인 패턴을 공부해본적이 아예 없어서 되게 생소했는데 생각보다 중요한 개념이였다. 나는 Adapter 패턴을 계산기에 적용시켜보기로 했는데 이게 간단한 코드에 패턴을 적용시키려 하니 오히려 좀 더 복잡해 지는 결과가 나왔다. 근데 그게 당연한 결과라고 한다. 코드가 규모가 커질 수록 디자인 패턴이 효과적으로 작동한다. 실제로 실무에서도 디자인패턴은 많이 적용된다고 하니 디자인 패턴을 좀 더 공부해 볼 필요가 있어 보인다...!\n\n<br><br><br><br>\n\n## 8. 😊\n\n이제 객체지향, 디자인 패턴에 대한 전반적인 공부가 끝이나서 jsp와 Servlet에 대해 공부를 한다. 사실 스프링을 공부하기 위한 사전지식 느낌으로 jsp 클론 코딩정도만 해본게 다라서 솔직히 어렵다. 멘토님께서 우리가 만들었던 계산기를 이제 jsp로 변경해서 만들어보라고 과제를 내주셨는데.. 이놈의 계산기만 2주째 만지고 있으니깐 약간 정신나갈거같다. 구글 검색 투닥투닥 하면서 jsp로 바꾸고는 있는데.. 후하 \n\n개념공부로는 Apache와 Tomcat의 차이, 웹서버와 WAS(Web Application Server)의 차이, Servlet의 작동원리를 배웠다. 아 얘네들 다 정리해서 블로그에 포스팅 해야하는데 언제하냐 진짜.. 일단 주말이랑 담주 월요일 쉬니깐 좀 쉬자.. \n\n😒😢😊😁😂⚡⭐🌙☀\n","properties":"\n","discussions":{},"comments":{},"hash":-113189089,"tx":145},"QBAJWTNeLD7raJPY/syncedContent":{"id":"QBAJWTNeLD7raJPY/syncedContent","type":"syncedContent","historyData":{"-113189089":{"id":"QBAJWTNeLD7raJPY/content","type":"content","text":"---\npermalink: /2022-08-12-2주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 2. 적응기 \"\ndate: 2022-08-12 20:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"적응기\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n<br><br><br>\n\n\n## 5. 😁\n오늘은 담당 멘토님께서 휴가를 가셔서 나랑 동기인턴이랑 하루종일 계산기 코드를 만졌다. 객체지향의 4대 특징과 Has-a 개념, Is-a 개념을 적용시켜 계산기를 만드는 토이(?)프로젝트다. 몇일동안 같은 코드를 계속 수정,보완하면서 고쳐나가는걸 얼마만에 하는지 모르겠는데 생각보다 너무 도움이 된다. \n\n오늘 계속 고민한 문제를 끄적여보겠다.. Is-a개념을 적용시키기 위해 클래스끼리 상속을 사용했는데, 전체적인 구조는 계산->결과출력->결과값 이런 상속구조를 띄고있다. 나는 main에서 계산, 결과출력, 결과값에 해당하는 클래스의 객체를 각각 만들고, 결과값을 최종적으로 저장한 뒤에 결과출력 객체를 사용해 결과값에 접근해서 결과를 보이려고 했는데, 계속 이상한 값이 나왔다. 분명 결과값은 제대로 저장이 됐는데, 결과출력-> 결과값 이렇게 접근하니 오류가 났다. 그래서 고민x1000000번 하다가 아예 처음 계산한 클래스에 접근을 먼저해서 계산->결과출력-> 결과값 이렇게 값에 접근하니깐 정답이 출력됐다.\n\n지금 이 문제에 대한 내 예상은 의존구조를 가질때 최하층 클래스부터 차근차근 상위 클래스로 접근하면서 값을 가져와야만 제대로 가져올수 있는것으로 보이는데 여쭤볼 수 있는 분이 없어서 내일 멘토님께 제대로 여쭤보려고 한다.. 뭐 아무튼 내 나름대로의 결과는 얻었으니 굉장히 만족한다..!\n\n<br><br><br><br>\n\n## 6. 😂\n오늘은 살짝 이슈가 있었다. 비가 엄청많이 와서 출근시간에 혼동이 있어가지구.. 허허 아무튼! 오늘은 어제 짜던 계산기를 마저 짰는데 아직 부족한점이 많았다. 변수를 public으로 선언한것부터 ( 정보은닉이 안됨) 생각없이 super를 사용하고.. 멘토님께 여러 피드백을 들었다. \n\n이후에 인터페이스와 추상클래스를 사용해서 계산기를 또 만들어봤는데, 기존에는 그냥 인터페이스 만들어서 메소드 넣고 implement해서 쓰고 추상클래스 만들어서 오버라이딩해서 쓰고 이런식으로 그냥 썼는데 그 본질을 모르고 썼었더라면 오늘 드디어 우리가 왜 인터페이스와 추상클래스를 쓰는건지 그 의미를 어느정도 깨달았다. \n\n인터페이스나 추상클래스에 선언된 추상메소드는 상속받은 클래스에서 반드시 재정의 해줘야하는데 이런 불편함을 줄이고 사용자마다 필요한 기능을 다르게 정의하기 위해 **추상클래스에 새로운 클래스를 선언하고 여기에 인터페이스를 상속받아 사용하는 방식을 배웠다.⚡** 이게 진짜 지리더만;\n\n<br><br><br><br>\n\n## 7. 😊\n어제 까지 인터페이스, 추상클래스를 사용해서 계산기를 만드는 코드를 계속 작성했고 오늘은 디자인 패턴을 학습하고 적용시키는 과제를 받았다! 디자인 패턴을 공부해본적이 아예 없어서 되게 생소했는데 생각보다 중요한 개념이였다. 나는 Adapter 패턴을 계산기에 적용시켜보기로 했는데 이게 간단한 코드에 패턴을 적용시키려 하니 오히려 좀 더 복잡해 지는 결과가 나왔다. 근데 그게 당연한 결과라고 한다. 코드가 규모가 커질 수록 디자인 패턴이 효과적으로 작동한다. 실제로 실무에서도 디자인패턴은 많이 적용된다고 하니 디자인 패턴을 좀 더 공부해 볼 필요가 있어 보인다...!\n\n<br><br><br><br>\n\n## 8. 😊\n\n이제 객체지향, 디자인 패턴에 대한 전반적인 공부가 끝이나서 jsp와 Servlet에 대해 공부를 한다. 사실 스프링을 공부하기 위한 사전지식 느낌으로 jsp 클론 코딩정도만 해본게 다라서 솔직히 어렵다. 멘토님께서 우리가 만들었던 계산기를 이제 jsp로 변경해서 만들어보라고 과제를 내주셨는데.. 이놈의 계산기만 2주째 만지고 있으니깐 약간 정신나갈거같다. 구글 검색 투닥투닥 하면서 jsp로 바꾸고는 있는데.. 후하 \n\n개념공부로는 Apache와 Tomcat의 차이, 웹서버와 WAS(Web Application Server)의 차이, Servlet의 작동원리를 배웠다. 아 얘네들 다 정리해서 블로그에 포스팅 해야하는데 언제하냐 진짜.. 일단 주말이랑 담주 월요일 쉬니깐 좀 쉬자.. \n\n😒😢😊😁😂⚡⭐🌙☀\n","properties":"\n","discussions":{},"comments":{},"hash":-113189089}},"syncHistory":{"main":[-113189089,null,null]},"v":1,"hash":1710111582485,"tx":145},"9JHueTxb1xmg5ZXP/syncedContent":{"id":"9JHueTxb1xmg5ZXP/syncedContent","type":"syncedContent","historyData":{"-1282855084":{"id":"9JHueTxb1xmg5ZXP/content","type":"content","text":"---\npermalink: /2022-08-16-프레임워크 vs 라이브러리/\npublished: true\ntitle: \"[개발상식] 프레임워크(Framework)와 라이브러리(Library)의 차이\"\ndate: 2022-08-16 21:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"프레임워크 vs 라이브러리\"\ncategories:\n- 개발상식\ntags:\n- 라이브러리\n- 프레임워크\n- 개발상식\n---\n**\"라이브러리와 프레임워크의 차이가 뭔지 알아요?\"**  \n\n\"음.. 라이브러리는 그냥 메소드같은걸 갖다 쓰는거고.. 프레임워크는 틀?\"  \n\n**\"스프링은 라이브러리 일까요 프레임워크일까요?\"**  \n\n\"음.. 프레임워크?\"  \n\n**\"최근에 사용한 라이브러리와 프레임워크를 뭐에요?\"**  \n\n\"...\"  \n\n<br>\n\n개발자로 공부하다보면 라이브러리, 프레임워크 라는 용어를 정말 많이 듣고 사용하는데 정작 이 둘이 뭐하는 애들인지, 무슨 차이가 있는지는 모른채 사용하는 경우가 많다. 나 또한 저 질문에 대답하지 못했고 정확히 알지도 못한다. 그래서 오늘은 라이브러리와 프레임워크의 정의와 기능, 예시, 차이점을 정리해서 포스팅 해보고자 한다!\n\n<br><br><br><br>\n\n## 💻 프레임워크란\n\n**원하는 기능 구현에 집중하여 개발할 수 있도록 일정한 형태와 기능을 갖추고 있는 골격, 뼈대**를 의미합니다. \n\n**프레임워크는 애플리케이션 개발 시 필수적인 코드, 알고리즘, DB연동과 같은 기능을 위해 어느정도 구조(뼈대)를 제공하고, 이러한 구조위에서 사용자가 코드를 작성해서 애플리케이션을 개발** 합니다. **앱/서버 등의 구동, 메모리관리, 이벤트 루프** 등 공통된 부분은 프레임워크가 관리하고, **사용자는 프레임워크가 정해준 방식대로 클래스, 메소드를 구현**하면 됩니다.\n\n한마디로 **소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합** 이라고 볼 수 있습니다.\n\n<br><br>\n\n### 🔍 예시\n- JAVA 서버 개발에 사용되는 Spring\n- Python 서버 개발에 사용되는 Django, Flask\n- 안드로이드 앱 개발에 사용되는 Android\n- 웹 개발에 사용되는 Angular, Vue.js\n- JAVA 기반의 JSP를 위한 Struts\n\n\n<br><br><br><br>\n\n## 💻 라이브러리란\n**라이브러리는 단순 활용가능한 도구들의 집합을 말합니다.**\n\n**소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임 입니다.**\n\n**미리 작성된 코드, 변수, 함수, 클래스가 포함됩니다.**\n\n<br><br>\n\n### 🔍 예시\n- Python pip로 설치한 패키지/모듈 ( tensorflow, pandas 등 )\n- C++의 STL\n- HTML의 클라이언트 사이드 조작을 단순화하는 JQuery\n- OOP ( 각 기능마다 함수화 하는 클래스 라이브러리 )\n\n\n<br><br><br><br>\n\n## 👀 프레임워크 vs 라이브러리\n\n라이브러리와 프레임워크의 차이는 **제어 흐름에 대한 주도성이 누구에게/어디에 있는가**에 있습니다. 즉, **어플리케이션의 Flow(흐름)를 누가 쥐고 있느냐**에 달려있습니다.\n\n**프레임워크**는 **전체적인 흐름을 프레임워크가 쥐고 있으며** 사용자는 그 안에 필요한 코드를 짜 넣으면 되고, 반면에 **라이브러리**는 **사용자가 전체적인 흐름을 직접 만들고** 필요에 따라 라이브러리를 가져다가 쓰는 것이라고 할 수 있습니다.\n\n한마디로 **프레임워크**는 **그 틀안에 제어 흐름에 대한 주도성이 내포**되어 있고, **라이브러리**는 **사용자가 전적으로 제어 흐름에 대한 주도성**을 가집니다.\n\n<br><br>\n🔍\n> **프레임워크 : 프레임워크가 흐름을 제어하고 사용자가 만든 코드를 사용 (제어의 역전)**\n> \n> **라이브러리 : 사용자가 흐름을 제어하고 라이브러리를 가져다 사용**\n","properties":"\n","discussions":{},"comments":{},"hash":-1282855084}},"syncHistory":{"main":[-1282855084,null,null]},"v":1,"hash":1710111584926,"tx":149},"dmRttHYhrK5WFmOh/content":{"id":"dmRttHYhrK5WFmOh/content","type":"content","text":"---\npermalink: /2022-08-19-3주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 3. 3주차 인턴일기\"\ndate: 2022-08-19 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"3주차 인턴일기\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n<br><br><br>\n\n## 9. 😊\n3일이라는 길다면 길고 짧다면 짧은 꿀맛같은 휴가를 보내고 회사로 복귀했다. 오늘은 팀원분들도 휴가라서 많이 안나오셨는데 멘토님도 업무때문에 너무 바쁘셔서 자율적으로 학습했다. jsp를 활용한 계산기 프로그램을 마무리 지었고 그동안 헷갈리던 객체 생성 개념도 어느정도 질문을 통해 해결했다. 점점 실력이 성장하고 있는게 느껴져서 기분이 좋다. 재미도 붙는것 같고..! 내일부터는 스프링에 대해서 본격적으로 공부를 한다고 하는데 걱정반 기대반 두근두근 하다...!\n\n## 10. 😂\n스프링 부트를 써서 공부를 해본적은 있는데, 아예 처음부터 Dynamic Web Project로 스프링을 만들어 본적은 없었다.. 근데 이번에 그렇게 구조를 까놓고 내가 만든 계산기를 얹어보라고 하셨다. web.xml은 뭔지.. servlet은 뭔지.. 서비스, DAO 전부다 구현해서 만들어보라고 하시는데.. 어렵다아...\n\n## 11. 😢\n그.. 같이 인턴하시는 분이 코로나에 걸리셔가지고.. 집에 왔다.... 일단 재택근무 하라고 하시는데.. 아마 내일까지는 재택을 할 것같다. 약간 쉬엄쉬엄 해도 될지도..?\n","properties":"\n","discussions":{},"comments":{},"hash":-2021189248,"tx":151},"dmRttHYhrK5WFmOh/syncedContent":{"id":"dmRttHYhrK5WFmOh/syncedContent","type":"syncedContent","historyData":{"-2021189248":{"id":"dmRttHYhrK5WFmOh/content","type":"content","text":"---\npermalink: /2022-08-19-3주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 3. 3주차 인턴일기\"\ndate: 2022-08-19 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"3주차 인턴일기\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n<br><br><br>\n\n## 9. 😊\n3일이라는 길다면 길고 짧다면 짧은 꿀맛같은 휴가를 보내고 회사로 복귀했다. 오늘은 팀원분들도 휴가라서 많이 안나오셨는데 멘토님도 업무때문에 너무 바쁘셔서 자율적으로 학습했다. jsp를 활용한 계산기 프로그램을 마무리 지었고 그동안 헷갈리던 객체 생성 개념도 어느정도 질문을 통해 해결했다. 점점 실력이 성장하고 있는게 느껴져서 기분이 좋다. 재미도 붙는것 같고..! 내일부터는 스프링에 대해서 본격적으로 공부를 한다고 하는데 걱정반 기대반 두근두근 하다...!\n\n## 10. 😂\n스프링 부트를 써서 공부를 해본적은 있는데, 아예 처음부터 Dynamic Web Project로 스프링을 만들어 본적은 없었다.. 근데 이번에 그렇게 구조를 까놓고 내가 만든 계산기를 얹어보라고 하셨다. web.xml은 뭔지.. servlet은 뭔지.. 서비스, DAO 전부다 구현해서 만들어보라고 하시는데.. 어렵다아...\n\n## 11. 😢\n그.. 같이 인턴하시는 분이 코로나에 걸리셔가지고.. 집에 왔다.... 일단 재택근무 하라고 하시는데.. 아마 내일까지는 재택을 할 것같다. 약간 쉬엄쉬엄 해도 될지도..?\n","properties":"\n","discussions":{},"comments":{},"hash":-2021189248}},"syncHistory":{"main":[-2021189248,null,null]},"v":1,"hash":1710111586092,"tx":151},"vznoAKrCVFYxkwJ0/content":{"id":"vznoAKrCVFYxkwJ0/content","type":"content","text":"---\npermalink: /2022-08-26-4주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 3. 4주차 인턴일기\"\ndate: 2022-08-26 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"4주차 인턴일기\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n## 12. 😊\n이번주는 기록을 한번도 안했네.. ㅎㅎ 같은 팀원 인턴분이 재택근무를 하셔서 나도 약간 방치? 된상태로 일주일간 출근을 했었다.. 근데 오히려 나쁘지 않았을지도..? 드디어 스프링으로 계산기 구현하는 작업은 완전히 마무리를 했다..! 다음으로 RESTful API를 학습하자고 하셨었는데 멘토님 업무가 갑자기 늘어나셔가지구 이번주는 거의 나 혼자 공부를 한 기억밖에 없다.\n\n토비의 스프링3 책을 멘토님께서 주셔가지고 스프링도 손에 익힐겸 차근차근 읽었다. 근데 책이 뭔가 스프링 서적이라기 보다는 객체지향설계를 하는 방법을 알려주는 책처럼 느껴진다. 스프링에 담긴 깊은 뜻을 알려주는 방식이랄까..? **가장 인상깊었던게 스프링 빈에 저장된 빈은 싱글톤 방식으로 저장되어서 어디서든 꺼내 쓸수 있다는 사실이였다**. 이거 때문에 거의 2주동안 고민이 많았는데 그 정답을 책에서 바로 찾아버렸다... @Autowired가 어떻게 작동하는지는 충분히 얻어간것 같다.. ㅋㅋ\n\n이제 인턴 종료까지 열흘정도 남았는데 남은기간 최선을 다해서 공부하고 성장해보자!\n","properties":"\n","discussions":{},"comments":{},"hash":-1898327262,"tx":159},"vznoAKrCVFYxkwJ0/syncedContent":{"id":"vznoAKrCVFYxkwJ0/syncedContent","type":"syncedContent","historyData":{"-1898327262":{"id":"vznoAKrCVFYxkwJ0/content","type":"content","text":"---\npermalink: /2022-08-26-4주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 3. 4주차 인턴일기\"\ndate: 2022-08-26 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"4주차 인턴일기\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n## 12. 😊\n이번주는 기록을 한번도 안했네.. ㅎㅎ 같은 팀원 인턴분이 재택근무를 하셔서 나도 약간 방치? 된상태로 일주일간 출근을 했었다.. 근데 오히려 나쁘지 않았을지도..? 드디어 스프링으로 계산기 구현하는 작업은 완전히 마무리를 했다..! 다음으로 RESTful API를 학습하자고 하셨었는데 멘토님 업무가 갑자기 늘어나셔가지구 이번주는 거의 나 혼자 공부를 한 기억밖에 없다.\n\n토비의 스프링3 책을 멘토님께서 주셔가지고 스프링도 손에 익힐겸 차근차근 읽었다. 근데 책이 뭔가 스프링 서적이라기 보다는 객체지향설계를 하는 방법을 알려주는 책처럼 느껴진다. 스프링에 담긴 깊은 뜻을 알려주는 방식이랄까..? **가장 인상깊었던게 스프링 빈에 저장된 빈은 싱글톤 방식으로 저장되어서 어디서든 꺼내 쓸수 있다는 사실이였다**. 이거 때문에 거의 2주동안 고민이 많았는데 그 정답을 책에서 바로 찾아버렸다... @Autowired가 어떻게 작동하는지는 충분히 얻어간것 같다.. ㅋㅋ\n\n이제 인턴 종료까지 열흘정도 남았는데 남은기간 최선을 다해서 공부하고 성장해보자!\n","properties":"\n","discussions":{},"comments":{},"hash":-1898327262}},"syncHistory":{"main":[-1898327262,null,null]},"v":1,"hash":1710111590280,"tx":159},"RTduSDZPEbBuUVtA/syncedContent":{"id":"RTduSDZPEbBuUVtA/syncedContent","type":"syncedContent","historyData":{"-1437351472":{"id":"RTduSDZPEbBuUVtA/content","type":"content","text":"---\npermalink: /2022-08-23-서블릿(Servlet)이란/\npublished: true\ntitle: \"[Web & Server] 서블릿(Servlet)이란? \"\ndate: 2022-08-23 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"서블릿(Servlet)이란\"\ncategories:\n- Web & Server\ntags:\n- WAS\n- Web 서버\n- 개발상식\n\n---\n<br><br><br>\n\n## ✅ 서블릿(Servlet)이란?\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet1.png?raw=true\">\n</p>\n\n**서블릿이란 Dynamic Web Page, 즉 동적 페이지를 만들 때 사용되는 JAVA기반 웹 애플리케이션 프로그래밍 기술이다.** 웹을 만들 때는 다양한 요청 (Request)과 응답(Response)이 있고, 이 요청과 응답에는 규칙이 존재하는데, 이러한 요청 응답을 간단한 메서드 호출로 체계적으로 다룰 수 있게 해주는 기술이라고 보면 된다.\n\n좁은 의미로 서블릿을 보면 위와 같은 기능을 하는 **자바 클래스**이고,\n넓은 의미로 서블릿을 보면 위와 같은 기능을 하는 **자바 패키지**이다.\n\n<br><br><br>\n\n## ✅ 서블릿의 등장 배경\n과거에 서버는 정적페이지(HTML,CSS,Image) 만을 처리했다. 클라이언트가 자료를 요청하면 서버는 미리 만들어둔 데이터를 저장하고 있다가 HTML로 반환했다. 그런데 점점 사용자가 많아지자 저장공간도 부족해지고, 사용자들은 정적페이지가 아닌 각자 필요에 맞는 동적 페이지를 받고 싶어했다. 그래서 이러한 **동적 페이지를 만들기 위해 생겨난 것**이 **서블릿(Servlet)**이다!\n\n\n<br><br><br>\n\n## ✅ 서블릿과 서버\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet3.png?raw=true\">\n</p>\n앞선 포스팅에서 Web서버와 WAS에 대해서 알아봤는데 서블릿과도 관계가 아주 깊다. Web서버는 정적페이지를 처리하고, WAS는 동적페이지를 처리하는데 **WAS에서 연산을 담당하는 것이 바로 서블릿이다.** 이러한 서블릿은 **WAS내의 서블릿 컨테이너(웹 컨테이너)에서 관리된다.**\n\n<br><br><br>\n\n## ✅ 서블릿 컨테이너 (웹 컨테이너)\n서블릿 컨테이너는 말그대로 서블릿을 담고 관리해주는 컨테이너 이다. 일반적으로 홈페이지에 들어가면 굉장히 많은 기능을 제공하는데 예를 들어 쇼핑몰 페이지만 봐도 구매, 장바구니 등록, 게시판, 회원가입 등 기능이 굉장히 많다. 이런 기능들은 데이터를 주고받으며 사용자에 따라 각기 다른 정보를 제공해야 하므로 동적 데이터, 즉 서블릿을 통해 작동되는데 하나의 서버 안에 수많은 서블릿이 존재하면, 이를 전부 컨트롤하기는 어려운 일이다. 따라서 서블릿 컨테이너가 모든 서블릿을 제어함으로써 효율적인 서버 관리가 가능하다.\n\n<br><br>\n\n앞서 서블릿은 일종의 **자바 클래스 혹은 패키지**라고 얘기 한 바 있다. 서블릿을 실제로 작성해보면 자바 언어로 쓰이고 자바 클래스 형태를 띄고 있는걸 알 수 있다. 그리고 이러한 서블릿은 ```javax.servlet.http``` 라는 패키지 안에 포함되어 있다. javax.servlet은 서블릿 구현을 위한 다양한 인터페이스와 클래스가 포함된 꾸러미이다. 우리가 쓰는 서블릿 클래스는 이 패키지 안에서 하나를 빌려와서 구현한 것이다.\n\n<br><br>\n\n우리가 servlet 클래스의 규칙에 맞게 구현을 하고 클라이언트가 요청을 하면 컨테이너는 **HttpServletRequest, HttpServletResponse** 두 객체를 생성하고 **POST,GET** 여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.\n<BR>\n\n- **HttpServletRequest**   \nhttp프로토콜의 request정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URI, URL 등의 정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있습니다.\n\n- **HttpServletResponse**   \nWAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여 서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송합니다.\n\n<br><br><br><br>\n\n## ✅ 서블릿 컨테이너의 실행 순서\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet4.png?raw=true\">\n</p>\n\n1️⃣ **클라이언트의 요청**\n\nHTTP프로토콜을 통해 Request 받은 요청이 정적 페이지라면 WEB서버를 통해 바로 처리해주고, 동적 페이지라면 서블릿 컨테이너로 넘긴다.\n\n<br>\n\t\n2️⃣ **HttpServletRequest, HttpServletResponse 객체 생성**\n\n요청이 들어오면 서블릿 컨테이너에서는 HttpServletRequest, HttpServletResponse 객체를 생성한다. HttpServletRequest는 요청에 대한 데이터 처리과정을 담당하고, HttpServletResponse는 요청에 대한 결과물 반환을 담당한다.\n\n<br>\n\n3️⃣ **Web.xml 파싱**\n\nWeb.xml은 서블릿의 위치(주소)는 어디인지, 어떤 이름으로 mapping 할 것인지 찾을 수 있도록 도와주는 문서이다. Web.xml을 참조해서 Servlet으로 접근한다고 보면 된다.\n서블릿 컨테이너는 Web.xml 문서에 따라 그에 맞는 서블릿 주소를 찾고 서블릿에 접근한다.\n\n<br>\n\t\n4️⃣ **서블릿 초기화**\nWeb.xml 문서에 따라 실행할 서블릿을 찾았다면 해당 서블릿 클래스를 로드한다. 그리고 서블릿에서 사용할 객체를 만든다. 그리고 이 객체를 이용해 init()메서드를 호출해서 서블릿을 사용할 수 있도록 초기화한다.\n\n<br>\n\n5️⃣ **Service 실행**\n서블릿 초기화 이후에는 요청을 처리하는 service() 메서드가 실행 된다. 그리고 service()는 요청이 get방식인지, post방식인지에 따라 맞는 메서드를 실행한다.\n\n요청이 get이라면 `doGet()`을,\n요청을 post라면 `doPost()`를 실행한다.\n\n<br>\n\n6️⃣ **destroy() 실행**\n더이상 사용되지 않는다고 판단하거나 서버가 종료될 때 컨테이너는 `destroy()` 메서드를 실행하여 서블릿을 제거한다.\n\n<br><br><br>\n\n \n\n","properties":"\n","discussions":{},"comments":{},"hash":-1437351472}},"syncHistory":{"main":[-1437351472,null,null]},"v":1,"hash":1710111592831,"tx":163},"Kl8goLjOCe4Y2iU1/content":{"id":"Kl8goLjOCe4Y2iU1/content","type":"content","text":"---\npermalink: /2022-08-25-팩토리 메소드(Factory Method)패턴/\npublished: true\ntitle: \"[Design Pattern] 팩토리 메소드(Factory Method) 패턴 \"\ndate: 2022-08-25 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"팩토리 메소드(Factory Method)패턴\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n- 생성 패턴\n---\n<br><br><br>\n\n## ✅ 팩토리 메소드 패턴 (Factory Method)\n\n\n- **객체 생성 처리를 서브 클래스로 분리 해 처리하도록 캡슐화 하는 패턴**\n\n- **객체의 생성코드를 별도의 클래스/메소드로 분리**함으로써 객체 생성의 변화 대비에 유용\n\n- 객체 생성 기능처럼 특정 기능을 개별 클래스를 통해 구현하는 것은 바람직한 객체 지향 설계 방법이다.\n\n- 생성 (Creational) 패턴의 하나이다.\n\n- **기존 코드 변경 없이 확장하기 위한 디자인 패턴!**\n\n<br><br>\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/factory1.png?raw=true\">\n</p>\n\n<br><br>\n\n📌 **Product** \n 　　　　팩토리 메소드로 생성 될 객체의 공통 인터페이스\n 　　　　　　\n📌 **ConcreteProduct** \n　　　　구체적으로 객체가 생성되는 클래스\n　　　\n📌 **Creator** \n　　　　팩토리 메소드를 갖는 클래스\n　　　\n📌 **ConcreteCreator** \n　　　　팩토리 메소드를 구현하는 클래스, ConcreteProduct 객체 생성\n\n\n<br><br><br><br>\n\n## ✅ 팩토리 메소드 예제\n<h5>⭐ 사용자 관리 프로그램이 있고 네이버 계정으로 가입할 수 있다.</h5>\n\n<br>\n\n### 📌 Product ( User )\n\n```java\npublic  interface User { \n\tvoid signup(); \n}\n```\n-``` User``` 인터페이스 정의\n\n<br>\n\n```java\npublic  class NaverUser implements User { \n\t@Override  \n\tpublic void signup() { \n\t\tSystem.out.println(\"네이버 아이디로 가입\"); \n\t} \n}\n```\n- ```User``` 인터페이스를 구현하는 ```NaverUser``` 클래스\n- 오버라이드한 메소드에서는 네이버 유저 전용 로직 추가\n\n<br><br>\n\n### 📌 Creator ( UserFactory )\n<h5>⭐ 실제로 객체를 생성하는 Factory</h5>\n\n```java\npublic abstract class UserFactory { \n\tpublic User newInstance() { \n\t\tUser user = createUser(); \n\t\tuser.signup(); \n\t\treturn user;\n\t} \n\tprotected abstract User createUser(); \n}\n```\n\n- 추상클래스로 UserFactory를 정의\n- 실제 객체를 생성하는 곳 ( 일종의 팩토리 )\n- 외부에서 User 객체를 생성 할 때는 ```newInstance()``` 메서드 호출\n- 어떤 객체를 생성할 지는 하위 클래스에서 결정\n\n<br>\n\n```java\npublic class NaverUserFactory extends UserFactory {\n\t@Override  \n\tprotected User createUser() { \n\t\treturn new NaverUser(); \n\t} \n}\n```\n\n- ```UserFactory```를 상속받는 ```NaverUserFactory```\n\n\n\n<br><br>\n\n\n\n### 📌 Client\n```java\nUserFactory userFactory = new NaverUserFactory(); \nUser user = userFactory.newInstance();\n```\n- 클라이언트 코드에서 ```NaverUser``` 클래스에 대한 의존성 없이 사용\n\n\n<br><br><br><br>\n\n## ✅ 팩토리 메소드 확장\n\n팩토리 메소드의 가장 큰 장점은 확장 시 기존 코드의 변경 없이도 확장이 가능하다는 것이다. 따라서 위 예시에서 네이버 외에 다른 회사가 추가 되어도 기존 코드 변경 없이 추가할 수 있다. 카카오 서비스가 새로 추가된다고 가정해보자.\n\n```java\npublic class NaverUser implements User { \n\t@Override  \n\tpublic void signup() { \n\t\tSystem.out.println(\"네이버 아이디로 가입\"); \n\t} \n}\n\npublic class KakaoUser implements User { \n\t@Override  \n\tpublic void signup() { \n\t\tSystem.out.println(\"카카오 아이디로 가입\"); \n\t} \n}\n```\n\n- ```KakaoUser``` 클래스를 추가해준다.\n\n<br><br>\n\n```java\npublic class NaverUserFactory extends UserFactory {\n\t@Override  \n\tprotected User createUser() { \n\t\treturn new NaverUser(); \n\t} \n}\n\npublic class KakaoUserFactory extends UserFactory {\n\t@Override  \n\tprotected User createUser() { \n\t\treturn new KakaoUser(); \n\t} \n}\n```\n- ```NaverUserFactory``` 와 동일하게 ```KakaoUserFactory``` 정의\n\n<br><br>\n\n```java\nUserFactory userFactory = new NaverUserFactory(); \nUser user = userFactory.newInstance();\n\nUserFactory userFactory = new KakaoUserFactory(); \nUser user = userFactory.newInstance();\n```\n- 클라이언트에 새로운 Kakao객체 선언해주면서 기존 코드 변경없이 확장 가능!\n","properties":"\n","discussions":{},"comments":{},"hash":-574971919,"tx":167},"Kl8goLjOCe4Y2iU1/syncedContent":{"id":"Kl8goLjOCe4Y2iU1/syncedContent","type":"syncedContent","historyData":{"-574971919":{"id":"Kl8goLjOCe4Y2iU1/content","type":"content","text":"---\npermalink: /2022-08-25-팩토리 메소드(Factory Method)패턴/\npublished: true\ntitle: \"[Design Pattern] 팩토리 메소드(Factory Method) 패턴 \"\ndate: 2022-08-25 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"팩토리 메소드(Factory Method)패턴\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n- 생성 패턴\n---\n<br><br><br>\n\n## ✅ 팩토리 메소드 패턴 (Factory Method)\n\n\n- **객체 생성 처리를 서브 클래스로 분리 해 처리하도록 캡슐화 하는 패턴**\n\n- **객체의 생성코드를 별도의 클래스/메소드로 분리**함으로써 객체 생성의 변화 대비에 유용\n\n- 객체 생성 기능처럼 특정 기능을 개별 클래스를 통해 구현하는 것은 바람직한 객체 지향 설계 방법이다.\n\n- 생성 (Creational) 패턴의 하나이다.\n\n- **기존 코드 변경 없이 확장하기 위한 디자인 패턴!**\n\n<br><br>\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/factory1.png?raw=true\">\n</p>\n\n<br><br>\n\n📌 **Product** \n 　　　　팩토리 메소드로 생성 될 객체의 공통 인터페이스\n 　　　　　　\n📌 **ConcreteProduct** \n　　　　구체적으로 객체가 생성되는 클래스\n　　　\n📌 **Creator** \n　　　　팩토리 메소드를 갖는 클래스\n　　　\n📌 **ConcreteCreator** \n　　　　팩토리 메소드를 구현하는 클래스, ConcreteProduct 객체 생성\n\n\n<br><br><br><br>\n\n## ✅ 팩토리 메소드 예제\n<h5>⭐ 사용자 관리 프로그램이 있고 네이버 계정으로 가입할 수 있다.</h5>\n\n<br>\n\n### 📌 Product ( User )\n\n```java\npublic  interface User { \n\tvoid signup(); \n}\n```\n-``` User``` 인터페이스 정의\n\n<br>\n\n```java\npublic  class NaverUser implements User { \n\t@Override  \n\tpublic void signup() { \n\t\tSystem.out.println(\"네이버 아이디로 가입\"); \n\t} \n}\n```\n- ```User``` 인터페이스를 구현하는 ```NaverUser``` 클래스\n- 오버라이드한 메소드에서는 네이버 유저 전용 로직 추가\n\n<br><br>\n\n### 📌 Creator ( UserFactory )\n<h5>⭐ 실제로 객체를 생성하는 Factory</h5>\n\n```java\npublic abstract class UserFactory { \n\tpublic User newInstance() { \n\t\tUser user = createUser(); \n\t\tuser.signup(); \n\t\treturn user;\n\t} \n\tprotected abstract User createUser(); \n}\n```\n\n- 추상클래스로 UserFactory를 정의\n- 실제 객체를 생성하는 곳 ( 일종의 팩토리 )\n- 외부에서 User 객체를 생성 할 때는 ```newInstance()``` 메서드 호출\n- 어떤 객체를 생성할 지는 하위 클래스에서 결정\n\n<br>\n\n```java\npublic class NaverUserFactory extends UserFactory {\n\t@Override  \n\tprotected User createUser() { \n\t\treturn new NaverUser(); \n\t} \n}\n```\n\n- ```UserFactory```를 상속받는 ```NaverUserFactory```\n\n\n\n<br><br>\n\n\n\n### 📌 Client\n```java\nUserFactory userFactory = new NaverUserFactory(); \nUser user = userFactory.newInstance();\n```\n- 클라이언트 코드에서 ```NaverUser``` 클래스에 대한 의존성 없이 사용\n\n\n<br><br><br><br>\n\n## ✅ 팩토리 메소드 확장\n\n팩토리 메소드의 가장 큰 장점은 확장 시 기존 코드의 변경 없이도 확장이 가능하다는 것이다. 따라서 위 예시에서 네이버 외에 다른 회사가 추가 되어도 기존 코드 변경 없이 추가할 수 있다. 카카오 서비스가 새로 추가된다고 가정해보자.\n\n```java\npublic class NaverUser implements User { \n\t@Override  \n\tpublic void signup() { \n\t\tSystem.out.println(\"네이버 아이디로 가입\"); \n\t} \n}\n\npublic class KakaoUser implements User { \n\t@Override  \n\tpublic void signup() { \n\t\tSystem.out.println(\"카카오 아이디로 가입\"); \n\t} \n}\n```\n\n- ```KakaoUser``` 클래스를 추가해준다.\n\n<br><br>\n\n```java\npublic class NaverUserFactory extends UserFactory {\n\t@Override  \n\tprotected User createUser() { \n\t\treturn new NaverUser(); \n\t} \n}\n\npublic class KakaoUserFactory extends UserFactory {\n\t@Override  \n\tprotected User createUser() { \n\t\treturn new KakaoUser(); \n\t} \n}\n```\n- ```NaverUserFactory``` 와 동일하게 ```KakaoUserFactory``` 정의\n\n<br><br>\n\n```java\nUserFactory userFactory = new NaverUserFactory(); \nUser user = userFactory.newInstance();\n\nUserFactory userFactory = new KakaoUserFactory(); \nUser user = userFactory.newInstance();\n```\n- 클라이언트에 새로운 Kakao객체 선언해주면서 기존 코드 변경없이 확장 가능!\n","properties":"\n","discussions":{},"comments":{},"hash":-574971919}},"syncHistory":{"main":[-574971919,null,null]},"v":1,"hash":1710111595393,"tx":167},"Nz2EkixXKQGcuEag/content":{"id":"Nz2EkixXKQGcuEag/content","type":"content","text":"---\npermalink: /2022-08-29-제어의 역전(IoC)/\npublished: true\ntitle: \"[스프링] 제어의 역전 (Inversion Of Control) \"\ndate: 2022-08-29 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"제어의 역전(IoC)\"\ncategories:\n- Spring\ntags:\n- Spring\n- IoC\n- 스프링 빈\n- 애플리케이션 콘텍스트\n- 싱글톤 레지스트리\n---\n<br><br>\n\n## ✅ 제어의 역전 (IoC)\n\n**제어의 역전**이라는 건, 간단히 **프로그램의 제어 흐름 구조가 뒤바뀌는 것**이라고 설명할 수 있다.\n\n<br>\n\n일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 **다음에 사용할 오브젝트를 결정**하고, **결정한 오브젝트를 생성**하고, 만들어진 오브젝트에 있는 **메소드를 호출**하고, 그 오브젝트 메소드 안에서 **다음에 사용할 것을 결정하고 호출**하는 식의 작업이 반복된다. \n\n<br>\n\n한마디로, 이런 프로그램 구조에서 각 **오브젝트는 프로그램의 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여한다.**\n\n<br>\n\n⭐ **제어의 역전(IoC, 이하 IoC라고 부르겠다)은 이런 제어의 흐름을 뒤바꾸는 것이다.** \n\n<br>\n\n- **오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.** \n- **오브젝트는 스스로 생성하지도 않는다.**\n- **오브젝트 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다.**\n- **모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다.**\n- **우리는 이것을 IoC라고 부른다.**\n\n<br><br><br><br>\n\n## ✅ JAVA의 IoC\n\n\n### 📌IoC 적용 전 예제\n<Br>\n\n```java\npublic class Test01 {\n\tpublic static void main(String[] args) {\n\t\tPlayer p = new Player();\n\t\tp.play();\n\t}\n}\n```\n\n```java\nclass Player {\n\tDice1 d = new Dice1();\t// 객체의 생성을 객체가 하고 있음\n\tpublic void play() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tSystem.out.println(d.getDiceValue()); \n\t\t}\n\t}\n}\n\nclass Dice1{\n\tpublic String getDiceValue(){return \"주사위알고리즘1로 play\";}\n}\n\nclass Dice2 {\n\tpublic String  getDiceValue(){return \"주사위알고리즘2로 play\";}\n}\n```\n\n위 코드를 보면 우리가 일반적으로 작성하는 코드와 거의 비슷하다. `main()` 에서 Player 객체를 하나 만들어 주고, Player 클래스에서 사용할 `Dice1()` 객체를 정해주고 있는 구조이다. \n\n이부분이 중요하다. **Player 클래스의 `d`인스턴스가 자신이 사용할 `Dice1()` 클래스를 직접 정하고 알고 있다는 점이다.** 이는 IOC가 적용되지 않은 코드를 의미한다.\n\n**그럼 IOC가 적용되지 않았을때 무엇이 문제가 되길래 IOC를 굳이 적용시켜주려는 것일까?** 만일 Player에서 Dice1객체가 아닌 Dice2객체를 사용하고자 하면 어떨까? 우리는 Player 클래스에 접근해서 소스코드를 변경해주어야만 한다.\n\n그렇다면 매번 사용할 객체가 변경되면 변경될때마다 Player에 접근해서 직접 소스코드를 변경해줘야하는 번거로움이 생긴다. 이를 해결하기위해 IOC를 적용해서 객체가 직접 객체를 선택하는 것이 아닌, 외부의 다른 요소를 통해 객체에 대한 생성 및 사용을 결정하게끔 하는것이다.\n<br><br>\n\n### 📌IoC 적용 후 예제\n```java\npublic class Test02 { \n\tpublic static void main(String[] args) { \n\t\tPlayer p = new Player(new Dice1()); \n\t\tp.play(); \n\t} \n}\n```\n```java\npublic class Player {\n\tprivate Dice d = null;\n\tpublic Player(Dice d) { this.d = d; }\n\n\tpublic void play() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tSystem.out.println(d.getDiceValue()); \n\t\t}\n\t}\n}\n\ninterface Dice {  \n\tpublic String getDiceValue();               \n}\n\nclass Dice1  implements Dice {\n\tpublic String getDiceValue(){return \"주사위알고리즘1로 play\";}\n}\n\nclass Dice2   implements Dice  {\n\tpublic String  getDiceValue(){return \"주사위알고리즘2로 play\";}\n}\n```\n위의 예제에서 변화된 부분은 Dice 인터페이스를 선언하고, 하위 Dice1, Dice2를 생성한 것이다.\n\n그리고, Player는 Dice 인터페이스를 필드로 가지고 있으며, 생성자에서 Dice를 매개인자로 선언하고있다.\n\n이것은 Player가 사용하는 주사위 객체를 고정하는 것이 아니라, Dice 하위의 여러 타입을 이용한다는 것을 의미한다.\n\n이제 Player의 사용 주사위 객체를 변경하고 싶을 때, Player 클래스의 소스를 수정할 필요가 없다.\n\n그런데, 이 예제에서도 문제점은 있다. Test02에서 Dice2객체를 Player의 생성자 매개인자로 넣고 있는데, Dice1으로 변경하려하면 Test02 소스코드를 수정해야 한다.\n\n소스코드에 하드 코딩되어 있기 때문이다. 이것을 개선하는 방법으로, 클래스 로더나 리플렉션을 이용할 수 있으나, 이러한 기술을 몰라도 스프링 프레임워크에서는 의존성을 주입하는 방법을 이용하여 이를 해결할 수 있다.\n\n\n<br><br><Br><Br>\n\n\n## ✅ 스프링의 IoC\n\n스프링 프레임워크는 IOC 개념을 기반으로 설계되었고, IOC가 적용된 다양한 기능과 개념을 제공하고 있다.\n\n1. **스프링 컨테이너**\n\t스프링 컨테이너를 통해 스프링 빈을 관리\n\t\n2. [**의존성 주입(DI)**](https://idkim97.github.io/2022-08-29-%EC%9D%98%EC%A1%B4%EC%84%B1%20%EC%A3%BC%EC%9E%85%28DI%29/)\n\t객체간의 의존관계를 스프링이 자동으로 처리\n\t\n3. **컴포넌트 스캔**\n\t스프링이 자동으로 빈을 찾아 등록\n\t\n4. **스프링 AOP**\n\t스프링이 자동으로 관심사를 분리하고 모듈화\n\t\n5. **트랜젝션 관리**\n\t스프링이 자동으로 트랜젝션의 시작, 커밋, 롤백 처리\n\n위처럼 스프링에서 IOC 개념이 탑재된 수많은 기능들이 존재한다. 각각의 개념들은 따로 포스팅을 통해 설명되어 있으니 참고하면 좋겠다.\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-66721485,"tx":169},"Nz2EkixXKQGcuEag/syncedContent":{"id":"Nz2EkixXKQGcuEag/syncedContent","type":"syncedContent","historyData":{"-66721485":{"id":"Nz2EkixXKQGcuEag/content","type":"content","text":"---\npermalink: /2022-08-29-제어의 역전(IoC)/\npublished: true\ntitle: \"[스프링] 제어의 역전 (Inversion Of Control) \"\ndate: 2022-08-29 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"제어의 역전(IoC)\"\ncategories:\n- Spring\ntags:\n- Spring\n- IoC\n- 스프링 빈\n- 애플리케이션 콘텍스트\n- 싱글톤 레지스트리\n---\n<br><br>\n\n## ✅ 제어의 역전 (IoC)\n\n**제어의 역전**이라는 건, 간단히 **프로그램의 제어 흐름 구조가 뒤바뀌는 것**이라고 설명할 수 있다.\n\n<br>\n\n일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 **다음에 사용할 오브젝트를 결정**하고, **결정한 오브젝트를 생성**하고, 만들어진 오브젝트에 있는 **메소드를 호출**하고, 그 오브젝트 메소드 안에서 **다음에 사용할 것을 결정하고 호출**하는 식의 작업이 반복된다. \n\n<br>\n\n한마디로, 이런 프로그램 구조에서 각 **오브젝트는 프로그램의 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여한다.**\n\n<br>\n\n⭐ **제어의 역전(IoC, 이하 IoC라고 부르겠다)은 이런 제어의 흐름을 뒤바꾸는 것이다.** \n\n<br>\n\n- **오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.** \n- **오브젝트는 스스로 생성하지도 않는다.**\n- **오브젝트 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다.**\n- **모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다.**\n- **우리는 이것을 IoC라고 부른다.**\n\n<br><br><br><br>\n\n## ✅ JAVA의 IoC\n\n\n### 📌IoC 적용 전 예제\n<Br>\n\n```java\npublic class Test01 {\n\tpublic static void main(String[] args) {\n\t\tPlayer p = new Player();\n\t\tp.play();\n\t}\n}\n```\n\n```java\nclass Player {\n\tDice1 d = new Dice1();\t// 객체의 생성을 객체가 하고 있음\n\tpublic void play() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tSystem.out.println(d.getDiceValue()); \n\t\t}\n\t}\n}\n\nclass Dice1{\n\tpublic String getDiceValue(){return \"주사위알고리즘1로 play\";}\n}\n\nclass Dice2 {\n\tpublic String  getDiceValue(){return \"주사위알고리즘2로 play\";}\n}\n```\n\n위 코드를 보면 우리가 일반적으로 작성하는 코드와 거의 비슷하다. `main()` 에서 Player 객체를 하나 만들어 주고, Player 클래스에서 사용할 `Dice1()` 객체를 정해주고 있는 구조이다. \n\n이부분이 중요하다. **Player 클래스의 `d`인스턴스가 자신이 사용할 `Dice1()` 클래스를 직접 정하고 알고 있다는 점이다.** 이는 IOC가 적용되지 않은 코드를 의미한다.\n\n**그럼 IOC가 적용되지 않았을때 무엇이 문제가 되길래 IOC를 굳이 적용시켜주려는 것일까?** 만일 Player에서 Dice1객체가 아닌 Dice2객체를 사용하고자 하면 어떨까? 우리는 Player 클래스에 접근해서 소스코드를 변경해주어야만 한다.\n\n그렇다면 매번 사용할 객체가 변경되면 변경될때마다 Player에 접근해서 직접 소스코드를 변경해줘야하는 번거로움이 생긴다. 이를 해결하기위해 IOC를 적용해서 객체가 직접 객체를 선택하는 것이 아닌, 외부의 다른 요소를 통해 객체에 대한 생성 및 사용을 결정하게끔 하는것이다.\n<br><br>\n\n### 📌IoC 적용 후 예제\n```java\npublic class Test02 { \n\tpublic static void main(String[] args) { \n\t\tPlayer p = new Player(new Dice1()); \n\t\tp.play(); \n\t} \n}\n```\n```java\npublic class Player {\n\tprivate Dice d = null;\n\tpublic Player(Dice d) { this.d = d; }\n\n\tpublic void play() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tSystem.out.println(d.getDiceValue()); \n\t\t}\n\t}\n}\n\ninterface Dice {  \n\tpublic String getDiceValue();               \n}\n\nclass Dice1  implements Dice {\n\tpublic String getDiceValue(){return \"주사위알고리즘1로 play\";}\n}\n\nclass Dice2   implements Dice  {\n\tpublic String  getDiceValue(){return \"주사위알고리즘2로 play\";}\n}\n```\n위의 예제에서 변화된 부분은 Dice 인터페이스를 선언하고, 하위 Dice1, Dice2를 생성한 것이다.\n\n그리고, Player는 Dice 인터페이스를 필드로 가지고 있으며, 생성자에서 Dice를 매개인자로 선언하고있다.\n\n이것은 Player가 사용하는 주사위 객체를 고정하는 것이 아니라, Dice 하위의 여러 타입을 이용한다는 것을 의미한다.\n\n이제 Player의 사용 주사위 객체를 변경하고 싶을 때, Player 클래스의 소스를 수정할 필요가 없다.\n\n그런데, 이 예제에서도 문제점은 있다. Test02에서 Dice2객체를 Player의 생성자 매개인자로 넣고 있는데, Dice1으로 변경하려하면 Test02 소스코드를 수정해야 한다.\n\n소스코드에 하드 코딩되어 있기 때문이다. 이것을 개선하는 방법으로, 클래스 로더나 리플렉션을 이용할 수 있으나, 이러한 기술을 몰라도 스프링 프레임워크에서는 의존성을 주입하는 방법을 이용하여 이를 해결할 수 있다.\n\n\n<br><br><Br><Br>\n\n\n## ✅ 스프링의 IoC\n\n스프링 프레임워크는 IOC 개념을 기반으로 설계되었고, IOC가 적용된 다양한 기능과 개념을 제공하고 있다.\n\n1. **스프링 컨테이너**\n\t스프링 컨테이너를 통해 스프링 빈을 관리\n\t\n2. [**의존성 주입(DI)**](https://idkim97.github.io/2022-08-29-%EC%9D%98%EC%A1%B4%EC%84%B1%20%EC%A3%BC%EC%9E%85%28DI%29/)\n\t객체간의 의존관계를 스프링이 자동으로 처리\n\t\n3. **컴포넌트 스캔**\n\t스프링이 자동으로 빈을 찾아 등록\n\t\n4. **스프링 AOP**\n\t스프링이 자동으로 관심사를 분리하고 모듈화\n\t\n5. **트랜젝션 관리**\n\t스프링이 자동으로 트랜젝션의 시작, 커밋, 롤백 처리\n\n위처럼 스프링에서 IOC 개념이 탑재된 수많은 기능들이 존재한다. 각각의 개념들은 따로 포스팅을 통해 설명되어 있으니 참고하면 좋겠다.\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-66721485}},"syncHistory":{"main":[-66721485,null,null]},"v":1,"hash":1710111596498,"tx":169},"jCnq3Wvv7Hqcz9L7/content":{"id":"jCnq3Wvv7Hqcz9L7/content","type":"content","text":"---\npermalink: /2022-08-26-4주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 3. 4주차 인턴일기\"\ndate: 2022-08-26 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"4주차 인턴일기\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n## 13. 😊\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1559413998,"tx":171},"jCnq3Wvv7Hqcz9L7/syncedContent":{"id":"jCnq3Wvv7Hqcz9L7/syncedContent","type":"syncedContent","historyData":{"-1559413998":{"id":"jCnq3Wvv7Hqcz9L7/content","type":"content","text":"---\npermalink: /2022-08-26-4주차 인턴일기/\npublished : true\ntitle: \"[인턴] [일상] 3. 4주차 인턴일기\"\ndate: 2022-08-26 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"4주차 인턴일기\"\ncategories:\n- 인턴\ntags:\n- 인턴\n---\n\n## 13. 😊\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1559413998}},"syncHistory":{"main":[-1559413998,null,null]},"v":1,"hash":1710111597658,"tx":171},"MTb2rEZmbJruPLxT/content":{"id":"MTb2rEZmbJruPLxT/content","type":"content","text":"---\npermalink: /2022-08-29-의존성 주입(DI)/\npublished: true\ntitle: \"[스프링] 의존성 주입(DI) \"\ndate: 2022-08-30 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"의존성 주입(DI)\"\ncategories:\n- Spring\ntags:\n- Spring\n- IoC\n- DI\n- 카카오 클라우드 스쿨\n---\n<br><br><br>\n\n## ✅ 의존 관계\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/di1.png?raw=true\">\n</p>\n\n의존성 주입(DI)을 공부하기 전에 의존 관계란 무엇인가 부터 살펴볼 필요가 있다. 두개의 클래스나 모듈이 의존 관계에 있다고 말할 때는 반드시 **방향성**이 있어야만 한다. '**누가 누구에게 의존하고 있다**' 라는 관계가 있어야 한다는 뜻이다. 위의 그림에서는 'A가 B에 의존하고 있다' 라고 볼 수 있다.\n\n<br><br>\n\n그렇다면 '의존한다' 라는게 정확히 무슨 의미일까? 여기서는 **B가 변하면 그것이 A에 영향을 미친다**는 뜻이다. B의 기능이 추가되거나 변경되거나, 형식이 바뀌거나 하면 그 영향이 A로 전달 된다는 것이다. 대표적으로 **A가 B에 정의된 메소드를 호출해서 사용하는 경우**, 사용에 대한 의존관계에 있다고 표현한다.\n\n<br><br><br><br>\n\n## ✅ 의존성 주입 (DI)\n\n스프링에서 의존성 주입(DI)은 **빈의 생성자**나 **세터 메서드**에 인수를 넘기는 방식으로 이뤄진다. **DI는 한마디로 객체 간의 의존 관계를 생성자 인수나 세터 메서드 인수로 명시하고 객체를 생성할 때 생성자나 세터를 통해 의존관계를 주입하는 방식을 따르는 디자인 패턴이다.**\n\n- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 **인터페이스**에만 의존하고 있어야 한다.\n- 런타임 시점의 의존관계는 **컨테이너나 팩토리 같은 제 3의 존재가 결정**한다.\n- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 **외부에서 주입**해줌으로써 만들어진다.\n\n의존성 주입 예제를 위한 코드를 간단하게 설명하도록 하겠다. `MyBank` 애플리케이션의 `PersonalBankingService` 에는 '은행계좌 명세서 가져오기', '은행 계좌 상세 정보 살펴보기', '연락처 갱신하기', '암호 변경하기', '고객 연락하기' 등의 서비스가 있다.  `PersonalBankingService` 클래스는 `JmsMessageSender` (JMS 메시지 전송), `EmailSender` (이메일 전송), `WebServiceInvoker` (외부 웹서비스 호출) 객체를 사용해 고객에게 필요한 기능을 제공한다.\n\n<br><br>\n\n### 1️⃣ 의존성 주입 - 생성자 \n\n#### 📌 DI 적용 이전 - 생성자\n\n```java\npublic class PersonalBankingService() {\n\t\n\tprivate JmsMessageSender jmsMessageSender;\n\tprivate EmailSender emailSender;\n\tprivate WebServiceInvoker webServiceInvoker;\n\t\n\tpublic PersonalBankingService() {\n\t\tjmsMessageSender = new TedJmsMessageSender();\n\t\temailSender = new TedEmailSender();\n\t\twebServiceInvoker = new TedWebServiceInvoker();\n\t}\n}\n```\n\n<Br>\n\n이 코드는 지금 **`PersonalBanksingService`가 설계 시점에서 이미 `TedJmsMessageSender()`, `TedEmailSender()` , `TedWebServiceInvoker()` 라는 구체적인 클래스의 존재를 알고 있다.** `PersonalBanksingService`가 `jmsMessageSender` , `emailSender`, `webServiceInvoker` 라는 인터페이스 뿐만 아니라 구체적인 오브젝트를 사용하겠다는 사실까지 이미 알고있는 셈이다.\n\n<br>\n\n런타임 시의 의존관계가 이미 코드속에 다 미리 결정되어 있는 것은 DI가 적용되지 않은 안좋은 코드이다. **DI에서 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정해야만 한다**. \n\n<br><br>\n\n#### 📌 DI 적용 이후 - 생성자\n\n```java\npublic class PersonalBankingService() {\n\n\tprivate JmsMessageSender jmsMessageSender;\n\tprivate EmailSender emailSender;\n\tprivate WebServiceInvoker webServiceInvoker;\n\n\t...\n\n\tpublic PersonalBankingService(JmsMessageSender jmsMessageSender,\n\t\t\t\t\t\t\t\t\tEmailSender emailSender,\n\t\t\t\t\t\t\t\t\tWebServiceInvoker webServiceInvoker) {\n\t\t\tthis.jmsMessageSender = jmsMessageSender;\n\t\t\tthis.emailSender = emailSender;\n\t\t\tthis.webServiceInvoker = webServiceInvoker;\n\t}\n}\n```\n<Br>\n\n이렇게 `PersonalBankingService` 오브젝트는 이제 더이상 스스로 `jmsMessageSender, emailSender, webServiceInvoker`를 사용하지 않고, **생성자를 통해 주입**받은 오브젝트를 사용하게 된다. 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 주입받은 오브젝트를 사용한 다는 점에서 IoC 개념에 딱 들어맞는다고 볼 수 있다.\n\n<br><br>\n\n#### 📌 DI 적용 이후 - 빈 정의\n\n```java\n<bean id=\"personalBankingService\" class=\"PersonalBankingService\">\n\t<constructor-arg index=\"0\" ref=\"jsmMessageSender\" />\n\t<constructor-arg index=\"1\" ref=\"emailSender\" />\n\t<constructor-arg index=\"2\" ref=\"webServiceInvoker\" />\n</bean>\n\n<bean id=\"jsmMessageSender\" class=\"JmsMessageSender\">\n...\n</bean>\n<bean id=\"emailSender\" class=\"EmailSender\">\n...\n</bean>\n<bean id=\"webServiceInvoker\" class=\"WebServiceInvoker\">\n...\n</bean>\n```\n<br>\n\n여기서 `<constructor-arg>` 엘리먼트는 `PersonalBankingService` 인스턴스의 생성자에 전달한 인수를 지정한다. index 속성은 생성자 인수의 순서이고, ref 속성은 빈에 참조를 전달한다. \n\n`<constructor-arg index=\"0\" ref=\"jsmMessageSender\" />` 이 코드를 해석해보면 \" `jsmMessageSender` 라는 이름을 가진 bean을 0번째 인자로 생성자에 등록하겠다.\" 라고 해석할 수 있다. \n\n<br><br><br><br>\n\n\n### 2️⃣ 의존성 주입 - 수정자 (Setter) \n\n생성자를 이용한 DI에서는 생성자에 파라미터를 만들어두고 이를 통해 DI 컨테이너가 의존할 오브젝트를 넘겨주도록 만들었다. 그러나 DI를 하는 방법은 생성자 외에도 또 있다. 바로 **수정자 (Setter)** 를 이용해 DI를 하는것이다. 스프링에서는 DI를 위한 방법으로 수정자 메소드를 가장 많이 활용한다. XML을 사용해 bean을 등록해 쓰는 경우 setter를 이용하는게 가장 편리하기 때문이다. \n\n<br><br>\n\n#### 📌 DI 적용 이후 - 세터\n\n```java\npublic class PersonalBankingService() {\n\n\tprivate JmsMessageSender jmsMessageSender;\n\tprivate EmailSender emailSender;\n\tprivate WebServiceInvoker webServiceInvoker;\n\n\t...\n\n\tpublic void setJmsMessageSender (JmsMessageSender jmsMessageSender) {\n\t\tthis.jmsMessageSender = jmsMessageSender;\n\t}\n\t\n\tpublic void setEmailSender (EmailSender emailSender) {\n\t\tthis.emailSender= emailSender;\n\t}\n\t\n\tpublic void setWebServiceInvoker (WebServiceInvoker webServiceInvoker) {\n\t\tthis.webServiceInvoker= webServiceInvoker;\n\t}\n}\n```\n<br>\n\n\n세터를 활용해 DI를 적용하는 방법은 어렵지 않다. 위 예시코드를 보면 `PersonalBankingService` 클래스의 각 의존 관계마다 세터 메서드를 정의한다. \n\n<br><br>\n\n####  📌 DI 적용 이후 - 빈 정의\n```java\n<bean id=\"personalBankingService\" class=\"PersonalBankingService\">\n\t<property name=\"jsmMessageSender\" ref=\"jsmMessageSender\" />\n\t<property name=\"emailSender\" ref=\"emailSender\" />\n\t<property name=\"webServiceInvoker\" ref=\"webServiceInvoker\" />\n</bean>\n\n<bean id=\"jsmMessageSender\" class=\"JmsMessageSender\">\n...\n</bean>\n<bean id=\"emailSender\" class=\"EmailSender\">\n...\n</bean>\n<bean id=\"webServiceInvoker\" class=\"WebServiceInvoker\">\n...\n</bean>\n```\n\n세터를 사용해 DI를 적용한 경우에 빈을 정의할때는 `<property>` 엘리먼트를 사용한다. \n`<property>`는 `name`과 `value` 속성이 필요한데, `name` 속성은 세터 메소드 이름의 set을 제외한 소문자를 `name`에 할당한다 (ex serUserId => userid ). `value` 속성은 세터에 할당할 값을 의미한다. `ref` 속성은 마찬가지로 참조할 값, 즉 bean의 id를 의미한다.\n\n<br><br>\n\n생성자를 이용하든, 수정자를 이용하든 실제 결과는 동일할 것이다. 스프링에서는 생성자, 수정자, 초기화 메소드 외에도 다양한 DI방법을 지원한다. \n","properties":"\n","discussions":{},"comments":{},"hash":1920367372,"tx":173},"MTb2rEZmbJruPLxT/syncedContent":{"id":"MTb2rEZmbJruPLxT/syncedContent","type":"syncedContent","historyData":{"1920367372":{"id":"MTb2rEZmbJruPLxT/content","type":"content","text":"---\npermalink: /2022-08-29-의존성 주입(DI)/\npublished: true\ntitle: \"[스프링] 의존성 주입(DI) \"\ndate: 2022-08-30 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"의존성 주입(DI)\"\ncategories:\n- Spring\ntags:\n- Spring\n- IoC\n- DI\n- 카카오 클라우드 스쿨\n---\n<br><br><br>\n\n## ✅ 의존 관계\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/di1.png?raw=true\">\n</p>\n\n의존성 주입(DI)을 공부하기 전에 의존 관계란 무엇인가 부터 살펴볼 필요가 있다. 두개의 클래스나 모듈이 의존 관계에 있다고 말할 때는 반드시 **방향성**이 있어야만 한다. '**누가 누구에게 의존하고 있다**' 라는 관계가 있어야 한다는 뜻이다. 위의 그림에서는 'A가 B에 의존하고 있다' 라고 볼 수 있다.\n\n<br><br>\n\n그렇다면 '의존한다' 라는게 정확히 무슨 의미일까? 여기서는 **B가 변하면 그것이 A에 영향을 미친다**는 뜻이다. B의 기능이 추가되거나 변경되거나, 형식이 바뀌거나 하면 그 영향이 A로 전달 된다는 것이다. 대표적으로 **A가 B에 정의된 메소드를 호출해서 사용하는 경우**, 사용에 대한 의존관계에 있다고 표현한다.\n\n<br><br><br><br>\n\n## ✅ 의존성 주입 (DI)\n\n스프링에서 의존성 주입(DI)은 **빈의 생성자**나 **세터 메서드**에 인수를 넘기는 방식으로 이뤄진다. **DI는 한마디로 객체 간의 의존 관계를 생성자 인수나 세터 메서드 인수로 명시하고 객체를 생성할 때 생성자나 세터를 통해 의존관계를 주입하는 방식을 따르는 디자인 패턴이다.**\n\n- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 **인터페이스**에만 의존하고 있어야 한다.\n- 런타임 시점의 의존관계는 **컨테이너나 팩토리 같은 제 3의 존재가 결정**한다.\n- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 **외부에서 주입**해줌으로써 만들어진다.\n\n의존성 주입 예제를 위한 코드를 간단하게 설명하도록 하겠다. `MyBank` 애플리케이션의 `PersonalBankingService` 에는 '은행계좌 명세서 가져오기', '은행 계좌 상세 정보 살펴보기', '연락처 갱신하기', '암호 변경하기', '고객 연락하기' 등의 서비스가 있다.  `PersonalBankingService` 클래스는 `JmsMessageSender` (JMS 메시지 전송), `EmailSender` (이메일 전송), `WebServiceInvoker` (외부 웹서비스 호출) 객체를 사용해 고객에게 필요한 기능을 제공한다.\n\n<br><br>\n\n### 1️⃣ 의존성 주입 - 생성자 \n\n#### 📌 DI 적용 이전 - 생성자\n\n```java\npublic class PersonalBankingService() {\n\t\n\tprivate JmsMessageSender jmsMessageSender;\n\tprivate EmailSender emailSender;\n\tprivate WebServiceInvoker webServiceInvoker;\n\t\n\tpublic PersonalBankingService() {\n\t\tjmsMessageSender = new TedJmsMessageSender();\n\t\temailSender = new TedEmailSender();\n\t\twebServiceInvoker = new TedWebServiceInvoker();\n\t}\n}\n```\n\n<Br>\n\n이 코드는 지금 **`PersonalBanksingService`가 설계 시점에서 이미 `TedJmsMessageSender()`, `TedEmailSender()` , `TedWebServiceInvoker()` 라는 구체적인 클래스의 존재를 알고 있다.** `PersonalBanksingService`가 `jmsMessageSender` , `emailSender`, `webServiceInvoker` 라는 인터페이스 뿐만 아니라 구체적인 오브젝트를 사용하겠다는 사실까지 이미 알고있는 셈이다.\n\n<br>\n\n런타임 시의 의존관계가 이미 코드속에 다 미리 결정되어 있는 것은 DI가 적용되지 않은 안좋은 코드이다. **DI에서 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정해야만 한다**. \n\n<br><br>\n\n#### 📌 DI 적용 이후 - 생성자\n\n```java\npublic class PersonalBankingService() {\n\n\tprivate JmsMessageSender jmsMessageSender;\n\tprivate EmailSender emailSender;\n\tprivate WebServiceInvoker webServiceInvoker;\n\n\t...\n\n\tpublic PersonalBankingService(JmsMessageSender jmsMessageSender,\n\t\t\t\t\t\t\t\t\tEmailSender emailSender,\n\t\t\t\t\t\t\t\t\tWebServiceInvoker webServiceInvoker) {\n\t\t\tthis.jmsMessageSender = jmsMessageSender;\n\t\t\tthis.emailSender = emailSender;\n\t\t\tthis.webServiceInvoker = webServiceInvoker;\n\t}\n}\n```\n<Br>\n\n이렇게 `PersonalBankingService` 오브젝트는 이제 더이상 스스로 `jmsMessageSender, emailSender, webServiceInvoker`를 사용하지 않고, **생성자를 통해 주입**받은 오브젝트를 사용하게 된다. 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 주입받은 오브젝트를 사용한 다는 점에서 IoC 개념에 딱 들어맞는다고 볼 수 있다.\n\n<br><br>\n\n#### 📌 DI 적용 이후 - 빈 정의\n\n```java\n<bean id=\"personalBankingService\" class=\"PersonalBankingService\">\n\t<constructor-arg index=\"0\" ref=\"jsmMessageSender\" />\n\t<constructor-arg index=\"1\" ref=\"emailSender\" />\n\t<constructor-arg index=\"2\" ref=\"webServiceInvoker\" />\n</bean>\n\n<bean id=\"jsmMessageSender\" class=\"JmsMessageSender\">\n...\n</bean>\n<bean id=\"emailSender\" class=\"EmailSender\">\n...\n</bean>\n<bean id=\"webServiceInvoker\" class=\"WebServiceInvoker\">\n...\n</bean>\n```\n<br>\n\n여기서 `<constructor-arg>` 엘리먼트는 `PersonalBankingService` 인스턴스의 생성자에 전달한 인수를 지정한다. index 속성은 생성자 인수의 순서이고, ref 속성은 빈에 참조를 전달한다. \n\n`<constructor-arg index=\"0\" ref=\"jsmMessageSender\" />` 이 코드를 해석해보면 \" `jsmMessageSender` 라는 이름을 가진 bean을 0번째 인자로 생성자에 등록하겠다.\" 라고 해석할 수 있다. \n\n<br><br><br><br>\n\n\n### 2️⃣ 의존성 주입 - 수정자 (Setter) \n\n생성자를 이용한 DI에서는 생성자에 파라미터를 만들어두고 이를 통해 DI 컨테이너가 의존할 오브젝트를 넘겨주도록 만들었다. 그러나 DI를 하는 방법은 생성자 외에도 또 있다. 바로 **수정자 (Setter)** 를 이용해 DI를 하는것이다. 스프링에서는 DI를 위한 방법으로 수정자 메소드를 가장 많이 활용한다. XML을 사용해 bean을 등록해 쓰는 경우 setter를 이용하는게 가장 편리하기 때문이다. \n\n<br><br>\n\n#### 📌 DI 적용 이후 - 세터\n\n```java\npublic class PersonalBankingService() {\n\n\tprivate JmsMessageSender jmsMessageSender;\n\tprivate EmailSender emailSender;\n\tprivate WebServiceInvoker webServiceInvoker;\n\n\t...\n\n\tpublic void setJmsMessageSender (JmsMessageSender jmsMessageSender) {\n\t\tthis.jmsMessageSender = jmsMessageSender;\n\t}\n\t\n\tpublic void setEmailSender (EmailSender emailSender) {\n\t\tthis.emailSender= emailSender;\n\t}\n\t\n\tpublic void setWebServiceInvoker (WebServiceInvoker webServiceInvoker) {\n\t\tthis.webServiceInvoker= webServiceInvoker;\n\t}\n}\n```\n<br>\n\n\n세터를 활용해 DI를 적용하는 방법은 어렵지 않다. 위 예시코드를 보면 `PersonalBankingService` 클래스의 각 의존 관계마다 세터 메서드를 정의한다. \n\n<br><br>\n\n####  📌 DI 적용 이후 - 빈 정의\n```java\n<bean id=\"personalBankingService\" class=\"PersonalBankingService\">\n\t<property name=\"jsmMessageSender\" ref=\"jsmMessageSender\" />\n\t<property name=\"emailSender\" ref=\"emailSender\" />\n\t<property name=\"webServiceInvoker\" ref=\"webServiceInvoker\" />\n</bean>\n\n<bean id=\"jsmMessageSender\" class=\"JmsMessageSender\">\n...\n</bean>\n<bean id=\"emailSender\" class=\"EmailSender\">\n...\n</bean>\n<bean id=\"webServiceInvoker\" class=\"WebServiceInvoker\">\n...\n</bean>\n```\n\n세터를 사용해 DI를 적용한 경우에 빈을 정의할때는 `<property>` 엘리먼트를 사용한다. \n`<property>`는 `name`과 `value` 속성이 필요한데, `name` 속성은 세터 메소드 이름의 set을 제외한 소문자를 `name`에 할당한다 (ex serUserId => userid ). `value` 속성은 세터에 할당할 값을 의미한다. `ref` 속성은 마찬가지로 참조할 값, 즉 bean의 id를 의미한다.\n\n<br><br>\n\n생성자를 이용하든, 수정자를 이용하든 실제 결과는 동일할 것이다. 스프링에서는 생성자, 수정자, 초기화 메소드 외에도 다양한 DI방법을 지원한다. \n","properties":"\n","discussions":{},"comments":{},"hash":1920367372}},"syncHistory":{"main":[1920367372,null,null]},"v":1,"hash":1710111598653,"tx":173},"EO4J8PI1VIfZ6v35/content":{"id":"EO4J8PI1VIfZ6v35/content","type":"content","text":"---\npermalink: /2022-10-25-스프링 입문_회원 관리 예제/\ntitle: \"[스프링부트] [JAVA] [입문] 3. 회원 관리 예제 - 백엔드 개발\"\ndate: 2022-10-25 21:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><br>\n\n## ✅ 비즈니스 요구사항\n- 데이터 : 회원 ID, 이름\n- 기능 : 회원 등록, 조회\n- 데이터 저장소는 선정되지 않음\n\n<br><br><br><br>\n\n## ✅ 웹 애플리케이션 구조\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/back1.png?raw=true\">\n</p>\n\n- 컨트롤러 : MVC의 컨트롤러 역할\n- 서비스 : 핵심 비즈니스 로직 구현\n- 리포지토리 : DB에 접근, 도메인 객체를 DB에 저장하고 관리\n- 도메인 : 비즈니스 도메인 객체\n\n<br><br><br><br>\n\n## ✅ 회원 도메인과 리포지토리 만들기\n\n📌 **Member 객체**\n\n```java\npackage hello.hellospring.domain;\npublic class Member {\n\n\t private Long id;\n\t private String name;\n\t \n\t public Long getId() {\n\t\t return id;\n\t }\n\t \n\t public void setId(Long id) {\n\t\t this.id = id;\n\t }\n \n\t public String getName() {\n\t\t return name;\n\t }\n \n\t public void setName(String name) {\n\t\t this.name = name;\n\t }\n}\n```\n<br><br>\n\n📌 **MemberRepository 인터페이스**\n```java\npackage hello.hellospring.repository;\n\nimport hello.hellospring.domain.Member;\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface MemberRepository {\n\tMember save(Member member); // save: 회원을 저장소에 저장\n\tOptional<Member> findById(Long id); // id로 멤버찾기\n\tOptional<Member> findByName(String name); // name으로 멤버찾기\n\tList<Member> findAll(); // 모든 회원 리스트 찾기\n}\n```\n<br><br>\n\n📌 **MemberRepository 구현부**\n```java\npackage hello.hellospring.repository;\n\nimport hello.hellospring.domain.Member;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.*;\n\n// Alt + Enter -> implement method -> 전부 ok\n@Repository\npublic class MemoryMemberRepository implements MemberRepository{\n\n    private static Map<Long, Member> store = new HashMap<>();\n    private static long sequence = 0L; // 0,1,2 key값을 생성\n\n    @Override\n    public Member save(Member member) {\n        member.setId(++sequence);\n        store.put(member.getId(), member);\n        return member;\n    }\n\n    @Override\n    public Optional<Member> findById(Long id) {\n        return Optional.ofNullable(store.get(id));\n    }\n\n    @Override\n    public Optional<Member> findByName(String name) {\n        return store.values().stream()\n                .filter(member->member.getName().equals(name))\n                .findAny();\n    }\n\n    @Override\n    public List<Member> findAll() {\n        return new ArrayList<>(store.values());\n    }\n\n    public void clearStore(){\n        store.clear();\n    }\n}\n```\n\n<br><br><br><br>\n\n## ✅ 회원 리포지토리 테스트 케이스\n📌 **MemberRepository 테스트**\n```java\npackage hello.hellospring.repository;\n\nimport hello.hellospring.domain.Member;\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.*;\n\npublic class MemoryMemberRepositoryTest {\n\n    MemoryMemberRepository repository = new MemoryMemberRepository();\n\n    // 테스트 끝나고 레포지토리 싹 지워주는거\n    @AfterEach\n    public void afterEach(){\n        repository.clearStore();\n    }\n\n    @Test\n    public void save(){\n        Member member = new Member();\n        member.setName(\"spring\");\n\n        repository.save(member);\n\n        Member result = repository.findById(member.getId()).get();\n        assertThat(member).isEqualTo(result);\n        //Assertions.assertEquals(member,result);\n        //System.out.println(\"result = \" + (result==member));\n    }\n\n    @Test\n    public void findByName(){\n        Member member1 = new Member();\n        member1.setName(\"spring1\");\n        repository.save(member1);\n\n        Member member2 = new Member();\n        member2.setName(\"spring2\");\n        repository.save(member2);\n\n        Member result = repository.findByName(\"spring1\").get();\n\n        assertThat(result).isEqualTo(member1);\n    }\n\n\n    @Test\n    public void findAll(){\n        Member member1 = new Member();\n        member1.setName(\"spring1\");\n        repository.save(member1);\n\n        Member member2 = new Member();\n        member2.setName(\"spring2\");\n        repository.save(member2);\n\n        List<Member> result = repository.findAll();\n\n        assertThat(result.size()).isEqualTo(2);\n    }\n}\n```\n<br>\n\n⭐ **```@AfterEach```** : 각 테스트가 **종료** 될때마다 ```AfterEach``` 문을 실행시켜주는 역할을 한다. 여기서는 각 테스트 실행시 메모리 DB에 직전 테스트 결과가 남아 있기 때문에 해당 메모리 DB를 비워주기위해 ```AfterEach```문을 사용했다.\n\n<br><br><br><br>\n\n## ✅ 회원 서비스 개발\n📌 **MemberService**\n```java\npackage hello.hellospring.service;\n\nimport hello.hellospring.domain.Member;\nimport hello.hellospring.repository.MemberRepository;\nimport hello.hellospring.repository.MemoryMemberRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\npublic class MemberService {\n// 컨트롤 + 시프트 + t 누르면 자동으로 테스트 만들수 있음\n    private final MemberRepository memberRepository;\n\n    @Autowired\n    public MemberService(MemberRepository memberRepository){\n        this.memberRepository = memberRepository;\n    }\n\n    // 회원가입\n    public Long join(Member member){\n        validateDuplicateMember(member);\n\n        memberRepository.save(member);\n        return member.getId();\n    }\n\n    // 같은 이름이 있는 회원은 중복안되게 하는 메소드\n    private void validateDuplicateMember(Member member) {\n        memberRepository.findByName(member.getName())\n                .ifPresent(m-> {\n                    throw new IllegalStateException(\"이미 존재하는 회원입니다\");\n                });\n    }\n\n    // 전체 회원 조회\n    public List<Member> findMembers(){\n        return memberRepository.findAll();\n    }\n\n    public Optional<Member> findOne(Long memberId){\n        return memberRepository.findById(memberId);\n    }\n}\n```\n\n<br><br><br><br>\n\n## ✅ 회원 서비스 테스트\n📌 **MemberServiceTest**\n```java\npackage hello.hellospring.service;\n\nimport hello.hellospring.domain.Member;\nimport hello.hellospring.repository.MemoryMemberRepository;\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass MemberServiceTest {\n\n    MemberService memberService;\n    MemoryMemberRepository memberRepository;\n\n    // 이런게 의존성 주입 (DI) !! 굉장히 중요한 개념\n    @BeforeEach\n    public void beforeEach(){\n        memberRepository = new MemoryMemberRepository();\n        memberService = new MemberService(memberRepository);\n    }\n\n    // 테스트 하나 돌린후에 DB에 저장된 정보 클리어\n    @AfterEach\n    public void afterEach(){\n        memberRepository.clearStore();\n    }\n\n\n    // 테스트는 메소드 이름 그냥 한글로 적어도 괜찮다..!\n    @Test\n    void 회원가입() {\n        // given\n        Member member = new Member();\n        member.setName(\"hello\");\n\n        // when\n        Long saveId = memberService.join(member);\n\n        // then\n        Member findMember = memberService.findOne(saveId).get();\n        Assertions.assertThat(member.getName()).isEqualTo(findMember.getName());\n    }\n\n    @Test\n    public void 중복_회원_예외(){\n        // given\n        Member member1 = new Member();\n        member1.setName(\"spring\");\n\n        Member member2 = new Member();\n        member2.setName(\"spring\");\n\n        // when\n        memberService.join(member1);\n        IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));\n\n        Assertions.assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다\");\n\n//        try{\n//            memberService.join(member2);\n//            fail();\n//        } catch (IllegalStateException e){\n//            assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");\n//        }\n\n        // then\n    }\n\n    @Test\n    void findMembers() {\n    }\n\n    @Test\n    void findOne() {\n    }\n}\n```\n\n⭐ **```@BeforeEach```** : 각 테스트 실행 전에 호출된다. 새로운 객체를 생성하거나 의존관계를 새로 맺어줄때 주로 사용한다. \n","properties":"\n","discussions":{},"comments":{},"hash":-1440377866,"tx":177},"EO4J8PI1VIfZ6v35/syncedContent":{"id":"EO4J8PI1VIfZ6v35/syncedContent","type":"syncedContent","historyData":{"-1440377866":{"id":"EO4J8PI1VIfZ6v35/content","type":"content","text":"---\npermalink: /2022-10-25-스프링 입문_회원 관리 예제/\ntitle: \"[스프링부트] [JAVA] [입문] 3. 회원 관리 예제 - 백엔드 개발\"\ndate: 2022-10-25 21:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><br>\n\n## ✅ 비즈니스 요구사항\n- 데이터 : 회원 ID, 이름\n- 기능 : 회원 등록, 조회\n- 데이터 저장소는 선정되지 않음\n\n<br><br><br><br>\n\n## ✅ 웹 애플리케이션 구조\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/back1.png?raw=true\">\n</p>\n\n- 컨트롤러 : MVC의 컨트롤러 역할\n- 서비스 : 핵심 비즈니스 로직 구현\n- 리포지토리 : DB에 접근, 도메인 객체를 DB에 저장하고 관리\n- 도메인 : 비즈니스 도메인 객체\n\n<br><br><br><br>\n\n## ✅ 회원 도메인과 리포지토리 만들기\n\n📌 **Member 객체**\n\n```java\npackage hello.hellospring.domain;\npublic class Member {\n\n\t private Long id;\n\t private String name;\n\t \n\t public Long getId() {\n\t\t return id;\n\t }\n\t \n\t public void setId(Long id) {\n\t\t this.id = id;\n\t }\n \n\t public String getName() {\n\t\t return name;\n\t }\n \n\t public void setName(String name) {\n\t\t this.name = name;\n\t }\n}\n```\n<br><br>\n\n📌 **MemberRepository 인터페이스**\n```java\npackage hello.hellospring.repository;\n\nimport hello.hellospring.domain.Member;\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface MemberRepository {\n\tMember save(Member member); // save: 회원을 저장소에 저장\n\tOptional<Member> findById(Long id); // id로 멤버찾기\n\tOptional<Member> findByName(String name); // name으로 멤버찾기\n\tList<Member> findAll(); // 모든 회원 리스트 찾기\n}\n```\n<br><br>\n\n📌 **MemberRepository 구현부**\n```java\npackage hello.hellospring.repository;\n\nimport hello.hellospring.domain.Member;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.*;\n\n// Alt + Enter -> implement method -> 전부 ok\n@Repository\npublic class MemoryMemberRepository implements MemberRepository{\n\n    private static Map<Long, Member> store = new HashMap<>();\n    private static long sequence = 0L; // 0,1,2 key값을 생성\n\n    @Override\n    public Member save(Member member) {\n        member.setId(++sequence);\n        store.put(member.getId(), member);\n        return member;\n    }\n\n    @Override\n    public Optional<Member> findById(Long id) {\n        return Optional.ofNullable(store.get(id));\n    }\n\n    @Override\n    public Optional<Member> findByName(String name) {\n        return store.values().stream()\n                .filter(member->member.getName().equals(name))\n                .findAny();\n    }\n\n    @Override\n    public List<Member> findAll() {\n        return new ArrayList<>(store.values());\n    }\n\n    public void clearStore(){\n        store.clear();\n    }\n}\n```\n\n<br><br><br><br>\n\n## ✅ 회원 리포지토리 테스트 케이스\n📌 **MemberRepository 테스트**\n```java\npackage hello.hellospring.repository;\n\nimport hello.hellospring.domain.Member;\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.*;\n\npublic class MemoryMemberRepositoryTest {\n\n    MemoryMemberRepository repository = new MemoryMemberRepository();\n\n    // 테스트 끝나고 레포지토리 싹 지워주는거\n    @AfterEach\n    public void afterEach(){\n        repository.clearStore();\n    }\n\n    @Test\n    public void save(){\n        Member member = new Member();\n        member.setName(\"spring\");\n\n        repository.save(member);\n\n        Member result = repository.findById(member.getId()).get();\n        assertThat(member).isEqualTo(result);\n        //Assertions.assertEquals(member,result);\n        //System.out.println(\"result = \" + (result==member));\n    }\n\n    @Test\n    public void findByName(){\n        Member member1 = new Member();\n        member1.setName(\"spring1\");\n        repository.save(member1);\n\n        Member member2 = new Member();\n        member2.setName(\"spring2\");\n        repository.save(member2);\n\n        Member result = repository.findByName(\"spring1\").get();\n\n        assertThat(result).isEqualTo(member1);\n    }\n\n\n    @Test\n    public void findAll(){\n        Member member1 = new Member();\n        member1.setName(\"spring1\");\n        repository.save(member1);\n\n        Member member2 = new Member();\n        member2.setName(\"spring2\");\n        repository.save(member2);\n\n        List<Member> result = repository.findAll();\n\n        assertThat(result.size()).isEqualTo(2);\n    }\n}\n```\n<br>\n\n⭐ **```@AfterEach```** : 각 테스트가 **종료** 될때마다 ```AfterEach``` 문을 실행시켜주는 역할을 한다. 여기서는 각 테스트 실행시 메모리 DB에 직전 테스트 결과가 남아 있기 때문에 해당 메모리 DB를 비워주기위해 ```AfterEach```문을 사용했다.\n\n<br><br><br><br>\n\n## ✅ 회원 서비스 개발\n📌 **MemberService**\n```java\npackage hello.hellospring.service;\n\nimport hello.hellospring.domain.Member;\nimport hello.hellospring.repository.MemberRepository;\nimport hello.hellospring.repository.MemoryMemberRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\npublic class MemberService {\n// 컨트롤 + 시프트 + t 누르면 자동으로 테스트 만들수 있음\n    private final MemberRepository memberRepository;\n\n    @Autowired\n    public MemberService(MemberRepository memberRepository){\n        this.memberRepository = memberRepository;\n    }\n\n    // 회원가입\n    public Long join(Member member){\n        validateDuplicateMember(member);\n\n        memberRepository.save(member);\n        return member.getId();\n    }\n\n    // 같은 이름이 있는 회원은 중복안되게 하는 메소드\n    private void validateDuplicateMember(Member member) {\n        memberRepository.findByName(member.getName())\n                .ifPresent(m-> {\n                    throw new IllegalStateException(\"이미 존재하는 회원입니다\");\n                });\n    }\n\n    // 전체 회원 조회\n    public List<Member> findMembers(){\n        return memberRepository.findAll();\n    }\n\n    public Optional<Member> findOne(Long memberId){\n        return memberRepository.findById(memberId);\n    }\n}\n```\n\n<br><br><br><br>\n\n## ✅ 회원 서비스 테스트\n📌 **MemberServiceTest**\n```java\npackage hello.hellospring.service;\n\nimport hello.hellospring.domain.Member;\nimport hello.hellospring.repository.MemoryMemberRepository;\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass MemberServiceTest {\n\n    MemberService memberService;\n    MemoryMemberRepository memberRepository;\n\n    // 이런게 의존성 주입 (DI) !! 굉장히 중요한 개념\n    @BeforeEach\n    public void beforeEach(){\n        memberRepository = new MemoryMemberRepository();\n        memberService = new MemberService(memberRepository);\n    }\n\n    // 테스트 하나 돌린후에 DB에 저장된 정보 클리어\n    @AfterEach\n    public void afterEach(){\n        memberRepository.clearStore();\n    }\n\n\n    // 테스트는 메소드 이름 그냥 한글로 적어도 괜찮다..!\n    @Test\n    void 회원가입() {\n        // given\n        Member member = new Member();\n        member.setName(\"hello\");\n\n        // when\n        Long saveId = memberService.join(member);\n\n        // then\n        Member findMember = memberService.findOne(saveId).get();\n        Assertions.assertThat(member.getName()).isEqualTo(findMember.getName());\n    }\n\n    @Test\n    public void 중복_회원_예외(){\n        // given\n        Member member1 = new Member();\n        member1.setName(\"spring\");\n\n        Member member2 = new Member();\n        member2.setName(\"spring\");\n\n        // when\n        memberService.join(member1);\n        IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));\n\n        Assertions.assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다\");\n\n//        try{\n//            memberService.join(member2);\n//            fail();\n//        } catch (IllegalStateException e){\n//            assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");\n//        }\n\n        // then\n    }\n\n    @Test\n    void findMembers() {\n    }\n\n    @Test\n    void findOne() {\n    }\n}\n```\n\n⭐ **```@BeforeEach```** : 각 테스트 실행 전에 호출된다. 새로운 객체를 생성하거나 의존관계를 새로 맺어줄때 주로 사용한다. \n","properties":"\n","discussions":{},"comments":{},"hash":-1440377866}},"syncHistory":{"main":[-1440377866,null,null]},"v":1,"hash":1710111601024,"tx":177},"iXzCHT0T4V83pjgR/content":{"id":"iXzCHT0T4V83pjgR/content","type":"content","text":"---\npermalink: /2022-10-27-스프링 입문_스프링 빈과 의존관계/\ntitle: \"[스프링부트] [JAVA] [입문] 4. 스프링 빈과 의존관계\"\ndate: 2022-10-27 05:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><br>\n\n## ✅ 컴포넌트 스캔과 자동 의존관계 설정\n\n컨트롤러가 서비스와 레포지토리를 사용할 수 있게 **의존관계**를 설정해야 한다.\n\n```java\npackage hello.hellospring.controller;\nimport hello.hellospring.service.MemberService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\n\n@Controller\npublic class MemberController {\n\tprivate final MemberService memberService;\n\n\t@Autowired\n\tpublic MemberController(MemberService memberService){\n\t\tthis.memberService = memberService;\n\t}\n}\n```\n\n📌 ```@Autowired``` 태그는 해당 객체를 스프링 컨테이너에 찾아서 넣어주는 역할을 한다. 일종의 DI(의존성 주입)를 담당하는 역할이다.\n\n📌 그러나 위 코드처럼 작성시 **오류**가 발생한다\n\n```\nConsider defining a bean of type \n'hello.hellospring.service.MemberService' in your configuration.\n```\n📌 MemberController는 MemberService를 생성자로 받아서 스프링빈에 등록되어야 하는데 정작 MemberService가 스프링 빈에 등록되어 있지 않기 때문이다. 때문에 **MemberService를 스프링 빈에 등록해줘야만 한다.**\n\n<br><Br><br><br>\n\n## ✅ 스프링 빈 등록 방법 1) 컴포넌트 스캔\n**```@Component```를 붙여 객체 위에 써주는 방법을 컴포넌트 스캔이라고 한다.**\n\n**```@Component```를 포함하는 다음 애노테이션도 스프링빈으로 자동 등록된다**\n- ```@Controller```\n- ```@Service```\n- ```@Repository```\n\n<br><br><br>\n\n**📌 회원 서비스 스프링 빈 등록**\n```java\n@Service \npublic class MemberService { \n\tprivate final MemberRepository memberRepository;\n\n\t@Autowired \n\tpublic MemberService(MemberRepository memberRepository) { \t\t\t\t\n\t\tthis.memberRepository = memberRepository; \n\t} \n}\n```\n- ```@Service``` 어노태이션을 붙여주면 자동으로 스프링 빈에 등록된다.\n\n<br><Br><br><br>\n\n## ✅ 스프링 빈 등록 방법 2) 직접 스프링빈 등록\n\n**📌 서비스와 레포지토리의 ```@Service```, ```@Repository``` 어노태이션을 제거하고 Configuration java 파일을 따로 만들어 등록한다.**\n```java\npackage hello.hellospring;\n\nimport hello.hellospring.repository.MemberRepository;\nimport hello.hellospring.repository.MemoryMemberRepository;\nimport hello.hellospring.service.MemberService;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class SpringConfig {\n\n    // 수동으로 스프링 빈에 빈 생성\n    @Bean\n    public MemberService memberService(){\n        return new MemberService(memberRepository());\n    }\n\n    @Bean\n    public MemberRepository memberRepository(){\n        return new MemoryMemberRepository();\n    }\n\n}\n```\n\n<br><br><br><br>\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-579796979,"tx":179},"iXzCHT0T4V83pjgR/syncedContent":{"id":"iXzCHT0T4V83pjgR/syncedContent","type":"syncedContent","historyData":{"-579796979":{"id":"iXzCHT0T4V83pjgR/content","type":"content","text":"---\npermalink: /2022-10-27-스프링 입문_스프링 빈과 의존관계/\ntitle: \"[스프링부트] [JAVA] [입문] 4. 스프링 빈과 의존관계\"\ndate: 2022-10-27 05:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><br>\n\n## ✅ 컴포넌트 스캔과 자동 의존관계 설정\n\n컨트롤러가 서비스와 레포지토리를 사용할 수 있게 **의존관계**를 설정해야 한다.\n\n```java\npackage hello.hellospring.controller;\nimport hello.hellospring.service.MemberService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\n\n@Controller\npublic class MemberController {\n\tprivate final MemberService memberService;\n\n\t@Autowired\n\tpublic MemberController(MemberService memberService){\n\t\tthis.memberService = memberService;\n\t}\n}\n```\n\n📌 ```@Autowired``` 태그는 해당 객체를 스프링 컨테이너에 찾아서 넣어주는 역할을 한다. 일종의 DI(의존성 주입)를 담당하는 역할이다.\n\n📌 그러나 위 코드처럼 작성시 **오류**가 발생한다\n\n```\nConsider defining a bean of type \n'hello.hellospring.service.MemberService' in your configuration.\n```\n📌 MemberController는 MemberService를 생성자로 받아서 스프링빈에 등록되어야 하는데 정작 MemberService가 스프링 빈에 등록되어 있지 않기 때문이다. 때문에 **MemberService를 스프링 빈에 등록해줘야만 한다.**\n\n<br><Br><br><br>\n\n## ✅ 스프링 빈 등록 방법 1) 컴포넌트 스캔\n**```@Component```를 붙여 객체 위에 써주는 방법을 컴포넌트 스캔이라고 한다.**\n\n**```@Component```를 포함하는 다음 애노테이션도 스프링빈으로 자동 등록된다**\n- ```@Controller```\n- ```@Service```\n- ```@Repository```\n\n<br><br><br>\n\n**📌 회원 서비스 스프링 빈 등록**\n```java\n@Service \npublic class MemberService { \n\tprivate final MemberRepository memberRepository;\n\n\t@Autowired \n\tpublic MemberService(MemberRepository memberRepository) { \t\t\t\t\n\t\tthis.memberRepository = memberRepository; \n\t} \n}\n```\n- ```@Service``` 어노태이션을 붙여주면 자동으로 스프링 빈에 등록된다.\n\n<br><Br><br><br>\n\n## ✅ 스프링 빈 등록 방법 2) 직접 스프링빈 등록\n\n**📌 서비스와 레포지토리의 ```@Service```, ```@Repository``` 어노태이션을 제거하고 Configuration java 파일을 따로 만들어 등록한다.**\n```java\npackage hello.hellospring;\n\nimport hello.hellospring.repository.MemberRepository;\nimport hello.hellospring.repository.MemoryMemberRepository;\nimport hello.hellospring.service.MemberService;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class SpringConfig {\n\n    // 수동으로 스프링 빈에 빈 생성\n    @Bean\n    public MemberService memberService(){\n        return new MemberService(memberRepository());\n    }\n\n    @Bean\n    public MemberRepository memberRepository(){\n        return new MemoryMemberRepository();\n    }\n\n}\n```\n\n<br><br><br><br>\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-579796979}},"syncHistory":{"main":[-579796979,null,null]},"v":1,"hash":1710111602126,"tx":179},"OiVTXhxEC6PT4wfS/content":{"id":"OiVTXhxEC6PT4wfS/content","type":"content","text":"---\npermalink: /2022-10-27-스프링 입문_웹 MVC 개발/\ntitle: \"[스프링부트] [JAVA] [입문] 5. 웹 MVC 개발\"\ndate: 2022-10-28 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><br>\n\n## ✅ @GetMapping 과 @PostMapping\n📌 **MemberController**\n\n```java\npackage hello.hellospring.controller;\n\nimport hello.hellospring.domain.Member;\nimport hello.hellospring.service.MemberService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\n\nimport java.util.List;\n\n@Controller\npublic class MemberController {\n    private final MemberService memberService;\n\n    @Autowired\n    public MemberController(MemberService memberService){\n        this.memberService = memberService;\n    }\n\n    @GetMapping(\"/members/new\")\n    public String createForm(){\n        return \"members/createMemberForm\";\n    }\n\n    @PostMapping(\"/members/new\")\n    public String create(MemberForm form){\n        Member member = new Member();\n        member.setName(form.getName());\n\n        memberService.join(member);\n\t\t\n\t\t// redirect는 :뒤에 /주소로 return시켜준다\n\t\t// 여기서는 다시 메인화면을 return\n        return \"redirect:/\";\n    }\n\n    @GetMapping(\"/members\")\n    public String list(Model model){\n        List<Member> members = memberService.findMembers();\n        model.addAttribute(\"members\",members);\n        return \"members/memberList\";\n    }\n}\n```\n\n- 기본적으로 자바스크립트의 form 태그는 **get 방식**으로 데이터를 전송한다.\n- ```@GetMapping``` 은 get방식으로 전송된 form태그에 접근 시켜준다.\n- ```@PostMapping```은 post방식으로 전송된 form태그에 접근 시켜준다.\n\n\n\n<br><br><br>\n\n📌 **/home.html : 메인 화면**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring6.png?raw=true\">\n</p>\n\n- 회원가입과 회원 목록 으로 구성\n\n<br>\n\n```javascript\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<div class=\"container\">\n    <div>\n        <h1>Hello Spring</h1>\n        <p>회원 기능</p>\n        <p>\n            <a href=\"/members/new\">회원 가입</a>\n            <a href=\"/members\">회원 목록</a>\n        </p>\n    </div>\n</div> <!-- /container -->\n</body>\n</html>\n```\n\n- 회원가입은 ```/members/new``` , 회원 목록은 ```/members``` 로 주소 설정 \n\n\n<br><br><br>\n\n📌 **/members/createMemberForm.html**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring7.png?raw=true\">\n</p>\n\n```javascript\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<div class=\"container\">\n\t// post방식으로 데이터 전송\n    <form action=\"/members/new\" method=\"post\">\n        <div class=\"form-group\">\n            <label for=\"name\">이름</label>\n            <input type=\"text\" id=\"name\" name=\"name\" placeholder=\"이름을 입력하세요\">\n        </div>\n        <button type=\"submit\">등록</button>\n    </form>\n</div> <!-- /container -->\n</body>\n</html>\n```\n\n<br><br><br>\n\n📌 **/members/memberList.html**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring8.png?raw=true\">\n</p>\n\n```javascript\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<div class=\"container\">\n    <div>\n        <table>\n            <thead>\n            <tr>\n                <th>#</th>\n                <th>이름</th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr th:each=\"member : ${members}\">\n                <td th:text=\"${member.id}\"></td>\n                <td th:text=\"${member.name}\"></td>\n            </tr>\n            </tbody>\n        </table>\n    </div>\n</div> <!-- /container -->\n</body>\n</html>\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1707962216,"tx":181},"OiVTXhxEC6PT4wfS/syncedContent":{"id":"OiVTXhxEC6PT4wfS/syncedContent","type":"syncedContent","historyData":{"-1707962216":{"id":"OiVTXhxEC6PT4wfS/content","type":"content","text":"---\npermalink: /2022-10-27-스프링 입문_웹 MVC 개발/\ntitle: \"[스프링부트] [JAVA] [입문] 5. 웹 MVC 개발\"\ndate: 2022-10-28 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\n<br><br><br>\n\n## ✅ @GetMapping 과 @PostMapping\n📌 **MemberController**\n\n```java\npackage hello.hellospring.controller;\n\nimport hello.hellospring.domain.Member;\nimport hello.hellospring.service.MemberService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\n\nimport java.util.List;\n\n@Controller\npublic class MemberController {\n    private final MemberService memberService;\n\n    @Autowired\n    public MemberController(MemberService memberService){\n        this.memberService = memberService;\n    }\n\n    @GetMapping(\"/members/new\")\n    public String createForm(){\n        return \"members/createMemberForm\";\n    }\n\n    @PostMapping(\"/members/new\")\n    public String create(MemberForm form){\n        Member member = new Member();\n        member.setName(form.getName());\n\n        memberService.join(member);\n\t\t\n\t\t// redirect는 :뒤에 /주소로 return시켜준다\n\t\t// 여기서는 다시 메인화면을 return\n        return \"redirect:/\";\n    }\n\n    @GetMapping(\"/members\")\n    public String list(Model model){\n        List<Member> members = memberService.findMembers();\n        model.addAttribute(\"members\",members);\n        return \"members/memberList\";\n    }\n}\n```\n\n- 기본적으로 자바스크립트의 form 태그는 **get 방식**으로 데이터를 전송한다.\n- ```@GetMapping``` 은 get방식으로 전송된 form태그에 접근 시켜준다.\n- ```@PostMapping```은 post방식으로 전송된 form태그에 접근 시켜준다.\n\n\n\n<br><br><br>\n\n📌 **/home.html : 메인 화면**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring6.png?raw=true\">\n</p>\n\n- 회원가입과 회원 목록 으로 구성\n\n<br>\n\n```javascript\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<div class=\"container\">\n    <div>\n        <h1>Hello Spring</h1>\n        <p>회원 기능</p>\n        <p>\n            <a href=\"/members/new\">회원 가입</a>\n            <a href=\"/members\">회원 목록</a>\n        </p>\n    </div>\n</div> <!-- /container -->\n</body>\n</html>\n```\n\n- 회원가입은 ```/members/new``` , 회원 목록은 ```/members``` 로 주소 설정 \n\n\n<br><br><br>\n\n📌 **/members/createMemberForm.html**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring7.png?raw=true\">\n</p>\n\n```javascript\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<div class=\"container\">\n\t// post방식으로 데이터 전송\n    <form action=\"/members/new\" method=\"post\">\n        <div class=\"form-group\">\n            <label for=\"name\">이름</label>\n            <input type=\"text\" id=\"name\" name=\"name\" placeholder=\"이름을 입력하세요\">\n        </div>\n        <button type=\"submit\">등록</button>\n    </form>\n</div> <!-- /container -->\n</body>\n</html>\n```\n\n<br><br><br>\n\n📌 **/members/memberList.html**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/spring8.png?raw=true\">\n</p>\n\n```javascript\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<div class=\"container\">\n    <div>\n        <table>\n            <thead>\n            <tr>\n                <th>#</th>\n                <th>이름</th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr th:each=\"member : ${members}\">\n                <td th:text=\"${member.id}\"></td>\n                <td th:text=\"${member.name}\"></td>\n            </tr>\n            </tbody>\n        </table>\n    </div>\n</div> <!-- /container -->\n</body>\n</html>\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1707962216}},"syncHistory":{"main":[-1707962216,null,null]},"v":1,"hash":1710111603366,"tx":181},"MRasIncXHMnDEsl4/content":{"id":"MRasIncXHMnDEsl4/content","type":"content","text":"---\npermalink: /2023-01-06-Error Code 1452 : Cannot add or update a child row: a foreign key constraint fails ​해결 /\ntitle: \"[DB] [MYSQL] [Error Code 1452] 외래키 문제 해결\"\ndate: 2023-01-06 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"DB\"\ncategories:\n- DB\ntags:\n- DB\n- MYSQL\n---\n<br><br><br>\n\n## ❗ 에러메세지\n\n```sql\nError Code: 1452. Cannot add or update a child row: a foreign key constraint fails (`user`.`#sql-19e0_13e`, CONSTRAINT `vam_book_ibfk_1` FOREIGN KEY (`authorId`) REFERENCES `vam_author` (`authorId`))\n```\n<br><br><br>\n\n## ❗ 상황\n📌 **vam_book, vam_bcate, vam_author** 라는 테이블이 있다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/db1.png?raw=true\">\n</p>\n\n📌 **vam_book**에는 기존에 넣어둔 튜플이 존재한다.\n\n📌 이때 **vam_author** 와 **vam_bcate**에 각각 있는 **authorId**와 **cateCode**를 **vam_book** 테이블의 외래키로 설정하려고 한다.\n```sql\nalter table vam_book add foreign key (authorId) references vam_author(authorId);\nalter table vam_book add foreign key (cateCode) references vam_bcate(cateCode);\n```\n\n📌 **authorId**와 **cateCode**를 외래키로 설정하자 에러가 발생했다.\n\n<br><br><br>\n\n## ❗ 원인\n결론부터 보면 **참조 무결성**을 위배 했기때문에 발생한 에러이다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/db2.png?raw=true\">\n</p>\n\n**참조 무결성이란 관계 데이터베이스 관계 모델에서 2개의 관련 있던 관계 변수 간의 일관성을 말한다.** \n\n예를들어 위의 그림을 보면 artist_id라는 컬럼을 두 테이블 모두 가지고 있는데 위의 테이블은 {1,2,3}의 값을 가지고 아래 테이블은 {3,4}의 값을 가지고 있는것을 볼 수 있다.\n\n참조하려는 테이블의 artist_id가 서로 일치하지 않기 때문에 이는 참조 무결성을 위배한것이라고 볼 수 있다.\n\n<br><br><br>\n\n## ❗ 해결\n**기존에 vam_book에 들어있던 데이터를 지움으로써 authorId 컬럼과 cateCode 컬럼의 무결성 문제를 해결했다.**\n\n","properties":"\n","discussions":{},"comments":{},"hash":190355118,"tx":185},"MRasIncXHMnDEsl4/syncedContent":{"id":"MRasIncXHMnDEsl4/syncedContent","type":"syncedContent","historyData":{"190355118":{"id":"MRasIncXHMnDEsl4/content","type":"content","text":"---\npermalink: /2023-01-06-Error Code 1452 : Cannot add or update a child row: a foreign key constraint fails ​해결 /\ntitle: \"[DB] [MYSQL] [Error Code 1452] 외래키 문제 해결\"\ndate: 2023-01-06 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"DB\"\ncategories:\n- DB\ntags:\n- DB\n- MYSQL\n---\n<br><br><br>\n\n## ❗ 에러메세지\n\n```sql\nError Code: 1452. Cannot add or update a child row: a foreign key constraint fails (`user`.`#sql-19e0_13e`, CONSTRAINT `vam_book_ibfk_1` FOREIGN KEY (`authorId`) REFERENCES `vam_author` (`authorId`))\n```\n<br><br><br>\n\n## ❗ 상황\n📌 **vam_book, vam_bcate, vam_author** 라는 테이블이 있다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/db1.png?raw=true\">\n</p>\n\n📌 **vam_book**에는 기존에 넣어둔 튜플이 존재한다.\n\n📌 이때 **vam_author** 와 **vam_bcate**에 각각 있는 **authorId**와 **cateCode**를 **vam_book** 테이블의 외래키로 설정하려고 한다.\n```sql\nalter table vam_book add foreign key (authorId) references vam_author(authorId);\nalter table vam_book add foreign key (cateCode) references vam_bcate(cateCode);\n```\n\n📌 **authorId**와 **cateCode**를 외래키로 설정하자 에러가 발생했다.\n\n<br><br><br>\n\n## ❗ 원인\n결론부터 보면 **참조 무결성**을 위배 했기때문에 발생한 에러이다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/db2.png?raw=true\">\n</p>\n\n**참조 무결성이란 관계 데이터베이스 관계 모델에서 2개의 관련 있던 관계 변수 간의 일관성을 말한다.** \n\n예를들어 위의 그림을 보면 artist_id라는 컬럼을 두 테이블 모두 가지고 있는데 위의 테이블은 {1,2,3}의 값을 가지고 아래 테이블은 {3,4}의 값을 가지고 있는것을 볼 수 있다.\n\n참조하려는 테이블의 artist_id가 서로 일치하지 않기 때문에 이는 참조 무결성을 위배한것이라고 볼 수 있다.\n\n<br><br><br>\n\n## ❗ 해결\n**기존에 vam_book에 들어있던 데이터를 지움으로써 authorId 컬럼과 cateCode 컬럼의 무결성 문제를 해결했다.**\n\n","properties":"\n","discussions":{},"comments":{},"hash":190355118}},"syncHistory":{"main":[190355118,null,null]},"v":1,"hash":1710111606201,"tx":185},"00TrVRATmgNqHn1N/content":{"id":"00TrVRATmgNqHn1N/content","type":"content","text":"---\npermalink: /2023-02-15-TCP와 UDP의 특징과 차이 /\ntitle: \"[HTTP] TCP와 UDP의 특징과 차이\"\ndate: 2023-02-15 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- TCP\n- UDP\n---\n<br><br><br>\n\nHTTP 프로토콜을 포스팅하기 앞서 네트워크의 전송계층에서 사용하는 **TCP와 UDP**에 대해서 알아보고자 한다. 간단하게 TCP,UDP란 무엇이고 그 특징과 차이에 대해서만 짚고 넘어가도록 하겠다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp1.jpg?raw=true\">\n</p>\n\n<br><br><br>\n\n## ✅ TCP(Transmission Control Protocol)\n\n### 📌 **TCP란?**\n\n**서버와 클라이언트간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜이다.** \n\n**데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜이다.**\n\n\n<br><br><br>\n\n### 📌 **TCP/IP 패킷 정보**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp2.png?raw=true\">\n</p>\n\n**TCP 데이터는 IP패킷에 담겨 전달되고 전송 제어, 전송 순서, 검증 정보 등의 데이터를 포함한다.**\n\n<br><br><br>\n\n### 📌 **TCP 특징**\n\n- **연결 지향 - TCP 3 way handshake(가상연결)**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp3.png?raw=true\">\n</p>\n\n1. SYN은 접속요청으로 클라이언트가 서버에게 접속을 요청한다\n2. ACK는 요청수락으로 요청받은 서버가 클라이언트에게 요청을 수락함과 동시에 이에 대한 SYN을 함께 보낸다\n3. 클라이언트는 다시 서버가 보낸 SYN에 대한 ACK를 전송한다.\n\n<br>\n\n- **순서 보장**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp4.png?raw=true\">\n</p>\n\nTCP 데이터는 전송순서 정보를 포함하고 있기때문에 패킷의 전송 순서를 보장해준다.\n\n<br>\n\n- **데이터 전달 보증 ( 높은 신뢰성 )**\n\n<br><br><br><br><br><br>\n\n\n## ✅ UDP(User Datagram Protocol)\n\n### 📌 **UDP란?**\n\n**데이터그램 단위로 데이터를 전송하는 프로토콜**\n\n**비연결형 프로토콜로 연결을 위해 할당되는 논리적인 경로가 없다.**\n\n<br><br><br>\n\n### 📌 **UDP 특징**\n\n- **비연결형 서비스로 데이터 그램 단위로 전송한다.**\n- **데이터 전달이 보증되지 않는다.**\n- **데이터 전달 순서가 보장되지 않는다.**\n- **신뢰성이 낮다.**\n- **UDP를 사용해 새로운 프로토콜의 최적화가 가능하다.**\n\n<br><br><br><br><br><br>\n\n\n## ✅ TCP와 UDP의 비교\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp5.png?raw=true\">\n</p>\n\n<br><br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-1011324602,"tx":187},"00TrVRATmgNqHn1N/syncedContent":{"id":"00TrVRATmgNqHn1N/syncedContent","type":"syncedContent","historyData":{"-1011324602":{"id":"00TrVRATmgNqHn1N/content","type":"content","text":"---\npermalink: /2023-02-15-TCP와 UDP의 특징과 차이 /\ntitle: \"[HTTP] TCP와 UDP의 특징과 차이\"\ndate: 2023-02-15 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- TCP\n- UDP\n---\n<br><br><br>\n\nHTTP 프로토콜을 포스팅하기 앞서 네트워크의 전송계층에서 사용하는 **TCP와 UDP**에 대해서 알아보고자 한다. 간단하게 TCP,UDP란 무엇이고 그 특징과 차이에 대해서만 짚고 넘어가도록 하겠다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp1.jpg?raw=true\">\n</p>\n\n<br><br><br>\n\n## ✅ TCP(Transmission Control Protocol)\n\n### 📌 **TCP란?**\n\n**서버와 클라이언트간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜이다.** \n\n**데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜이다.**\n\n\n<br><br><br>\n\n### 📌 **TCP/IP 패킷 정보**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp2.png?raw=true\">\n</p>\n\n**TCP 데이터는 IP패킷에 담겨 전달되고 전송 제어, 전송 순서, 검증 정보 등의 데이터를 포함한다.**\n\n<br><br><br>\n\n### 📌 **TCP 특징**\n\n- **연결 지향 - TCP 3 way handshake(가상연결)**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp3.png?raw=true\">\n</p>\n\n1. SYN은 접속요청으로 클라이언트가 서버에게 접속을 요청한다\n2. ACK는 요청수락으로 요청받은 서버가 클라이언트에게 요청을 수락함과 동시에 이에 대한 SYN을 함께 보낸다\n3. 클라이언트는 다시 서버가 보낸 SYN에 대한 ACK를 전송한다.\n\n<br>\n\n- **순서 보장**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp4.png?raw=true\">\n</p>\n\nTCP 데이터는 전송순서 정보를 포함하고 있기때문에 패킷의 전송 순서를 보장해준다.\n\n<br>\n\n- **데이터 전달 보증 ( 높은 신뢰성 )**\n\n<br><br><br><br><br><br>\n\n\n## ✅ UDP(User Datagram Protocol)\n\n### 📌 **UDP란?**\n\n**데이터그램 단위로 데이터를 전송하는 프로토콜**\n\n**비연결형 프로토콜로 연결을 위해 할당되는 논리적인 경로가 없다.**\n\n<br><br><br>\n\n### 📌 **UDP 특징**\n\n- **비연결형 서비스로 데이터 그램 단위로 전송한다.**\n- **데이터 전달이 보증되지 않는다.**\n- **데이터 전달 순서가 보장되지 않는다.**\n- **신뢰성이 낮다.**\n- **UDP를 사용해 새로운 프로토콜의 최적화가 가능하다.**\n\n<br><br><br><br><br><br>\n\n\n## ✅ TCP와 UDP의 비교\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tcp5.png?raw=true\">\n</p>\n\n<br><br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-1011324602}},"syncHistory":{"main":[-1011324602,null,null]},"v":1,"hash":1710111607430,"tx":187},"INiNbmVlPhYbw2lt/content":{"id":"INiNbmVlPhYbw2lt/content","type":"content","text":"---\npermalink: /2023-02-16-URI와 URL 그리고 URN/\ntitle: \"[HTTP] URI와 URL 그리고 URN\"\ndate: 2023-02-16 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- URI\n- URL\n- URN\n---\n<br><br><br>\n\n## ✅ URI (Uniform Resource Identifier)\n\n**인터넷 자원을 나타내는 고유 식별자**.\n\n**URI는 로케이터(Locator), 이름(Name) 또는 둘다로 분류될 수 있다.**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/uri1.png?raw=true\">\n</p>\n\n\n<br><br>\n\n### 📌 **URI 의미**\n- **Uniform : 리소스를 식별하는 통일된 방식**\n- **Resource : 자원, URI로 식별할 수 있는 모든 것(제한없음)**\n- **Identifier : 다른 항목과 구분하는데 필요한 정보**\n\n<br><br>\n\n\n### 📌 **URL과 URN의 구조**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/uri2.png?raw=true\">\n</p>\n\n- **URL : 리소스가 있는 위치를 지정**\n\n- **URN : 리소스에 이름을 부여**\n\n- **위치는 변할 수 있지만 이름은 변하지 않는다.**\n\n- **그러나 URN으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않아 URL을 주로 사용한다.**\n\n- **때문에 URI와 URL을 혼용해서 부르기도 한다.**\n\n\n<br><br><br><br><br><br>\n\n## ✅ URL 분석\n\n### 📌 전체 문법\n\n> **scheme://[userinfo@]host[:port][/path][?query][#fragment]**\n> \n> **https://www.google.com:443/search?q=hello&hl=ko**\n\n<br>\n\n- **프로토콜 (https)**\n\n- **호스트명 (www.google.com)**\n\n- **포트번호 (443)**\n\n- **경로 (/search)**\n\n- **쿼리 파라미터 (q=hello&hl=ko)**\n\n\n<br><br>\n\n### 📌 프로토콜 ( scheme )\n> **scheme**://[userinfo@]host[:port][/path][?query][#fragment]\n> \n> **https:**//www.google.com:443/search?q=hello&hl=ko\n\n- 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 ex) http, https, ftp\n- http는 80포트, https는 443포트를 주로 사용한다.\n\n<br><br>\n\n### 📌 사용자정보 ( userinfo )\n> scheme://**[userinfo@]**host[:port][/path][?query][#fragment]\n> \n> https://www.google.com:443/search?q=hello&hl=ko\n\n- URL에 사용자정보를 포함해서 인증할때 사용하나 거의 쓰이지 않는다.\n\n<br><br>\n\n### 📌 호스트 ( host )\n\n> scheme://[userinfo@]**host**[:port][/path][?query][#fragment]\n> \n> https://**www.google.com**:443/search?q=hello&hl=ko\n\n- 호스트명\n- 도메인명 또는 IP주소를 직접 사용가능하다.\n\n<br><br>\n\n### 📌 포트번호 ( port )\n> scheme://[userinfo@]host**[:port]**[/path][?query][#fragment]\n> \n> https://www.google.com:**443**/search?q=hello&hl=ko\n\n- 포트 번호를 의미한다.\n- 일반적으로는 생략하고, http는 80, https는 443을 사용한다.\n\n<br><br>\n\n### 📌 경로 ( path )\n> scheme://[userinfo@]host[:port]**[/path]**[?query][#fragment]\n> \n> https://www.google.com:443 **/search**?q=hello&hl=ko\n\n- 리소스 경로를 의미하며 계층적 구조를 가진다.\n- ex ) /home/file1.jpg\n\n\n<br><br>\n\n### 📌 쿼리파라미터 ( query )\n> scheme://[userinfo@]host[:port][/path]**[?query]**[#fragment]\n> \n> https://www.google.com:443/search?**q=hello&hl=ko**\n\n- key=value 형태를 가지는 쿼리파라미터이다.\n- ?로 시작하고, &로 추가가 가능하다.\n\n\n<br><br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-894337863,"tx":189},"INiNbmVlPhYbw2lt/syncedContent":{"id":"INiNbmVlPhYbw2lt/syncedContent","type":"syncedContent","historyData":{"-894337863":{"id":"INiNbmVlPhYbw2lt/content","type":"content","text":"---\npermalink: /2023-02-16-URI와 URL 그리고 URN/\ntitle: \"[HTTP] URI와 URL 그리고 URN\"\ndate: 2023-02-16 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- URI\n- URL\n- URN\n---\n<br><br><br>\n\n## ✅ URI (Uniform Resource Identifier)\n\n**인터넷 자원을 나타내는 고유 식별자**.\n\n**URI는 로케이터(Locator), 이름(Name) 또는 둘다로 분류될 수 있다.**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/uri1.png?raw=true\">\n</p>\n\n\n<br><br>\n\n### 📌 **URI 의미**\n- **Uniform : 리소스를 식별하는 통일된 방식**\n- **Resource : 자원, URI로 식별할 수 있는 모든 것(제한없음)**\n- **Identifier : 다른 항목과 구분하는데 필요한 정보**\n\n<br><br>\n\n\n### 📌 **URL과 URN의 구조**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/uri2.png?raw=true\">\n</p>\n\n- **URL : 리소스가 있는 위치를 지정**\n\n- **URN : 리소스에 이름을 부여**\n\n- **위치는 변할 수 있지만 이름은 변하지 않는다.**\n\n- **그러나 URN으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않아 URL을 주로 사용한다.**\n\n- **때문에 URI와 URL을 혼용해서 부르기도 한다.**\n\n\n<br><br><br><br><br><br>\n\n## ✅ URL 분석\n\n### 📌 전체 문법\n\n> **scheme://[userinfo@]host[:port][/path][?query][#fragment]**\n> \n> **https://www.google.com:443/search?q=hello&hl=ko**\n\n<br>\n\n- **프로토콜 (https)**\n\n- **호스트명 (www.google.com)**\n\n- **포트번호 (443)**\n\n- **경로 (/search)**\n\n- **쿼리 파라미터 (q=hello&hl=ko)**\n\n\n<br><br>\n\n### 📌 프로토콜 ( scheme )\n> **scheme**://[userinfo@]host[:port][/path][?query][#fragment]\n> \n> **https:**//www.google.com:443/search?q=hello&hl=ko\n\n- 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 ex) http, https, ftp\n- http는 80포트, https는 443포트를 주로 사용한다.\n\n<br><br>\n\n### 📌 사용자정보 ( userinfo )\n> scheme://**[userinfo@]**host[:port][/path][?query][#fragment]\n> \n> https://www.google.com:443/search?q=hello&hl=ko\n\n- URL에 사용자정보를 포함해서 인증할때 사용하나 거의 쓰이지 않는다.\n\n<br><br>\n\n### 📌 호스트 ( host )\n\n> scheme://[userinfo@]**host**[:port][/path][?query][#fragment]\n> \n> https://**www.google.com**:443/search?q=hello&hl=ko\n\n- 호스트명\n- 도메인명 또는 IP주소를 직접 사용가능하다.\n\n<br><br>\n\n### 📌 포트번호 ( port )\n> scheme://[userinfo@]host**[:port]**[/path][?query][#fragment]\n> \n> https://www.google.com:**443**/search?q=hello&hl=ko\n\n- 포트 번호를 의미한다.\n- 일반적으로는 생략하고, http는 80, https는 443을 사용한다.\n\n<br><br>\n\n### 📌 경로 ( path )\n> scheme://[userinfo@]host[:port]**[/path]**[?query][#fragment]\n> \n> https://www.google.com:443 **/search**?q=hello&hl=ko\n\n- 리소스 경로를 의미하며 계층적 구조를 가진다.\n- ex ) /home/file1.jpg\n\n\n<br><br>\n\n### 📌 쿼리파라미터 ( query )\n> scheme://[userinfo@]host[:port][/path]**[?query]**[#fragment]\n> \n> https://www.google.com:443/search?**q=hello&hl=ko**\n\n- key=value 형태를 가지는 쿼리파라미터이다.\n- ?로 시작하고, &로 추가가 가능하다.\n\n\n<br><br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-894337863}},"syncHistory":{"main":[-894337863,null,null]},"v":1,"hash":1710111608647,"tx":189},"5wKp8vROJwBo4Sce/content":{"id":"5wKp8vROJwBo4Sce/content","type":"content","text":"---\npermalink: /2023-02-17-웹 브라우저 요청 흐름/\ntitle: \"[HTTP] 웹 브라우저 요청 흐름\"\ndate: 2023-02-16 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n---\n<br><br><br>\n\n## ✅ 웹 브라우저의 요청 흐름\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web1.png?raw=true\">\n</p>\n\n여기 우리가 사용하는 **웹 브라우저(클라이언트)**가 있고, 이를 지원하는 **구글 서버**가 있다고 가정해보자. \n\n<br><br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web2.png?raw=true\">\n</p>\n우리가 전송할 데이터는 **TCP/IP패킷**에 **HTTP 메세지 형태**로 담겨 전송된다.\n\n<br><br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web3.png?raw=true\">\n</p>\n웹브라우저에서 요청패킷을 서버로 전달한다.\n\n<br><br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web4.png?raw=true\">\n</p>\n\n이후 서버에서는 이에 대한 응답패킷을 다시 웹브라우저에 전송해준다.\n\n<br><br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web5.png?raw=true\">\n</p>\n이후 최종적으로 클라이언트가 요청한 웹 페이지를 렌더링한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1831956372,"tx":191},"5wKp8vROJwBo4Sce/syncedContent":{"id":"5wKp8vROJwBo4Sce/syncedContent","type":"syncedContent","historyData":{"-1831956372":{"id":"5wKp8vROJwBo4Sce/content","type":"content","text":"---\npermalink: /2023-02-17-웹 브라우저 요청 흐름/\ntitle: \"[HTTP] 웹 브라우저 요청 흐름\"\ndate: 2023-02-16 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n---\n<br><br><br>\n\n## ✅ 웹 브라우저의 요청 흐름\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web1.png?raw=true\">\n</p>\n\n여기 우리가 사용하는 **웹 브라우저(클라이언트)**가 있고, 이를 지원하는 **구글 서버**가 있다고 가정해보자. \n\n<br><br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web2.png?raw=true\">\n</p>\n우리가 전송할 데이터는 **TCP/IP패킷**에 **HTTP 메세지 형태**로 담겨 전송된다.\n\n<br><br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web3.png?raw=true\">\n</p>\n웹브라우저에서 요청패킷을 서버로 전달한다.\n\n<br><br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web4.png?raw=true\">\n</p>\n\n이후 서버에서는 이에 대한 응답패킷을 다시 웹브라우저에 전송해준다.\n\n<br><br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/web5.png?raw=true\">\n</p>\n이후 최종적으로 클라이언트가 요청한 웹 페이지를 렌더링한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1831956372}},"syncHistory":{"main":[-1831956372,null,null]},"v":1,"hash":1710111609822,"tx":191},"74ZWcTXgBSlLBzjE/content":{"id":"74ZWcTXgBSlLBzjE/content","type":"content","text":"\n\n# 📕 BuyBooks \n\n> **Spring 기반 온라인 책 쇼핑몰 웹 페이지 입니다.**\n> \n> **MVC 패턴, HTTP 프로토콜 등 Backend 로직을 중점으로 설계한 프로젝트 입니다.** \n\n<br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bb1.png?raw=true\" align=\"left\" width=\"40%\" height=\"50%\" >\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bb2.png?raw=true\" align=\"center\" width=\"40%\" height=\"50%\">\n<figcaption align=\"center\"></figcaption>\n</p>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bb13.png?raw=true\" align=\"left\" width=\"40%\" height=\"50%\" >\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bb14.png?raw=true\" align=\"center\" width=\"40%\" height=\"50%\">\n<figcaption align=\"center\"></figcaption>\n</p>\n<br>\n\n## 💻 개요\n\n- **개발기간 : 22.12~22.02**\n\n- **개발 환경**\n\t- JAVA 11\n\t- STS 3.9.9\n\t- Apache Tomcat 8.5\n\t- MySQL\n\t- MyBatis\n\n- **주요기능**\n\t- 회원가입 및 로그인&로그아웃\n\t- Ajax 활용 회원가입 유효성 검사\n\t- SMTP 기반 이메일 인증번호 전송\n\t- kakao 제공 주소록 API 활용\n\t- BCryptPasswordEncoder 활용 비밀번호 인코딩\n\t- 관리자 전용 페이지 인터셉터 적용\n\t- 관리자 전용 상품등록&관리, 작가 등록&관리, 주문 현황 파악 페이지\n\t- 위지윅 에디터, 캘린더 위젯 적용, 메인페이지 slick 적용\n\t- 카테고리 리스트 구현\n\t- 상품 이미지 및 썸네일 저장&삭제\n\t- 상품 검색\n\t- 장바구니 기능\n\t- 상품 주문\n\t- 상품 리뷰\n\t- DB Batch Program 적용\n\n<br><br>\n\n## 📜 프로젝트 구성도\n📦src  \n ┣ 📂main  \n ┃ ┣ 📂java  \n ┃ ┃ ┗ 📂com  \n ┃ ┃ ┃ ┗ 📂vam  \n ┃ ┃ ┃ ┃ ┣ 📂controller  \t\t\t\t// 컨트롤러  \n ┃ ┃ ┃ ┃ ┣ 📂interceptor  \t\t\t// 인터셉터  \n ┃ ┃ ┃ ┃ ┣ 📂mapper  \t\t\t\t\t// Mapper 인터페이스  \n ┃ ┃ ┃ ┃ ┣ 📂model  \t\t\t\t\t\t// VO,DTO 클래스  \n ┃ ┃ ┃ ┃ ┣ 📂service  \t\t\t\t\t// Service 인터페이스, 클래스  \n ┃ ┃ ┃ ┃ ┗ 📂task  \t\t\t\t\t\t// Batch Program  \n ┃ ┣ 📂resources  \n ┃ ┃ ┣ 📂com  \n ┃ ┃ ┃ ┗ 📂vam  \n ┃ ┃ ┃ ┃ ┗ 📂mapper  \t\t\t\t\t// Mapper xml ( 쿼리문 )  \n ┃ ┃ ┣ 📂META-INF  \n ┃ ┗ 📂webapp  \n ┃ ┃ ┣ 📂resources  \n ┃ ┃ ┃ ┣ 📂css  \n ┃ ┃ ┃ ┃ ┣ 📂admin  \t\t\t\t\t\t// 관리자 페이지 css  \n ┃ ┃ ┃ ┃ ┣ 📂member  \t\t\t\t\t// 로그인, 회원가입 css  \n ┃ ┃ ┃ ┃ ┣ 📜cart.css  \t\t\t\t\t// 장바구니 css  \n ┃ ┃ ┃ ┃ ┣ 📜goodsDetail.css  \t// 상품 상세 페이지 css  \n ┃ ┃ ┃ ┃ ┣ 📜main.css  \t\t\t\t\t// 메인화면 css  \n ┃ ┃ ┃ ┃ ┣ 📜order.css  \t\t\t\t// 주문화면 css  \n ┃ ┃ ┃ ┃ ┗ 📜search.css  \t\t\t\t// 상품검색 css  \n ┃ ┃ ┃ ┗ 📂img  \t\t\t\t\t\t\t\t// 이미지 파일 모아놓기  \n ┃ ┃ ┗ 📂WEB-INF  \n ┃ ┃ ┃ ┣ 📂classes  \n ┃ ┃ ┃ ┣ 📂spring  \n ┃ ┃ ┃ ┃ ┣ 📂appServlet  \n ┃ ┃ ┃ ┃ ┗ 📜root-context.xml  \n ┃ ┃ ┃ ┣ 📂views  \n ┃ ┃ ┃ ┃ ┣ 📂admin  \n ┃ ┃ ┃ ┃ ┣ 📂includes  \n ┃ ┃ ┃ ┃ ┃ ┗ 📂admin  \t\t\t\t// 관리자 페이지 JSP  \n ┃ ┃ ┃ ┃ ┣ 📂member  \t\t\t\t\t// 로그인, 회원가입 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜cart.jsp  \t\t\t\t\t// 장바구니 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜goodsDetail.jsp  \t\t// 상품 상세 페이지 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜home.jsp  \t\t\t\t// 기본 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜main.jsp  \t\t\t\t\t// 메인화면 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜order.jsp  \t\t\t\t// 주문화면 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜replyEnroll.jsp  \t\t// 댓글등록 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜replyUpdate.jsp  \t// 댓글갱신 JSP  \n ┃ ┃ ┃ ┃ ┗ 📜search.jsp  \t\t\t\t// 상품검색 JSP  \n ┃ ┃ ┃ ┗ 📜web.xml  \n ┗ 📂test  \n ┃ ┣ 📂java  \n ┃ ┃ ┗ 📂com  \n ┃ ┃ ┃ ┗ 📂vam  \n ┃ ┃ ┃ ┃ ┣ 📂mapper  \t\t\t\t\t// Mapper 테스트  \n ┃ ┃ ┃ ┃ ┣ 📂persistence  \t\t\t// DB연동 테스트  \n ┃ ┃ ┃ ┃ ┣ 📂service  \t\t\t\t\t// Service 테스트  \n ┃ ┃ ┃ ┃ ┗ 📂task  \t\t\t\t\t\t// Batch Program 테스트  \n ┃ ┗ 📂resources  \n ┃ ┃ ┗ 📜log4j.xml  \n\n<br><br>\n\n## 📜 DB 구조도\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/BuyBooks_DB.png?raw=true\">\n</p>\n\n- vam_book : 책 정보 테이블\n- vam_imgage : 책 이미지 테이블\n- vam_bcate : 책 카테고리 테이블\n- vam_author : 작가 정보 테이블\n- vam_nation : 작가 소속 국가 테이블\n- vam_orderItem : 책 주문시 책 정보 테이블 ( 수량, 가격, 할인율 등 )\n- vam_order : 책 주문시 주문자 정보 테이블 ( 주소, 아이디, 배달비 등 )\n- vam_cart : 장바구니 정보 테이블\n- book_member : 회원 정보 테이블\n- vam_reply : 댓글 정보 테이블\n\n<br><br>\n\n## 📜 API ( GitBook 활용 )\n\n### 📄 API 문서 주소 : [BuyBooks API](https://kims-organization-2.gitbook.io/buybooks-api/)\n\n<br>\n\n**🛒 장바구니 API**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bbapi2.png?raw=true\" width=\"65%\" height=\"65%\">\n</p>\n<br>\n\n**☝ 댓글 API**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bbapi3.png?raw=true\" width=\"65%\" height=\"65%\">\n</p>\n\n<br>\n\n**💻 관리자 API**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bbapi1.png?raw=true\" width=\"65%\" height=\"65%\">\n</p>\n\n","properties":"\n","discussions":{},"comments":{},"hash":-858899268,"tx":193},"74ZWcTXgBSlLBzjE/syncedContent":{"id":"74ZWcTXgBSlLBzjE/syncedContent","type":"syncedContent","historyData":{"-858899268":{"id":"74ZWcTXgBSlLBzjE/content","type":"content","text":"\n\n# 📕 BuyBooks \n\n> **Spring 기반 온라인 책 쇼핑몰 웹 페이지 입니다.**\n> \n> **MVC 패턴, HTTP 프로토콜 등 Backend 로직을 중점으로 설계한 프로젝트 입니다.** \n\n<br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bb1.png?raw=true\" align=\"left\" width=\"40%\" height=\"50%\" >\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bb2.png?raw=true\" align=\"center\" width=\"40%\" height=\"50%\">\n<figcaption align=\"center\"></figcaption>\n</p>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bb13.png?raw=true\" align=\"left\" width=\"40%\" height=\"50%\" >\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bb14.png?raw=true\" align=\"center\" width=\"40%\" height=\"50%\">\n<figcaption align=\"center\"></figcaption>\n</p>\n<br>\n\n## 💻 개요\n\n- **개발기간 : 22.12~22.02**\n\n- **개발 환경**\n\t- JAVA 11\n\t- STS 3.9.9\n\t- Apache Tomcat 8.5\n\t- MySQL\n\t- MyBatis\n\n- **주요기능**\n\t- 회원가입 및 로그인&로그아웃\n\t- Ajax 활용 회원가입 유효성 검사\n\t- SMTP 기반 이메일 인증번호 전송\n\t- kakao 제공 주소록 API 활용\n\t- BCryptPasswordEncoder 활용 비밀번호 인코딩\n\t- 관리자 전용 페이지 인터셉터 적용\n\t- 관리자 전용 상품등록&관리, 작가 등록&관리, 주문 현황 파악 페이지\n\t- 위지윅 에디터, 캘린더 위젯 적용, 메인페이지 slick 적용\n\t- 카테고리 리스트 구현\n\t- 상품 이미지 및 썸네일 저장&삭제\n\t- 상품 검색\n\t- 장바구니 기능\n\t- 상품 주문\n\t- 상품 리뷰\n\t- DB Batch Program 적용\n\n<br><br>\n\n## 📜 프로젝트 구성도\n📦src  \n ┣ 📂main  \n ┃ ┣ 📂java  \n ┃ ┃ ┗ 📂com  \n ┃ ┃ ┃ ┗ 📂vam  \n ┃ ┃ ┃ ┃ ┣ 📂controller  \t\t\t\t// 컨트롤러  \n ┃ ┃ ┃ ┃ ┣ 📂interceptor  \t\t\t// 인터셉터  \n ┃ ┃ ┃ ┃ ┣ 📂mapper  \t\t\t\t\t// Mapper 인터페이스  \n ┃ ┃ ┃ ┃ ┣ 📂model  \t\t\t\t\t\t// VO,DTO 클래스  \n ┃ ┃ ┃ ┃ ┣ 📂service  \t\t\t\t\t// Service 인터페이스, 클래스  \n ┃ ┃ ┃ ┃ ┗ 📂task  \t\t\t\t\t\t// Batch Program  \n ┃ ┣ 📂resources  \n ┃ ┃ ┣ 📂com  \n ┃ ┃ ┃ ┗ 📂vam  \n ┃ ┃ ┃ ┃ ┗ 📂mapper  \t\t\t\t\t// Mapper xml ( 쿼리문 )  \n ┃ ┃ ┣ 📂META-INF  \n ┃ ┗ 📂webapp  \n ┃ ┃ ┣ 📂resources  \n ┃ ┃ ┃ ┣ 📂css  \n ┃ ┃ ┃ ┃ ┣ 📂admin  \t\t\t\t\t\t// 관리자 페이지 css  \n ┃ ┃ ┃ ┃ ┣ 📂member  \t\t\t\t\t// 로그인, 회원가입 css  \n ┃ ┃ ┃ ┃ ┣ 📜cart.css  \t\t\t\t\t// 장바구니 css  \n ┃ ┃ ┃ ┃ ┣ 📜goodsDetail.css  \t// 상품 상세 페이지 css  \n ┃ ┃ ┃ ┃ ┣ 📜main.css  \t\t\t\t\t// 메인화면 css  \n ┃ ┃ ┃ ┃ ┣ 📜order.css  \t\t\t\t// 주문화면 css  \n ┃ ┃ ┃ ┃ ┗ 📜search.css  \t\t\t\t// 상품검색 css  \n ┃ ┃ ┃ ┗ 📂img  \t\t\t\t\t\t\t\t// 이미지 파일 모아놓기  \n ┃ ┃ ┗ 📂WEB-INF  \n ┃ ┃ ┃ ┣ 📂classes  \n ┃ ┃ ┃ ┣ 📂spring  \n ┃ ┃ ┃ ┃ ┣ 📂appServlet  \n ┃ ┃ ┃ ┃ ┗ 📜root-context.xml  \n ┃ ┃ ┃ ┣ 📂views  \n ┃ ┃ ┃ ┃ ┣ 📂admin  \n ┃ ┃ ┃ ┃ ┣ 📂includes  \n ┃ ┃ ┃ ┃ ┃ ┗ 📂admin  \t\t\t\t// 관리자 페이지 JSP  \n ┃ ┃ ┃ ┃ ┣ 📂member  \t\t\t\t\t// 로그인, 회원가입 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜cart.jsp  \t\t\t\t\t// 장바구니 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜goodsDetail.jsp  \t\t// 상품 상세 페이지 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜home.jsp  \t\t\t\t// 기본 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜main.jsp  \t\t\t\t\t// 메인화면 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜order.jsp  \t\t\t\t// 주문화면 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜replyEnroll.jsp  \t\t// 댓글등록 JSP  \n ┃ ┃ ┃ ┃ ┣ 📜replyUpdate.jsp  \t// 댓글갱신 JSP  \n ┃ ┃ ┃ ┃ ┗ 📜search.jsp  \t\t\t\t// 상품검색 JSP  \n ┃ ┃ ┃ ┗ 📜web.xml  \n ┗ 📂test  \n ┃ ┣ 📂java  \n ┃ ┃ ┗ 📂com  \n ┃ ┃ ┃ ┗ 📂vam  \n ┃ ┃ ┃ ┃ ┣ 📂mapper  \t\t\t\t\t// Mapper 테스트  \n ┃ ┃ ┃ ┃ ┣ 📂persistence  \t\t\t// DB연동 테스트  \n ┃ ┃ ┃ ┃ ┣ 📂service  \t\t\t\t\t// Service 테스트  \n ┃ ┃ ┃ ┃ ┗ 📂task  \t\t\t\t\t\t// Batch Program 테스트  \n ┃ ┗ 📂resources  \n ┃ ┃ ┗ 📜log4j.xml  \n\n<br><br>\n\n## 📜 DB 구조도\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/BuyBooks_DB.png?raw=true\">\n</p>\n\n- vam_book : 책 정보 테이블\n- vam_imgage : 책 이미지 테이블\n- vam_bcate : 책 카테고리 테이블\n- vam_author : 작가 정보 테이블\n- vam_nation : 작가 소속 국가 테이블\n- vam_orderItem : 책 주문시 책 정보 테이블 ( 수량, 가격, 할인율 등 )\n- vam_order : 책 주문시 주문자 정보 테이블 ( 주소, 아이디, 배달비 등 )\n- vam_cart : 장바구니 정보 테이블\n- book_member : 회원 정보 테이블\n- vam_reply : 댓글 정보 테이블\n\n<br><br>\n\n## 📜 API ( GitBook 활용 )\n\n### 📄 API 문서 주소 : [BuyBooks API](https://kims-organization-2.gitbook.io/buybooks-api/)\n\n<br>\n\n**🛒 장바구니 API**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bbapi2.png?raw=true\" width=\"65%\" height=\"65%\">\n</p>\n<br>\n\n**☝ 댓글 API**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bbapi3.png?raw=true\" width=\"65%\" height=\"65%\">\n</p>\n\n<br>\n\n**💻 관리자 API**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bbapi1.png?raw=true\" width=\"65%\" height=\"65%\">\n</p>\n\n","properties":"\n","discussions":{},"comments":{},"hash":-858899268}},"syncHistory":{"main":[-858899268,null,null]},"v":1,"hash":1710111610899,"tx":193},"FfQclKsMdVNJJRNd/content":{"id":"FfQclKsMdVNJJRNd/content","type":"content","text":"---\npermalink: /2023-02-18-HTTP의 특징/\ntitle: \"[HTTP] HTTP의 특징 ( Stateless, Connectionless ) \"\ndate: 2023-02-18 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n---\n<br><br><br>\n\n## ✅ HTTP란\n초기에는 HTML과 같은 하이퍼미디어 문서를 주로 전송했지만, 최근에는 Plain text, JSON, XML 등 다양한 형태의 정보도 전송하는 애플리케이션 레이어 프로토콜이다.  \n초기에는 웹 브라우저와 웹 서버 간의 커뮤니케이션을 위해 디자인되었지만 최근에는 모바일 애플리케이션 및 IoT 등과의 커뮤니케이션과 같이 다른 목적으로도 사용되고 있다.  \nHTTP는 클라이언트가 요청을 생성하기 위한 연결을 연 다음 응답을 받을 때까지 대기하는 전통적인 클라이언트-서버 모델을 따른다.  \nHTTP는 무상태 프로토콜이며, 이는 서버가 두 요청 간에 어떠한 상태나 데이터를 유지하지 않음을 의미한다. (상태를 유지하기 위한 노력으로 Cookie와 Session을 사용한다.)  \n일반적으로 안정적인 TCP/IP 레이어를 기반으로 사용하는 응용 프로토콜이다.\n\n<br><br>\n\n## ✅ HTTP 특징\n\n### 📌 **클라이언트 서버 구조**\nRequest Response 구조로 클라이언트는 서버에 요청을 보내고, 응답을 대기한다.\n서버가 요청에 대한 결과를 만들어서 응답한다.\n\n<br><br>\n\n### 📌 **무상태(Stateless) 프로토콜**\n무상태 프로토콜이란 서버가 클라이언트의 상태를 보존하지 않는 특징이다.\n서버의 확장성에 용이하다는 장점이 있지만, 클라이언트가 추가 데이터를 전송해야 하는 단점이 있다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stateless1.png?raw=true\">\n</p>\n\n<br><br>\n\n> **상태 유지(Stateful)란?**   \n> 클라이언트의 요청1에 대한 상태를 해당 요청을 받은 서버A가 기억하고 있는 것으로 항상 같은 서버A가 유지되어야 할 것이다. 만약 서버A에서 장애가 난다면 유지되던 상태 정보가 없어져 버리므로 처음부터 다시 요청을 해야한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stateful1.png?raw=true\">\n</p>\n\n<br><br>\n\n무상태 프로토콜은 클라이언트에 요청을 보낼때 필요한 데이터를 항상 담아서 전송하기 때문에 어떠한 서버든지 상관없이 호출해서 사용할 수 있다. 때문에 **서버가 고장나도 다른 서버로 대체하여 사용가능하고, 서버의 무한증설이 가능하다!**\n\n<br><br>\n\n> **무상태(stateless)의 한계**   \n> 로그인이 필요 없는 단순한 서비스 소개 화면 같은 경우엔 무상태로 설계할 수 있지만, 로그인이 필요한 서비스라면 유저의 상태를 유지해야 되기 때문에 **브라우저 쿠키**, **서버 세션**, **토큰** 등을 이용해 상태를 유지한다. 이러한 상태 유지는 최소한만 사용한다.\n\n<br><br>\n\n### 📌 **비연결성 (Conectionless) 프로토콜**\nHTTP는 기본적으로 **연결을 유지하지 않는 모델**이다. 일반적으로 초 단위 이하의 빠른속도로 응답하고, 수천명이 서비스를 사용해도 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작기 때문에 서버 자원을 매우 효율적으로 사용할 수 있다. \n\n<br><br>\n\n> **연결성 모델 (Connection Oriented)** \n> TCP/IP의 경우 기본적으로 연결을 유지한다. 클라이언트는 요청을 보내지 않아도 계속 연결을 유지해야 한다. 이러한 경우 연결을 유지하는 서버의 자원이 계속 소모가 된다.\n\n<br><br>\n\n비연결성 프로토콜은 **TCP/IP 연결을 새로 맺어야** 하기때문에 3 way handShake 시간이 추가되고, 웹브라우저로 사이트를 요청하면 HTML뿐만 아니라 자바스크립트, CSS, 이미지 등 수많은 자원이 함께 다운로드 되어 **시간이 오래 걸리는 단점**이 있다.\n\n그러나 최근에는  **HTTP 지속연결 (Persistent Connections)** 로 문제를 해결한다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":1225997900,"tx":195},"FfQclKsMdVNJJRNd/syncedContent":{"id":"FfQclKsMdVNJJRNd/syncedContent","type":"syncedContent","historyData":{"1225997900":{"id":"FfQclKsMdVNJJRNd/content","type":"content","text":"---\npermalink: /2023-02-18-HTTP의 특징/\ntitle: \"[HTTP] HTTP의 특징 ( Stateless, Connectionless ) \"\ndate: 2023-02-18 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n---\n<br><br><br>\n\n## ✅ HTTP란\n초기에는 HTML과 같은 하이퍼미디어 문서를 주로 전송했지만, 최근에는 Plain text, JSON, XML 등 다양한 형태의 정보도 전송하는 애플리케이션 레이어 프로토콜이다.  \n초기에는 웹 브라우저와 웹 서버 간의 커뮤니케이션을 위해 디자인되었지만 최근에는 모바일 애플리케이션 및 IoT 등과의 커뮤니케이션과 같이 다른 목적으로도 사용되고 있다.  \nHTTP는 클라이언트가 요청을 생성하기 위한 연결을 연 다음 응답을 받을 때까지 대기하는 전통적인 클라이언트-서버 모델을 따른다.  \nHTTP는 무상태 프로토콜이며, 이는 서버가 두 요청 간에 어떠한 상태나 데이터를 유지하지 않음을 의미한다. (상태를 유지하기 위한 노력으로 Cookie와 Session을 사용한다.)  \n일반적으로 안정적인 TCP/IP 레이어를 기반으로 사용하는 응용 프로토콜이다.\n\n<br><br>\n\n## ✅ HTTP 특징\n\n### 📌 **클라이언트 서버 구조**\nRequest Response 구조로 클라이언트는 서버에 요청을 보내고, 응답을 대기한다.\n서버가 요청에 대한 결과를 만들어서 응답한다.\n\n<br><br>\n\n### 📌 **무상태(Stateless) 프로토콜**\n무상태 프로토콜이란 서버가 클라이언트의 상태를 보존하지 않는 특징이다.\n서버의 확장성에 용이하다는 장점이 있지만, 클라이언트가 추가 데이터를 전송해야 하는 단점이 있다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stateless1.png?raw=true\">\n</p>\n\n<br><br>\n\n> **상태 유지(Stateful)란?**   \n> 클라이언트의 요청1에 대한 상태를 해당 요청을 받은 서버A가 기억하고 있는 것으로 항상 같은 서버A가 유지되어야 할 것이다. 만약 서버A에서 장애가 난다면 유지되던 상태 정보가 없어져 버리므로 처음부터 다시 요청을 해야한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stateful1.png?raw=true\">\n</p>\n\n<br><br>\n\n무상태 프로토콜은 클라이언트에 요청을 보낼때 필요한 데이터를 항상 담아서 전송하기 때문에 어떠한 서버든지 상관없이 호출해서 사용할 수 있다. 때문에 **서버가 고장나도 다른 서버로 대체하여 사용가능하고, 서버의 무한증설이 가능하다!**\n\n<br><br>\n\n> **무상태(stateless)의 한계**   \n> 로그인이 필요 없는 단순한 서비스 소개 화면 같은 경우엔 무상태로 설계할 수 있지만, 로그인이 필요한 서비스라면 유저의 상태를 유지해야 되기 때문에 **브라우저 쿠키**, **서버 세션**, **토큰** 등을 이용해 상태를 유지한다. 이러한 상태 유지는 최소한만 사용한다.\n\n<br><br>\n\n### 📌 **비연결성 (Conectionless) 프로토콜**\nHTTP는 기본적으로 **연결을 유지하지 않는 모델**이다. 일반적으로 초 단위 이하의 빠른속도로 응답하고, 수천명이 서비스를 사용해도 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작기 때문에 서버 자원을 매우 효율적으로 사용할 수 있다. \n\n<br><br>\n\n> **연결성 모델 (Connection Oriented)** \n> TCP/IP의 경우 기본적으로 연결을 유지한다. 클라이언트는 요청을 보내지 않아도 계속 연결을 유지해야 한다. 이러한 경우 연결을 유지하는 서버의 자원이 계속 소모가 된다.\n\n<br><br>\n\n비연결성 프로토콜은 **TCP/IP 연결을 새로 맺어야** 하기때문에 3 way handShake 시간이 추가되고, 웹브라우저로 사이트를 요청하면 HTML뿐만 아니라 자바스크립트, CSS, 이미지 등 수많은 자원이 함께 다운로드 되어 **시간이 오래 걸리는 단점**이 있다.\n\n그러나 최근에는  **HTTP 지속연결 (Persistent Connections)** 로 문제를 해결한다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":1225997900}},"syncHistory":{"main":[1225997900,null,null]},"v":1,"hash":1710111612062,"tx":195},"ygsX3wnSWEPl4aQH/content":{"id":"ygsX3wnSWEPl4aQH/content","type":"content","text":"---\npermalink: /2023-02-19-HTTP 메세지/\ntitle: \"[HTTP] HTTP 메세지\"\ndate: 2023-02-19 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n---\n<br><br><br>\n\n## ✅ HTTP 메세지\nHTTP 메시지는 서버와 클라이언트 간에 데이터가 교환되는 방식입니다. 메시지 타입은 두 가지가 있습니다. 요청(_request)_ 은 클라이언트가 서버로 전달해서 서버의 액션이 일어나게끔 하는 메시지고, 응답(_response)_ 은 요청에 대한 서버의 답변입니다.\n\nHTTP 메시지는 HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터를 전송 가능하고 서버간에 데이터를 주고 받을 때도 대부분 HTTP를 사용합니다.\n\n<br>\n\n### 📌 **HTTP 요청&응답 메세지**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/httpmessage1.jpg?raw=true\">\n</p>\nHTTP 메시지의 시작 줄과 HTTP 헤더를 묶어서 **요청 헤드(head)** 라고 부르며, 이와 반대로 HTTP 메시지의 페이로드는 **본문(body)**이라고 합니다.\n<br><br><br>\n\n## ✅ HTTP  요청\n\n### 📌 **시작줄(시작라인)**\nHTTP요청은 서버가 특정 동작을 취하게끔 만들기 위해 클라이언트 전송하는 메세지입니다.  \n시작줄은 **세가지 요소**로 이루어져 있습니다.\n<br><br>\n\n#### ✔ HTTP 메서드\n> **GET** / search?q=hello&hi=ko HTTP/1.1  \n> Host : www.google.com\n\n```GET, POST, PUT, DELETE``` 같은 동사형태나 ```HEAD,OPTIONS``` 같은 명사형태를 사용해 서버가 수행해야할 동작을 나타냅니다. 예를들어 ```GET```은 리소스를 클라이언트로 가져다 달라는 것을 의미하고, ```POST```는 데이터가 서버로 들어가야 함을 의미합니다. HTTP 메서드에 대한 자세한 설명은 HTTP 메서드 포스팅에 있으니 참고해주시길 바랍니다.\n\n<BR><BR>\n#### ✔ 요청 대상 ( URL, 프로토콜, 포트, 도메인 ... )\n> GET **/ search?q=hello&hi=ko** HTTP/1.1  \n> Host : www.google.com\n\n요청대상은 주로 URL, 프로토콜, 포트, 도메인의 절대경로로 나타내지며 요청 컨텍스트에 의해 특정지어 집니다. 요청대상의 포멧은 HTTP 메소드에 따라 달라지고 다음과 같은 것들이 있습니다.\n\n- _ORIGIN형식_ : 끝에 `'?'`와 쿼리 문자열이 붙는 절대 경로입니다. 이는 가장 일반적인 형식이며, `GET`, `POST`, `HEAD`, `OPTIONS` 메서드와 함께 사용합니다.\n -   _absolute 형식_ : 완전한 URL 형식입니다.  프록시에 연결하는 경우 대부분  `GET`과 함께 사용됩니다.  `GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1`\n-   _authority 형식_:  도메인 이름 및 옵션 포트(`':'`가 앞에 붙습니다)로 이루어진 URL의 authority component 입니다. HTTP 터널을 구축하는 경우에만  `CONNECT`와 함께 사용할 수 있습니다.  `CONNECT developer.mozilla.org:80 HTTP/1.1`\n-   _asterisk 형식_:  `OPTIONS`와 함께 별표(`'*'`) 하나로 간단하게 서버 전체를 나타냅니다.  `OPTIONS * HTTP/1.1`\n\n<BR><BR>\n\n\n#### ✔ HTTP 버전\n> GET / search?q=hello&hi=ko **HTTP/1.1**  \n> Host : www.google.com\n\nHTTP 버전을 의미합니다.\n\n\n<BR><BR><BR>\n\n### 📌 **HTTP 헤더**\nHTTP 헤더에는 HTTP 전송에 필요한 모든 부가정보가 포함됩니다. 예를들어 메세지 바디의 내용, 바디의 크기, 압축여부, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보... 등이 있습니다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/httpmessage2.png?raw=true\">\n</p>\n\n일반적으로 ```문자열 : 헤더 정보``` 의 형태를 띄고 헤더 종류에 따라 값이 달라집니다. 표준헤더가 굉장히 많기 때문에 전부다 알기는 어렵고 [참고자료](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)를 첨부해놓겠습니다. \n\n<br><br><br>\n\n### 📌 **HTTP 바디**\n실제 전송할 데이터를 담고있습니다. HTML문서, 이미지, 영상, JSON 등 BYTE로 표현할 수 있는 모든 데이터의 전송이 가능합니다. HTTP 요청의 마지막 부분에 들어가고, 모든 요청에 바디가 들어가지는 않습니다. `GET`, `HEAD`, `DELETE`, `OPTIONS` 처럼 리소스를 가져오는 요청은 보통 본문이 필요하지 않고 `POST` 처럼 HTML 폼 데이터를 포함하는 경우 바디가 필요하곤 합니다.\n\n<BR><BR><BR>\n\n## ✅ HTTP  응답\n\n### 📌 **시작줄(시작라인)**\n#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✔ HTTP 버전 \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;보통 HTTP/1.1 을 사용합니다\n#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✔ HTTP 상태 코드\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요청의 성공, 실패를 나타냅니다. 예를들어 200 : 성공, 400: 클라이언트 요청 오류, \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;500 : 서버내부 오류 를 의미합니다.\n#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✔ 이유 문구\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사람이 이해할 수 있는 짧은 상태코드 설명입니다.\n\n<BR><BR><bR>\n\n### 📌 **HTTP 헤더와 바디**\nHTTP요청과 내용이 동일합니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1868238632,"tx":197},"ygsX3wnSWEPl4aQH/syncedContent":{"id":"ygsX3wnSWEPl4aQH/syncedContent","type":"syncedContent","historyData":{"-1868238632":{"id":"ygsX3wnSWEPl4aQH/content","type":"content","text":"---\npermalink: /2023-02-19-HTTP 메세지/\ntitle: \"[HTTP] HTTP 메세지\"\ndate: 2023-02-19 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n---\n<br><br><br>\n\n## ✅ HTTP 메세지\nHTTP 메시지는 서버와 클라이언트 간에 데이터가 교환되는 방식입니다. 메시지 타입은 두 가지가 있습니다. 요청(_request)_ 은 클라이언트가 서버로 전달해서 서버의 액션이 일어나게끔 하는 메시지고, 응답(_response)_ 은 요청에 대한 서버의 답변입니다.\n\nHTTP 메시지는 HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태의 데이터를 전송 가능하고 서버간에 데이터를 주고 받을 때도 대부분 HTTP를 사용합니다.\n\n<br>\n\n### 📌 **HTTP 요청&응답 메세지**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/httpmessage1.jpg?raw=true\">\n</p>\nHTTP 메시지의 시작 줄과 HTTP 헤더를 묶어서 **요청 헤드(head)** 라고 부르며, 이와 반대로 HTTP 메시지의 페이로드는 **본문(body)**이라고 합니다.\n<br><br><br>\n\n## ✅ HTTP  요청\n\n### 📌 **시작줄(시작라인)**\nHTTP요청은 서버가 특정 동작을 취하게끔 만들기 위해 클라이언트 전송하는 메세지입니다.  \n시작줄은 **세가지 요소**로 이루어져 있습니다.\n<br><br>\n\n#### ✔ HTTP 메서드\n> **GET** / search?q=hello&hi=ko HTTP/1.1  \n> Host : www.google.com\n\n```GET, POST, PUT, DELETE``` 같은 동사형태나 ```HEAD,OPTIONS``` 같은 명사형태를 사용해 서버가 수행해야할 동작을 나타냅니다. 예를들어 ```GET```은 리소스를 클라이언트로 가져다 달라는 것을 의미하고, ```POST```는 데이터가 서버로 들어가야 함을 의미합니다. HTTP 메서드에 대한 자세한 설명은 HTTP 메서드 포스팅에 있으니 참고해주시길 바랍니다.\n\n<BR><BR>\n#### ✔ 요청 대상 ( URL, 프로토콜, 포트, 도메인 ... )\n> GET **/ search?q=hello&hi=ko** HTTP/1.1  \n> Host : www.google.com\n\n요청대상은 주로 URL, 프로토콜, 포트, 도메인의 절대경로로 나타내지며 요청 컨텍스트에 의해 특정지어 집니다. 요청대상의 포멧은 HTTP 메소드에 따라 달라지고 다음과 같은 것들이 있습니다.\n\n- _ORIGIN형식_ : 끝에 `'?'`와 쿼리 문자열이 붙는 절대 경로입니다. 이는 가장 일반적인 형식이며, `GET`, `POST`, `HEAD`, `OPTIONS` 메서드와 함께 사용합니다.\n -   _absolute 형식_ : 완전한 URL 형식입니다.  프록시에 연결하는 경우 대부분  `GET`과 함께 사용됩니다.  `GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1`\n-   _authority 형식_:  도메인 이름 및 옵션 포트(`':'`가 앞에 붙습니다)로 이루어진 URL의 authority component 입니다. HTTP 터널을 구축하는 경우에만  `CONNECT`와 함께 사용할 수 있습니다.  `CONNECT developer.mozilla.org:80 HTTP/1.1`\n-   _asterisk 형식_:  `OPTIONS`와 함께 별표(`'*'`) 하나로 간단하게 서버 전체를 나타냅니다.  `OPTIONS * HTTP/1.1`\n\n<BR><BR>\n\n\n#### ✔ HTTP 버전\n> GET / search?q=hello&hi=ko **HTTP/1.1**  \n> Host : www.google.com\n\nHTTP 버전을 의미합니다.\n\n\n<BR><BR><BR>\n\n### 📌 **HTTP 헤더**\nHTTP 헤더에는 HTTP 전송에 필요한 모든 부가정보가 포함됩니다. 예를들어 메세지 바디의 내용, 바디의 크기, 압축여부, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보... 등이 있습니다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/httpmessage2.png?raw=true\">\n</p>\n\n일반적으로 ```문자열 : 헤더 정보``` 의 형태를 띄고 헤더 종류에 따라 값이 달라집니다. 표준헤더가 굉장히 많기 때문에 전부다 알기는 어렵고 [참고자료](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)를 첨부해놓겠습니다. \n\n<br><br><br>\n\n### 📌 **HTTP 바디**\n실제 전송할 데이터를 담고있습니다. HTML문서, 이미지, 영상, JSON 등 BYTE로 표현할 수 있는 모든 데이터의 전송이 가능합니다. HTTP 요청의 마지막 부분에 들어가고, 모든 요청에 바디가 들어가지는 않습니다. `GET`, `HEAD`, `DELETE`, `OPTIONS` 처럼 리소스를 가져오는 요청은 보통 본문이 필요하지 않고 `POST` 처럼 HTML 폼 데이터를 포함하는 경우 바디가 필요하곤 합니다.\n\n<BR><BR><BR>\n\n## ✅ HTTP  응답\n\n### 📌 **시작줄(시작라인)**\n#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✔ HTTP 버전 \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;보통 HTTP/1.1 을 사용합니다\n#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✔ HTTP 상태 코드\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요청의 성공, 실패를 나타냅니다. 예를들어 200 : 성공, 400: 클라이언트 요청 오류, \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;500 : 서버내부 오류 를 의미합니다.\n#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;✔ 이유 문구\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사람이 이해할 수 있는 짧은 상태코드 설명입니다.\n\n<BR><BR><bR>\n\n### 📌 **HTTP 헤더와 바디**\nHTTP요청과 내용이 동일합니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1868238632}},"syncHistory":{"main":[-1868238632,null,null]},"v":1,"hash":1710111613198,"tx":197},"RPnGLdVL2Co43fn3/content":{"id":"RPnGLdVL2Co43fn3/content","type":"content","text":"---\npermalink: /2023-02-20-HTTP 메서드 총정리/\ntitle: \"[HTTP] HTTP 메서드 총정리\"\ndate: 2023-02-20 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- HTTP 메서드\n---\n<br><br>\n\n## ✅ HTTP 메서드\n\nHTTP 메서드란 클라이언트와 서버 사이에 이루어지는 요청과 응답 데이터를 전송하는 방식을 일컫습니다. 즉, 서버에 주어진 리소스에 수행하길 원하는 행동, 서버가 수행해야 할 동작을 지정하는 요청을 보내는 방법을 말합니다.\n\nHTTP메서드는 총 9종류로 주로 쓰이는 메서드는 5가지 정도가 존재합니다.\n\n### 📌 주요 메서드\n- `GET` : 리소스 조회\n- `POST` : 요청 데이터 처리, 주로 등록에 사용\n- `PUT`: 리소스 대체, 해당 리소스가 없으면 생성\n- `PATCH` : 리소스 부분 변경\n- `DELETE` : 리소스 삭제\n\n### 📌 기타 메서드\n- `HEAD` : `GET`과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환\n- `OPTIONS` : 대상 리소스에 대한 통신 가능 옵션을 설명 ( 주로 CORS에서 사용 )\n- `CONNECT` : 대상 자원으로 식별되는 서버에 대한 터널을 설정\n- `TRACE` : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - GET\n\n- 리소스 조회 메서드 ( CRUD의 READ)\n- 서버에 전달하고 싶은 데이터는 쿼리를 통해서 전달합니다.\n\t> GET /members/100?userName=kim&age=27\n- 메시지 바디를 통해서 데이터를 전달할 수도 있지만, 지원하지 않는 곳이 많아 권장하지 않습니다.\n- 조회 할때 POST도 사용 가능하지만, GET 메서드는 캐싱이 가능하기 때문에 GET을 사용하는것이 유리합니다.\n\n\n<BR><BR>\n\n### 📌 정적 데이터 GET 과정\n\n이미지, 텍스트 같은 정적 데이터는 쿼리파라미터 없이 **리소스 경로**만으로 조회가 가능합니다.\n\n<BR>\n\n\n**1. 클라이언트에서 `/memebers/100` 으로 100번 멤버에 대한 정보를 달라고 `GET` 요청을 보냅니다.**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get1.png?raw=true\">\n</p>\n\n<br>\n\n**2. 서버에서는 GET요청을 분석후 필요한 데이터를 담아 Response를 만듭니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get2.png?raw=true\">\n</p>\n\n<br>\n\n**3. 서버는 Response에 대한 응답데이터를 만들고 클라이언트에 응답데이터를 전송합니다. \n200 OK status를 가집니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get3.png?raw=true\">\n</p>\n\n<br><br>\n\n### 📌 동적 데이터 GET 과정\n- 주로 검색, 게시판 목록에서 정렬 필터에 사용됩니다.\n- 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용합니다.\n- 쿼리 파라미터를 사용해서 데이터를 전달합니다.\n- 쿼리 파라미터는 `key1=value1&key2=value2` 의 구조를 띄고 있습니다.\n\n<br>\n\n**1. 요청 URL뒤에 쿼리파라미터를 부여하고 상세한 조회 데이터를 얻을 수 있습니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get4.png?raw=true\">\n</p>\n\n\n<br><br>\n\n### 📌 HTML Form 데이터 GET 과정\n- HTML Form 태그를 활용해 서버와 클라이언트가 통신할 수 있습니다.\n- HTML Form 전송은 `GET`과 `POST`만을 지원합니다.\n- `GET`, `POST` 이외의 태그를 사용하기 위해서는 Ajax비동기통신을 사용할 수 있습니다.\n\n<br><br>\n\n**1. 웹페이지에서 Form 태그안에 데이터를 작성하고 전송버튼을 누릅니다.**\n\n**2. GET 메서드 동작에 따라 input 태그안에 들어간 값들이 쿼리스트링으로 서버로 전송됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get5.png?raw=true\">\n</p>\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - POST\n- 전달한 데이터를 처리하는 메서드 ( CRUD의  CREATE )\n- 메시지 바디를 통해 서버로 요청 데이터를 전달하면 서버에서 요청데이터를 처리합니다.\n- 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행합니다.\n- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용합니다.\n\n<BR><BR>\n### 📌 요청 데이터를 어떻게 처리한다는 뜻일까?\n<BR>\n데이터를 처리한다는 말이 잘 이해가 되지 않을 수 있습니다. 구체적으로 '처리'라는 개념이 어떤것인지 먼저 예시로 알아보고 `POST`에 대해서 알아보겠습니다.\n\n정식 스펙에서 POST는 다음과 같이 설명합니다. **POST 메서드는 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청합니다.**\n\n- HTML 양식에 입력 된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공 ( HTML FORM에 입력한 정보로 회원가입, 주문 등에서 사용 )\n- 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시 ( 게시판 글쓰기, 댓글 달기 )\n- 서버가 아직 식별하지 않은 새 리소스 생성 ( 신규 주문 생성 )\n- 기존 자원에 데이터 추가 ( 한 문서 끝에 내용 추가하기 )\n\n**한마디로 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해줘야 합니다.**\n\n<BR><BR>\n\n### 📌 JSON 데이터 POST 과정\n<BR>\n\n**1. 클라이언트는 처리하고자 하는 데이터를 메시지 바디에 담아 서버로 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/post1.png?raw=true\">\n</p>\n\n<br>\n\n**2. 서버는 받은 메시지를 분석해 요청한 로직대로 처리합니다.\n 아래 그림에서는 신규 리소스 식별자를 생성하는 로직을 처리합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/post2.png?raw=true\">\n</p>\n\n<br>\n\n**3. 처리한 로직에 대한 데이터를 바디에 담아 클라이언트로 보내줍니다. \n신규자원에 대한 생성은 200 or 201의 status로 지정합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/post3.png?raw=true\">\n</p>\n\n<br><br>\n\n### 📌 HTML Form 데이터 POST 과정\n\n- HTML Form 태그를 활용해 서버와 클라이언트가 통신할 수 있습니다.\n- HTML Form 전송은 `GET`과 `POST`만을 지원합니다.\n- `GET`, `POST` 이외의 태그를 사용하기 위해서는 Ajax비동기통신을 사용할 수 있습니다.\n- `GET` 방식과 동일하게 사용됩니다.\n\n<BR>\n\n**1. 클라이언트가 웹페이지에 있는 Form 태그를 통해 데이터를 전송합니다.**\n\n**2. 서버는 POST메서드를 받아오고 데이터를 처리한 뒤 메시지 바디에 데이터를 저장해서 응답합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/post4.png?raw=true\">\n</p>\n\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - PUT\n- 리소스를 대체(수정) 하는 메서드 입니다. ( CRUD의 UPDATE )\n- 리스소가 존재한다면 대체하고, 리소스가 없으면 생성합니다.\n- 한마디로 리소스를 덮어쓰기 한다고 볼 수 있습니다.\n- 리소스를 대체해야 하므로 클라이언트가 URI를 지정해야 합니다.\n- PUT은 리소스 전체 변경, PATCH는 리소스 부분 변경\n\n<br><br>\n\n### 📌 PUT 요청에 기존 리소스가 존재하는 경우\n\n<BR>\n\n**1. `PUT /members/100` : 기존 리소스가 존재하는 경우에 리소스를 교체하겠다는 PUT요청을 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put1.png?raw=true\">\n</p>\n\n<br>\n\n**2. 기존 `/members/100` 리소스에서 새로 요청한 리소스로 변경됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put2.png?raw=true\">\n</p>\n\n<br><br>\n\n### 📌 PUT 요청에 기존 리소스가 존재하지 않는 경우\n<BR>\n\n**1. `PUT /members/100` : 기존 리소스가 존재하지 않을때 PUT요청을 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put3.png?raw=true\">\n</p>\n\n<BR>\n\n**2. 기존 리소스가 존재하지 않으므로 요청한 PUT리소스를 생성합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put4.png?raw=true\">\n</p>\n\n<BR><BR>\n\n### 주의❗ - PUT메서드는 기존리소스를 완전히 대체합니다!\n<BR>\n\n**1. 기존 `/members/100` 에 `username`과 `age`라는 필드 두개가 존재하고, `PUT`요청으로는 `age`필드만 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put5.png?raw=true\">\n</p>\n\n<br>\n\n**2. `PUT`요청은 리소스를 완전히 대체하기 때문에 `username`필드는 삭제됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put6.png?raw=true\">\n</p>\n\n**👀 PUT과 PATCH 메서드의 가장 큰 차이점이므로 반드시 알아두어야 합니다!**\n\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - PATCH\n- 리소스의 일부분을 변경해주는 메서드 ( CRUD의 UPDATE )\n- PATCH를 지원하지 않는 서버에서는 POST를 사용하기도 합니다.\n- PUT은 리소스 전체 변경, PATCH는 리소스 부분 변경\n\n<BR><BR>\n\n**1. PATCH /members/100 : 기존 리소스를 대체하기 위한 요청을 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/patch1.png?raw=true\">\n</p>\n\n<br>\n\n**2. 기존 리소스에서 요청된 `age` 필드만 변경됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/patch2.png?raw=true\">\n</p>\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - DELETE\n- 리소스를 삭제합니다. ( CRUD의 DELETE )\n\n<BR><BR>\n\n**1. DELETE /members/100 : 리소스를 삭제하기 위한 요청을 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/delete1.png?raw=true\">\n</p>\n\n<br>\n\n**2. /members/100 리소스가 삭제됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/delete2.png?raw=true\">\n</p>\n","properties":"\n","discussions":{},"comments":{},"hash":1812622952,"tx":201},"RPnGLdVL2Co43fn3/syncedContent":{"id":"RPnGLdVL2Co43fn3/syncedContent","type":"syncedContent","historyData":{"1812622952":{"id":"RPnGLdVL2Co43fn3/content","type":"content","text":"---\npermalink: /2023-02-20-HTTP 메서드 총정리/\ntitle: \"[HTTP] HTTP 메서드 총정리\"\ndate: 2023-02-20 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- HTTP 메서드\n---\n<br><br>\n\n## ✅ HTTP 메서드\n\nHTTP 메서드란 클라이언트와 서버 사이에 이루어지는 요청과 응답 데이터를 전송하는 방식을 일컫습니다. 즉, 서버에 주어진 리소스에 수행하길 원하는 행동, 서버가 수행해야 할 동작을 지정하는 요청을 보내는 방법을 말합니다.\n\nHTTP메서드는 총 9종류로 주로 쓰이는 메서드는 5가지 정도가 존재합니다.\n\n### 📌 주요 메서드\n- `GET` : 리소스 조회\n- `POST` : 요청 데이터 처리, 주로 등록에 사용\n- `PUT`: 리소스 대체, 해당 리소스가 없으면 생성\n- `PATCH` : 리소스 부분 변경\n- `DELETE` : 리소스 삭제\n\n### 📌 기타 메서드\n- `HEAD` : `GET`과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환\n- `OPTIONS` : 대상 리소스에 대한 통신 가능 옵션을 설명 ( 주로 CORS에서 사용 )\n- `CONNECT` : 대상 자원으로 식별되는 서버에 대한 터널을 설정\n- `TRACE` : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - GET\n\n- 리소스 조회 메서드 ( CRUD의 READ)\n- 서버에 전달하고 싶은 데이터는 쿼리를 통해서 전달합니다.\n\t> GET /members/100?userName=kim&age=27\n- 메시지 바디를 통해서 데이터를 전달할 수도 있지만, 지원하지 않는 곳이 많아 권장하지 않습니다.\n- 조회 할때 POST도 사용 가능하지만, GET 메서드는 캐싱이 가능하기 때문에 GET을 사용하는것이 유리합니다.\n\n\n<BR><BR>\n\n### 📌 정적 데이터 GET 과정\n\n이미지, 텍스트 같은 정적 데이터는 쿼리파라미터 없이 **리소스 경로**만으로 조회가 가능합니다.\n\n<BR>\n\n\n**1. 클라이언트에서 `/memebers/100` 으로 100번 멤버에 대한 정보를 달라고 `GET` 요청을 보냅니다.**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get1.png?raw=true\">\n</p>\n\n<br>\n\n**2. 서버에서는 GET요청을 분석후 필요한 데이터를 담아 Response를 만듭니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get2.png?raw=true\">\n</p>\n\n<br>\n\n**3. 서버는 Response에 대한 응답데이터를 만들고 클라이언트에 응답데이터를 전송합니다. \n200 OK status를 가집니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get3.png?raw=true\">\n</p>\n\n<br><br>\n\n### 📌 동적 데이터 GET 과정\n- 주로 검색, 게시판 목록에서 정렬 필터에 사용됩니다.\n- 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용합니다.\n- 쿼리 파라미터를 사용해서 데이터를 전달합니다.\n- 쿼리 파라미터는 `key1=value1&key2=value2` 의 구조를 띄고 있습니다.\n\n<br>\n\n**1. 요청 URL뒤에 쿼리파라미터를 부여하고 상세한 조회 데이터를 얻을 수 있습니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get4.png?raw=true\">\n</p>\n\n\n<br><br>\n\n### 📌 HTML Form 데이터 GET 과정\n- HTML Form 태그를 활용해 서버와 클라이언트가 통신할 수 있습니다.\n- HTML Form 전송은 `GET`과 `POST`만을 지원합니다.\n- `GET`, `POST` 이외의 태그를 사용하기 위해서는 Ajax비동기통신을 사용할 수 있습니다.\n\n<br><br>\n\n**1. 웹페이지에서 Form 태그안에 데이터를 작성하고 전송버튼을 누릅니다.**\n\n**2. GET 메서드 동작에 따라 input 태그안에 들어간 값들이 쿼리스트링으로 서버로 전송됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/get5.png?raw=true\">\n</p>\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - POST\n- 전달한 데이터를 처리하는 메서드 ( CRUD의  CREATE )\n- 메시지 바디를 통해 서버로 요청 데이터를 전달하면 서버에서 요청데이터를 처리합니다.\n- 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행합니다.\n- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용합니다.\n\n<BR><BR>\n### 📌 요청 데이터를 어떻게 처리한다는 뜻일까?\n<BR>\n데이터를 처리한다는 말이 잘 이해가 되지 않을 수 있습니다. 구체적으로 '처리'라는 개념이 어떤것인지 먼저 예시로 알아보고 `POST`에 대해서 알아보겠습니다.\n\n정식 스펙에서 POST는 다음과 같이 설명합니다. **POST 메서드는 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청합니다.**\n\n- HTML 양식에 입력 된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공 ( HTML FORM에 입력한 정보로 회원가입, 주문 등에서 사용 )\n- 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시 ( 게시판 글쓰기, 댓글 달기 )\n- 서버가 아직 식별하지 않은 새 리소스 생성 ( 신규 주문 생성 )\n- 기존 자원에 데이터 추가 ( 한 문서 끝에 내용 추가하기 )\n\n**한마디로 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해줘야 합니다.**\n\n<BR><BR>\n\n### 📌 JSON 데이터 POST 과정\n<BR>\n\n**1. 클라이언트는 처리하고자 하는 데이터를 메시지 바디에 담아 서버로 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/post1.png?raw=true\">\n</p>\n\n<br>\n\n**2. 서버는 받은 메시지를 분석해 요청한 로직대로 처리합니다.\n 아래 그림에서는 신규 리소스 식별자를 생성하는 로직을 처리합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/post2.png?raw=true\">\n</p>\n\n<br>\n\n**3. 처리한 로직에 대한 데이터를 바디에 담아 클라이언트로 보내줍니다. \n신규자원에 대한 생성은 200 or 201의 status로 지정합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/post3.png?raw=true\">\n</p>\n\n<br><br>\n\n### 📌 HTML Form 데이터 POST 과정\n\n- HTML Form 태그를 활용해 서버와 클라이언트가 통신할 수 있습니다.\n- HTML Form 전송은 `GET`과 `POST`만을 지원합니다.\n- `GET`, `POST` 이외의 태그를 사용하기 위해서는 Ajax비동기통신을 사용할 수 있습니다.\n- `GET` 방식과 동일하게 사용됩니다.\n\n<BR>\n\n**1. 클라이언트가 웹페이지에 있는 Form 태그를 통해 데이터를 전송합니다.**\n\n**2. 서버는 POST메서드를 받아오고 데이터를 처리한 뒤 메시지 바디에 데이터를 저장해서 응답합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/post4.png?raw=true\">\n</p>\n\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - PUT\n- 리소스를 대체(수정) 하는 메서드 입니다. ( CRUD의 UPDATE )\n- 리스소가 존재한다면 대체하고, 리소스가 없으면 생성합니다.\n- 한마디로 리소스를 덮어쓰기 한다고 볼 수 있습니다.\n- 리소스를 대체해야 하므로 클라이언트가 URI를 지정해야 합니다.\n- PUT은 리소스 전체 변경, PATCH는 리소스 부분 변경\n\n<br><br>\n\n### 📌 PUT 요청에 기존 리소스가 존재하는 경우\n\n<BR>\n\n**1. `PUT /members/100` : 기존 리소스가 존재하는 경우에 리소스를 교체하겠다는 PUT요청을 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put1.png?raw=true\">\n</p>\n\n<br>\n\n**2. 기존 `/members/100` 리소스에서 새로 요청한 리소스로 변경됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put2.png?raw=true\">\n</p>\n\n<br><br>\n\n### 📌 PUT 요청에 기존 리소스가 존재하지 않는 경우\n<BR>\n\n**1. `PUT /members/100` : 기존 리소스가 존재하지 않을때 PUT요청을 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put3.png?raw=true\">\n</p>\n\n<BR>\n\n**2. 기존 리소스가 존재하지 않으므로 요청한 PUT리소스를 생성합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put4.png?raw=true\">\n</p>\n\n<BR><BR>\n\n### 주의❗ - PUT메서드는 기존리소스를 완전히 대체합니다!\n<BR>\n\n**1. 기존 `/members/100` 에 `username`과 `age`라는 필드 두개가 존재하고, `PUT`요청으로는 `age`필드만 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put5.png?raw=true\">\n</p>\n\n<br>\n\n**2. `PUT`요청은 리소스를 완전히 대체하기 때문에 `username`필드는 삭제됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/put6.png?raw=true\">\n</p>\n\n**👀 PUT과 PATCH 메서드의 가장 큰 차이점이므로 반드시 알아두어야 합니다!**\n\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - PATCH\n- 리소스의 일부분을 변경해주는 메서드 ( CRUD의 UPDATE )\n- PATCH를 지원하지 않는 서버에서는 POST를 사용하기도 합니다.\n- PUT은 리소스 전체 변경, PATCH는 리소스 부분 변경\n\n<BR><BR>\n\n**1. PATCH /members/100 : 기존 리소스를 대체하기 위한 요청을 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/patch1.png?raw=true\">\n</p>\n\n<br>\n\n**2. 기존 리소스에서 요청된 `age` 필드만 변경됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/patch2.png?raw=true\">\n</p>\n\n<BR><BR><BR><BR><BR>\n\n## ✅ HTTP 메서드 - DELETE\n- 리소스를 삭제합니다. ( CRUD의 DELETE )\n\n<BR><BR>\n\n**1. DELETE /members/100 : 리소스를 삭제하기 위한 요청을 전송합니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/delete1.png?raw=true\">\n</p>\n\n<br>\n\n**2. /members/100 리소스가 삭제됩니다.**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/delete2.png?raw=true\">\n</p>\n","properties":"\n","discussions":{},"comments":{},"hash":1812622952}},"syncHistory":{"main":[1812622952,null,null]},"v":1,"hash":1710111615342,"tx":201},"WD9Bzi9mPGSI4cK9/content":{"id":"WD9Bzi9mPGSI4cK9/content","type":"content","text":"---\npermalink: /2023-02-21-HTTP의 안전, 멱등, 캐시가능 속성/\ntitle: \"[HTTP] HTTP의 안전, 멱등, 캐시가능 속성\"\ndate: 2023-02-21 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- 안전\n- 멱등\n- 캐시가능\n---\n<br><br>\n\n## ✅ HTTP 메서드의 속성\n\nHTTP 메서드인 `GET` / `POST` / `PUT` / `PATCH` / `DELETE` 는 메서드의 동작 과정 뿐만 아니라, 각 메서드가 가지고 있는 속성을 반드시 알 필요가 있습니다. 왜냐하면 어떤 HTTP 메서드로 서버에 요청했느냐에 따라 API 설계나 복구 메커니즘 캐시 최적화 등 설계 로직이 달라질 수 있기 때문입니다.\n\nHTTP 메서드의 속성은 크게 **안전( Safe ), 멱등( Idempotent ), 캐시 가능( Cacheable )** 로 3가지가 존재합니다. 3가지 속성에 대한 이해와 각 메서드 별 어떤 속성을 지니고 있는지 알아보도록 하겠습니다. \n\n<p align=\"middle\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/http1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n## ✅ 안정성 ( Safe )\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/safe1.png?raw=true\">\n</p>\n\nHTTP 메서드의 **안정성**이란 보안 취약점에 대한 안정을 말하는게 아니라, **호출해도 리소스가 변경되지 않는 성질**, 즉 리소스 유지에 대한 안정성을 의미합니다.\n\n`GET` 메서드는 리소스를 조회하는 기능을 수행하기 때문에, 리소스에 대한 변경 및 수정이 전혀 이루어지지 않으므로, 안정성을 띄는 HTTP 메서드라고 볼 수 있습니다.\n\n그러나 `POST`, `PUT`, `PATCH`, `DELETE` 같은 메서드는 리소스에 대한 처리, 수정, 삭제를 수행하기 때문에 안정성을 띄지 않는 HTTP 메서드 입니다.\n\n여기서 `GET` 메서드가 엄청나게 많은 양의 호출을 통해 서버가 터지거나, 로그가 쌓여 장애가 발생하는 상황이 발생할지라도, HTTP 메서드의 속성에서 정의하는 안정성, 즉 리소스가 변경되지 않는 성질은 변하지 않기 때문에 리소스의 유지에 있어서는 안전하다고 볼 수 있다.\n\n한마디로 안정성은 시스템 장애와는 별개로 리소스 유지에만 집중한다는 뜻이다. \n\n\n<br><br><br><br><br><br>\n\n## ✅ 멱등 ( Idempotent )\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/idem1.png?raw=true\">\n</p>\n\n**멱등**이란, **수학이나 전산학에서 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질**을 의미합니다.\n\n이를 HTTP의 멱등성에 대입해보면, **요청을 한번 호출하든 여러번 호출하든 결과가 항상 동일함**을 의미합니다. 즉, **동일한 요청을 한번 보내는 것과 여러번 연속으로 보내는 것이 같은 결과를 가져오고, 서버의 상태도 동일할 때 해당 HTTP 메서드가 멱등성을 가진다고 말합니다.**\n\n여기서 안정과 멱등을 혼동하기 쉬운데,\n- 안전은 한번 호출하든 여러번 호출하든 리소스 수정 X\n- 멱등은 한번 호출하든 여러번 호출하든 수정이 발생할 지라도 실행 결과가 계속 같음\n\n여기서 멱등은 **동일한 결과 + 동일한 서버 상태**가 유지 되어야 함을 유의해야 한다. 예를 들어 응답 상태코드가 다르다 할지라도, 서버의 상태가 같다면 멱등성이 있다고 판단하는 것 입니다.\n\n<BR><BR>\n좀 더 쉬운 이해를 위해 예시로 알아보도록 하겠습니다.\n\n`GET /pageX HTTP/1.1` 은 멱등성을 가집니다. 여러번 연속해서 호출해도 클라이언트가 받는 응답은 동일합니다.\n\n ```\n GET /pageX HTTP/1.1\n \n GET /pageX HTTP/1.1\n \n GET /pageX HTTP/1.1\n \n GET /pageX HTTP/1.1\n ```\n\n<BR>\n`POST /add_row HTTP/1.1`는 멱등성을 갖지 않습니다. 여러 번 호출할 경우, 여러 열을 추가합니다.\n\n    POST /add_row HTTP/1.1\n    POST /add_row HTTP/1.1   -> Adds a 2nd row\n    POST /add_row HTTP/1.1   -> Adds a 3rd row\n\n<BR>\n\n`DELETE /idX/delete HTTP/1.1`의 상태 코드는 응답마다 달라질 수 있지만, 그럼에도 멱등성을 가집니다. 이 예시를 통해 응답 상태코드는 다르지만, 서버의 상태는 같으므로 멱등성을 가진다는 것을 알 수 있습니다.\n\n    DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists\n    DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted\n    DELETE /idX/delete HTTP/1.1   -> Returns 404\n\n\n<br><br><br><br><br><br>\n\n## ✅ 캐시 가능 ( Cacheable )\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/cache1.png?raw=true\">\n</p>\n\n캐시 가능 속성은 **응답 결과 리소스를 캐시해서 사용해도 되는가**를 의미합니다.\n\n브라우저도 캐시를 가지고 있는데, 클라이언트가 서버에 요청한 데이터에 대해 캐시를 보관하는게 가능합니다.\n\n즉, 캐싱이 가능한 HTTP 메소드는 빠르게 캐시 데이터를 가져와 결과값을 가질 수 있습니다.\n\n일반적으로 `GET`, `POST`, `PATCH`, `HEAD` 메서드가 캐시가능 속성을 지니지만\n실제로는 `GET`, `HEAD`만 캐시로 사용합니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1863059686,"tx":203},"WD9Bzi9mPGSI4cK9/syncedContent":{"id":"WD9Bzi9mPGSI4cK9/syncedContent","type":"syncedContent","historyData":{"-1863059686":{"id":"WD9Bzi9mPGSI4cK9/content","type":"content","text":"---\npermalink: /2023-02-21-HTTP의 안전, 멱등, 캐시가능 속성/\ntitle: \"[HTTP] HTTP의 안전, 멱등, 캐시가능 속성\"\ndate: 2023-02-21 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- 안전\n- 멱등\n- 캐시가능\n---\n<br><br>\n\n## ✅ HTTP 메서드의 속성\n\nHTTP 메서드인 `GET` / `POST` / `PUT` / `PATCH` / `DELETE` 는 메서드의 동작 과정 뿐만 아니라, 각 메서드가 가지고 있는 속성을 반드시 알 필요가 있습니다. 왜냐하면 어떤 HTTP 메서드로 서버에 요청했느냐에 따라 API 설계나 복구 메커니즘 캐시 최적화 등 설계 로직이 달라질 수 있기 때문입니다.\n\nHTTP 메서드의 속성은 크게 **안전( Safe ), 멱등( Idempotent ), 캐시 가능( Cacheable )** 로 3가지가 존재합니다. 3가지 속성에 대한 이해와 각 메서드 별 어떤 속성을 지니고 있는지 알아보도록 하겠습니다. \n\n<p align=\"middle\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/http1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n## ✅ 안정성 ( Safe )\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/safe1.png?raw=true\">\n</p>\n\nHTTP 메서드의 **안정성**이란 보안 취약점에 대한 안정을 말하는게 아니라, **호출해도 리소스가 변경되지 않는 성질**, 즉 리소스 유지에 대한 안정성을 의미합니다.\n\n`GET` 메서드는 리소스를 조회하는 기능을 수행하기 때문에, 리소스에 대한 변경 및 수정이 전혀 이루어지지 않으므로, 안정성을 띄는 HTTP 메서드라고 볼 수 있습니다.\n\n그러나 `POST`, `PUT`, `PATCH`, `DELETE` 같은 메서드는 리소스에 대한 처리, 수정, 삭제를 수행하기 때문에 안정성을 띄지 않는 HTTP 메서드 입니다.\n\n여기서 `GET` 메서드가 엄청나게 많은 양의 호출을 통해 서버가 터지거나, 로그가 쌓여 장애가 발생하는 상황이 발생할지라도, HTTP 메서드의 속성에서 정의하는 안정성, 즉 리소스가 변경되지 않는 성질은 변하지 않기 때문에 리소스의 유지에 있어서는 안전하다고 볼 수 있다.\n\n한마디로 안정성은 시스템 장애와는 별개로 리소스 유지에만 집중한다는 뜻이다. \n\n\n<br><br><br><br><br><br>\n\n## ✅ 멱등 ( Idempotent )\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/idem1.png?raw=true\">\n</p>\n\n**멱등**이란, **수학이나 전산학에서 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질**을 의미합니다.\n\n이를 HTTP의 멱등성에 대입해보면, **요청을 한번 호출하든 여러번 호출하든 결과가 항상 동일함**을 의미합니다. 즉, **동일한 요청을 한번 보내는 것과 여러번 연속으로 보내는 것이 같은 결과를 가져오고, 서버의 상태도 동일할 때 해당 HTTP 메서드가 멱등성을 가진다고 말합니다.**\n\n여기서 안정과 멱등을 혼동하기 쉬운데,\n- 안전은 한번 호출하든 여러번 호출하든 리소스 수정 X\n- 멱등은 한번 호출하든 여러번 호출하든 수정이 발생할 지라도 실행 결과가 계속 같음\n\n여기서 멱등은 **동일한 결과 + 동일한 서버 상태**가 유지 되어야 함을 유의해야 한다. 예를 들어 응답 상태코드가 다르다 할지라도, 서버의 상태가 같다면 멱등성이 있다고 판단하는 것 입니다.\n\n<BR><BR>\n좀 더 쉬운 이해를 위해 예시로 알아보도록 하겠습니다.\n\n`GET /pageX HTTP/1.1` 은 멱등성을 가집니다. 여러번 연속해서 호출해도 클라이언트가 받는 응답은 동일합니다.\n\n ```\n GET /pageX HTTP/1.1\n \n GET /pageX HTTP/1.1\n \n GET /pageX HTTP/1.1\n \n GET /pageX HTTP/1.1\n ```\n\n<BR>\n`POST /add_row HTTP/1.1`는 멱등성을 갖지 않습니다. 여러 번 호출할 경우, 여러 열을 추가합니다.\n\n    POST /add_row HTTP/1.1\n    POST /add_row HTTP/1.1   -> Adds a 2nd row\n    POST /add_row HTTP/1.1   -> Adds a 3rd row\n\n<BR>\n\n`DELETE /idX/delete HTTP/1.1`의 상태 코드는 응답마다 달라질 수 있지만, 그럼에도 멱등성을 가집니다. 이 예시를 통해 응답 상태코드는 다르지만, 서버의 상태는 같으므로 멱등성을 가진다는 것을 알 수 있습니다.\n\n    DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists\n    DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted\n    DELETE /idX/delete HTTP/1.1   -> Returns 404\n\n\n<br><br><br><br><br><br>\n\n## ✅ 캐시 가능 ( Cacheable )\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/cache1.png?raw=true\">\n</p>\n\n캐시 가능 속성은 **응답 결과 리소스를 캐시해서 사용해도 되는가**를 의미합니다.\n\n브라우저도 캐시를 가지고 있는데, 클라이언트가 서버에 요청한 데이터에 대해 캐시를 보관하는게 가능합니다.\n\n즉, 캐싱이 가능한 HTTP 메소드는 빠르게 캐시 데이터를 가져와 결과값을 가질 수 있습니다.\n\n일반적으로 `GET`, `POST`, `PATCH`, `HEAD` 메서드가 캐시가능 속성을 지니지만\n실제로는 `GET`, `HEAD`만 캐시로 사용합니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1863059686}},"syncHistory":{"main":[-1863059686,null,null]},"v":1,"hash":1710111616761,"tx":203},"erk03SWntmHYKgf9/content":{"id":"erk03SWntmHYKgf9/content","type":"content","text":"---\npermalink: /2023-02-22-HTTP 상태코드(1) - 2xx ( Successful )/\ntitle: \"[HTTP] HTTP 상태코드(1) - 2xx ( Successful )\"\ndate: 2023-02-22 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- HTTP 상태코드\n---\n<br><br><br><br>\n\n## ✅ HTTP 상태코드\n**HTTP 상태코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 의미합니다.** 1xx 부터 5xx 까지 존재하고 각 상태코드 마다 처리 상태에 대한 결과를 알려줍니다.\n\n- 1xx ( Informational ) : 요청이 수신되어 처리중 ( 거의 사용 x )\n- 2xx ( Successful ) : 요청 정상 처리\n- 3xx ( Redirection ) : 요청을 완료하면 추가 행동이 필요\n- 4xx ( Client Error ) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음\n- 5xx ( Server Error ) : 서버 오류, 서버가 정상 요청을 처리하지 못함.\n\n이번 포스팅은 2xx 상태코드에 대해서 알아볼텐데, 그전에 실무에서 거의 사용되지 않는 1xx 상태코드에 대해 간단하게 먼저 알아보고 2xx 상태코드를 이해해보도록 하겠습니다.\n\n<br><br><br><br><br><br>\n\n## ✅ 1xx 상태 코드 ( Informational )\n\n1xx 번대의 상태 코드들은 **요청이 수신되어 처리중** 이라는 의미를 가집니다.\n\n- 100 : Continue -> 처리가 되었으니 다음으로 진행하라\n- 101 : Switching Protocols -> 서버가 프로토콜을 전환중\n- 102 : Processing -> 서버가 요청을 수신하였으며 이를 처리중\n- 103 : Early Hints -> 리소스에 대한 힌트를 제공하여 리소스를 사전 로드하게 함\n\n이러한 상태코드들이 있지만 실무에서는 거의 사용되지 않으므로 한번 보고 넘어가도록 하자.\n\n<br><br><br><br><br><br>\n\n## ✅ 2xx 상태 코드 ( Successful )\n2xx 상태코드들은 **클라이언트의 요청을 성공적으로 처리했음**을 의미합니다. 단순히 요청에 대한 성공을 의미하지만 어떠한 행위에 대한 성공인지, 응답을 받고 클라이언트가 어떤 행동을 취할것인지 등 결정하기에 따라 다른 상태코드를 가집니다.\n\n- 200 : OK\n- 201 : Created\n- 202 : Accepted\n- 204 : No Content\n- ...\n\n\n<br><br><br><br><br><br>\n## ✅ 200 OK\n**상태코드 200은 클라이언트의 요청을 서버가 정상적으로 처리했음을 의미합니다.**\n\n\n<p align=\"middle\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/2xx1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n## ✅ 201 Created\n**상태코드 201은 요청에 성공해서 새로운 리소스가 생성됐음을 의미합니다.**\n\n<br><br><br><br><br><br>\n\n## ✅ 202 Accepted\n**상태코드 202는 요청이 접수되었으나 처리가 완료되지 않았음을 의미합니다.**\n\n- Batch 처리 같은 곳에서 사용\n- 예) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리한다.\n\n<br><br><br><br><br><br>\n\n## ✅ 204 No Content\n**상태코드 204는 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음을 의미합니다.**\n\n- 예) 웹 문서 편집기에서 save 버튼\n- save 버튼의 결과로 아무 내용이 없어도 된다.\n- save 버튼을 눌러도 같은 화면을 유지해야 한다.\n- 결과 내용이 없어도 204 메시지만으로 성공을 인식할 수 있다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":991426833,"tx":205},"erk03SWntmHYKgf9/syncedContent":{"id":"erk03SWntmHYKgf9/syncedContent","type":"syncedContent","historyData":{"991426833":{"id":"erk03SWntmHYKgf9/content","type":"content","text":"---\npermalink: /2023-02-22-HTTP 상태코드(1) - 2xx ( Successful )/\ntitle: \"[HTTP] HTTP 상태코드(1) - 2xx ( Successful )\"\ndate: 2023-02-22 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- HTTP 상태코드\n---\n<br><br><br><br>\n\n## ✅ HTTP 상태코드\n**HTTP 상태코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 의미합니다.** 1xx 부터 5xx 까지 존재하고 각 상태코드 마다 처리 상태에 대한 결과를 알려줍니다.\n\n- 1xx ( Informational ) : 요청이 수신되어 처리중 ( 거의 사용 x )\n- 2xx ( Successful ) : 요청 정상 처리\n- 3xx ( Redirection ) : 요청을 완료하면 추가 행동이 필요\n- 4xx ( Client Error ) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음\n- 5xx ( Server Error ) : 서버 오류, 서버가 정상 요청을 처리하지 못함.\n\n이번 포스팅은 2xx 상태코드에 대해서 알아볼텐데, 그전에 실무에서 거의 사용되지 않는 1xx 상태코드에 대해 간단하게 먼저 알아보고 2xx 상태코드를 이해해보도록 하겠습니다.\n\n<br><br><br><br><br><br>\n\n## ✅ 1xx 상태 코드 ( Informational )\n\n1xx 번대의 상태 코드들은 **요청이 수신되어 처리중** 이라는 의미를 가집니다.\n\n- 100 : Continue -> 처리가 되었으니 다음으로 진행하라\n- 101 : Switching Protocols -> 서버가 프로토콜을 전환중\n- 102 : Processing -> 서버가 요청을 수신하였으며 이를 처리중\n- 103 : Early Hints -> 리소스에 대한 힌트를 제공하여 리소스를 사전 로드하게 함\n\n이러한 상태코드들이 있지만 실무에서는 거의 사용되지 않으므로 한번 보고 넘어가도록 하자.\n\n<br><br><br><br><br><br>\n\n## ✅ 2xx 상태 코드 ( Successful )\n2xx 상태코드들은 **클라이언트의 요청을 성공적으로 처리했음**을 의미합니다. 단순히 요청에 대한 성공을 의미하지만 어떠한 행위에 대한 성공인지, 응답을 받고 클라이언트가 어떤 행동을 취할것인지 등 결정하기에 따라 다른 상태코드를 가집니다.\n\n- 200 : OK\n- 201 : Created\n- 202 : Accepted\n- 204 : No Content\n- ...\n\n\n<br><br><br><br><br><br>\n## ✅ 200 OK\n**상태코드 200은 클라이언트의 요청을 서버가 정상적으로 처리했음을 의미합니다.**\n\n\n<p align=\"middle\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/2xx1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n## ✅ 201 Created\n**상태코드 201은 요청에 성공해서 새로운 리소스가 생성됐음을 의미합니다.**\n\n<br><br><br><br><br><br>\n\n## ✅ 202 Accepted\n**상태코드 202는 요청이 접수되었으나 처리가 완료되지 않았음을 의미합니다.**\n\n- Batch 처리 같은 곳에서 사용\n- 예) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리한다.\n\n<br><br><br><br><br><br>\n\n## ✅ 204 No Content\n**상태코드 204는 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음을 의미합니다.**\n\n- 예) 웹 문서 편집기에서 save 버튼\n- save 버튼의 결과로 아무 내용이 없어도 된다.\n- save 버튼을 눌러도 같은 화면을 유지해야 한다.\n- 결과 내용이 없어도 204 메시지만으로 성공을 인식할 수 있다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":991426833}},"syncHistory":{"main":[991426833,null,null]},"v":1,"hash":1710111617987,"tx":205},"bHqTE0XjV1KS586A/content":{"id":"bHqTE0XjV1KS586A/content","type":"content","text":"### transform과 변형함수\n\n`transform : 함수`\n\n### 2차원 변형함수\n| 종류 | 설명 |\n|--|--|\n| translate(tx,ty) | 지정한 크기만큼 x축, y축으로 이동 |\n| translateX(tx) | 지정한 크기만큼 x축으로 이동 |\n| translateY(ty) | 지정한 크기만큼 y축으로 이동 |\n| scale(sx,sy) | 지정한 크기만큼 x축, y축으로 확대or축소 |\n| scaleX(sx) | 지정한 크기만큼 x축으로 확대 or 축소 |\n| scaleY(sy) | 지정한 크기만큼 y축으로 확대 or 축소 |\n| rotate(각도) | 지정한 각도만큼 회전 |\n| skew(ax,ay) | 지정한 각도만큼 x축과 y축으로 왜곡 |\n| skewX(ax) | 지정한 각도만큼 x축으로 왜곡  |\n| skewY(ay) | 지정한 각도만큼 y축으로 왜곡 |\n\n### 3차원 변형함수\n| 종류 | 설명 |\n|--|--|\n| translate3d(tx,ty,tz) | 지정한 크기만큼 x축, y축, z축으로 이동 |\n| translateX(tx) | 지정한 크기만큼 x축으로 이동 |\n| translateY(ty) | 지정한 크기만큼 y축으로 이동 |\n| scale(sx,sy) | 지정한 크기만큼 x축, y축으로 확대or축소 |\n| scaleX(sx) | 지정한 크기만큼 x축으로 확대 or 축소 |\n| scaleY(sy) | 지정한 크기만큼 y축으로 확대 or 축소 |\n| rotate(각도) | 지정한 각도만큼 회전 |\n| skew(ax,ay) | 지정한 각도만큼 x축과 y축으로 왜곡 |\n| skewX(ax) | 지정한 각도만큼 x축으로 왜곡  |\n| skewY(ay) | 지정한 각도만큼 y축으로 왜곡 |\n\n\n\n## 트랜지션\n트랜지션은 웹 요소의 배경색을 바꾸거나, 도형의 테두리를 사각형에서 원형으로 바꾸는 것처럼 스타일의 속성이 바뀌는 것을 말합니다. 단순 `:hover` 태그를 통해서 스타일을 변경할 수 있지만 트랜지션은 **시간에 따라 자연스럽게 스타일을 변경**해주는 역할을 수행합니다. \n\n\n## 그리드 레이아웃\n###  플렉서블 박스 레이아웃\n### CSS 그리드 레이아웃\n","properties":"\n","discussions":{},"comments":{},"hash":1609655638,"tx":209},"bHqTE0XjV1KS586A/syncedContent":{"id":"bHqTE0XjV1KS586A/syncedContent","type":"syncedContent","historyData":{"1609655638":{"id":"bHqTE0XjV1KS586A/content","type":"content","text":"### transform과 변형함수\n\n`transform : 함수`\n\n### 2차원 변형함수\n| 종류 | 설명 |\n|--|--|\n| translate(tx,ty) | 지정한 크기만큼 x축, y축으로 이동 |\n| translateX(tx) | 지정한 크기만큼 x축으로 이동 |\n| translateY(ty) | 지정한 크기만큼 y축으로 이동 |\n| scale(sx,sy) | 지정한 크기만큼 x축, y축으로 확대or축소 |\n| scaleX(sx) | 지정한 크기만큼 x축으로 확대 or 축소 |\n| scaleY(sy) | 지정한 크기만큼 y축으로 확대 or 축소 |\n| rotate(각도) | 지정한 각도만큼 회전 |\n| skew(ax,ay) | 지정한 각도만큼 x축과 y축으로 왜곡 |\n| skewX(ax) | 지정한 각도만큼 x축으로 왜곡  |\n| skewY(ay) | 지정한 각도만큼 y축으로 왜곡 |\n\n### 3차원 변형함수\n| 종류 | 설명 |\n|--|--|\n| translate3d(tx,ty,tz) | 지정한 크기만큼 x축, y축, z축으로 이동 |\n| translateX(tx) | 지정한 크기만큼 x축으로 이동 |\n| translateY(ty) | 지정한 크기만큼 y축으로 이동 |\n| scale(sx,sy) | 지정한 크기만큼 x축, y축으로 확대or축소 |\n| scaleX(sx) | 지정한 크기만큼 x축으로 확대 or 축소 |\n| scaleY(sy) | 지정한 크기만큼 y축으로 확대 or 축소 |\n| rotate(각도) | 지정한 각도만큼 회전 |\n| skew(ax,ay) | 지정한 각도만큼 x축과 y축으로 왜곡 |\n| skewX(ax) | 지정한 각도만큼 x축으로 왜곡  |\n| skewY(ay) | 지정한 각도만큼 y축으로 왜곡 |\n\n\n\n## 트랜지션\n트랜지션은 웹 요소의 배경색을 바꾸거나, 도형의 테두리를 사각형에서 원형으로 바꾸는 것처럼 스타일의 속성이 바뀌는 것을 말합니다. 단순 `:hover` 태그를 통해서 스타일을 변경할 수 있지만 트랜지션은 **시간에 따라 자연스럽게 스타일을 변경**해주는 역할을 수행합니다. \n\n\n## 그리드 레이아웃\n###  플렉서블 박스 레이아웃\n### CSS 그리드 레이아웃\n","properties":"\n","discussions":{},"comments":{},"hash":1609655638}},"syncHistory":{"main":[1609655638,null,null]},"v":1,"hash":1710111620335,"tx":209},"6L2BLz0U8N7KSVN2/content":{"id":"6L2BLz0U8N7KSVN2/content","type":"content","text":"---\npermalink: /2023-05-18-JS 내장 객체, 브라우저 객체, JS 삽입위치/\ntitle: \"[JavaScript] 문서객체모델 (Document Object Model)\"\ndate: 2023-05-18 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 내장 객체, 브라우저 객체, JS 삽입위치\"\ncategories:\n- JavaScript\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n## ✅ 문서객체모델 ( Document Object Model )\n\n우리가 자바스크립트를 사용하는 이유중 하나는 어떤 조건에 맞거나 사용자의 동작이 있을 때 웹 문서 전체 또는 일부분이 **동적으로 반응**하게 하기 위함 이다. 이를 위해서는 웹 문서의 모든 요소를 따로 제어할 수 있어야 한다.\n\n예를 들어, 웹 문서에 텍스트와 이미지가 들어있다면 웹 브라우저는 마크업 정보를 보며 텍스트 단락이 몇개고 내용은 무엇인지 살펴본다. 또한 이미지가 몇개이고 이미지 파일 경로는 어떠한지 이미지 별로 정리해서 인식한다. 그리고 이러한 텍스트와 이미지를 브라우저가 제어하려면 두 요소를 따로 구별해서 인식해야 한다.\n\n이런 모든 정보를 자바스크립트로 가져와 프로그래밍할 때 사용하는데 이때 필요한 개념이 바로 **문서 객체 모델 ( Document Object Model )** 줄여서 **DOM**\n\n\n문서 객체 모델은 DOM, 그리고 XML도 생성가능\n\n\n\n\nElement, Attribute, Value 가 뭔지 정확히 알필요 있음.\n\n\n## DOM의 event 객체\n\n`preventDefault` 중요!!\n각 태그마다 Default핸들러가 있는데 이걸 기능을 못하도록 만드는 것\n","properties":"\n","discussions":{},"comments":{},"hash":782466471,"tx":223},"QfcCQHZlB9I2iOQ0/syncedContent":{"id":"QfcCQHZlB9I2iOQ0/syncedContent","type":"syncedContent","historyData":{"-1675570753":{"id":"QfcCQHZlB9I2iOQ0/content","type":"content","text":"---\npermalink: /2023-05-19-AWS 글로벌 인프라 ( 리전, 가용영역, 엣지로케이션 )/\ntitle: \"[AWS] AWS 글로벌 인프라 ( 리전, 가용영역, 엣지로케이션 )\"\ndate: 2023-05-19 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"AWS 글로벌 인프라 ( 리전, 가용영역, 엣지로케이션 )\"\ncategories:\n- AWS\ntags:\n- 카카오 클라우드 스쿨\n- AWS\n---\n<br><br>\n\n## ✅ AWS 글로벌 인프라\n\nAWS에 대해 알아보기 앞서 사용하는 다양한 용어에 대한 정리를 간략하게 해보자\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws1.png?raw=true\">\n</p>\n\n<br><br>\n\n\n### 📌리전\n\nAWS가 전 세계에서 데이터 센터를 클러스터링 하는 물리적 위치를 리전이라고 한다. AWS 리전은 지리적 영역 내에서 격리되고 물리적으로 분리된 최소 3개의 AZ(가용영역)로 구성된다. 현재는 31개 리전이 존재한다. 아프리카, 아시아 태평양, 유럽, 중동, 미국 등 다양한 리전이 존재한다.\n\n사용자가 적절한 리전을 선택 해야할 때 고려해야할 사항은 4가지 정도가 있다. \n\n1. **가격** : 리전에 따라 가격이 다르다.\n2. **지연시간** : 사용자의 지리적 위치와 리전의 위치에 따라 지연시간이 다르다. \n3. **서비스 유무**\n4. **법 규제** : 가장 중요한 고려사항이다. 예를 들어 중국 국민들의 개인정보가 담긴 데이터를 AWS에 저장하고자 한다. 그런데 중국에는 자국민의 개인정보는 반드시 자국내의 데이터센터에 존재해야 한다는 법 규제가 있다고 가정하자. 그렇다면 AWS 리전은 중국에 위치한 리전을 사용해야만 하는 상황이 발생한다.\n\n\n\n<br><br><br>\n\n### 📌가용영역 ( Available Zone )\n AWS의 서비스는 매우 높은 가용성 목표에 따라 구축된다. 따라서 장애가 발생할 경우에도 복원력을 유지하도록 시스템이 설계되어있다. 이를 위해 설계된 기능이 가용영역이다. 가용 영역은 **논리적으로 격리된 AWS 리전의 섹션이다.** 각 리전에는 독립적으로 운영되도록 설계된 여러 개의 가용영역이 있고 이를 통해 일부 애플리케이션이 장애가 발생하더라도 중단 없이 신속하게 장애를 조치할 수 있다. 총 99개가 존재한다. \n\n<br><br><br>\n### 📌엣지 로케이션 ( Edge Location )\n엣지 로케이션이란 한마디로 **캐싱 서비스를 위한 시설물** 이다. Amazon의 CDN 서비스인 CloudFront를 위한 캐시 서버들의 모음이고, 콘텐츠(HTML, 이미지, 동영상, 기타 파일)를 사용자들이 빠르게 받을 수 있도록 전세계 곳곳에 위치한 캐시 서버에 복제해주는 서비스이다. 450여개가 존재한다.\n\nex ) CloudFront, Route53, Global Accelator 등\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-1675570753}},"syncHistory":{"main":[-1675570753,null,null]},"v":1,"hash":1710111630146,"tx":225},"WJFVWbFTBiUUqpiQ/syncedContent":{"id":"WJFVWbFTBiUUqpiQ/syncedContent","type":"syncedContent","historyData":{"-508047216":{"id":"WJFVWbFTBiUUqpiQ/content","type":"content","text":"---\npermalink: /2023-05-19-AWS 루트 사용자 Access Key 삭제, MFA 활성화/\ntitle: \"[AWS] AWS 루트 사용자 Access Key 삭제, MFA 활성화\"\ndate: 2023-05-19 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"AWS 루트 사용자 Access Key 삭제, MFA 활성화\"\ncategories:\n- AWS\ntags:\n- 카카오 클라우드 스쿨\n- AWS\n---\n<br><br>\n\n## ✅ AWS 계정 루트 사용자\n\nAWS 계정을 처음 생성한다면 계정의 모든 AWS 서비스 및 리소스에 대한 전체 엑세스 권한을 지닌 **루트 사용자**를 가지게 된다. 루트 사용자는 모든 권한을 지니고 있기 때문에 보안에 굉장히 취약하고 해킹을 당했을 때 큰 피해를 입을 수 있다.\n\n때문에 AWS에서는 루트 사용자를 거의 사용하지 않을 것을 강력히 권장하고 있다. 이를 위해 AWS 엑세스 키( Access Key)를 비활성화 후 삭제하거나, MFA를 활성화 하는 등 다양한 방법을 통해 위험 요소를 미리 제거할 수 있게끔 도와준다.\n\n\n<br><br><Br><br>\n\n## ✅ AWS 루트 사용자 Access Key 비활성화 후 삭제\n\n1. Root user로 로그인 후 IAM 서비스 화면으로 이동한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws2.png?raw=true\">\n</p>\n\n<br><br><Br>\n\n2. 루트 사용자의 Access Key를 선택한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws3.png?raw=true\">\n</p>\n\n<br><Br><Br>\n\n3. 비활성화 버튼을 클릭한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws4.png?raw=true\">\n</p>\n\n<br><br><br>\n\n4. 비활성화 버튼을 한번 더 클릭한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws5.png?raw=true\">\n</p>\n\n<br><br><br>\n\n5. 삭제를 위해 키를 입력하고 삭제버튼을 클릭한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws6.png?raw=true\">\n</p>\n\n<br><br><br>\n\n6. 루트 사용자의 Access Key 삭제가 완료되면 다음과 같이 나온다. ( MFA 활성화도 이루어지고 난 후의 이미지)\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws7.png?raw=true\">\n</p>\n\n\n<br><br><br><br>\n\n## ✅ AWS 루트 사용자 MFA 활성화\n\nMFA(다중 인증)를 사용하여 AWS 환경의 보안을 강화할 수 있다. 여러 유형의 MFA가 있기 때문에 루트 사용자에 대해 여러 MFA 디바이스를 활성화 하는것이 좋다. \n\n<br><br>\n\n1. 루트 유저에 로그인 후 IAM > Security credentials 로 이동한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mfa1.png?raw=true\">\n</p>\n\n<br><Br><Br>\n\n2. MFA 활성화를 할 디바이스를 선택한다. 여기서는 Authenticator app을 선택하도록 하겠다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mfa2.png?raw=true\">\n</p>\n\n<br><br><Br>\n\n3. 사용중인 스마트폰 기기의 OS 유형에 따라 Google Play Store 또는 Apple App Store에서 Google OTP 어플을 다운받아 설치한다.\n\n<br><br><br>\n\n4. 2번 Show QR code를 클릭하면 QR코드가 생성되는데 이를 Google OTP 앱으로 스캔하여 MFA 할당을 설정한다. Google OTP 앱에 표시되는 MFA 코드 2개 ( OTP하나 입력후, 기다리면 새로운 OTP 번호가 발급된다)를 각각 입력후 하단 MFA 할당을 클릭하면 설정이 완료된다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mfa3.png?raw=true\">\n</p>\n\n\n<br><br><br>\n\nAWS 루트 사용자 Access Key 삭제와 MFA 활성화는 \"이 사람이 AWS를 그래도 어느정도 써봤고 관심이 있는 사람이구나\" 정도를 판단할 수 있는 척도 중 하나가 될 수 있기 때문에 반드시 적용시켜주는것이 좋다.\n","properties":"\n","discussions":{},"comments":{},"hash":-508047216}},"syncHistory":{"main":[-508047216,null,null]},"v":1,"hash":1710111631336,"tx":227},"fazmhohPrMfu2qvK/syncedContent":{"id":"fazmhohPrMfu2qvK/syncedContent","type":"syncedContent","historyData":{"-436172038":{"id":"fazmhohPrMfu2qvK/content","type":"content","text":"---\npermalink: /2023-05-19-AWS 컴퓨팅 서비스 EC2/\ntitle: \"[AWS] AWS 컴퓨팅 서비스 EC2\"\ndate: 2023-05-19 14:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"AWS 컴퓨팅 서비스 EC2\"\ncategories:\n- AWS\ntags:\n- 카카오 클라우드 스쿨\n- AWS\n- EC2\n---\n<br><br>\n\n\n## ✅ AWS EC2(Elastic Compute Cloud)란?\n\nEC2는 AWS에서 제공하는 **클라우드 컴퓨팅 서비스** 이다. EC2를 통해서 아마존이 전 세계에 구축한 데이터 센터의 서버용 컴퓨터들의 자원을 원격으로 사용할 수 있다. 쉽게 말해 아마존으로부터 한대의 컴퓨터를 빌리는 것이다.\n\n물론, 가정용 컴퓨터와 EC2는 중요한 차이가 존재한다. EC2는 생성 요청시 바로 생성되고 삭제 역시 즉시 제거된다. 또한 초기 구입비, 세팅비가 전혀 없고 사용한 만큼 비용을 지불하면 된다. \n\n또한 복잡한 공유기 세팅없이 인터넷을 통해서 자유롭게 접속 할 수 있고, AMI 기능을 사용해서 OS 및 기타 SW 세팅을 편리하게 할 수 있다.\n\n그리고 원하는 만큼의 가상 서버를 구축하고 보안 및 네트워킹을 구성하며 스토리지를 관리할 수 있으며 추가 요구사항이나 갑작스러운 트래픽 증가 등 변동 사항에 따라 신속하게 규모를 확장하거나 축소 할 수 있어 서버 트래픽 예측 필요성이 줄어든다는 장점이 있다.\n\n실제 컴퓨터는 OS세팅, SW설치, 하드웨어 설치, 초기비용 등 여러가지 준비해야 할 것들이 많지만 EC2는 이런 모든 세팅을 편리하게 도와주기 때문에 굉장히 편리하다.\n\n\n<br><br><br>\n\n### 📌EC2 특징 요약\nEC2의 특징을 요약 정리하자면 다음과 같다.\n\n- 컴퓨팅 요구사항의 변화에 따라 컴퓨팅 파워를 조정할 수 있다.\n\n- 실제로 사용한 용량 만큼만 지불한다 ( HW비용x, 선입금x )\n\n- AMI를 통해 Linux, Windows 중 OS 선택이 쉽게 가능하다.\n\n- 빠르게 많은 PC를 생성 할 수 있다.\n\n- 여러 다른 AWS 서비스와의 유기적인 연동이 가능하다. \n\n\n<br><br><br><br>\n\n## ✅ EC2의 구성요소\n\n### 📌인스턴스\n\nAWS 클라우드에서 사용하는 **가상 컴퓨터** 라고 이해하면 된다.\n\n가상 컴퓨터의 CPU, 메모리, 그래픽 카드 등 연산을 위한 하드웨어 부분을 담당한다.\n\n내가 어떤 용도로 EC2를 사용하고자 하는지에 따라 적합한 인스턴스를 선택하면 된다. 이를 인스턴스 유형(타입) 이라고 한다.\n\n\n<br><br><Br>\n\n### 📌인스턴스 유형\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec25.png?raw=true\">\n</p>\n\n\n한정된 요금으로 EC2 인스턴스의 유형을 고르고 사이즈를 골라 인스턴스 별 사용 목적에 따라 최적화를 시키기 위해 적절한 인스턴스 유형을 선택하면 된다.\n\n예를들어 CPU에 힘을 실어 연산능력이 좋은 서버를 만든다던지, 메모리 위주에 힘을 실어 저장소로서 기능을 구성한다던지, 그래픽 카드에 힘을 실어 게임을 돌린다던지 등 다양하게 구성이 가능하다.\n\n<Br>\n\n**인스턴스 읽는법**\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec22.png?raw=true\">\n</p>\n\n<br>\n\n인스턴스 타입이 어떤게 있고 사이즈는 뭐가 있고를 전부다 외울 필요는 없다. 다만 위 사진 처럼 인스턴스가 주어졌을 때 무슨무슨 의미인지만 알면 된다.\n\n- 인스턴스 타입 : 사용 목적 ( 서버용, 머신러닝용, 게임용 )에 따라 이름을 구분지어 사용한다.\n\n- 세대 : 1세대, 2세대 ... 숫자가 높을 수록 최신 버전이라고 보면 된다.\n\n- 접두사 : a는 amd기반의 CPU 프로세서를 사용한다는 의미이다.\n\n- 사이즈 : nano, micro, small, medium, large, xlarge, 2xlarge 로 구성되고 사이즈가 클수록 더 많은 메모리, 더 많은 CPU, 더 많은 네트워크 대역폭을 가질 수 있다. <p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec23.png?raw=true\"> </p>\n\n\n<Br><br><br>\n\n### 📌AMI ( Amazon Machine Image )\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec26.png?raw=true\">\n</p>\n\n인스턴스를 시작하는데 필요한 소프트웨어 구성 ( OS, 애플리케이션 서버 및 애플리케이션 ) 이 포함된 템플릿이다.\n\nEC2를 실행하기 위해서는 CPU 프로세서 타입이라던지 저장공간 용량은 몇인지, 32비트인지 64비트인지, OS는 윈도우인지 리눅스인지, 소프트웨어는 어떤게 설치되었는지 등의 정보가 필요한데 이러한 세팅정보를 템플릿단위로 저장한 것을 AMI라고 한다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec24.png?raw=true\">\n</p>\n\n<br><Br><br>\n\n### 📌기타 구성요소\n\n- **키 페어(선택)** : 인스턴스 로그인 정보를 보호한다. (AWS는 공개키를 저장하고, 사용자는 개인키를 안전한 장소에 보관하는 방식)\n\n- **Elastic Block Store(EBS)** : HDD, SSD 같은 하드디스크 용량이라고 보면 된다.\n\n- **리전 및 가용영역**\n\n- **태그** : key-value로 태그를 달아준다. 일반적으로 기업에서 보통 수백개의 ec2를 사용하는데, 부서별, 사용자별로 사용 EC2가 굉장히 많다. 이런 EC2들을 효과적으로 관리하기 위해 태그를 반드시 달아줘야 한다. 이를 통해 같은 태그가 달린 EC2들을 일괄적으로 관리하는데 예를들면 test태그가 붙은 ec2는 전부 사용종료해라 혹은 temp태그가 붙은 ec2는 전부 실행해라 이런식으로 관리에 용이하다.\n\n- **사용자 데이터 (User Data)** : EC2 인스턴스가 start 되자 마자 실행할 스크립트 \n\n- **배치그룹** : 인스턴스를 시작할 클러스터 그룹이다. 일부 인스턴스 유형에서만 지원되며, 호환되지 않는 인스턴스 유형을 지정하면 인스턴스를 시작하는 데 실패합니다.\n\n- **네트워크 설정** : VPC, subnet, 보안그룹 등\n\n\n<br><br><Br>\n\n### 📌EC2 인스턴스 스토어\n<Br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec28.png?raw=true\">\n</p>\n\n<br>\n인스턴스 스토어는 인스턴스에 블록 수준의 임시 스토리지를 제공한다. 스토리지가 물리적으로 연결된 디스크라면 인스턴스 스토어는 버퍼, 캐시 등 자주 변경되는 정보의 임시 저장소라고 보면 된다. \n\n인스턴스 실행시 인스턴스 스토어 볼륨을 지정할 수 있고 하나의 인스턴스에서 인스턴스 스토어를 분리해서 다른 인스턴스에 연결하는것은 불가능하다.\n\n인스턴스가 재부팅(의도적이든 의도적이지 않든)되어도 인스턴스 스토어의 데이터는 유지되지만 일부 상황에서는 데이터가 손실 된다.\n- 인스턴스 중지\n- 인스턴스 종료\n- 인스턴스 최대 절전 모드 전환\n- 기본 디스크 드라이브 오류\n\n때문에 중요한 장기 데이터는 인스턴스 스토어에 저장하지 않는것이 좋다.\n\n<br><Br><br>\n\n### 📌EC2 인스턴스 생명주기\n\nAmazon EC2 인스턴스는 시작한 순간부터 종료될 때까지 다양한 상태로 전환된다.\n아래 그림은 인스턴스 상태 간 전환을 나타낸다. \n \n <p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec21.png?raw=true\">\n</p>\n\n\n| 인스턴스 상태 | 설명 |\t인스턴스 사용 요금|\n|--|--|--|\n| pending | 인스턴스는 running 상태로 될 준비를 하고있습니다. 인스턴스는 시작되거나 stopped 상태 이후에 시작되면 pending 상태로 들어갑니다. | 미청구 |\n| running | 인스턴스를 실행하고 사용할 준비가 되었습니다. | 청구 |\n| stopping | 인스턴스를 중지할 준비를 하고 있습니다. | 미청구 |\n| stopped | 인스턴스가 종료되고 사용이 불가합니다. 언제든지 인스턴스를 다시 시작할 수 있습니다. | 미청구 |\n| shutting-down | 인스턴스가 종료할 준비를 하고 있습니다. | 미청구|\n| terminated | 인스턴스가 영구적으로 삭제되었으며 시작할 수 없습니다.| 미청구 |\n\n\n<br><br><br><br>\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-436172038}},"syncHistory":{"main":[-436172038,null,null]},"v":1,"hash":1710111632557,"tx":229},"ZrlBGkPkFqYFyKak/content":{"id":"ZrlBGkPkFqYFyKak/content","type":"content","text":"AWS 웹 관리 콘솔 -> ID/PW로 인증\nAWS CLI나머지는 -> 키로 인증\n\n\n## EC2 인스턴스 -> S3로 요청을 보낼때\n노트에 대충 적어놧음\n\n\n\n## EC2 인스턴스 Role 수임하는 과정 매우 중요\n\n\n\n## 정적 웹페이지 작성 및 S3배포 프로젝트\n\n\n## ✅ EC2의 구조도\n <p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec27.png?raw=true\">\n</p>\n\n<br>\n\n위의 그림은 AWS에서 EC2가 어떻게 작동하고 구성되는지를 보여주는 그림이다. 내가 이해한 대로 그림의 흐름을 따라가면서 EC2의 구조를 살펴보겠다.\n\n1. AWS에 접근하는 방법은 크게 3가지가 있다. 이를 이용해 AWS에 접근한다.\n\n\tAWS 웹 관리 콘솔 : 웹페이지에서 로그인 하여 사용하는 일반적인 방법\n\t프로그래밍적 접근 : `java`, `.NET`, `python` 등의 언어를 사용하여 커맨드로 접근\n\tAWS CLI : AWS 서비스를 관리하는 통합 도구\n\n2. \n","properties":"\n","discussions":{},"comments":{},"hash":2113864203,"tx":231},"aJrzklaPe7FlmPv5/content":{"id":"aJrzklaPe7FlmPv5/content","type":"content","text":"\n\n### 클라우드 컴퓨팅\nIT리소스를 인터넷, 온디멘드, 종량요금제 + Iaac(Infra as a code) -> DevOps ( 개발이 끝나자마자 바로 배포환경으로 넘기는것 )\n### DevOps\n데브옵스는 app설치 + 설정 + Infra를 전부 배포해줘야 가능한데, 이를 수동으로 하는건 정말 어렵다. 때문에 설정+Infra를 코드로 제작하여 자동화함으로써 배포를 편리하게 하는것을 DevOps라고 한다.\n\n\n-   [**클라우드 컴퓨팅 이란?**](https://aws.amazon.com/what-is-cloud-computing/)\n    -   클라우드 컴퓨팅은 **IT 리소스**를 인터넷을 통해 **온디맨드**로 제공하고 사용한 만큼만 비용을 지불하는 것을 말합니다.\n\n\npublic cloud : AWS, GCP, AZURE ...\nprivate cloud : 내부에서 자체적으로만 사용하는 클라우드\n\n\n## AWS 대칭키와 비대칭키\n\n|  | 암호화 | | 복호화  |\n|--|--|--|--|\n| 대칭키 | 비밀키 | =| 비밀키  |\n| 비대칭키 | 공개키 |!= |  비밀키 |\n| 비대칭키 | 비밀키(SAK) |!= | 공개키  |\n\n\n암호화를 비밀키로, 복호화를 공개키로 사용하는게 인증을 위한 비대칭키 이다.\n\n암호화를 공개키로 복호화를 비밀키고 사용하는 경우는 기밀성을 \n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1436715068,"tx":233},"aJrzklaPe7FlmPv5/syncedContent":{"id":"aJrzklaPe7FlmPv5/syncedContent","type":"syncedContent","historyData":{"1436715068":{"id":"aJrzklaPe7FlmPv5/content","type":"content","text":"\n\n### 클라우드 컴퓨팅\nIT리소스를 인터넷, 온디멘드, 종량요금제 + Iaac(Infra as a code) -> DevOps ( 개발이 끝나자마자 바로 배포환경으로 넘기는것 )\n### DevOps\n데브옵스는 app설치 + 설정 + Infra를 전부 배포해줘야 가능한데, 이를 수동으로 하는건 정말 어렵다. 때문에 설정+Infra를 코드로 제작하여 자동화함으로써 배포를 편리하게 하는것을 DevOps라고 한다.\n\n\n-   [**클라우드 컴퓨팅 이란?**](https://aws.amazon.com/what-is-cloud-computing/)\n    -   클라우드 컴퓨팅은 **IT 리소스**를 인터넷을 통해 **온디맨드**로 제공하고 사용한 만큼만 비용을 지불하는 것을 말합니다.\n\n\npublic cloud : AWS, GCP, AZURE ...\nprivate cloud : 내부에서 자체적으로만 사용하는 클라우드\n\n\n## AWS 대칭키와 비대칭키\n\n|  | 암호화 | | 복호화  |\n|--|--|--|--|\n| 대칭키 | 비밀키 | =| 비밀키  |\n| 비대칭키 | 공개키 |!= |  비밀키 |\n| 비대칭키 | 비밀키(SAK) |!= | 공개키  |\n\n\n암호화를 비밀키로, 복호화를 공개키로 사용하는게 인증을 위한 비대칭키 이다.\n\n암호화를 공개키로 복호화를 비밀키고 사용하는 경우는 기밀성을 \n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1436715068}},"syncHistory":{"main":[1436715068,null,null]},"v":1,"hash":1710111634898,"tx":233},"J3qxgGs4hhBbD0IK/content":{"id":"J3qxgGs4hhBbD0IK/content","type":"content","text":"## AWS 인증과 권한 권리 서비스 (IAM)\n\n### IAM 이란 ?\n\nRESTAPI를 통해서 AWS에 접근하면 IAM을 통해 인증을 진행.\n이떄 id/pw(AWS콘솔을 통해 제공)나 키(AKid/SAK)(CLI나 SDK를 통해접근할때 제공)를 제시함.\n\naccount를 생성한다 (가입)\n-> IAM Root User가 생기는데 얘는 권장하지 않아\n-> IAM User(account 내 user)를 만들어! ( id/pw or key )\n-> IAM User는 처음에는 권한이 하나도 없어\n-> policy/정책 이라는 문서에 권한을 명시해서 IAM user에게 부여\n-> policy는 JSON방식으로 작성되어 있어\n-> IAM Group을 만들어서 권한을 각각 부여\n-> IAM Role\n\n\n### IAM Role\n어떤 부분에 대해 policy가 필요한 사람이 계속 생길거야\n그럼그떄마다 policy주고 필요없을떄 지우면 너무 힘들어\n그래서 IAM Role이란게 있어\nIAM Role을 모자라고 생각하면 그 모자에는 여러 policy가 들어있어\n근데 그 모자를 쓸 수 있는 권한을 누군가에게 주는거야\nIAM User는 본인의 키도 있고 모자를 쓰면 임시키도 발급을 받는거야\n그럼 AWS에 임시키를 제공하고 인증을 받아, 즉 권한을 받아.\n그럼 IAM User는 본인이 필요한 policy를 가지고 기존에 자기가 갖고 있던 policy는 사용하지못해 -> 최소권한을 유지하는 정책이야\n\n일반적으로 IAM User가 가지는 key는 파일ㄹ로 저장가능한 영구키야\n그러나 IAM Role을 통해 가지는 임시key는 메모리에 떠있다가 사라지는 임시키야.\n\n얘네는 아래 기능을 사용할 때 발급받고 사용함\n1. IAM USer\n2. 연동 유저 (SSO, ferdera...)\n3. AWS 서비스\n\n### IAM Policy\n\n","properties":"\n","discussions":{},"comments":{},"hash":-525366682,"tx":235},"J3qxgGs4hhBbD0IK/syncedContent":{"id":"J3qxgGs4hhBbD0IK/syncedContent","type":"syncedContent","historyData":{"-525366682":{"id":"J3qxgGs4hhBbD0IK/content","type":"content","text":"## AWS 인증과 권한 권리 서비스 (IAM)\n\n### IAM 이란 ?\n\nRESTAPI를 통해서 AWS에 접근하면 IAM을 통해 인증을 진행.\n이떄 id/pw(AWS콘솔을 통해 제공)나 키(AKid/SAK)(CLI나 SDK를 통해접근할때 제공)를 제시함.\n\naccount를 생성한다 (가입)\n-> IAM Root User가 생기는데 얘는 권장하지 않아\n-> IAM User(account 내 user)를 만들어! ( id/pw or key )\n-> IAM User는 처음에는 권한이 하나도 없어\n-> policy/정책 이라는 문서에 권한을 명시해서 IAM user에게 부여\n-> policy는 JSON방식으로 작성되어 있어\n-> IAM Group을 만들어서 권한을 각각 부여\n-> IAM Role\n\n\n### IAM Role\n어떤 부분에 대해 policy가 필요한 사람이 계속 생길거야\n그럼그떄마다 policy주고 필요없을떄 지우면 너무 힘들어\n그래서 IAM Role이란게 있어\nIAM Role을 모자라고 생각하면 그 모자에는 여러 policy가 들어있어\n근데 그 모자를 쓸 수 있는 권한을 누군가에게 주는거야\nIAM User는 본인의 키도 있고 모자를 쓰면 임시키도 발급을 받는거야\n그럼 AWS에 임시키를 제공하고 인증을 받아, 즉 권한을 받아.\n그럼 IAM User는 본인이 필요한 policy를 가지고 기존에 자기가 갖고 있던 policy는 사용하지못해 -> 최소권한을 유지하는 정책이야\n\n일반적으로 IAM User가 가지는 key는 파일ㄹ로 저장가능한 영구키야\n그러나 IAM Role을 통해 가지는 임시key는 메모리에 떠있다가 사라지는 임시키야.\n\n얘네는 아래 기능을 사용할 때 발급받고 사용함\n1. IAM USer\n2. 연동 유저 (SSO, ferdera...)\n3. AWS 서비스\n\n### IAM Policy\n\n","properties":"\n","discussions":{},"comments":{},"hash":-525366682}},"syncHistory":{"main":[-525366682,null,null]},"v":1,"hash":1710111635898,"tx":235},"6d0K7UYUnaJHcUwH/syncedContent":{"id":"6d0K7UYUnaJHcUwH/syncedContent","type":"syncedContent","historyData":{"-1564742317":{"id":"6d0K7UYUnaJHcUwH/content","type":"content","text":"---\npermalink: /2023-05-22-AWS 스토리지 서비스 - S3 ( Simple Storage Service )/\ntitle: \"[AWS] AWS 스토리지 서비스 - S3 ( Simple Storage Service )\"\ndate: 2023-05-12 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"AWS 스토리지 서비스 - S3 ( Simple Storage Service )\"\ncategories:\n- AWS\ntags:\n- 카카오 클라우드 스쿨\n- AWS\n- S3\n---\n<br><br>\n\n\n\n## ✅ AWS 스토리지 종류\n\n### 📌 스토리지 종류\n\nAWS에서 제공하는 스토리지 서비스는 5가지이다. \n\n- Amazon EBS ( Elastic Block Storage )\n- Amazon EFS ( Elastic File System )\n- Amazon S3 ( Simple Storage Service )\n- Amazon S3 Galcier\n- AWS Storage Gateway\n\n오늘은 이런 스토리지 서비스중 가장 많이 쓰이는 S3에 대해 알아보도록 하겠다.\n\n그전에 전통적 스토리지에 대한 종류와 특징을 간단하게 알아보고 넘어가자.\n\n<br><Br><Br>\n\n### 📌 전통적 스토리지\n\n1. **블록 스토리지 ( Block Storage )**\n\n\t데이터를 블록 단위로 관리하는 스토리지이다. **데이터베이스처럼 빈번히 갱신되거나, 고속의 액세스가 필요할 때 사용된다.** 일부 파일 내용 변경시에 해당 block만 갱신이 가능하다. 쉽게 예를 들면 엑셀에서 블록 하나 수정하는것과 유사하다. 계층 구조를 가지고, 계층구조는 `/doc/storage/a.txt` 이런식으로 구조를 갖는것을 말한다. AWS 스토리지 서비스 중에서는 **EBS(Elastic Block Storage), 인스턴스 스토어**가 해당한다.\n\n<br>\n\n \n2. **파일 스토리지 ( File Storage )**\n\n\t블록 스토리지 위에 파일 시스템을 구성해서 파일 단위로 관리하는 스토리지이다. **복수의 클라이언트로 부터 네트워크를 경유하여 파일에 접근 하거나, 데이터를 일괄 저장하는 용도로 많이 쓰인다.** 파일 단위로 관리하기 때문에 일부 파일 내용 변경시 전체 파일이 갱신된다. 예를 들면 구글드라이브에 올라가져 있는 파일을 일부 수정하면 파일 자체를 다시 업로드 해야하는 것과 유사하다. 블록 스토리지와 마찬가지로 계층구조를 가진다. AWS 스토리지 서비스 중에서는 **EFS ( Elastic File Storage ), FSx**가 해당한다.\n\n<br>\n\n\n3. **오브젝트 스토리지 ( Object Storage )**\n\n\t**파일에 임의의 메타데이터를 추가하여 오브젝트 단위로 관리하는 스토리지이다.** **HTTP 프로토콜**을 사용하여 데이터를 추가, 삭제할 수 있다. **갱신 빈도가 적은 데이터나 대용량 멀티미디어 컨텐츠를 보관하는 용도**로 사용된다. 앞선 두 스토리지와는 다르게 계층 구조가 없는 **flat한 구조**를 가진다. `doc/storage/a.txt`, `doc/storage/b.txt`처럼 폴더를 만들어 보관할 수는 있지만, 실제 데이터는 `a.txt`와 `b.txt`가 같이 존재하지 않고 폴더정보는 그저 파일의 접두어일 뿐, 단일 저장소에 보관된다. 기존의 계층구조는 메타데이터가 굉장히 많이 쌓여 효율적이지 못하므로 이를 최소화 하기위해 이런 구조를 가진다. AWS 스토리지 서비스 중에서는 **S3**가 해당한다.\n\n<br><br><Br><Br>\n\n## ✅ Amazon S3 ( Simple Storage Service )\n\n**매우 우수한 내구성을 가진 용량 무제한의 오브젝트 스토리지 서비스**이다. 오브젝트 스토리지 이기때문에 디렉토리 구조를 가지지 않는 **플랫한 구성**과, 유저가 독자적으로 **메타 데이터를 부여**할 수 있다.\n\nS3의 각 오브젝트에는 **REST나 SOAP같은 HTTP API를 통한 액세스가 가능**하다 ( 최신 Amazon S3 기능은 SOAP를 더이상 지원하지 않는다 ). 유연성이 매우 강한 서비스이기 때문에 아이디어만 있다면 수만가지의 방법으로 사용할 수 있고, AWS 중에서도 매우 중요한 서비스로서의 위치를 가지고 있다. S3가 포함되지 않은 AWS 서비스를 찾아보기가 힘들정도로 많이 사용된다.\n\n- 데이터 백업\n- 정적 웹 컨텐츠와 미디어 저장 및 배포\n- 전체 정적 웹 사이트 호스팅 ( HTML, Image, 동영상 등 )\n- 간략한 Key-Value 형식의 데이터 베이스\n- Auto Scaling 구성의 EC2 인스턴스나 컨테이너로 부터의 로그 전송\n- 연산 및 대규모 분석용 데이터 스토어\n\n\n<br><Br><br>\n\n### 📌 Amazon S3의 구성요소\n\n- **버킷** : 오브젝트를 저장하기 위한 영역이다. 버킷이름은 고유해야 한다. S3 버킷에 policy(정책)을 추가하여 다른 AWS 계정 또는 사용자에게 액세스하도록 허용할 수 있다.\n\n- **오브젝트** : 버킷내에 저장될 데이터를 말한다. 각 오브젝트는 키가 부여되고, [버킷명 + 키명 + 버전 ID ]로 유니크한 URL이 만들어 진다. 버킷내에 저장되는 오브젝트 수는 제한이 없지만, 하나의 오브젝트 사이즈는 최대 5TB이다.\n\n- **메타 데이터** : S3는 오브젝트 스토리지이므로 메타 데이터를 가진다. 오브젝트를 관리하기 위한 정보이고, 오브젝트 작성 일시나 사이즈 등의 메타 데이터 뿐만 아니라 유저가 정의한 메타 데이터를 가질 수도 있다.\n\n\n<br><Br><br>\n\n### 📌 Amazon S3의 스토리지 클래스\n\n데이터의 복원력, 액세스, 및 비용에 따라 선택할 수 있는 다양한 스토리지 클래스가 있다. 종류에 대해 간단하게 알아보자.\n\n- **Amazon S3 Standard**\n\t가장 범용적인 클래스. 즉시 액세스 할 수 있어야 하고, 자주 요청되는 데이터를 다룬다.\n\n- **Amazon S3 Standard - Infrequent Access**\n\t표준 데이터와 마찬가지로 즉시 액세스 할 수 있어야 하지만 자주 요청되지 않을 것으로 예상되는 데이터를 저장한다. 저장된 GB당 비용은 저렴하지만, HTTP API 요청당 비용이 높다.\n\n- **Amazon S3 One Zone - Infrequent Access**\n\t최소 3개의 AZ(가용영역)에 데이터를 저장하는 다른 스토리지 클래스와는 달리 단일 AZ에 데이터를 저장한다. 때문에 S3 Standard -IA 보다 20%정도 저렴하다.\n\n- **Amazon S3 Glacier**\n\t거의 참조되지 않는 아카이브 목적의 데이터를 저장하는 스토리지 클래스이다. 오브젝트 신규 작성시에는 이 클래스를 사용할 수 없고, 이후에  라이프 사이클 관리 기능을 사용하여 S3 Glacier를 사용하는것이 가능하다. 이 클래스에 저장된 데이터에 엑세스 하는 경우 사전에 액세스 Request를 해둘 필요가 있고, 액세스를 가능하도록 하는데 수시간이 걸린다. 데이터를 불러오는데에는 몇분~수시간이 걸린다.\n\n- **Amazon S3 - Intelligent - Tiering**\n\t성능에 대한 영향, 검색 요금 또는 운영 부담 없이 액세스 빈도에 따라 가장 비용 효율적인 액세스 티어로 데이터를 자동으로 이동하여 세분화된 객체 수준에서 스토리지 비용을 자동으로 절감해주는 최초의 클라우드 스토리지이다. S3 Intelligent-Tiering은 Frequent, Infrequent Access 및 Archive Instant Access 티어에서 자주 액세스하는 데이터, 자주 액세스하지 않는 데이터, 그리고 거의 액세스하지 않는 데이터에 대해 밀리초 단위의 대기 시간과 높은 처리량을 제공한다. 거의 모든 워크로드, 특히 데이터 레이크, 데이터 분석, 새로운 애플리케이션 및 사용자 생성 콘텐츠에 대한 기본 스토리지 클래스로 S3 Intelligent-Tiering을 사용할 수 있습니다.\n\n- **Amazon S3 스토리지 클래스 분석**\n\t스토리지 액세스 패턴을 분석해 데이터를 적절한 스토리지 클래스로 옮길 시점을 알려준다. 예를 들면 자주 액세스 하지 않는 Standard 스토리지를 Standard-IA 스토리지 클래스로 옮길 시점을 알려준다. 단, Standard 스토리지와 Standard-IA 클래스에 대한 분석만 제공한다.\n\n\n\n<br><br><br>\n\n### 📌 Amazon S3의 수명 주기 관리\n\n수명 주기 동안 객체가 비용 효율적으로 저장되도록 관리하기 위해 Amazon S3의 수명 주기를 구성한다. 크게 두 가지 유형의 작업으로 나뉜다.\n\n- 전환 작업\n\n\t객체가 다른 스토리지 클래스로 전환되는 시기를 정의한다. 예를 들어 생성 후 30일이 지난 객체는 S3 Standard-IA 스토리지 클래스로 전환하거나, 생성 후 1년이 지난 객체는 S3 Glacier Flexible Retrieval 스토리지 클래스로 전환하는 경우가 있다.\n\n- 만료 작업\n\n\t객체가 만료되는 시기를 정의한다. 만료 시기 이후에는 Amazon S3에서 자동으로 객체를 삭제한다.\n\n\n공부하거나 프로젝트를 제작할 때 수명 주기 정책을 함께 사용해보면 좋을 것 같다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1564742317}},"syncHistory":{"main":[-1564742317,null,null]},"v":1,"hash":1710111637926,"tx":237},"VCnzbwtUALknf6h2/content":{"id":"VCnzbwtUALknf6h2/content","type":"content","text":"ESlint Prettier 설정 및 적용\n","properties":"\n","discussions":{},"comments":{},"hash":1276359454,"tx":239},"VCnzbwtUALknf6h2/syncedContent":{"id":"VCnzbwtUALknf6h2/syncedContent","type":"syncedContent","historyData":{"1276359454":{"id":"VCnzbwtUALknf6h2/content","type":"content","text":"ESlint Prettier 설정 및 적용\n","properties":"\n","discussions":{},"comments":{},"hash":1276359454}},"syncHistory":{"main":[1276359454,null,null]},"v":1,"hash":1710111639084,"tx":239},"vVPdin3FmpSihQxj/content":{"id":"vVPdin3FmpSihQxj/content","type":"content","text":"HTML/CSS/Javascript로 구성된 웹페이지를 만듦\n\n이 페이지를 AWS S3 서비스에 넣어 정적 웹페이지 호스팅 시도\n\nbit/ly를 이용해 도메인 생성 후 접속 `https://bit.ly/yeounsuself`\n\n잘 실행되지만 카메라 기능 고장\n\n`getUserMedia()` 오류 발생\n\n`Uncaught TypeError: Cannot read properties of undefined (reading 'getUserMedia')\n    at script.js:583:30`\n\n오류 원인 분석\n1. 브라우저 호환성 : 현재 사용하고 있는 chrome 브라우저가 `getUserMedia` 메서드를 호환하지 않는 경우 -> 지원함\n2. HTTPS 사용 : `getUserMedia` 메서드를 사용하는 경우 HTTPS 프로토콜을 사용해서 웹페이지에 액세스 해야하는데 로컬에서는 자동으로 HTTPS를 사용할 수 있지만 S3에 업로드 한경우 HTTP만 사용가능하므로 추가설정이 필요함.  -> route 53, 인증서 발급, cloudfront 설정이 필요 -> route 53 설정할때 버킷이름과 도메인이름이 완전히 같아야 됨 -> 이걸 모른채 s3에 버킷생성해서 더이상 못함 -> 버킷을 새로만들고 이름을 생성한 도메인 이름과 동일하게 설정 후 기존 버킷내용을 새로운 버킷으로 이전시켜주면 될거같음 -> 근데 이거 돈나감 -> 그냥 새로 만드는게 나음 \n","properties":"\n","discussions":{},"comments":{},"hash":-789946578,"tx":241},"vVPdin3FmpSihQxj/syncedContent":{"id":"vVPdin3FmpSihQxj/syncedContent","type":"syncedContent","historyData":{"-789946578":{"id":"vVPdin3FmpSihQxj/content","type":"content","text":"HTML/CSS/Javascript로 구성된 웹페이지를 만듦\n\n이 페이지를 AWS S3 서비스에 넣어 정적 웹페이지 호스팅 시도\n\nbit/ly를 이용해 도메인 생성 후 접속 `https://bit.ly/yeounsuself`\n\n잘 실행되지만 카메라 기능 고장\n\n`getUserMedia()` 오류 발생\n\n`Uncaught TypeError: Cannot read properties of undefined (reading 'getUserMedia')\n    at script.js:583:30`\n\n오류 원인 분석\n1. 브라우저 호환성 : 현재 사용하고 있는 chrome 브라우저가 `getUserMedia` 메서드를 호환하지 않는 경우 -> 지원함\n2. HTTPS 사용 : `getUserMedia` 메서드를 사용하는 경우 HTTPS 프로토콜을 사용해서 웹페이지에 액세스 해야하는데 로컬에서는 자동으로 HTTPS를 사용할 수 있지만 S3에 업로드 한경우 HTTP만 사용가능하므로 추가설정이 필요함.  -> route 53, 인증서 발급, cloudfront 설정이 필요 -> route 53 설정할때 버킷이름과 도메인이름이 완전히 같아야 됨 -> 이걸 모른채 s3에 버킷생성해서 더이상 못함 -> 버킷을 새로만들고 이름을 생성한 도메인 이름과 동일하게 설정 후 기존 버킷내용을 새로운 버킷으로 이전시켜주면 될거같음 -> 근데 이거 돈나감 -> 그냥 새로 만드는게 나음 \n","properties":"\n","discussions":{},"comments":{},"hash":-789946578}},"syncHistory":{"main":[-789946578,null,null]},"v":1,"hash":1710111640176,"tx":241},"Wg83VoN5zGPoNo1y/content":{"id":"Wg83VoN5zGPoNo1y/content","type":"content","text":"레이아웃 구조 파악이 우선\n레이아웃은 최대한 흐름을 유지하면서 통일성 있게 만들어주는게 좋음\n1. 화면이 모바일환경일때\n2. 화면이 커졌을때 \n\nWireFrame 만들기 -> 전반적으로 구조를 어떻게 잡을지 박스단위로 프레임을 잡아보고 만들기시작하는게 좋음 \n구조를 잡고 레이블링 ( 박스나 아이템들을 이름을 뭘로 설정할지 생각해보기 )\n\n그다음 HTML 마크업 해줘야됨\n`header+section.player+section.info+section.upNext` 이런식으로 입력해주면 자동 태그생성됨 신기하쥬 ?\n\n필요한 아이콘은 font-awesome에서 가져와서 사용\n\n영상은 html에서 제공해주는 태그를 사용함\nhttps://developer.mozilla.org/ko/docs/Web/HTML/element 여기서 찾아서 사용\n제공해주는 태그를 알고있는것과 모르는건 천지차이!\n\n\n마크업이 끝나면 CSS 작업해주기\n\nCSS 작업할때는 색깔, 사이즈, 폰트사이즈 등 많이 사용할 속성을 미리 가져와서\n저장해놓고 나중에 갖다 쓰기\n\n가져오고싶은 색깔은\n","properties":"\n","discussions":{},"comments":{},"hash":-1068186218,"tx":243},"Wg83VoN5zGPoNo1y/syncedContent":{"id":"Wg83VoN5zGPoNo1y/syncedContent","type":"syncedContent","historyData":{"-1068186218":{"id":"Wg83VoN5zGPoNo1y/content","type":"content","text":"레이아웃 구조 파악이 우선\n레이아웃은 최대한 흐름을 유지하면서 통일성 있게 만들어주는게 좋음\n1. 화면이 모바일환경일때\n2. 화면이 커졌을때 \n\nWireFrame 만들기 -> 전반적으로 구조를 어떻게 잡을지 박스단위로 프레임을 잡아보고 만들기시작하는게 좋음 \n구조를 잡고 레이블링 ( 박스나 아이템들을 이름을 뭘로 설정할지 생각해보기 )\n\n그다음 HTML 마크업 해줘야됨\n`header+section.player+section.info+section.upNext` 이런식으로 입력해주면 자동 태그생성됨 신기하쥬 ?\n\n필요한 아이콘은 font-awesome에서 가져와서 사용\n\n영상은 html에서 제공해주는 태그를 사용함\nhttps://developer.mozilla.org/ko/docs/Web/HTML/element 여기서 찾아서 사용\n제공해주는 태그를 알고있는것과 모르는건 천지차이!\n\n\n마크업이 끝나면 CSS 작업해주기\n\nCSS 작업할때는 색깔, 사이즈, 폰트사이즈 등 많이 사용할 속성을 미리 가져와서\n저장해놓고 나중에 갖다 쓰기\n\n가져오고싶은 색깔은\n","properties":"\n","discussions":{},"comments":{},"hash":-1068186218}},"syncHistory":{"main":[-1068186218,null,null]},"v":1,"hash":1710111641381,"tx":243},"C0Q29ajZZPzh3Jcv/content":{"id":"C0Q29ajZZPzh3Jcv/content","type":"content","text":"---\npermalink: /2023-06-09-React Router DOM 총정리/\ntitle: \"[React] React Router DOM 총정리!\"\ndate: 2023-06-09 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"React Router DOM 총정리\"\ncategories:\n- React\ntags:\n- 카카오 클라우드 스쿨\n- React\n---\n<br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1243151226,"tx":247},"C0Q29ajZZPzh3Jcv/syncedContent":{"id":"C0Q29ajZZPzh3Jcv/syncedContent","type":"syncedContent","historyData":{"-1243151226":{"id":"C0Q29ajZZPzh3Jcv/content","type":"content","text":"---\npermalink: /2023-06-09-React Router DOM 총정리/\ntitle: \"[React] React Router DOM 총정리!\"\ndate: 2023-06-09 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"React Router DOM 총정리\"\ncategories:\n- React\ntags:\n- 카카오 클라우드 스쿨\n- React\n---\n<br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1243151226}},"syncHistory":{"main":[-1243151226,null,null]},"v":1,"hash":1710111644031,"tx":247},"xJpL045jRDmgWJHa/content":{"id":"xJpL045jRDmgWJHa/content","type":"content","text":"기존 json 데이터를 import해와서 가져다 쓰는 방식에서\n\njson-server를 사용해 데이터를 가져오고자 함\n\njson-server 연동완료\n\n댓글을 삭제하고 싶은데 json데이터가 배열구조로 이루어져 있고 배열속 인덱스처럼 선언된 댓글로 접근이 안됨 -> 댓글만 삭제할수가 없는 구조임\n해결하려면 댓글 json을 따로만들어서 관리하고 접근해야함\n\n이 외에도 제목 클릭시 json데이터의 view값을 +1시킨다음 그 값을 다시 가져와서 조회수가 증가한것을 보여주고 싶었음\n또한 댓글 등록시 패스워드를 같이 입력해서 입력된 값을 json데이터가 추가하고 싶었음. 그리고 댓글을 등록하면 json 파일에 데이터 저장하고 싶었음.\n\n그러나 json-server를 이용해서 서버를 열면 json 데이터에 대한 DELETE 메소드는 실제 json데이터를 삭제해줄 수 있지만 \nPUT,PATCH 메소드는 메모리상의 데이터를 수정하여 수정된 값을 반환하기는 하지만, 실제 json 데이터를 수정해줄수는 없다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1977129061,"tx":249},"xJpL045jRDmgWJHa/syncedContent":{"id":"xJpL045jRDmgWJHa/syncedContent","type":"syncedContent","historyData":{"-1977129061":{"id":"xJpL045jRDmgWJHa/content","type":"content","text":"기존 json 데이터를 import해와서 가져다 쓰는 방식에서\n\njson-server를 사용해 데이터를 가져오고자 함\n\njson-server 연동완료\n\n댓글을 삭제하고 싶은데 json데이터가 배열구조로 이루어져 있고 배열속 인덱스처럼 선언된 댓글로 접근이 안됨 -> 댓글만 삭제할수가 없는 구조임\n해결하려면 댓글 json을 따로만들어서 관리하고 접근해야함\n\n이 외에도 제목 클릭시 json데이터의 view값을 +1시킨다음 그 값을 다시 가져와서 조회수가 증가한것을 보여주고 싶었음\n또한 댓글 등록시 패스워드를 같이 입력해서 입력된 값을 json데이터가 추가하고 싶었음. 그리고 댓글을 등록하면 json 파일에 데이터 저장하고 싶었음.\n\n그러나 json-server를 이용해서 서버를 열면 json 데이터에 대한 DELETE 메소드는 실제 json데이터를 삭제해줄 수 있지만 \nPUT,PATCH 메소드는 메모리상의 데이터를 수정하여 수정된 값을 반환하기는 하지만, 실제 json 데이터를 수정해줄수는 없다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1977129061}},"syncHistory":{"main":[-1977129061,null,null]},"v":1,"hash":1710111645214,"tx":249},"VhXoCDuP9kB8fjSR/content":{"id":"VhXoCDuP9kB8fjSR/content","type":"content","text":"트랜젝션\n\nAtomicity : 트랜젝션의 수행은 성공하든지 실패해야 한다.\nConsistency : 트랜젝션은 데이터의 일관성을 보장해야 한다.\nIsolation : 각 트랜젝션은 동시에 수행되지 않고 각각 고립되어 실행되어야 한다.\nDurability : 트랜잭션이 성공적으로 완료(Commit)된 뒤에, 그 데이터는 유실되지 않아야 한다.\n\n\n조인\n\n뷰\n\n인덱스\n\n\n\n제 2정규형\n\n기본키가 2개로 조합되어 있는 경우에 기본키의 일부분이 속성을 결정하면 안됨. 무슨소리냐? -> 학번과 과목번호를 조합한 칼럼을 기본키로 지정했을 때 다른 컬럼으로는 성적과 학년이 있다고 하자. 그때 학년은 학번과 과목번호가 조합된 기본키로 결정되는게 아니라, 단순히 학번만 알면 학년이 결정되는 상황이 발생하는데 이런 경우에 제2정규화가 필요하다!\n\n\n제 3정규형\n기본키를 제외하고 다른 attribute 사이에 종속관계가 있는 경우, 즉 기본키를 제외한 attribute가 기본키 역할을 하고 있는 경우 제 3정규화가 필요하다.\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1835859566,"tx":259},"VhXoCDuP9kB8fjSR/syncedContent":{"id":"VhXoCDuP9kB8fjSR/syncedContent","type":"syncedContent","historyData":{"1835859566":{"id":"VhXoCDuP9kB8fjSR/content","type":"content","text":"트랜젝션\n\nAtomicity : 트랜젝션의 수행은 성공하든지 실패해야 한다.\nConsistency : 트랜젝션은 데이터의 일관성을 보장해야 한다.\nIsolation : 각 트랜젝션은 동시에 수행되지 않고 각각 고립되어 실행되어야 한다.\nDurability : 트랜잭션이 성공적으로 완료(Commit)된 뒤에, 그 데이터는 유실되지 않아야 한다.\n\n\n조인\n\n뷰\n\n인덱스\n\n\n\n제 2정규형\n\n기본키가 2개로 조합되어 있는 경우에 기본키의 일부분이 속성을 결정하면 안됨. 무슨소리냐? -> 학번과 과목번호를 조합한 칼럼을 기본키로 지정했을 때 다른 컬럼으로는 성적과 학년이 있다고 하자. 그때 학년은 학번과 과목번호가 조합된 기본키로 결정되는게 아니라, 단순히 학번만 알면 학년이 결정되는 상황이 발생하는데 이런 경우에 제2정규화가 필요하다!\n\n\n제 3정규형\n기본키를 제외하고 다른 attribute 사이에 종속관계가 있는 경우, 즉 기본키를 제외한 attribute가 기본키 역할을 하고 있는 경우 제 3정규화가 필요하다.\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1835859566}},"syncHistory":{"main":[1835859566,null,null]},"v":1,"hash":1710111651748,"tx":259},"Bars6CC7H5Joqa8P/content":{"id":"Bars6CC7H5Joqa8P/content","type":"content","text":"---\npermalink: /2023-06-29-DB설계 예제와 고민/\ntitle: \"[DB] [MYSQL] DB설계 예제와 고민\"\ndate: 2023-06-29 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"DB설계 예제와 고민\"\ncategories:\n- DB\ntags:\n- DB\n- MYSQL\n- 카카오 클라우드 스쿨\n---\n<br><br>\n\n오늘은 DB 공부를 하며 설계해본 데이터 베이스에 대한 설명과 그 과정에서 배우고 깨달은점, 그리고 고민했던 과정을 포스팅 해보려고 한다. 비교적 간단한 예제이지만 고민하는 과정에서 충분히 배울점이 있었고 이를 기록해서 남기려고 한다.\n\n<br><br>\n## ✅ 테이블 생성 예제\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/dbexercise1.png?raw=true\">\n</p>\n\n<BR>\n\n🚩 **처음 보고 든 생각**\n\n주어진 E-R 다이어그램을 보고 적절하게 테이블을 생성하는 예제이다. E-R다이어그램을 예전에 학부생때 공부해보고 오랜만에 봐서 각각의 네모, 마름모, 동그라미가 어떤 역할을 하는지 확신이 없었다. 네모는 테이블, 동그라미는 칼럼 정도겠다 라는 감은 잡혔지만, 마름모가 의미하는게 뭔지 모르겠어서 관련 자료를 찾아봤다.\n\nE-R다이어그램에서 **네모는 개체, 동그라미는 속성, 마름모는 관계**를 의미한다. 좀더 정확한 설명을 위해 **ERD 표준 기호** 관련 그림을 첨부하겠다.\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/dbexercise2.png?raw=true\">\n</p>\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/dbexercise3.png?raw=true\">\n</p>\n\n이정도만 알고있으면 ER 다이어그램을 이해하는데 어려움은 없을거다.\n\n<br><br>\n\n아무튼 처음 그림을 보고서 생각한 DB구조는 교수, 학생, 과목, 등록, 강의, 지도 테이블을 만들어야 겠다 생각했다. 아무래도 관계를 나타내는 기호를 잘 몰랐기 때문에 관계에 해당하는 기호도 테이블로 만드려고 했다. 그런데 지도 같은 경우에는 지도에 해당하는 attribute가 하나도 없기 때문에 뭔가 이상하다 어떻게 만들지 생각을 하긴했다. \n\n\n<br><br><br>\n\n🚩 **중간 과정**\n\n 이후 ER다이어그램의 기호를 익히고 다시 생각을 했다. 지도는 교수와 학생을 연결해주는 관계를 표현하는것이기 때문에 테이블로 만들 필요가 없구나. 그렇다면 지도를 제외한 나머지를 테이블로 만들어야겠다.\n\n그렇게 테이블을 만드려고 하는데 다른 분의 조언을 듣고 다시 설계를 하게되었다. 나는 **강의** 엔티티를 하나의 테이블로 만들어 주고 **교수-강의**, **강의-과목**에 외래키를 추가하여 연결해주려고 했는데, \n","properties":"\n","discussions":{},"comments":{},"hash":1816006844,"tx":261},"Bars6CC7H5Joqa8P/syncedContent":{"id":"Bars6CC7H5Joqa8P/syncedContent","type":"syncedContent","historyData":{"1816006844":{"id":"Bars6CC7H5Joqa8P/content","type":"content","text":"---\npermalink: /2023-06-29-DB설계 예제와 고민/\ntitle: \"[DB] [MYSQL] DB설계 예제와 고민\"\ndate: 2023-06-29 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"DB설계 예제와 고민\"\ncategories:\n- DB\ntags:\n- DB\n- MYSQL\n- 카카오 클라우드 스쿨\n---\n<br><br>\n\n오늘은 DB 공부를 하며 설계해본 데이터 베이스에 대한 설명과 그 과정에서 배우고 깨달은점, 그리고 고민했던 과정을 포스팅 해보려고 한다. 비교적 간단한 예제이지만 고민하는 과정에서 충분히 배울점이 있었고 이를 기록해서 남기려고 한다.\n\n<br><br>\n## ✅ 테이블 생성 예제\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/dbexercise1.png?raw=true\">\n</p>\n\n<BR>\n\n🚩 **처음 보고 든 생각**\n\n주어진 E-R 다이어그램을 보고 적절하게 테이블을 생성하는 예제이다. E-R다이어그램을 예전에 학부생때 공부해보고 오랜만에 봐서 각각의 네모, 마름모, 동그라미가 어떤 역할을 하는지 확신이 없었다. 네모는 테이블, 동그라미는 칼럼 정도겠다 라는 감은 잡혔지만, 마름모가 의미하는게 뭔지 모르겠어서 관련 자료를 찾아봤다.\n\nE-R다이어그램에서 **네모는 개체, 동그라미는 속성, 마름모는 관계**를 의미한다. 좀더 정확한 설명을 위해 **ERD 표준 기호** 관련 그림을 첨부하겠다.\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/dbexercise2.png?raw=true\">\n</p>\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/dbexercise3.png?raw=true\">\n</p>\n\n이정도만 알고있으면 ER 다이어그램을 이해하는데 어려움은 없을거다.\n\n<br><br>\n\n아무튼 처음 그림을 보고서 생각한 DB구조는 교수, 학생, 과목, 등록, 강의, 지도 테이블을 만들어야 겠다 생각했다. 아무래도 관계를 나타내는 기호를 잘 몰랐기 때문에 관계에 해당하는 기호도 테이블로 만드려고 했다. 그런데 지도 같은 경우에는 지도에 해당하는 attribute가 하나도 없기 때문에 뭔가 이상하다 어떻게 만들지 생각을 하긴했다. \n\n\n<br><br><br>\n\n🚩 **중간 과정**\n\n 이후 ER다이어그램의 기호를 익히고 다시 생각을 했다. 지도는 교수와 학생을 연결해주는 관계를 표현하는것이기 때문에 테이블로 만들 필요가 없구나. 그렇다면 지도를 제외한 나머지를 테이블로 만들어야겠다.\n\n그렇게 테이블을 만드려고 하는데 다른 분의 조언을 듣고 다시 설계를 하게되었다. 나는 **강의** 엔티티를 하나의 테이블로 만들어 주고 **교수-강의**, **강의-과목**에 외래키를 추가하여 연결해주려고 했는데, \n","properties":"\n","discussions":{},"comments":{},"hash":1816006844}},"syncHistory":{"main":[1816006844,null,null]},"v":1,"hash":1710111653146,"tx":261},"yZcqkNTKpThPrnfx/content":{"id":"yZcqkNTKpThPrnfx/content","type":"content","text":"---\npermalink: /2023-07-03-스프링 컨테이너/\npublished: true\ntitle: \"[스프링] 스프링 (IOC) 컨테이너\"\ndate: 2023-07-03 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링 (IOC) 컨테이너\"\ncategories:\n- Spring\ntags:\n- Spring\n- IoC\n- 카카오 클라우드 스쿨\n---\n<br><br>\n\n## ✅ 스프링 IOC 컨테이너\n\n스프링 컨테이너는 Bean들의 생명주기를 관리하는 핵심 컴포넌트이다. Bean의 생성, 관리, 제거 등의 역할을 담당하며 IOC개념이 적용된 대표적인 기능이다. \n\n스프링 컨테이너는 DI가 이루어진 빈들을 **BeanFactory**와 **ApplicationContext**라는 2개의 컨테이너로 제어하고 관리한다.\n\n스프링 컨테이너는 **XML**, **@Annotation 기반의 자바 설정정보 클래스**로 만들수 있는데, 스프링 부트를 사용하기 전에는 xml을 통해 직접 설정해줘야 했지만 스프링 부트가 등장한 현재 대부분 사용하지 않는다. 그러나 스프링 컨테이너가 어떻게 구성되고 동작하는지를 알고 사용하는것과 모르고 사용하는것은 천지차이 이므로 반드시 알고 넘어가자.\n\n참고 ) **\"스프링 컨테이너\"라는 용어는 주로 ApplicationContext 인터페이스를 구현한 구체적인 컨테이너 클래스를 지칭하는 경우가 많습니다.** 그러나 스프링 프레임워크에서는 ApplicationContext를 확장한 다양한 컨테이너 구현체를 제공하고 있습니다. \n\n- AnnotationConfigApplicationContext\n- ClassPathXmlApplicationContext\n- FileSystemXmlApplicationContext\n- XmlWebApplicationContext\n\n\n<br><Br>\n\n\n###  📌 스프링 컨테이너를 왜 사용할까 ?\n\n스프링 컨테이너는 빈의 생명주기를 관리한다고 했다. 생명주기 관리는 빈의 생성,제거 등을 의미하고 이를 관리한다는 것은 빈을 사용하는 주체 대신 빈에 설정정보를 대입하여 생성 및 제거를 대신한다는 것을 의미한다. **IOC**가 적용된 개념이라고 볼 수 있다.\n\n기존의 자바코드에서는 객체(Bean)를 사용하기 위해서는 new라는 생성자를 사용했다. 이후 객체끼리 참조를 반복하여 객체간의 의존성이 높아지게 된다. 그러나 참조가 심해지면 객체간의 의존성이 지나치게 높아져 좋은 객체 지향 설계 원칙에 위배된다.\n\n이러한 기존 자바의 단점을 보완하기 위해 탄생하게 된것이 Spring이고, **이때 객체 간의 의존성을 낮추기 위해 사용하게 된것이 바로 스프링 컨테이너 이다.** 이를 정리하면 다음과 같다.\n\n1. **객체의 생명주기 관리**: 스프링 컨테이너는 객체의 생성, 초기화, 소멸 등의 생명주기를 관리합니다. 개발자는 객체의 생성과 소멸에 대한 로직을 신경쓰지 않고, 단순히 컨테이너에게 객체 생성을 요청함으로써 효율적으로 객체를 관리할 수 있습니다.\n\n2. **의존성 주입(Dependency Injection)**: 스프링 컨테이너는 의존성 주입을 통해 객체 간의 의존성을 해결합니다. 의존성 주입은 객체가 다른 객체에 의존할 때 직접 객체를 생성하거나 참조하는 것이 아니라, 컨테이너가 객체 간의 의존성을 자동으로 연결해줌으로써 개발자가 객체 간의 결합도를 낮출 수 있습니다. 이를 통해 코드의 재사용성과 유지보수성을 향상시킬 수 있습니다.\n\n3. **관심사의 분리**: 스프링 컨테이너는 객체 생성과 의존성 주입을 담당하므로, 개발자는 비즈니스 로직에 집중할 수 있습니다. 컨테이너는 애플리케이션의 구성 요소들을 중앙에서 관리하기 때문에, 객체 간의 관계와 설정 정보를 한 곳에서 관리할 수 있습니다.\n\n<br><br><br><br>\n\n## ✅ 스프링 컨테이너의 구성\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/sspring2.png?raw=true\">\n</p>\n\n스프링컨테이너의 구성을 보기 앞서 ApplicationContext와 BeanFactory가 어떤 역할을 하는지 간단하게 살펴보자.\n\n- **BeanFactory** - 모든 유형의 개체를 관리할 수 있는 구성 프레임워크 및 기본기능 제공\n- **ApplicationContext** - BeanFactory를 확장하고 Spring AOP와의 통합, 메시지 리소스 처리 및 이벤트 게시와 같은 다양한 엔터프라이즈 특정 기능 추가\n\n앞서 스프링 컨테이너는 ApplicationContext와 BeanFactory로 이루어졌다고 언급했는데, 사실 ApplicationContext는 BeanFactory를 상속하고 있는 구조를 띈다. 뿐만 아니라 여러 인터페이스를 다중상속 하고 있는데 각 기능을 살펴보면 다음과 같다.\n\n- MessageSource : 다국어 메시지 처리 기능 제공\n- EnvironmentCapable : 프로파일, 프로퍼티 기능 제공\n- **BeanFactory : 스프링 빈을 관리하고 조회하는 역할 담당**\n- ApplicationEventPublisher : 이벤트 기반 프로그래밍을 할때 필요한 기능 제공\n- ResourceLoader : 리소스를 읽어오는 기능 제공\n\n**때문에 ApplicationContext는 Bean을 관리하는 기능 뿐만 아니라 다국어 메시지처리, 리소스, 이벤트와 관련된 기능을 전부 가지고 있는 인터페이스이다.**\n\n다시 정리하면 스프링 컨테이너는\n**크게보면 ApplicationContext 인터페이스를 구현한 구체적인 컨테이너 클래스를 가리키고,** **일반적으로는 BeanFactory 인터페이스를 구현하여 빈을 관리하는 컨테이너 클래스를 의미한다.** \n\n<br>\n\n> **빈 팩토리 : 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점** \n> \n> **애플리케이션 컨텍스트 : 애플리케이션 전반에 걸쳐 모든 구성요소의 제어를 담당하는 IoC 엔진**\n\n\n<br><br><br><br>\n\n## ✅ 스프링 컨테이너 구현\n\n스프링 컨테이너를 코드로 구현하는 방식은 크게 두가지가 있다.\n1. @Annotation을 사용한 구현\n2. XML 파일을 사용한 구현\n\n두가지 경우 모두 예제를 통해 살펴보겠다.\n\n<br><Br>\n \n###  📌 @Annotation을 활용한 스프링 컨테이너 구현\n <br>\n \n```java\n@Configuration  // 설정정보 라는 표시\npublic class DaoFactory {\n\n\t@Bean // 오브젝트 생성을 담당하는 IoC용 메소드 라는 표시\n\tpublic UserDao userDao() {\n\t\tUserDao userDao = new UserDao();\n\t\tuserDao.setDataSource(dataSource());\n\t\treturn userDao();\n\t}\n\n\t@Bean // 오브젝트 생성을 담당하는 IoC용 메소드 라는 표시\n\tpublic DataSource dataSource() {\n\t\tSimpleDriverDataSource dataSource = new SimpleDriverDataSource();\n\t\t\n\t\tdataSource.setDriverClass(com.mysql.jdbc.Driver.class);\n\t\tdataSource.setUrl(\"jdbc:mysql://localhost/user\");\n\t\tdataSource.setUsername(\"root\");\n\t\tdataSource.setPassword(\"root\");\n\t\t\n\t\treturn dataSource;\n\t}\n}\n```\n\n<br>\n\n```java\npublic class UserDaoTest {\n\tpublic static void main(String[] args) throws ClassNotFoundException, SQLException {\n\t\tApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n\t\tUserDao dao = context.getBean(\"userDao\", UserDao.class);\n\t...\n}\n```\n<br><br>\n\n`DaoFactory` 클래스를 `@Configuration` 어노테이션을 사용해 설정정보 클래스라고 선언한뒤 `UserDao` 와 `Datasource` 객체를 `@Bean`으로 설정했다. 스프링에서 제공하는 어노테이션을 활용해 간단하게 설정정보와 빈을 등록할 수 있다.\n\n`userDao()` 메소드 내에서 `UserDao` 객체를 생성하고, `setDataSource()` 메소드를 사용하여 `DataSource` 객체를 주입했다. 이를 통해 `UserDao`가 `DataSource`에 의존성을 갖게 된다.\n\n`dataSource()` 메소드에서는 `SimpleDriverDataSource` 객체를 생성하고, 데이터베이스 연결 정보를 설정하여 반환합니다.\n\n이후 `UserDaoTest` 클래스에서는 `DaoFactory` 클래스를 설정정보로 사용하는 스프링 컨테이너 ( ApplicationContext )를 만들고 있다.\n\n위의 코드는 `@Bean`으로 생성된 `userDao` 스프링빈을 `UserDaoTest` 에서 가져와 사용하는 코드이다. `UserDaoTest`는 `UserDao`의 설정정보를 사용하는 애플리케이션 콘텍스트로 작동하는 것이다.\n\n<br><br><br>\n\n###  📌 XML을 활용한 스프링 컨테이너 구현\n<br>\n\n```xml\n<!-- DaoFactory.xml -->  \n\n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\t<bean id=\"userDao\" class=\"com.example.UserDao\">  \n\t\t<property name=\"dataSource\" ref=\"dataSource\"/>  \n\t</bean>\n\t\n\t<bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\">  <property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/>  \n\t\t<property name=\"url\" value=\"jdbc:mysql://localhost/user\"/>\n\t\t<property name=\"username\" value=\"root\"/>  \n\t\t<property name=\"password\" value=\"root\"/>  \n\t</bean>\n\t\n</beans>\n```\n<br>\n\n위의 XML 설정 파일은 `DaoFactory` 클래스에서 사용한 빈 객체들을 정의하고 구성한다.\n\n`<bean>` 요소는 스프링 빈을 정의하는 역할을 한다. `id` 속성은 빈의 식별자를 지정하고, `class` 속성은 해당 빈 객체의 클래스 경로를 지정한다.\n\n`<property>` 요소는 빈 객체의 프로퍼티를 설정하는 역할을 한다. `name` 속성은 프로퍼티 이름을 지정하고, `value` 속성은 프로퍼티 값을 지정한다. `ref` 속성은 다른 빈 객체를 참조할 때 사용된다.\n\n따라서, 위의 XML 설정 파일은 `userDao` 빈 객체와 `dataSource` 빈 객체를 정의하고, `userDao`의 `dataSource` 프로퍼티에 `dataSource` 빈 객체를 주입하는 설정을 나타낸다.\n\n<Br><Br><Br><Br>\n\n## ✅ 애플리케이션 컨텍스트 동작 방식\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ioc1.jpg?raw=true\">\n</p>\n\nApplication Context는 IOC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다. 생성정보와 관계설정에 대한 정보는 별도의 설정정보를 통해 얻는데 `@Configuration` 어노테이션이 달린 클래스나 XML파일에서 설정정보를 가져온다. 앞선 예제에 대한 그림으로 Application Context의 동작 방식을 설명해보겠다.\n\n1. ApplicationContext는 `@Configuration` 어노테이션이 사용된 `DaoFactory` 클래스를 설정정보로 지정한다.\n2. 설정정보에서 `@Bean` 어노테이션이 사용된 메소드의 이름을 가져와 Bean 목록을 만들어 저장해둔다.\n3. 클라이언트가 `getBean()` 메소드를 사용해 userDao 객체 사용을 요청한다\n4. ApplicationContext는 빈목록에서 userDao 빈을 찾고 해당 메소드를 호출해서 오브젝트를 생성한다.\n5. 생성된 userDao 빈을 클라이언트가 사용한다.\n\n\n\n\n<br><br><br><br>\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":57789330,"tx":263},"yZcqkNTKpThPrnfx/syncedContent":{"id":"yZcqkNTKpThPrnfx/syncedContent","type":"syncedContent","historyData":{"57789330":{"id":"yZcqkNTKpThPrnfx/content","type":"content","text":"---\npermalink: /2023-07-03-스프링 컨테이너/\npublished: true\ntitle: \"[스프링] 스프링 (IOC) 컨테이너\"\ndate: 2023-07-03 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링 (IOC) 컨테이너\"\ncategories:\n- Spring\ntags:\n- Spring\n- IoC\n- 카카오 클라우드 스쿨\n---\n<br><br>\n\n## ✅ 스프링 IOC 컨테이너\n\n스프링 컨테이너는 Bean들의 생명주기를 관리하는 핵심 컴포넌트이다. Bean의 생성, 관리, 제거 등의 역할을 담당하며 IOC개념이 적용된 대표적인 기능이다. \n\n스프링 컨테이너는 DI가 이루어진 빈들을 **BeanFactory**와 **ApplicationContext**라는 2개의 컨테이너로 제어하고 관리한다.\n\n스프링 컨테이너는 **XML**, **@Annotation 기반의 자바 설정정보 클래스**로 만들수 있는데, 스프링 부트를 사용하기 전에는 xml을 통해 직접 설정해줘야 했지만 스프링 부트가 등장한 현재 대부분 사용하지 않는다. 그러나 스프링 컨테이너가 어떻게 구성되고 동작하는지를 알고 사용하는것과 모르고 사용하는것은 천지차이 이므로 반드시 알고 넘어가자.\n\n참고 ) **\"스프링 컨테이너\"라는 용어는 주로 ApplicationContext 인터페이스를 구현한 구체적인 컨테이너 클래스를 지칭하는 경우가 많습니다.** 그러나 스프링 프레임워크에서는 ApplicationContext를 확장한 다양한 컨테이너 구현체를 제공하고 있습니다. \n\n- AnnotationConfigApplicationContext\n- ClassPathXmlApplicationContext\n- FileSystemXmlApplicationContext\n- XmlWebApplicationContext\n\n\n<br><Br>\n\n\n###  📌 스프링 컨테이너를 왜 사용할까 ?\n\n스프링 컨테이너는 빈의 생명주기를 관리한다고 했다. 생명주기 관리는 빈의 생성,제거 등을 의미하고 이를 관리한다는 것은 빈을 사용하는 주체 대신 빈에 설정정보를 대입하여 생성 및 제거를 대신한다는 것을 의미한다. **IOC**가 적용된 개념이라고 볼 수 있다.\n\n기존의 자바코드에서는 객체(Bean)를 사용하기 위해서는 new라는 생성자를 사용했다. 이후 객체끼리 참조를 반복하여 객체간의 의존성이 높아지게 된다. 그러나 참조가 심해지면 객체간의 의존성이 지나치게 높아져 좋은 객체 지향 설계 원칙에 위배된다.\n\n이러한 기존 자바의 단점을 보완하기 위해 탄생하게 된것이 Spring이고, **이때 객체 간의 의존성을 낮추기 위해 사용하게 된것이 바로 스프링 컨테이너 이다.** 이를 정리하면 다음과 같다.\n\n1. **객체의 생명주기 관리**: 스프링 컨테이너는 객체의 생성, 초기화, 소멸 등의 생명주기를 관리합니다. 개발자는 객체의 생성과 소멸에 대한 로직을 신경쓰지 않고, 단순히 컨테이너에게 객체 생성을 요청함으로써 효율적으로 객체를 관리할 수 있습니다.\n\n2. **의존성 주입(Dependency Injection)**: 스프링 컨테이너는 의존성 주입을 통해 객체 간의 의존성을 해결합니다. 의존성 주입은 객체가 다른 객체에 의존할 때 직접 객체를 생성하거나 참조하는 것이 아니라, 컨테이너가 객체 간의 의존성을 자동으로 연결해줌으로써 개발자가 객체 간의 결합도를 낮출 수 있습니다. 이를 통해 코드의 재사용성과 유지보수성을 향상시킬 수 있습니다.\n\n3. **관심사의 분리**: 스프링 컨테이너는 객체 생성과 의존성 주입을 담당하므로, 개발자는 비즈니스 로직에 집중할 수 있습니다. 컨테이너는 애플리케이션의 구성 요소들을 중앙에서 관리하기 때문에, 객체 간의 관계와 설정 정보를 한 곳에서 관리할 수 있습니다.\n\n<br><br><br><br>\n\n## ✅ 스프링 컨테이너의 구성\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/sspring2.png?raw=true\">\n</p>\n\n스프링컨테이너의 구성을 보기 앞서 ApplicationContext와 BeanFactory가 어떤 역할을 하는지 간단하게 살펴보자.\n\n- **BeanFactory** - 모든 유형의 개체를 관리할 수 있는 구성 프레임워크 및 기본기능 제공\n- **ApplicationContext** - BeanFactory를 확장하고 Spring AOP와의 통합, 메시지 리소스 처리 및 이벤트 게시와 같은 다양한 엔터프라이즈 특정 기능 추가\n\n앞서 스프링 컨테이너는 ApplicationContext와 BeanFactory로 이루어졌다고 언급했는데, 사실 ApplicationContext는 BeanFactory를 상속하고 있는 구조를 띈다. 뿐만 아니라 여러 인터페이스를 다중상속 하고 있는데 각 기능을 살펴보면 다음과 같다.\n\n- MessageSource : 다국어 메시지 처리 기능 제공\n- EnvironmentCapable : 프로파일, 프로퍼티 기능 제공\n- **BeanFactory : 스프링 빈을 관리하고 조회하는 역할 담당**\n- ApplicationEventPublisher : 이벤트 기반 프로그래밍을 할때 필요한 기능 제공\n- ResourceLoader : 리소스를 읽어오는 기능 제공\n\n**때문에 ApplicationContext는 Bean을 관리하는 기능 뿐만 아니라 다국어 메시지처리, 리소스, 이벤트와 관련된 기능을 전부 가지고 있는 인터페이스이다.**\n\n다시 정리하면 스프링 컨테이너는\n**크게보면 ApplicationContext 인터페이스를 구현한 구체적인 컨테이너 클래스를 가리키고,** **일반적으로는 BeanFactory 인터페이스를 구현하여 빈을 관리하는 컨테이너 클래스를 의미한다.** \n\n<br>\n\n> **빈 팩토리 : 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점** \n> \n> **애플리케이션 컨텍스트 : 애플리케이션 전반에 걸쳐 모든 구성요소의 제어를 담당하는 IoC 엔진**\n\n\n<br><br><br><br>\n\n## ✅ 스프링 컨테이너 구현\n\n스프링 컨테이너를 코드로 구현하는 방식은 크게 두가지가 있다.\n1. @Annotation을 사용한 구현\n2. XML 파일을 사용한 구현\n\n두가지 경우 모두 예제를 통해 살펴보겠다.\n\n<br><Br>\n \n###  📌 @Annotation을 활용한 스프링 컨테이너 구현\n <br>\n \n```java\n@Configuration  // 설정정보 라는 표시\npublic class DaoFactory {\n\n\t@Bean // 오브젝트 생성을 담당하는 IoC용 메소드 라는 표시\n\tpublic UserDao userDao() {\n\t\tUserDao userDao = new UserDao();\n\t\tuserDao.setDataSource(dataSource());\n\t\treturn userDao();\n\t}\n\n\t@Bean // 오브젝트 생성을 담당하는 IoC용 메소드 라는 표시\n\tpublic DataSource dataSource() {\n\t\tSimpleDriverDataSource dataSource = new SimpleDriverDataSource();\n\t\t\n\t\tdataSource.setDriverClass(com.mysql.jdbc.Driver.class);\n\t\tdataSource.setUrl(\"jdbc:mysql://localhost/user\");\n\t\tdataSource.setUsername(\"root\");\n\t\tdataSource.setPassword(\"root\");\n\t\t\n\t\treturn dataSource;\n\t}\n}\n```\n\n<br>\n\n```java\npublic class UserDaoTest {\n\tpublic static void main(String[] args) throws ClassNotFoundException, SQLException {\n\t\tApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n\t\tUserDao dao = context.getBean(\"userDao\", UserDao.class);\n\t...\n}\n```\n<br><br>\n\n`DaoFactory` 클래스를 `@Configuration` 어노테이션을 사용해 설정정보 클래스라고 선언한뒤 `UserDao` 와 `Datasource` 객체를 `@Bean`으로 설정했다. 스프링에서 제공하는 어노테이션을 활용해 간단하게 설정정보와 빈을 등록할 수 있다.\n\n`userDao()` 메소드 내에서 `UserDao` 객체를 생성하고, `setDataSource()` 메소드를 사용하여 `DataSource` 객체를 주입했다. 이를 통해 `UserDao`가 `DataSource`에 의존성을 갖게 된다.\n\n`dataSource()` 메소드에서는 `SimpleDriverDataSource` 객체를 생성하고, 데이터베이스 연결 정보를 설정하여 반환합니다.\n\n이후 `UserDaoTest` 클래스에서는 `DaoFactory` 클래스를 설정정보로 사용하는 스프링 컨테이너 ( ApplicationContext )를 만들고 있다.\n\n위의 코드는 `@Bean`으로 생성된 `userDao` 스프링빈을 `UserDaoTest` 에서 가져와 사용하는 코드이다. `UserDaoTest`는 `UserDao`의 설정정보를 사용하는 애플리케이션 콘텍스트로 작동하는 것이다.\n\n<br><br><br>\n\n###  📌 XML을 활용한 스프링 컨테이너 구현\n<br>\n\n```xml\n<!-- DaoFactory.xml -->  \n\n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\t<bean id=\"userDao\" class=\"com.example.UserDao\">  \n\t\t<property name=\"dataSource\" ref=\"dataSource\"/>  \n\t</bean>\n\t\n\t<bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\">  <property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/>  \n\t\t<property name=\"url\" value=\"jdbc:mysql://localhost/user\"/>\n\t\t<property name=\"username\" value=\"root\"/>  \n\t\t<property name=\"password\" value=\"root\"/>  \n\t</bean>\n\t\n</beans>\n```\n<br>\n\n위의 XML 설정 파일은 `DaoFactory` 클래스에서 사용한 빈 객체들을 정의하고 구성한다.\n\n`<bean>` 요소는 스프링 빈을 정의하는 역할을 한다. `id` 속성은 빈의 식별자를 지정하고, `class` 속성은 해당 빈 객체의 클래스 경로를 지정한다.\n\n`<property>` 요소는 빈 객체의 프로퍼티를 설정하는 역할을 한다. `name` 속성은 프로퍼티 이름을 지정하고, `value` 속성은 프로퍼티 값을 지정한다. `ref` 속성은 다른 빈 객체를 참조할 때 사용된다.\n\n따라서, 위의 XML 설정 파일은 `userDao` 빈 객체와 `dataSource` 빈 객체를 정의하고, `userDao`의 `dataSource` 프로퍼티에 `dataSource` 빈 객체를 주입하는 설정을 나타낸다.\n\n<Br><Br><Br><Br>\n\n## ✅ 애플리케이션 컨텍스트 동작 방식\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ioc1.jpg?raw=true\">\n</p>\n\nApplication Context는 IOC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다. 생성정보와 관계설정에 대한 정보는 별도의 설정정보를 통해 얻는데 `@Configuration` 어노테이션이 달린 클래스나 XML파일에서 설정정보를 가져온다. 앞선 예제에 대한 그림으로 Application Context의 동작 방식을 설명해보겠다.\n\n1. ApplicationContext는 `@Configuration` 어노테이션이 사용된 `DaoFactory` 클래스를 설정정보로 지정한다.\n2. 설정정보에서 `@Bean` 어노테이션이 사용된 메소드의 이름을 가져와 Bean 목록을 만들어 저장해둔다.\n3. 클라이언트가 `getBean()` 메소드를 사용해 userDao 객체 사용을 요청한다\n4. ApplicationContext는 빈목록에서 userDao 빈을 찾고 해당 메소드를 호출해서 오브젝트를 생성한다.\n5. 생성된 userDao 빈을 클라이언트가 사용한다.\n\n\n\n\n<br><br><br><br>\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":57789330}},"syncHistory":{"main":[57789330,null,null]},"v":1,"hash":1710111654429,"tx":263},"N72RguIezt8KuflR/content":{"id":"N72RguIezt8KuflR/content","type":"content","text":"---\npermalink: /2023-07-04-빈 스코프 - 싱글톤, 프로토타입/\npublished: true\ntitle: \"[스프링] 빈 스코프 - 싱글톤, 프로토타입\"\ndate: 2023-07-04 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"빈 스코프 - 싱글톤, 프로토타입\"\ncategories:\n- Spring\ntags:\n- Spring\n- 카카오 클라우드 스쿨\n---\n\n<br><br>\n\n\n## ✅ 빈(Bean) 스코프\n\n빈 스코프는 우리가 빈을 생성할 때, 빈을 공유하기 위한 인스턴스를 하나만 만들지(싱글턴 스코프), 아니면 빈이 요청될 때마다 새로운 빈 인스턴스를 생성할지(프로토타입 스코프) 여부를 제어하고자 할때 사용하는 개념이다.\n\n빈의 스코프를 정의하는 방식은 스프링 버전에 따라 다를 수 있고 여러가지가 있지만 대표적으로 두가지 방식이 존재한다. 첫번째로는 **설정정보를 담고있는 XML파일에서 <bean>엘리먼트의 scope속성을 사용하는 방법**이 있다. 두번째로는 **`@Scope` 어노테이션을 활용해 빈 스코프를 정의해주는 방법**이 있다.\n\n위와 같은 방식으로 빈 스코프를 따로 정의해주지 않았다면 빈 스코프는 자동으로 싱글턴 스코프를 가지게 된다.\n\n빈 스코프의 종류는 **Singleton, Prototype**, Request, Session, Application 등이 있는데 우리는 자주 사용하는 **Singleton과 Prototype**에 대해서만 다루도록 하겠다.\n\n<br><Br><Br><br>\n\n## ✅ 싱글턴 (Singleton) 스코프\n싱글턴 스코프는 XML파일에 정의된 모든 빈의 디폴트 스코프이다. **싱글턴 스코프 빈의 인스턴스는 스프링 컨테이너가 생성될 때 함께 생성되고, 스프링 컨테이너가 파괴될 때 함께 파괴된다. 또한 싱글턴 스코프 빈은 호출이 한번되든 여러번되든 상관없이 단일 스프링 컨테이너 내에서는 단 한개만 생성되고, 그 빈에 의존하는 모든 빈에 유일한 인스턴스를 공유한다.**\n\n너무너무 중요한 설명이니 위의 내용을 완벽하게 이해하고 넘어가야만 한다. xml방식과 클래스방식으로 설정정보를 저장하는 두가지 예제를 통해 좀더 자세히 알아보자.\n\n<br><br>\n\n###  📌 XML 파일로 bean 설정\n```xml\n// bankapp이라는 프로젝트의 applicationContext.xml\n\n<beans ...>  \n\t<bean id=\"controller\" class=\"bankapp.controller.FixedDepositControllerImpl\">  \n\t\t<property name=\"fixedDepositService\" ref=\"service\" />  \n\t</bean>  \n  \n\t<bean id=\"service\" class=\"bankapp.service.FixedDepositServiceImpl\">  \n\t\t<property name=\"fixedDepositDao\" ref=\"dao\"/>  \n\t</bean>  \n  \n\t<bean id=\"dao\" class=\"bankapp.dao.FixedDepositDaoImpl\" />\n\t...\n</beans>\n```\n\ncontroller, service, dao 빈은 스코프 지정을 해주지 않았기 때문에 싱글턴 스코프를 가진다. 때문에 스프링 컨테이너는 FixedDepositControllerImpl, FixedDepositServiceImpl, FixedDepositDaoImpl 클래스의 인스턴스를 단 하나씩만 만들게 된다. \n\n<br><br><br>\n\n###  📌 자바 클래스로 bean 설정\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Scope;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    @Scope(\"singleton\")\n    public FixedDepositController fixedDepositController() {\n        FixedDepositControllerImpl controller = new FixedDepositControllerImpl();\n        controller.setFixedDepositService(fixedDepositService());\n        return controller;\n    }\n\n    @Bean\n    @Scope(\"singleton\")\n    public FixedDepositService fixedDepositService() {\n        FixedDepositServiceImpl service = new FixedDepositServiceImpl();\n        service.setFixedDepositDao(fixedDepositDao());\n        return service;\n    }\n\n    @Bean\n    @Scope(\"singleton\")\n    public FixedDepositDao fixedDepositDao() {\n        return new FixedDepositDaoImpl();\n    }\n\n    // 다른 빈 정의 및 설정...\n\n}\n\n```\nxml의 `<bean>` 형태로 설정정보를 저장할 수도 있지만 설정정보를 담당하는 새로운 **클래스**를 만들수도 있다. `AppConfig` 라는 클래스를 만들고 `@Configuration` 처리를 하면 설정정보를 담당하는 클래스로 지정된다. 이후 각각의 빈에 `@Scope()`와 함께 `\"singleton\"` , `\"prototype\"` 등 값을 넣어주면 빈 스코프를 지정할 수 있다.\n\n<br><br>\n \n###  📌 싱글턴 스코프 테스트\n```java\npublic class SingletonTest {\n\n\tprivate static ApplicationContext context;  \n  \n\t@BeforeClass  \n\tpublic static void init() {  \n\t\tcontext = new ClassPathXmlApplicationContext(  \n\t\t\"classpath:META-INF/spring/applicationContext.xml\");  \n\t}  \n  \n\t@Test  \n\tpublic void testInstances() {  \n\t\tFixedDepositController controller1 \n\t\t= (FixedDepositController)context.getBean(\"controller\");\n\t\t\n\t\tFixedDepositController controller2 \n\t\t= (FixedDepositController)context.getBean(\"controller\");  \n  \n\t\tassertSame(\"Different FixedDepositController instances\", controller1,controller2);\n\t}\n\t...\n}\n```\nApplicationContext를 하나 생성하고 FixedDepositController 클래스의 서로 다른 객체 두개(controller1, controller2)를 생성했다. 각각의 객체는 `getBean()` 메소드를 통해 `controller` 라는 이름을 가진 빈을 가져온다. 그리고 이를 `assertSame` 메소드를 통해 같은 값을 반환하는지 확인했다. 이러한 테스트코드를 실행하면 오류없이 잘 작동하는 것을 볼 수 있다. 정리하면 서로 다른 객체에서 각자 빈을 호출했을 때 동일한 빈을 가져왔음을 의미하고 이는 싱글턴 스코프 빈이 잘 적용됐다는 뜻이다.\n\n<br><br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/beanscope1.png?raw=true\">\n</p>\n위 그림을 보면 싱글턴 스코프 빈을 여러번 요청해도 항상 동일한 빈을 반환하는 것을 알 수 있다.\n\n<br><br><br>\n\n### 📌 의존관계 빈들의 싱글턴 스코프\n싱글턴 스코프 빈 인스턴스는 의존관계에 있는 모든 빈 사이에서도 공유된다. 바로 예제를 통해 살펴보자.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/beanscope2.png?raw=true\">\n</p>\n\n```java\npublic class SingletonTest {  \nprivate static ApplicationContext context;  \n  \n\t@BeforeClass  \n\tpublic static void init() {  \n\t\tcontext = new ClassPathXmlApplicationContext(  \n\t\t\"classpath:META-INF/spring/applicationContext.xml\");  \n\t}  \n  \n\t@Test  \n\tpublic void testReference() {  \n\t\tFixedDepositController controller \n\t\t= (FixedDepositController) context.getBean(\"controller\");\n\t\t\n\t\tFixedDepositDao fixedDepositDao1 \n\t\t= controller.getFixedDepositService().getFixedDepositDao();\n\t\t \n\t\tFixedDepositDao fixedDepositDao2 \n\t\t= (FixedDepositDao) context.getBean(\"dao\");  \n  \n\t\tassertSame(\"Different FixedDepositDao instances\",\n\t\tfixedDepositDao1, fixedDepositDao2);\n\t}  \n}\n```\n그림에 기반해서 코드를 살펴보면, `FixedDepositController`빈이 참조하는 `FixedDepositDao` 인스턴스를 읽고(fixedDepositDao1), 이후 `getBean()` 메서드를 사용해 `FixedDepositDao` 빈의 다른 인스턴스를 읽었다(fixedDepositDao2). 테스트를 실행해보면 두 인스턴스가 같음을 알 수 있다.\n\n<br><br><br>\n\n### 📌 싱글턴 스코프는 같은 스프링 컨테이너 내에서만 유지된다!\n앞서 계속 싱글턴 스코프 빈은 인스턴스를 한개만 생성하고 호출될 때마다 해당 빈을 공유한다고 설명했다. 그러나 이는 하나의 스프링 컨테이너 내에서만 해당하는 얘기이다. 스프링 컨테이너를 두개이상 만들고 각 스프링 컨테이너마다 싱글턴 빈 인스턴스를 만들면, 각 컨테이너의 싱글턴 인스턴스는 서로 다른 빈이 된다.\n\n<br><Br><br><br>\n\n\n\n## ✅ 프로토타입 (Prototype) 스코프\n프로토타입 스코프 빈이 싱글턴 스코프 빈과 다른점은 스프링 컨테이너가 **항상 프로토타입 스코프 빈의 새로운 인스턴스를 반환한다**는 점이다.\n\n```java\n// ApplicationContext.xml\n<bean id=\"fixedDepositDetails\"  \n\tclass=\"sample.spring.chapter02.bankapp.domain.FixedDepositDetails\" \n\tscope=\"prototype\" />  \n</beans>\n```\n\n정의하는 방법은 싱글턴과 동일하다. `<bean>` 엘리먼트에 `scope=\"prototype\"` 을 추가해주면 된다. 어려운 개념은 없다. 싱글턴 스코프 빈은 단 한개의 인스턴스만 생성되는 것이고, 프로토타입 스코프 빈은 호출될 때마다 새로운 인스턴스를 생성하는 것이다.\n","properties":"\n","discussions":{},"comments":{},"hash":1850828839,"tx":265},"06MckntYpMDISZ8b/content":{"id":"06MckntYpMDISZ8b/content","type":"content","text":"---\npermalink: /2023-07-11-컴포넌트 스캔(@ComponentScan)/\npublished: true\ntitle: \"[스프링] 컴포넌트 스캔(ComponentScan)\"\ndate: 2023-07-11 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"컴포넌트 스캔(@ComponentScan)\"\ncategories:\n- Spring\ntags:\n- Spring\n- 카카오 클라우드 스쿨\n---\n\n<br><br>\n\n## ✅ 컴포넌트 스캔이란?\n\n**의존성 주입을 위해 스프링은 어플리케이션 컨텍스트를 생성한다. 스프링은 객체를 인스턴스화 하고 이를 어플리케이션 컨텍스트에 추가하는데 이때 인스턴스화 된 객체를 우리는 스프링 빈 혹은 컴포넌트 라고 부른다.**\n\n**이때, 어플리케이션 컨텍스트에 스프링 빈(컴포넌트)으로 등록될 클래스들을 스캔하여 빈으로 등록해주는 과정을 우리는 컴포넌트 스캔 이라고 부른다.**\n\n**다른말로 스프링 빈으로 등록될 클래스패스(Classpath)를 스캔하여 빈으로 등록해주는 과정을 컴포넌트 스캔이라고 한다.**\n\n컴포넌트 스캔이 무엇인지 모르는 상태라면 기존에 스프링 빈을 등록할 때는 자바 코드의 `@Bean`이나 XML의 `<bean>`을 통해서 설정 정보를 직접 등록했을 것이다. 그러나 이렇게 등록해야 할 **스프링 빈의 수가 엄청 많아지게 되면 일일이 등록하기도 힘들뿐더러, 설정정보의 양도 많아지고 실수가 생길 수 있다.**\n\n그래서 스프링에서는 **설정정보 없이 자동으로 스프링 빈을 등록하는 컴포넌트 스캔**을 제공한다. 추가적으로 의존관계를 자동으로 주입해주는 `@Autowired` 까지 함께 알아보도록 하겠다.\n\n먼저 비교를 위해 기존 `@Bean`을 사용한 스프링 빈 등록방법과 DI를 적용한 코드를 살펴보고 컴포넌트 스캔과의 차이를 살펴보도록 하자.\n\n<br><br><br>\n\n###  📌 `@Bean` 을 사용한 스프링 빈 등록\n\n```java\npackage hello.core;  \n  \nimport hello.core.discount.DiscountPolicy;  \nimport hello.core.discount.FixDiscountPolicy;  \nimport hello.core.member.MemberService;  \nimport hello.core.member.MemberServiceImpl;  \nimport hello.core.member.MemoryMemberRepository;  \nimport hello.core.order.OrderService;  \nimport hello.core.order.OrderServiceImpl;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  // 설정 정보 등록\npublic class AppConfig {  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemberService memberService(){  \n\t\treturn new MemberServiceImpl(memoryMemberRepository());  // 의존성 주입\n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic OrderService orderService(){  \n\t\treturn new OrderServiceImpl(memoryMemberRepository(), discountPolicy());  // 의존성 주입\n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemoryMemberRepository memoryMemberRepository(){  \n\t\treturn new MemoryMemberRepository();  \n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic DiscountPolicy discountPolicy(){  \n\t\treturn new FixDiscountPolicy();  \n\t}  \n}\n```\n<br>\n기존 스프링 빈을 등록하는 방식의 코드이다.\n\n1. 설정정보를 담고있는 클래스에 `@Configuration` 태그 사용\n2. 스프링 빈으로 등록할 객체에 `@Bean` 태그 사용\n3. 스프링 빈에 생성자 형태로 의존성 주입\n\n일반적으로는 이러한 방식으로 스프링 빈을 등록했을 것이다. 그러나 앞서 언급한 것처럼 위와 같은 방식은 편의성이 많이 떨어지기 때문에 스프링에서는 `@ComponentScan` 이라는 기능을 제공한다.\n\n<br><Br><Br>\n\n###  📌 `@ComponentScan` 을 사용한 스프링 빈 등록\n\n```java\npackage hello.core; \n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType; \n\nimport static org.springframework.context.annotation.ComponentScan.*; \n\n@Configuration \n@ComponentScan\npublic class AutoAppConfig { \n\n}\n```\n\n컴포넌트 스캔을 사용하기 위해서는 `@ComponentScan`을 설정정보에 붙여주기만 하면 된다. 기존에는 `@Bean`을 사용해 스프링 빈을 등록해줬지만 여기에는 하나도 없는것을 볼 수 있다. 컴포넌트 스캔을 사용할 때 스프링 빈 등록은 `@Component` 태그를 붙여줌으로써 가능해진다.  \n\n<br><br>\n\n####  📌 MemoryMemberRepository에  `@Component` 추가\n```java\n@Component \npublic class MemoryMemberRepository implements MemberRepository {}\n```\n<br>\n\n####  📌 RateDiscountPolicy 에  `@Component` 추가\n```java\n@Component \npublic class RateDiscountPolicy implements DiscountPolicy {}\n```\n<br>\n\n####  📌 MemberServiceImpl 에  `@Component` 추가 + `@Autowired` DI\n```java\n@Component \npublic class MemberServiceImpl implements MemberService { \n\tprivate final MemberRepository memberRepository; \n\n\t@Autowired \n\tpublic MemberServiceImpl(MemberRepository memberRepository) {\n\t\tthis.memberRepository = memberRepository; \n\t}\n}\n```\n<br>\n\n####  📌 OrderServiceImpl 에  `@Component` 추가 + `@Autowired` DI\n```java\n@Component \npublic class OrderServiceImpl implements OrderService { \n\n\tprivate final MemberRepository memberRepository; \n\tprivate final DiscountPolicy discountPolicy; \n\n\t@Autowired \n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { \n\t\tthis.memberRepository = memberRepository; \n\t\tthis.discountPolicy = discountPolicy; \n\t} \n}\n```\n\n<br>\n\n빈으로 등록하려는 클래스에 `@Component` 를 붙여줌으로써 컴포넌트 스캔을 사용한 스프링 빈 등록이 가능해진다. 또한 `@Autowired` 태그를 붙이면 자동으로 의존관계를 주입해주는 기능을 한다. 이를 통해 더이상 `@Bean`을 사용한 스프링 빈 등록과 의존성 주입을 할 필요 없이 편하게 스프링 빈을 등록할 수 있게 되었다. 이 과정을 정리하면 다음과 같다.\n\n1. 설정정보 클래스에 `@ComponentScan` 어노테이션을 추가해준다.\n2. 스프링 빈으로 등록할 클래스에 `@Component` 어노테이션을 추가하여 `@ComponentScan`의 대상이 되도록 지정하고 스프링 빈으로 등록해준다.\n3. 스프링 빈으로 등록할 때 필요한 DI는 `@Autowired`를 이용해 처리한다.\n\n<br><br><br>\n\n###  📌 `@ComponentScan`의 스캔 대상\n\n\n컴포넌트 스캔은 기본적으로 `@Component` 어노테이션이 붙은 클래스를 대상으로 스캔한다. 이름그대로 컴포넌트스캔 이기때문에 컴포넌트를 스캔한다고 생각하면 쉽다.\n\n그러나 `@Component`만 스캔하는 것은 아니다. 다음 내용들도 스캔 대상에 포함된다.\n- `@Component` : 컴포넌트 스캔에 사용\n- `@Controller` : 스프링 MVC 컨트롤러로 지정\n- `@Service` : 스프링 비즈니스 로직으로 지정\n- `@Repository` : 스프링 데이터 접근 계층으로 지정\n- `@Configuration` : 스프링 설정 정보로 지정\n\n위 어노테이션들을 스캔하는 이유가 있다. 각 어노테이션을 뜯어보면 모두 `@Component` 를 포함하고 있다. 때문에 컴포넌트 스캔 대상에 포함되는 것이다.\n\n<br><Br><br>\n\n###  📌 `@ComponentScan`의 스캔 시작 위치\n\n컴포넌트 스캔은 시작위치를 지정할 수 있다.\n\n```java\n// 하나의 패키지를 시작위치로 지정\n@ComponentScan( basePackages =\"hello.core\" )\n\n// 여러개의 패키지를 시작위치로 지정\n@ComponentScan( basePackages = {\"hello.core\", \"hello.service\"} )\n```\n\n- `basePackages` : 탐색할 패키지의 시작위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.\n- `basePackageClasses` : 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.\n- 만약 지정하지 않으면 `@ComponentScan` 이 붙은 설정정보 클래스의 패키지가 시작위치가 된다.\n\n<br><Br>\n\n####  📌 `@ComponentScan`의 스캔 시작 위치 예제\n\n다음과 같은 패키지 구조를 가진 스프링 프로젝트가 있다고 하자.\n\n```\ncom.example.myapp\n├── controllers\n│   └── UserController.java\n├── services\n│   └── UserService.java\n└── repositories\n    └── UserRepository.java\n```\n\ncontrollers 패키지와 services 패키지를 컴포넌트 스캔의 시작 위치로 지정하고자 하면 다음과 같이 코드를 작성할 수 있다.\n\n<br>\n\n```java\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan(basePackages = {\"com.example.myapp.controllers\", \"com.example.myapp.services\"})\npublic class AppConfig {\n    // AppConfig configuration\n}\n```\n이러면 `com.example.myapp.controllers` 패키지와 `com.example.myapp.services` 패키지를 컴포넌트 스캔의 시작위치로 지정하여 수행하고 하위 패키지가 따로 없기때문에 두개의 패키지만 컴포넌트 스캔이 진행된다.\n\n<br><Br><br>\n\n###  📌 컴포넌트 스캔 시작위치 권장 방법\n\n**요즘은 컴포넌트 스캔의 시작위치를 따로 지정해주지 않는 방식을 주로 택한다.** 시작위치를 지정해주지 않으면 디폴트값은 `@ComponentScan` 어노테이션이 달려있는 설정정보 클래스의 패키지를 기준으로 하위 모든 패키지로 지정된다.\n\n이를 잘 활용해 설정정보 클래스를 프로젝트의 시작 루트에 생성하고 `@ComponentScan` 을 붙임으로써 모든 패키지가 컴포넌트 스캔의 대상이 될 수 있도록 설정한다.\n<br>\n\n```java\ncom.example.myapp\n│   \n├── AppConfig.java\n│   \n├── controllers\n│   └── UserController.java\n│   \n├── services\n│   └── UserService.java\n│   \n└── repositories\n    └── UserRepository.java\n```\n위 패키지 구조처럼 프로젝트의 시작 루트에 `AppConfig.java` 라는 설정정보를 위치하고 해당 클래스에 `@ComponentScan`을 붙이는게 요즘 권장사항이다..!\n\n\n<br><Br><br>\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1794458094,"tx":269},"06MckntYpMDISZ8b/syncedContent":{"id":"06MckntYpMDISZ8b/syncedContent","type":"syncedContent","historyData":{"-1794458094":{"id":"06MckntYpMDISZ8b/content","type":"content","text":"---\npermalink: /2023-07-11-컴포넌트 스캔(@ComponentScan)/\npublished: true\ntitle: \"[스프링] 컴포넌트 스캔(ComponentScan)\"\ndate: 2023-07-11 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"컴포넌트 스캔(@ComponentScan)\"\ncategories:\n- Spring\ntags:\n- Spring\n- 카카오 클라우드 스쿨\n---\n\n<br><br>\n\n## ✅ 컴포넌트 스캔이란?\n\n**의존성 주입을 위해 스프링은 어플리케이션 컨텍스트를 생성한다. 스프링은 객체를 인스턴스화 하고 이를 어플리케이션 컨텍스트에 추가하는데 이때 인스턴스화 된 객체를 우리는 스프링 빈 혹은 컴포넌트 라고 부른다.**\n\n**이때, 어플리케이션 컨텍스트에 스프링 빈(컴포넌트)으로 등록될 클래스들을 스캔하여 빈으로 등록해주는 과정을 우리는 컴포넌트 스캔 이라고 부른다.**\n\n**다른말로 스프링 빈으로 등록될 클래스패스(Classpath)를 스캔하여 빈으로 등록해주는 과정을 컴포넌트 스캔이라고 한다.**\n\n컴포넌트 스캔이 무엇인지 모르는 상태라면 기존에 스프링 빈을 등록할 때는 자바 코드의 `@Bean`이나 XML의 `<bean>`을 통해서 설정 정보를 직접 등록했을 것이다. 그러나 이렇게 등록해야 할 **스프링 빈의 수가 엄청 많아지게 되면 일일이 등록하기도 힘들뿐더러, 설정정보의 양도 많아지고 실수가 생길 수 있다.**\n\n그래서 스프링에서는 **설정정보 없이 자동으로 스프링 빈을 등록하는 컴포넌트 스캔**을 제공한다. 추가적으로 의존관계를 자동으로 주입해주는 `@Autowired` 까지 함께 알아보도록 하겠다.\n\n먼저 비교를 위해 기존 `@Bean`을 사용한 스프링 빈 등록방법과 DI를 적용한 코드를 살펴보고 컴포넌트 스캔과의 차이를 살펴보도록 하자.\n\n<br><br><br>\n\n###  📌 `@Bean` 을 사용한 스프링 빈 등록\n\n```java\npackage hello.core;  \n  \nimport hello.core.discount.DiscountPolicy;  \nimport hello.core.discount.FixDiscountPolicy;  \nimport hello.core.member.MemberService;  \nimport hello.core.member.MemberServiceImpl;  \nimport hello.core.member.MemoryMemberRepository;  \nimport hello.core.order.OrderService;  \nimport hello.core.order.OrderServiceImpl;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  // 설정 정보 등록\npublic class AppConfig {  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemberService memberService(){  \n\t\treturn new MemberServiceImpl(memoryMemberRepository());  // 의존성 주입\n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic OrderService orderService(){  \n\t\treturn new OrderServiceImpl(memoryMemberRepository(), discountPolicy());  // 의존성 주입\n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemoryMemberRepository memoryMemberRepository(){  \n\t\treturn new MemoryMemberRepository();  \n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic DiscountPolicy discountPolicy(){  \n\t\treturn new FixDiscountPolicy();  \n\t}  \n}\n```\n<br>\n기존 스프링 빈을 등록하는 방식의 코드이다.\n\n1. 설정정보를 담고있는 클래스에 `@Configuration` 태그 사용\n2. 스프링 빈으로 등록할 객체에 `@Bean` 태그 사용\n3. 스프링 빈에 생성자 형태로 의존성 주입\n\n일반적으로는 이러한 방식으로 스프링 빈을 등록했을 것이다. 그러나 앞서 언급한 것처럼 위와 같은 방식은 편의성이 많이 떨어지기 때문에 스프링에서는 `@ComponentScan` 이라는 기능을 제공한다.\n\n<br><Br><Br>\n\n###  📌 `@ComponentScan` 을 사용한 스프링 빈 등록\n\n```java\npackage hello.core; \n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType; \n\nimport static org.springframework.context.annotation.ComponentScan.*; \n\n@Configuration \n@ComponentScan\npublic class AutoAppConfig { \n\n}\n```\n\n컴포넌트 스캔을 사용하기 위해서는 `@ComponentScan`을 설정정보에 붙여주기만 하면 된다. 기존에는 `@Bean`을 사용해 스프링 빈을 등록해줬지만 여기에는 하나도 없는것을 볼 수 있다. 컴포넌트 스캔을 사용할 때 스프링 빈 등록은 `@Component` 태그를 붙여줌으로써 가능해진다.  \n\n<br><br>\n\n####  📌 MemoryMemberRepository에  `@Component` 추가\n```java\n@Component \npublic class MemoryMemberRepository implements MemberRepository {}\n```\n<br>\n\n####  📌 RateDiscountPolicy 에  `@Component` 추가\n```java\n@Component \npublic class RateDiscountPolicy implements DiscountPolicy {}\n```\n<br>\n\n####  📌 MemberServiceImpl 에  `@Component` 추가 + `@Autowired` DI\n```java\n@Component \npublic class MemberServiceImpl implements MemberService { \n\tprivate final MemberRepository memberRepository; \n\n\t@Autowired \n\tpublic MemberServiceImpl(MemberRepository memberRepository) {\n\t\tthis.memberRepository = memberRepository; \n\t}\n}\n```\n<br>\n\n####  📌 OrderServiceImpl 에  `@Component` 추가 + `@Autowired` DI\n```java\n@Component \npublic class OrderServiceImpl implements OrderService { \n\n\tprivate final MemberRepository memberRepository; \n\tprivate final DiscountPolicy discountPolicy; \n\n\t@Autowired \n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { \n\t\tthis.memberRepository = memberRepository; \n\t\tthis.discountPolicy = discountPolicy; \n\t} \n}\n```\n\n<br>\n\n빈으로 등록하려는 클래스에 `@Component` 를 붙여줌으로써 컴포넌트 스캔을 사용한 스프링 빈 등록이 가능해진다. 또한 `@Autowired` 태그를 붙이면 자동으로 의존관계를 주입해주는 기능을 한다. 이를 통해 더이상 `@Bean`을 사용한 스프링 빈 등록과 의존성 주입을 할 필요 없이 편하게 스프링 빈을 등록할 수 있게 되었다. 이 과정을 정리하면 다음과 같다.\n\n1. 설정정보 클래스에 `@ComponentScan` 어노테이션을 추가해준다.\n2. 스프링 빈으로 등록할 클래스에 `@Component` 어노테이션을 추가하여 `@ComponentScan`의 대상이 되도록 지정하고 스프링 빈으로 등록해준다.\n3. 스프링 빈으로 등록할 때 필요한 DI는 `@Autowired`를 이용해 처리한다.\n\n<br><br><br>\n\n###  📌 `@ComponentScan`의 스캔 대상\n\n\n컴포넌트 스캔은 기본적으로 `@Component` 어노테이션이 붙은 클래스를 대상으로 스캔한다. 이름그대로 컴포넌트스캔 이기때문에 컴포넌트를 스캔한다고 생각하면 쉽다.\n\n그러나 `@Component`만 스캔하는 것은 아니다. 다음 내용들도 스캔 대상에 포함된다.\n- `@Component` : 컴포넌트 스캔에 사용\n- `@Controller` : 스프링 MVC 컨트롤러로 지정\n- `@Service` : 스프링 비즈니스 로직으로 지정\n- `@Repository` : 스프링 데이터 접근 계층으로 지정\n- `@Configuration` : 스프링 설정 정보로 지정\n\n위 어노테이션들을 스캔하는 이유가 있다. 각 어노테이션을 뜯어보면 모두 `@Component` 를 포함하고 있다. 때문에 컴포넌트 스캔 대상에 포함되는 것이다.\n\n<br><Br><br>\n\n###  📌 `@ComponentScan`의 스캔 시작 위치\n\n컴포넌트 스캔은 시작위치를 지정할 수 있다.\n\n```java\n// 하나의 패키지를 시작위치로 지정\n@ComponentScan( basePackages =\"hello.core\" )\n\n// 여러개의 패키지를 시작위치로 지정\n@ComponentScan( basePackages = {\"hello.core\", \"hello.service\"} )\n```\n\n- `basePackages` : 탐색할 패키지의 시작위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.\n- `basePackageClasses` : 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.\n- 만약 지정하지 않으면 `@ComponentScan` 이 붙은 설정정보 클래스의 패키지가 시작위치가 된다.\n\n<br><Br>\n\n####  📌 `@ComponentScan`의 스캔 시작 위치 예제\n\n다음과 같은 패키지 구조를 가진 스프링 프로젝트가 있다고 하자.\n\n```\ncom.example.myapp\n├── controllers\n│   └── UserController.java\n├── services\n│   └── UserService.java\n└── repositories\n    └── UserRepository.java\n```\n\ncontrollers 패키지와 services 패키지를 컴포넌트 스캔의 시작 위치로 지정하고자 하면 다음과 같이 코드를 작성할 수 있다.\n\n<br>\n\n```java\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan(basePackages = {\"com.example.myapp.controllers\", \"com.example.myapp.services\"})\npublic class AppConfig {\n    // AppConfig configuration\n}\n```\n이러면 `com.example.myapp.controllers` 패키지와 `com.example.myapp.services` 패키지를 컴포넌트 스캔의 시작위치로 지정하여 수행하고 하위 패키지가 따로 없기때문에 두개의 패키지만 컴포넌트 스캔이 진행된다.\n\n<br><Br><br>\n\n###  📌 컴포넌트 스캔 시작위치 권장 방법\n\n**요즘은 컴포넌트 스캔의 시작위치를 따로 지정해주지 않는 방식을 주로 택한다.** 시작위치를 지정해주지 않으면 디폴트값은 `@ComponentScan` 어노테이션이 달려있는 설정정보 클래스의 패키지를 기준으로 하위 모든 패키지로 지정된다.\n\n이를 잘 활용해 설정정보 클래스를 프로젝트의 시작 루트에 생성하고 `@ComponentScan` 을 붙임으로써 모든 패키지가 컴포넌트 스캔의 대상이 될 수 있도록 설정한다.\n<br>\n\n```java\ncom.example.myapp\n│   \n├── AppConfig.java\n│   \n├── controllers\n│   └── UserController.java\n│   \n├── services\n│   └── UserService.java\n│   \n└── repositories\n    └── UserRepository.java\n```\n위 패키지 구조처럼 프로젝트의 시작 루트에 `AppConfig.java` 라는 설정정보를 위치하고 해당 클래스에 `@ComponentScan`을 붙이는게 요즘 권장사항이다..!\n\n\n<br><Br><br>\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1794458094}},"syncHistory":{"main":[-1794458094,null,null]},"v":1,"hash":1710111658390,"tx":269},"Fr15DxYxCrywoW1c/content":{"id":"Fr15DxYxCrywoW1c/content","type":"content","text":"## 숫자를 문자열로 변환\n\n```java\nint num = 12345;\n\n// toString 사용\nString str = Integer.toString(num);\n\n// valueOf 사용\nString str = String.valueof(num);\n\n// 약간 야매\nString str = \"\"+num;\n```\n\n## 문자열을 숫자로 변환\n\n```java\nString str = \"123456789\";\n\n// Integer.parseInt()\nint num = Integer.parseInt(str);\n\n// Integer.valueOf()\nint num = Integer.valueOf(str);\n```\n\n\n\n## 정수인지 아닌지 판별\n```java\nDouble num = 15.23;\t// 이때 double이 아니라 Double 객체로 선언\n\t\t\t\t\t// double은 자료형이고 Double은 객체라 Double객체 안에 포함된 다양한 메서드를 사용 가능 \n\nif(num==num.IntValue()) -> 이렇게 하면 정수인지 아닌지 판별 가능\n```\n\n\n## 배열 선언후 초기화\n배열은 선언 후 `{}` 로 초기화는 불가능하다. \n선언과 동시에 초기화는 가능\n\n\n## String을 String 배열로 변환\n```java\nString s = \"안녕하세요\";\nString[] arr = s.split(\"\");\n```\n\n\n## 대문자인지 소문자인지 판별\n```java\nCharacter.isLowerCase('A') -> false\nCharacter.isUpperCase('A') -> true\n\nCharacter.isLowerCase('a') -> true\nCharacter.isUpperCase('a') -> false\n```\n\n## Long 범위\n-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\n\n19자리!\n\n\n\n## String 배열에 값 추가하기\n\nString[] arr = \n\narr[i] += str;\n이거 안됨\n\nnull이 출력값 맨 앞에 붙는 이유는 다음 부분에서 발생합니다:\n\njavaCopy code\n\n`String[] answer = new String[n];` \n\nJava에서 배열을 생성하면 해당 배열의 모든 요소는 초기화됩니다. `String` 배열의 초기값은 `null`입니다. 따라서 `answer` 배열의 각 요소는 `null`로 초기화됩니다.\n\n그런 다음 `answer` 배열의 요소에 문자열을 추가하려고 할 때 `+=` 연산자를 사용합니다:\n\njavaCopy code\n\n`answer[i] += \"#\";` \n\n여기서 문제가 발생합니다. `answer[i]`의 초기값은 `null`이기 때문에 `null`과 문자열 `#`을 연결하려고 하면 `null`과 `#`이 결합되어 `null#`이라는 결과를 얻게 됩니다. 따라서 출력값에서 `null`이 맨 앞에 붙는 것을 볼 수 있습니다.\n\n해결 방법은 `answer` 배열의 요소를 빈 문자열로 초기화하면 됩니다. 예를 들면 다음과 같이 변경할 수 있습니다:\n\njavaCopy code\n\n`String[] answer = new String[n];\nArrays.fill(answer, \"\");` \n\n이렇게 하면 `answer` 배열의 각 요소가 빈 문자열로 초기화되므로 `null`이 출력값에서 사라집니다.\n\n\n\n## 문자열 치환하기\n```java\nString s = \"onetwothreefourfive\"\nString[] numStr = {\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\n                     \"six\", \"seven\", \"eight\", \"nine\"};\n\nfor(int i=0;i<numStr.length();i++){\n\ts = s.replaceAll(numStr[i],i);\n}\n```\n\n## 문자열 뒤집기\n```java\nString s = \"123456789\";\nStringBuilder sb = new StringBuilder(s);\nString temp = sb.reverse().toString();\n```\n\n\n## int 배열 Integer 배열로 변경\n```java\nint arr = {1,5,2,7,3,8};\nInteger[] arr2 = Arrays.stream(arr).boxed().toArray(Integer[]::new);\n// int배열 내림차순 정렬하려면 Collection.reverseOrder() 써야하는데 이게 Integer배열만 받기때문에 이렇게 사용\n```\n\n\n## 다음 순열\n```java\npublic  static  boolean  nextPermutation(int[] nums) {\n\n\tint  a = nums.length-2;\n\n\twhile(a>=0 && nums[a]>=nums[a+1]) a--;\n\tif(a<0) return  false;\n\n\tint b = nums.length-1;\n\n\twhile(nums[a]>nums[b]) b--;\n\tswap(nums,a,b);\n\n\tint  start = a+1;\n\tint  end = nums.length-1;\n\n\twhile(start<end) swap(nums,start++,end--);\n\n\treturn  true;\n}\n```\n\n<br><br>\n\n## 십진수를 이진수로\n```java\nint num = 13;\nString binaryString = Integer.toBinaryString(num);\nSystem.out.println(binaryString) // 1101\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-28015155,"tx":271},"Fr15DxYxCrywoW1c/syncedContent":{"id":"Fr15DxYxCrywoW1c/syncedContent","type":"syncedContent","historyData":{"-28015155":{"id":"Fr15DxYxCrywoW1c/content","type":"content","text":"## 숫자를 문자열로 변환\n\n```java\nint num = 12345;\n\n// toString 사용\nString str = Integer.toString(num);\n\n// valueOf 사용\nString str = String.valueof(num);\n\n// 약간 야매\nString str = \"\"+num;\n```\n\n## 문자열을 숫자로 변환\n\n```java\nString str = \"123456789\";\n\n// Integer.parseInt()\nint num = Integer.parseInt(str);\n\n// Integer.valueOf()\nint num = Integer.valueOf(str);\n```\n\n\n\n## 정수인지 아닌지 판별\n```java\nDouble num = 15.23;\t// 이때 double이 아니라 Double 객체로 선언\n\t\t\t\t\t// double은 자료형이고 Double은 객체라 Double객체 안에 포함된 다양한 메서드를 사용 가능 \n\nif(num==num.IntValue()) -> 이렇게 하면 정수인지 아닌지 판별 가능\n```\n\n\n## 배열 선언후 초기화\n배열은 선언 후 `{}` 로 초기화는 불가능하다. \n선언과 동시에 초기화는 가능\n\n\n## String을 String 배열로 변환\n```java\nString s = \"안녕하세요\";\nString[] arr = s.split(\"\");\n```\n\n\n## 대문자인지 소문자인지 판별\n```java\nCharacter.isLowerCase('A') -> false\nCharacter.isUpperCase('A') -> true\n\nCharacter.isLowerCase('a') -> true\nCharacter.isUpperCase('a') -> false\n```\n\n## Long 범위\n-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\n\n19자리!\n\n\n\n## String 배열에 값 추가하기\n\nString[] arr = \n\narr[i] += str;\n이거 안됨\n\nnull이 출력값 맨 앞에 붙는 이유는 다음 부분에서 발생합니다:\n\njavaCopy code\n\n`String[] answer = new String[n];` \n\nJava에서 배열을 생성하면 해당 배열의 모든 요소는 초기화됩니다. `String` 배열의 초기값은 `null`입니다. 따라서 `answer` 배열의 각 요소는 `null`로 초기화됩니다.\n\n그런 다음 `answer` 배열의 요소에 문자열을 추가하려고 할 때 `+=` 연산자를 사용합니다:\n\njavaCopy code\n\n`answer[i] += \"#\";` \n\n여기서 문제가 발생합니다. `answer[i]`의 초기값은 `null`이기 때문에 `null`과 문자열 `#`을 연결하려고 하면 `null`과 `#`이 결합되어 `null#`이라는 결과를 얻게 됩니다. 따라서 출력값에서 `null`이 맨 앞에 붙는 것을 볼 수 있습니다.\n\n해결 방법은 `answer` 배열의 요소를 빈 문자열로 초기화하면 됩니다. 예를 들면 다음과 같이 변경할 수 있습니다:\n\njavaCopy code\n\n`String[] answer = new String[n];\nArrays.fill(answer, \"\");` \n\n이렇게 하면 `answer` 배열의 각 요소가 빈 문자열로 초기화되므로 `null`이 출력값에서 사라집니다.\n\n\n\n## 문자열 치환하기\n```java\nString s = \"onetwothreefourfive\"\nString[] numStr = {\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\n                     \"six\", \"seven\", \"eight\", \"nine\"};\n\nfor(int i=0;i<numStr.length();i++){\n\ts = s.replaceAll(numStr[i],i);\n}\n```\n\n## 문자열 뒤집기\n```java\nString s = \"123456789\";\nStringBuilder sb = new StringBuilder(s);\nString temp = sb.reverse().toString();\n```\n\n\n## int 배열 Integer 배열로 변경\n```java\nint arr = {1,5,2,7,3,8};\nInteger[] arr2 = Arrays.stream(arr).boxed().toArray(Integer[]::new);\n// int배열 내림차순 정렬하려면 Collection.reverseOrder() 써야하는데 이게 Integer배열만 받기때문에 이렇게 사용\n```\n\n\n## 다음 순열\n```java\npublic  static  boolean  nextPermutation(int[] nums) {\n\n\tint  a = nums.length-2;\n\n\twhile(a>=0 && nums[a]>=nums[a+1]) a--;\n\tif(a<0) return  false;\n\n\tint b = nums.length-1;\n\n\twhile(nums[a]>nums[b]) b--;\n\tswap(nums,a,b);\n\n\tint  start = a+1;\n\tint  end = nums.length-1;\n\n\twhile(start<end) swap(nums,start++,end--);\n\n\treturn  true;\n}\n```\n\n<br><br>\n\n## 십진수를 이진수로\n```java\nint num = 13;\nString binaryString = Integer.toBinaryString(num);\nSystem.out.println(binaryString) // 1101\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-28015155}},"syncHistory":{"main":[-28015155,null,null]},"v":1,"hash":1710111659389,"tx":271},"miFoxjEkLW2xg652/content":{"id":"miFoxjEkLW2xg652/content","type":"content","text":"## 회원가입\n\njoin.jsp에서 정보 입력\n가입하기 버튼 클릭 \n-> POST방식으로 action : /member/join 으로 전송\n-> MemberController.java에서 joinPOST 메서드 실행\n-> memberService.memberJoin(member) 호출!\n-> MemberService.java 에서 Membermapper.memberJoin(member) 호출\n-> MemberMapper.java에서 memberJoin(MemberVO member) 호출\n-> MemberMapper.xml 에서 id=\"memberJoin\" 쿼리문 실행\n-> DB에서 쿼리문 실행\n\n\n회원정보 DB저장 -> 테이블 생성 -> 데이터를 담을 객체인 MemberVO 생성  \n-> MemberMapper.xml을 통해서 쿼리문 작성 ( MyBatis 사용 )\n-> MemberMapper.java 인터페이스를 추가해서 회원가입 메소드 생성\n-> MemberService.java 인터페이스에 회원가입 메소드 생성\n-> MemberServiceImpl.java 클래스가 MemberService를 implements하고 MemberMapper 클래스를 객체로 가짐\n-> MemberServiceImpl에서 회원가입 메소드를 구현하고, memberMapper.memberJoin(member)를 실행!\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/buybooks1.jpg?raw=true\">\n</p>\n\n### 메일 인증\nSMTP를 이용했음\npox.xml 설정\nmailSender Bean등록\nController메서드 추가\n메일 계정 보안 설정\n\njsp에서 인증번호 전송 클릭 -> 클릭이벤트로 ajax실행 -> 인증번호 생성 컨트롤러에서 인증번호 생성 후 메일전송 & 인증번호를 return -> return받은 인증번호와 사용자가 입력한 인증번호가 일치하는지 확인 \n\n\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1886577830,"tx":275},"miFoxjEkLW2xg652/syncedContent":{"id":"miFoxjEkLW2xg652/syncedContent","type":"syncedContent","historyData":{"-1886577830":{"id":"miFoxjEkLW2xg652/content","type":"content","text":"## 회원가입\n\njoin.jsp에서 정보 입력\n가입하기 버튼 클릭 \n-> POST방식으로 action : /member/join 으로 전송\n-> MemberController.java에서 joinPOST 메서드 실행\n-> memberService.memberJoin(member) 호출!\n-> MemberService.java 에서 Membermapper.memberJoin(member) 호출\n-> MemberMapper.java에서 memberJoin(MemberVO member) 호출\n-> MemberMapper.xml 에서 id=\"memberJoin\" 쿼리문 실행\n-> DB에서 쿼리문 실행\n\n\n회원정보 DB저장 -> 테이블 생성 -> 데이터를 담을 객체인 MemberVO 생성  \n-> MemberMapper.xml을 통해서 쿼리문 작성 ( MyBatis 사용 )\n-> MemberMapper.java 인터페이스를 추가해서 회원가입 메소드 생성\n-> MemberService.java 인터페이스에 회원가입 메소드 생성\n-> MemberServiceImpl.java 클래스가 MemberService를 implements하고 MemberMapper 클래스를 객체로 가짐\n-> MemberServiceImpl에서 회원가입 메소드를 구현하고, memberMapper.memberJoin(member)를 실행!\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/buybooks1.jpg?raw=true\">\n</p>\n\n### 메일 인증\nSMTP를 이용했음\npox.xml 설정\nmailSender Bean등록\nController메서드 추가\n메일 계정 보안 설정\n\njsp에서 인증번호 전송 클릭 -> 클릭이벤트로 ajax실행 -> 인증번호 생성 컨트롤러에서 인증번호 생성 후 메일전송 & 인증번호를 return -> return받은 인증번호와 사용자가 입력한 인증번호가 일치하는지 확인 \n\n\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1886577830}},"syncHistory":{"main":[-1886577830,null,null]},"v":1,"hash":1710111661691,"tx":275},"1hoxohbjUViggy6d/content":{"id":"1hoxohbjUViggy6d/content","type":"content","text":"---\npermalink: /2023-07-14-의존관계 자동 주입/\npublished: true\ntitle: \"[스프링] 의존관계 자동 주입\"\ndate: 2023-07-14 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"의존관계 자동 주입\"\ncategories:\n- Spring\ntags:\n- Spring\n- 카카오 클라우드 스쿨\n---\n\n<br><br>\n\n\n## ✅ 의존관계 주입 방법\n\n###  📌 생성자 주입\n생성자를 통해 의존관계를 주입받는 방식으로 생성자 호출 시점에 딱 1번 호출되는 것이 보장된다. \n\n**불변, 필수** 의존관계에 사용된다.\n\n- 불변한 외부 의존성 : 의존하는 객체가 외부에서 생성되고 한번 주입된 후에는 변경되지 않아야 하는 경우\n- 의존성 주입 후 변경이 불필요한 의존성 : 읽기 전용 데이터베이스 연결, 로깅 구성\n\n- 필수적인 의존성 : 해당 의존성이 없으면 어플리케이션의 실행이나 기능이 제대로 동작하지 않는 경우\n\n- 의존성을 외부에서 주입받는 경우 : 객체 생성 시 외부에서 의존성을 주입받아야 하는 경우 \n\n \n\n \n```java\npublic class OrderServiceImpl implements OrderService{  \n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;  \n\n\t@Autowired \n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  \n\t\tthis.memberRepository = memberRepository;  \n\t\tthis.discountPolicy = discountPolicy;  \n\t}  \n}\n```\n\n```java\n@Configuration  // 설정 정보 등록\npublic class AppConfig {  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemberService memberService(){  \n\t\treturn new MemberServiceImpl(memoryMemberRepository());  // 의존성 주입\n\t}  \n    \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemoryMemberRepository memoryMemberRepository(){  \n\t\treturn new MemoryMemberRepository();  \n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic DiscountPolicy discountPolicy(){  \n\t\treturn new FixDiscountPolicy();  \n\t}  \n}\n```\n위 코드를 보면 `AppConfig` 라는 설정정보를 갖고있는 클래스에서 `MemberService`, `MemoryMemberRepository`, `DiscountPolicy` 에 DI를 적용하고 스프링 빈으로 등록했다.\n\n그리고 `OrderServiceImpl` 클래스에서는 `MemberRepository` 와 `DiscountPolicy` 에 대한 DI를 적용했는데 이때는 `@Autowired` 어노테이션을 통해 DI를 적용한 것이다.\n\n**DI된 스프링 빈**들이 final 키워드를 붙혀 필수값인 경우에 생성자 주입을 통해 의존관계를 주입한다.\n\n이 때 반드시!! **DI가 완료된 스프링 빈**을 생성자의 파라미터로 DI해야만 한다. \n\n**이는 스프링의 의존성 주입 원칙과 관련이 있는데 스프링은 의존성 주입을 통해 객체간의 결합도를 낮추고 유연성을 높이는 것을 지향한다. 이를 위해 스프링은 생성자를 통해 DI를 할때 객체의 생성과 동시에 의존성이 주입되어야 한다는 원칙을 따른다.**\n\n**또한 생성자는 컴파일시에 호출되기 때문에 생성자를 통해 주입할 의존성은 빈으로 등록되어 있어야 생성자를 통한 DI가 가능한 이유도 있다.**\n\n**중요! 생성자가 단 하나인경우에는 `@Autowired` 어노테이션이 생략가능하다.**\n\n<br><br>\n\n굳이 `OrderServiceImpl` 클래스에서 `@Autowired`태그를 이용한 DI 말고 기존 `AppConfig` 클래스에서 `@Bean` 어노테이션을 사용해 DI를 주입할 수도 있다.\n\n```java\n@Configuration  // 설정 정보 등록\npublic class AppConfig {  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemberService memberService(){  \n\t\treturn new MemberServiceImpl(memoryMemberRepository());  // 의존성 주입\n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemoryMemberRepository memoryMemberRepository(){  \n\t\treturn new MemoryMemberRepository();  \n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic DiscountPolicy discountPolicy(){  \n\t\treturn new FixDiscountPolicy();  \n\t}\n\n\t@Bean  // 스프링 빈으로 등록\n\tpublic OrderService orderService(){  \n\t\treturn new OrderServiceImpl(memoryMemberRepository(), discountPolicy());  // 의존성 주입\n\t}  \n}\n```\n\n코드 마지막 부분을 보면 `OrderService`에 `OrderServiceImpl` 를 DI해주고 , `OrderServiceImpl` 에 다시 `memoryMemberRepository, discountPolicy` 를 DI해준걸 볼 수 있다. 앞서 언급한 `@Autowired` DI와 같은 역할을 하는 코드이다.\n\n\n<br><br><br>\n\n###  📌 수정자(Setter) 주입\n자바 빈 규약에 따라 Setter를 통해 필드의 값을 수정할 수 있는 수정자 메서드를 통해 의존관계를 주입할 수 있다.\n\n**선택, 변경** 가능성이 있는 의존관계에 사용된다.\n\n```java\npublic class OrderServiceImpl implements OrderService{  \n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;  \n\n\t@Autowired \n\tpublic void setMemberRepository(MemberRepository memberRepository) {\n\t\tthis.memberRepository = memberRepository;\n\t}\n\n\t@Autowired\n\tpublic void setDiscountPolicy(DiscountPolicy discountPolicy) {\n\t\tthis.discountPolicy = discountPolicy;\n\t}\n}\n```\n\n각각의 수정자(Setter) 메서드에 `@Autowired` 어노테이션을 붙여 의존관계를 주입한다.\n\n수정자 주입은 생성자 주입과는 다르게 의존 관계로 주입되어야 할 객체가 스프링 빈으로 등록되지 않아도 사용이 가능하다. \n\n그러나 `@Autowired` 어노테이션은 주입 할 대상이 없으면 오류가 발생하는데, 오류가 발생하지 않게 하려면 속성으로 (`required = false`) 를 지정하면 된다.\n\n<br><br><Br>\n\n###  📌 필드 주입\n필드에 바로 의존성을 주입하는 방식도 있다.\n\n```java\n@Component\npublic class OrderServiceImpl implements OrderService{  \n\t\n\t@Autowired\n\tprivate final MemberRepository memberRepository;\n\t\n\t@Autowired\n\tprivate final DiscountPolicy discountPolicy;  \n```\n\n접근제어자가 `private` 인 경우 외부에서 값을 변경하거나 접근하는게 불가능하지만 `@Autowired`를 사용하면 문제없이 DI가 가능하다.\n\n**그러나 외부에서의 변경 및 테스트가 어렵다는 큰 단점이 있다.**\n\n<br>\n\n❗❗ **왜 테스트가 어려울까 ?**\n\n간단한 예시를 통해 알아보자.\n\nUserService\n\n-   매우 간단한 기능만 가지고 있음\n-   그럼에도 불구하고 세 가지 타입의 의존 오브젝트가 필요\n    1.  UserDao : DB 처리 **( 필드를 통한 DI를 했다고 가정 )**\n    2.  MailSender : 메일 처리 **( 필드를 통한 DI를 했다고 가정 )**\n    3.  PlatformTransactionManager : 트랜잭션 처리 **( 필드를 통한 DI를 했다고 가정 )**\n\nUserServiceTest\n\n-   본래의 목적 : UserService에 대한 테스트\n-   세 가지 의존관계를 갖고 있으므로 테스트가 진행되는 동안 세 가지 오브젝트가 모두 정상이어야 한다.\n-   실제로는 해당 오브젝트의 뒤에 존재하는 훨씬 더 많은 오브젝트와 환경, 서비스, 서버 등을 함께 테스트하는 것\n\n이런 상황이 있을 때, 우리는 UserService의 간단한 기능만 테스트 하고 싶다. 그러나 DB, 메일, 트랜젝션을 처리하는 메소드들이 존재하기 때문에 이를 제외하고 테스트를 하는 편이 훨씬 효율적이다.\n\n만약 생성자를 통한 DI를 활용해 세가지 기능에 대한 DI를 했다면, 우리는 스프링이 제공하는 `mock` 라이브러리를 통해 세가지 기능을 제외하거나, 임의의 값을 넣어준다던가, 생성자에 가상 오브젝트를 주입하여 복잡한 로직을 간단하게 처리가 가능하다.\n\n그러나 필드 단위에 DI를 적용해놓은 경우에는, 이미 세가지 기능에 대한 DI가 서비스 단위에 적용되었기 때문에, 앞서 언급한 여러 간단한 처리가 불가능하고, 모든 로직을 다 확인해야만 한다.\n\n때문에 간단한 로직만을 테스트 하고싶어도 포함된 모든 로직을 테스트 해야만 하는 상황이 벌어질수 밖에없다. **그래서 필드에 DI를 하는건 권장하지 않는다.**\n\n<br><Br><Br>\n\n###  📌 일반 메서드 주입\n일반 메서드를 통해서 주입받을 수도 있다.\n\n생성자처럼 한번에 여러 필드를 주입받을수도 있는데, 일반적으로 사용되지는 않는다.\n(생성자 주입이나 수정자주입으로 다 해결되기 때문이다.)\n\n 더하여, 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 한다. 스프링 빈으로 등록되지 않은 클래스(ex: Member와 같은 Domain ) 는 주입받을 수 없다.\n\n```java\n@Component \npublic class OrderServiceImpl implements OrderService { \n\tprivate MemberRepository memberRepository; \n\tprivate DiscountPolicy discountPolicy; \n\n\t@Autowired \n\tpublic void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) { \n\t\tthis.memberRepository = memberRepository; this.discountPolicy = discountPolicy; \n\t} \n}\n```\n\n<br><br><br><br>\n\n## ✅ 생성자 주입 방식을 선택해라!\n\n- 대부분의 의존관계 주입은 한번 일어나면 어플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 어플리케이션 종료 전까지 변하면 안된다.\n- 수정자 주입을 사용하면 setXXX메서드를 public으로 열어두어야 하는데 이로인해 누군가 변경할 수있게되고 이는 좋은 설계 방법이 아니다.\n- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출될 일이 없다. 따라서 불변하게 설계할 수 있다.\n\n\n<br><Br><Br>\n\n###  📌 final 키워드를 사용해라\n\n생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.\n\n```java\n@Component\npublic class OrderServiceImpl implements OrderService {\n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;\n \n\t@Autowired // 생략가능\n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {\n\t\tthis.memberRepository = memberRepository;\n\t}\n //...\n}\n```\n\n위 코드를 보면 `discountPolicy`에 값을 설정하는 부분이 누락되었다. 자바는 이를 컴파일 오류를 발생시킨다. `java: variable discountPolicy might not have been initialized`\n\n또한 생성자 주입을 제외한 나머지 주입 방식은 생성자 이후에 호출되기 때문에 필드에 `final` 키워드를 사용할 수 없다. 오직 생성자 주입 방식만 `final`키워드를 사용 할 수 있다.\n\n<br><br><br>\n\n###  📌 롬복을 활용해라\n\n최근 프로젝트를 진행하며 배운점인데, 실제로 개발단계에서는 생성자 주입방식을 거의 대부분 사용하고 불변했다. 그래서 실제로 `final`키워드를 사용했다. 그리고 롬복을 활용하여 코드를 최적화 했는데 다음 코드들을 비교하며 어떤 방식으로 최적화가 되는지 살펴보자.\n\n<br><br>\n\n⭐**기본코드**\n```java\n@Component\npublic class OrderServiceImpl implements OrderService {\n\n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;\n \n\t@Autowired\n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {\n\t\tthis.memberRepository = memberRepository;\n\t\tthis.discountPolicy = discountPolicy;\n\t}\n}\n```\n<br><br>\n\n\n**⭐ Autowired 생략 코드**\n```java\n@Component\npublic class OrderServiceImpl implements OrderService {\n\n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;\n \n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {\n\t\tthis.memberRepository = memberRepository;\n\t\tthis.discountPolicy = discountPolicy;\n\t}\n}\n```\n\n<br><br>\n\n**⭐ 롬복 적용 코드**\n```java\n@Component\n@RequiredArgsConstructor\npublic class OrderServiceImpl implements OrderService {\n\n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;\n}\n```\n\n롬복 라이브러리가 제공하는 `@RequiredArgsConstructor` 기능을 사용하면 `final`이 붙은 필드를 모아서 생성자를 자동으로 만들어준다. 이를 활용하면 정말 깔끔한 코드를 만들 수 있다!\n","properties":"\n","discussions":{},"comments":{},"hash":568030896,"tx":277},"vCSdbkmBz8WS1NuE/content":{"id":"vCSdbkmBz8WS1NuE/content","type":"content","text":"## vagrant 사용법\n1. vagrantFile 설정 후 vagrantfile 파일이 설치된 곳에 cmd로 접근해서 `vagrant up` 명령어 입력하면 가상머신이 vagrantfile에 지정한대로 생성됨 \n2. `vargrant plugin install/uninstall/list` 을 입력해서 플러그인 설치/삭제/확인 가능\n3. `vagrant halt` : 가상 머신 종료\n4. `vagrant destoy` : 가상 머신 삭제\n5. `vagrant status` : 가상머신 확인\n6. `vagrant ssh VMNAME` : 가상머신에 원격접속\n7. `vagrant snapshot create/restore` : 가상머신 스냅샷 관리\n\n\n<br><Br>\n\n## 리눅스 서버 구축 명령어\n`systemctl isolate XXXXXXXX` : \n`systemctl get-default` : \n`sudo systemctl set-dafault XXXXXX` : 위의 디폴트 타겟을 변경해줄수 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":2018250629,"tx":279},"vCSdbkmBz8WS1NuE/syncedContent":{"id":"vCSdbkmBz8WS1NuE/syncedContent","type":"syncedContent","historyData":{"2018250629":{"id":"vCSdbkmBz8WS1NuE/content","type":"content","text":"## vagrant 사용법\n1. vagrantFile 설정 후 vagrantfile 파일이 설치된 곳에 cmd로 접근해서 `vagrant up` 명령어 입력하면 가상머신이 vagrantfile에 지정한대로 생성됨 \n2. `vargrant plugin install/uninstall/list` 을 입력해서 플러그인 설치/삭제/확인 가능\n3. `vagrant halt` : 가상 머신 종료\n4. `vagrant destoy` : 가상 머신 삭제\n5. `vagrant status` : 가상머신 확인\n6. `vagrant ssh VMNAME` : 가상머신에 원격접속\n7. `vagrant snapshot create/restore` : 가상머신 스냅샷 관리\n\n\n<br><Br>\n\n## 리눅스 서버 구축 명령어\n`systemctl isolate XXXXXXXX` : \n`systemctl get-default` : \n`sudo systemctl set-dafault XXXXXX` : 위의 디폴트 타겟을 변경해줄수 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":2018250629}},"syncHistory":{"main":[2018250629,null,null]},"v":1,"hash":1710111664482,"tx":279},"s15Pyg21tX1o16W5/content":{"id":"s15Pyg21tX1o16W5/content","type":"content","text":"# 🍜 오점뭐 ( 오늘 점심 뭐먹지? )\n\n> **오점뭐는 카카오 클라우드 스쿨 수강생들을 대상으로, 당일 점심 식사를 함께할 인원을 구하는 과정을 오프라인보다 시각적이고 편리하게 웹 서비스로 제공하기 위한 서비스입니다.**\n\n\n<br><br>\n\n\n## 💻 프로젝트 개요\n\n카카오 클라우드 스쿨에 등교하며 점심 식사와 함께할 인원에 대한 고민을 하는 클래스 메이트들의 모습을 짧지않은 시간 보아왔습니다. 클래스 메이트들에게 보다 편리하게 점심 식사 스케줄을 세울 기회를 제공함과 동시에, 미니 프로젝트지만 실사용 가치가 있는 웹 서비스를 구현하고자 하는 희망에 “오늘 점심 뭐먹지?” → 오점뭐? 를 기획하게 되었습니다.\n\n본 프로젝트는 2주라는 짧은 개발 기간 동안 협업으로 이루어지는 프로젝트로, 프로젝트 규모를 작게 해 기획부터 개발, 운영, 그리고 유지 보수까지 일반적인 프로젝트에서 이루어지는 과정을 모두 경험하는 것을 목표로 진행했습니다.\n\n<br><br>\n\n- **1차 개발 기간 : 23.07.17~23.07.31**\n- **유지 보수 기간 : 23.08.01~ ing**\n\n- **개발 환경**\n\t- JAVA 11\n\t- SpringBoot 3.1.1\n\t- MyBatis\n\n- **주요기능**\n\t- 회원가입 및 로그인&로그아웃 ( SpringSecurity )\n\t- 회원 탈퇴\n\t- 회원 정보 수정\n\t- 식사 모집글 작성,수정,삭제\n\t- 비동기 Modal창 게시글 조회\n\t- 댓글 작성,조회,수정,삭제\n\t- 페이징 처리\n\t\n\n\n<br><br>\n\n## 📜 프로젝트 구성도\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1093891315,"tx":283},"s15Pyg21tX1o16W5/syncedContent":{"id":"s15Pyg21tX1o16W5/syncedContent","type":"syncedContent","historyData":{"1093891315":{"id":"s15Pyg21tX1o16W5/content","type":"content","text":"# 🍜 오점뭐 ( 오늘 점심 뭐먹지? )\n\n> **오점뭐는 카카오 클라우드 스쿨 수강생들을 대상으로, 당일 점심 식사를 함께할 인원을 구하는 과정을 오프라인보다 시각적이고 편리하게 웹 서비스로 제공하기 위한 서비스입니다.**\n\n\n<br><br>\n\n\n## 💻 프로젝트 개요\n\n카카오 클라우드 스쿨에 등교하며 점심 식사와 함께할 인원에 대한 고민을 하는 클래스 메이트들의 모습을 짧지않은 시간 보아왔습니다. 클래스 메이트들에게 보다 편리하게 점심 식사 스케줄을 세울 기회를 제공함과 동시에, 미니 프로젝트지만 실사용 가치가 있는 웹 서비스를 구현하고자 하는 희망에 “오늘 점심 뭐먹지?” → 오점뭐? 를 기획하게 되었습니다.\n\n본 프로젝트는 2주라는 짧은 개발 기간 동안 협업으로 이루어지는 프로젝트로, 프로젝트 규모를 작게 해 기획부터 개발, 운영, 그리고 유지 보수까지 일반적인 프로젝트에서 이루어지는 과정을 모두 경험하는 것을 목표로 진행했습니다.\n\n<br><br>\n\n- **1차 개발 기간 : 23.07.17~23.07.31**\n- **유지 보수 기간 : 23.08.01~ ing**\n\n- **개발 환경**\n\t- JAVA 11\n\t- SpringBoot 3.1.1\n\t- MyBatis\n\n- **주요기능**\n\t- 회원가입 및 로그인&로그아웃 ( SpringSecurity )\n\t- 회원 탈퇴\n\t- 회원 정보 수정\n\t- 식사 모집글 작성,수정,삭제\n\t- 비동기 Modal창 게시글 조회\n\t- 댓글 작성,조회,수정,삭제\n\t- 페이징 처리\n\t\n\n\n<br><br>\n\n## 📜 프로젝트 구성도\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1093891315}},"syncHistory":{"main":[1093891315,null,null]},"v":1,"hash":1710111666650,"tx":283},"ZQ1P22aGt9pYBZQY/content":{"id":"ZQ1P22aGt9pYBZQY/content","type":"content","text":"---\npermalink: /2023-08-30-외부 프로퍼티 적용/\npublished: true\ntitle: \"[스프링] 외부 프로퍼티 적용\"\ndate: 2023-08-30 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"외부 프로퍼티 적용\"\ncategories:\n- Spring\ntags:\n- Spring\n- 카카오 클라우드 스쿨\n---\n\n<br><br>\n\n카카오 클라우드 스쿨에서 프로젝트를 진행하며 CI/CD를 진행했다. github action을 사용해서 AWS EC2 서버에 jar파일 형태로 배포를 진행했다. 그런데 배포 중 프로퍼티 값 관련 오류가 너무나도 많이 발생했다. 로컬환경에서는 OS에 환경변수를 등록하고 사용했기 때문에 문제없이 동작했지만, EC2에서는 리눅스에 환경변수를 직접 등록해도, 원하지 않는 값들이 호출되거나, 아예 값이 안넘어오는 상황이 많이 발생했다.\n\n문제의 원인은 외부 프로퍼티를 적용할 때 우선순위가 존재하기 때문이였다. 스프링부트는 프로퍼티 값을 적용 할 수 있는 방법이 정말 많기 때문에, 이 방법들에 우선순위를 매겨 우선순위가 높은 방법이 최우선 적용되게끔 설계되어 있다.\n\n이러한 우선순위와, 주로 사용하는 방법들에 대해서 자세히 알아보도록 하자.\n\n<br><Br><br>\n\n## ✅ Property 우선순위\n1. **유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties**\n2.  **테스트에 있는 @TestPropertySource**\n3.  **@SpringBootTest 애노테이션의 properties 애트리뷰트**\n4.  **커맨드 라인 아규먼트**\n5.  SPRING_APPLICATION_JSON (환경 변수 또는 시스템 프로퍼티) 에 들어있는 프로퍼티\n6.  ServletConfig 파라미터\n7.  ServletContext 파라미터\n8.  java:comp/env JNDI 애트리뷰트\n9.  System.getProperties() 자바 시스템 프로퍼티\n10.  **OS 환경 변수**\n11.  RandomValuePropertySource\n12.  **JAR 밖에 있는 특정 프로파일용 application properties**\n13.  **JAR 안에 있는 특정 프로파일용 application properties**\n14.  JAR 밖에 있는 application properties\n15.  **JAR 안에 있는 application properties**\n16.  @PropertySource\n17.  기본 프로퍼티 (SpringApplication.setDefaultProperties)\n\n\n\n<br><Br>\n많이 사용되는 방법 위주로 예제와 함께 살펴보도록 하겠다.\n<br><br>\n\n1. **유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties**\n```java\n# application.properties 파일\n\nspring.datasource.username=아이디 \nspring.datasource.password=비밀번호 \nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\nproperties파일에 값을 노출시키지 않기 위해 JVM에 값을 등록하고 properties파일에서 참조하는 방식으로 사용하려면 다음과 같이 쓰면된다.\n\n```\nspring.datasource.username=${DB_ID}}\n \n","properties":"\n","discussions":{},"comments":{},"hash":655151792,"tx":285},"1yvS1owczbvG7a0y/content":{"id":"1yvS1owczbvG7a0y/content","type":"content","text":"---\npermalink: /2023-08-10-네트워크 토폴로지의 종류와 특징/\npublished: true\ntitle: \"[네트워크] 네트워크 토폴로지의 종류와 특징\"\ndate: 2023-08-10 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"네트워크 토폴로지의 종류와 특징\"\ncategories:\n- 네트워크\ntags:\n- 네트워크\n---\n\n<br><br>\n\n# ✅ 네트워크 토폴로지\n\n네트워크 토폴로지 혹은 네트워크 구성은 네트워크 성능을 결정하는 핵심 요소라고 할 수 있다. 네트워크 토폴로지는 네트워크를 배치하는 방식으로, **링크와 노드들이 어떤 식으로 배치되어 서로 연결되는지를 물리적으로 혹은 논리적으로 설명한다.**\n\n네트워크 토폴로지는 수없이 많고, 각각의 장단점이 있으며 특정 상황에 따라 더 유용한 배치 방식이 달라진다. 이번 포스팅에서는 대표적으로 많이 사용되는 5가지의 네트워크 토폴로지의 장단점과 특징에 대해서 알아보도록 하겠다.\n\n<br><br><br><br>\n\n## ✅ 트리 토폴로지\n\n트리 토폴로지는 계층형 토폴로지라고 하며 트리형태로 배치한 네트워크 구성을 말한다. 노드들이 부모-자식 계층구조로 연결되어 있고, 연결된 두 노드는 하나의 연결만을 상호 공유한다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tree.png?raw=true\">\n</p>\n\n<br>\n\n### 📌 트리 토폴로지의 장점\n- 노드의 추가, 삭제가 쉽다.\n- 성능에 이상이 생긴 경우 네트워크 장애를 해결하기 쉽다.\n\n\n\n### 📌트리 토폴로지의 단점\n- 중앙 노드에 문제가 발생하면, 노드들 끼리의 연결이 끊어진다.\n- 계층구조가 복잡하고 선형배치 구조때문에, 노드를 추가할 수록 관리가 어렵다.\n- 비용이 많이 든다.\n\n\n<br><br><br><br>\n\n## ✅ 버스 토폴로지\n\n버스 토폴로지는 중앙 통신 회선하나에 여러개의 노드가 연결되어 공유하는 네트워크 구성이다. 보통 근거리 통신망(LAN)에 사용한다.\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bus.png?raw=true\">\n</p>\n\n<br>\n\n### 📌 버스 토폴로지의 장점\n- 노드의 추가, 삭제가 쉽다.\n- 네트워크 배치가 단순하기 때문에 비용 효율적이며, 소규모 네트워크에 적합하다.\n\n\n### 📌 버스 토폴로지의 단점\n- 하나의 케이블만을 사용해 통신하기 때문에 보안에 굉장히 취약하다.\n- **스푸핑**이 발생할 수 있다.\n- 케이블에 장애가 발생하면 전체 네트워크가 멈추고, 복구하는데 많은 시간과 비용이 든다.\n- 단방향으로만 데이터 전송이 가능하다.\n\n<br>\n\n> **📄 스푸핑이란?**  \n> LAN상에서 송신부의 패킷을 송신과 관련없는 다른 호스트에 가지 않도록 하는 스위칭 기능을 마비시키거나 속여서 특정노드에 해당 패킷이 오도록 처리하는 것\n\n<br><br><br><br>\n\n## ✅ 스타 토폴로지\n\n가장 흔하게 사용되는 네트워크 토폴로지로, 네트워크 안의 모든 노드가 중앙 허브에 연결되어 있는 구조이다. 중앙 노드는 서버로서 작동하여 데이터의 흐름을 관리한다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/star.png?raw=true\">\n</p>\n\n<br>\n\n### 📌 스타 토폴로지의 장점\n- 노드의 추가, 삭제 및 장애 발견이 쉽다.\n- 패킷의 충돌 가능성이 적다.\n- 노드간 영향을 끼치는것이 적다.\n- 모든 네트워크를 연결하는데 상대적으로 적은 케이블을 사용하기 때문에 시간이 지남에 따라 네트워크 확장 및 관리가 간단하다.\n\n\n### 📌 스타 토폴로지의 단점\n- 중앙 허브에 장애가 발생하면 모든 네트워크가 멈춘다.\n- 초기 설치비용이 비싸다.\n\n\n<br><br><br><br>\n\n## ✅ 링 토폴로지\n\n각각의 노트가 양 옆의 두 노드와 연결되어 고리처럼 하나의 연속된 길을 통해 통신하는 네트워크 구성방식이다. 데이터가 한방향 또는 양방향으로 흐를수 있다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ring.png?raw=true\">\n</p>\n\n### 📌 링 토폴로지의 장점\n- 노드 수가 증가되어도 네트워크 상의 손실이 거의 없다.\n- 데이터의 충돌 가능성이 적다.\n- 장애를 쉽게 발견 가능하다.\n\n\n### 📌 링 토폴로지의 단점\n- 네트워크 구성 변경이 어렵다.\n- 회선에 장애가 발생하면 전체 네트워크에 큰 영향을 끼친다.\n- 노드의 추가 및 제거를 위해선 전체 네트워크를 중단해야 한다.\n\n<br><br><br><br>\n\n## ✅ 메시 토폴로지\n\n망형 토폴로지라고도 하며 그물망처럼 연결되어 있는 네트워크 구조이다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mesh.png?raw=true\">\n</p>\n\n\n### 📌 메시 토폴로지의 장점\n- 안정성과 보안성이 뛰어나다.\n- 장애가 발생해도 여러 경로가 존재하므로 네트워크를 계속 사용할 수 있다.\n- 트래픽의 분산 처리가 가능하다.\n\n\n### 📌 메시 토폴로지의 단점\n- 노드의 추가 및 삭제가 어렵다.\n- 구축비용과 운용비용이 많이 든다.\n","properties":"\n","discussions":{},"comments":{},"hash":-671205607,"tx":289},"2DVrg5MrmpVbUmh6/content":{"id":"2DVrg5MrmpVbUmh6/content","type":"content","text":"---\npermalink: /2023-02-23-HTTP 상태코드(2) - 3xx ( Redirection )\ntitle: \"[HTTP] HTTP 상태코드(2) - 3xx ( Redirection )\"\ndate: 2023-02-23 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- HTTP 상태코드\n---\n<br><br><br><br>\n\n\n## ✅ HTTP 상태코드\n**HTTP 상태코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 의미합니다.** 1xx 부터 5xx 까지 존재하고 각 상태코드 마다 처리 상태에 대한 결과를 알려줍니다.\n\n- 1xx ( Informational ) : 요청이 수신되어 처리중 ( 거의 사용 x )\n- 2xx ( Successful ) : 요청 정상 처리\n- 3xx ( Redirection ) : 요청을 완료하면 추가 행동이 필요\n- 4xx ( Client Error ) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음\n- 5xx ( Server Error ) : 서버 오류, 서버가 정상 요청을 처리하지 못함.\n\n이번 포스팅은 **3xx 상태코드**에 대해서 알아보도록 하겠습니다.\n\n<br><br><br><br><br><br>\n\n## ✅ 3xx 상태 코드 ( Redirection )\n\n3xx 번대의 상태 코드들은 **요청을 완료하기 위해 유저 에이전트의 추가적인 조치가 필요함을 의미**합니다.\n\n- 300 Multiple Choices\n- 301 Moved Permanently\n- 302 Found\n- 303 See Other\n- 304 Not modified\n- 307 Temporary Redirect\n- 308 Permanent Redirect\n\n\n<br><br><br><br><br><br>\n\n## ✅ Redirect란 ?\n요청에 대한 응답 결과에 Location 헤더가 있으면, **Location 위치로 자동 이동**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/redirect.png?raw=true\">\n</p>\n\n<br>\n\n- **영구 리다이렉션** : 특정 리소스의 URI가 영구적으로 이동\n\t- 예) /members -> /users\n\t- 예) /event -> /new-event\n\n- **일시 리다이렉션** : 일시적인 변경\n\t- 주문 완료 후 주문 내역 화면으로 이동\n\t- PRG : Post/Redirect/Get\n\n- **특수 리다이렉션**\n\t- 결과 대신 캐시를 사용\n\n\n<br><br><br><br><br><br>\n\n## ✅ 영구 리다이렉션 - 301, 308\n\n- 리소스의 URI가 영구적으로 이동\n- 원래의 URL을 사용하지 않고 검색엔진에서도 이를 인지한다.\n- **301 Moved Permanently**\n\t- **리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음**\n- **308 Permanent Redirect**\n\t- 301과 기능은 같음\n\t- **리다이렉트시 요청 메서드와 본문을 그대로 유지함**\n\n\n<br><br><br><br><br><br>\n\n## ✅ 301 Moved Permanently\n\n- 리다이렉트 요청시 요청메서드가 **GET**으로 변하고, **본문이 제거될 수 있다.**\n- **301 Moved Permanently는 안전하지 않은 HTTP URL을 HTTPS로 변경하는데 자주 사용된다.**\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/redirect2.png?raw=true\">\n</p>\n\n<br>\n\n위 그림을 보면 HTTP 요청시 POST요청과 본문이 존재한다. 그리고 요청에 대한 응답은 301 Moved Permanently로 /new-event로 리다이렉트 하는 응답을 반환했다.\n\n때문에 HTTP 요청은 GET 메서드로 변경되었고, 본문은 제거 되었다.\n\n<br><br><br><br><br><br>\n\n## ✅ 308 Permanent Redirect\n\n- 301 Moved Permanently와 기능적으로는 같다.\n- 리다이렉트시 요청 메서드와 본문이 그대로 유지된다.\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/redirect3.png?raw=true\">\n</p>\n\n\n<br><br><br><br><br><br>\n\n## ✅ 일시적인 리다이렉션 - 302, 303, 307\n\n**리소스의 URI가 일시적으로 변경된다.**\n\n\n- **302 Found**\n\t- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다.\n- **303 See Other**\n\t- 302와 기능은 같고 요청메서드가 GET으로 변경된다.\n- **307 Temporary Redirect**\n\t- 302와 기능은 같으나 요청메서드와 본문을 반드시 유지해야 한다.\n\n\n<br><br><br><br><br><br>\n\n## ✅ RPG : Post/Redirect/Get\n\n**만약 POST요청으로 물건을 주문한뒤에 웹 브라우저를 새로고침하면 어떻게 될까? 새로고침은 POST요청을 다시 요청하게 되고 중복 주문이 발생한다.**\n\n**때문에 POST요청 후에 GET요청으로 변경해주는 Redirect 작업이 필요하다!**\n\n<br>\n\n### 📌 RPG 적용 전\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/rpg1.png?raw=true\">\n</p>\n\n1. POST요청으로 주문작업 실행\n2. 주문 데이터 1개 저장\n3. 그냥 200 OK로 성공 반환\n4. 결과 화면에서 웹페이지 새로고침\n5. 다시 POST요청으로 주문작업 실행\n6. 같은 주문 데이터 1개 또 저장\n7. 주문이 중복되는 문제 발생!\n\n<br><br>\n### 📌 RPG 적용 후\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/rpg2.png?raw=true\">\n</p>\n\n1. POST 요청으로 주문작업 실행\n2. 주문 데이터 1개 저장\n3. 302 Found로 임시적인 리다이렉션 반환\n4. 결과화면에서 웹페이지 새로고침\n5. 기존 POST요청에서 GET요청으로 HTTP 메서드 변경\n6. 주문 데이터 조회 요청\n7. 주문 데이터 조회 반환\n\n<br><br><br><br><br><br>\n\n## ✅ 실무 적용 방법\n- **임시 리다이렉션 정리**\n\t- 302 Found -> GET으로 변할 수 있음\n\t- 303 See Other -> 메서드가 GET으로 변경\n\t- 307 Temporart Redirect -> 메서드가 변경될 수 없음\n\n- **역사**\n\t- 처음 302 스펙의 의도는 HTTP 메서드를 유지하는것\n\t- 그러나 웹브라우저들이 대부분 GET으로 바꿔버림\n\t- 그래서 모호한 302대신 명확한 303,307이 등장\n\n- **현실**\n\t- 307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용중\n\t- 자동 리다이렉션시에 GET으로 변해도 되면 그냥 302 사용해도 문제없음\n","properties":"\n","discussions":{},"comments":{},"hash":84187449,"tx":291},"2DVrg5MrmpVbUmh6/syncedContent":{"id":"2DVrg5MrmpVbUmh6/syncedContent","type":"syncedContent","historyData":{"84187449":{"id":"2DVrg5MrmpVbUmh6/content","type":"content","text":"---\npermalink: /2023-02-23-HTTP 상태코드(2) - 3xx ( Redirection )\ntitle: \"[HTTP] HTTP 상태코드(2) - 3xx ( Redirection )\"\ndate: 2023-02-23 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- HTTP 상태코드\n---\n<br><br><br><br>\n\n\n## ✅ HTTP 상태코드\n**HTTP 상태코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 의미합니다.** 1xx 부터 5xx 까지 존재하고 각 상태코드 마다 처리 상태에 대한 결과를 알려줍니다.\n\n- 1xx ( Informational ) : 요청이 수신되어 처리중 ( 거의 사용 x )\n- 2xx ( Successful ) : 요청 정상 처리\n- 3xx ( Redirection ) : 요청을 완료하면 추가 행동이 필요\n- 4xx ( Client Error ) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음\n- 5xx ( Server Error ) : 서버 오류, 서버가 정상 요청을 처리하지 못함.\n\n이번 포스팅은 **3xx 상태코드**에 대해서 알아보도록 하겠습니다.\n\n<br><br><br><br><br><br>\n\n## ✅ 3xx 상태 코드 ( Redirection )\n\n3xx 번대의 상태 코드들은 **요청을 완료하기 위해 유저 에이전트의 추가적인 조치가 필요함을 의미**합니다.\n\n- 300 Multiple Choices\n- 301 Moved Permanently\n- 302 Found\n- 303 See Other\n- 304 Not modified\n- 307 Temporary Redirect\n- 308 Permanent Redirect\n\n\n<br><br><br><br><br><br>\n\n## ✅ Redirect란 ?\n요청에 대한 응답 결과에 Location 헤더가 있으면, **Location 위치로 자동 이동**\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/redirect.png?raw=true\">\n</p>\n\n<br>\n\n- **영구 리다이렉션** : 특정 리소스의 URI가 영구적으로 이동\n\t- 예) /members -> /users\n\t- 예) /event -> /new-event\n\n- **일시 리다이렉션** : 일시적인 변경\n\t- 주문 완료 후 주문 내역 화면으로 이동\n\t- PRG : Post/Redirect/Get\n\n- **특수 리다이렉션**\n\t- 결과 대신 캐시를 사용\n\n\n<br><br><br><br><br><br>\n\n## ✅ 영구 리다이렉션 - 301, 308\n\n- 리소스의 URI가 영구적으로 이동\n- 원래의 URL을 사용하지 않고 검색엔진에서도 이를 인지한다.\n- **301 Moved Permanently**\n\t- **리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음**\n- **308 Permanent Redirect**\n\t- 301과 기능은 같음\n\t- **리다이렉트시 요청 메서드와 본문을 그대로 유지함**\n\n\n<br><br><br><br><br><br>\n\n## ✅ 301 Moved Permanently\n\n- 리다이렉트 요청시 요청메서드가 **GET**으로 변하고, **본문이 제거될 수 있다.**\n- **301 Moved Permanently는 안전하지 않은 HTTP URL을 HTTPS로 변경하는데 자주 사용된다.**\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/redirect2.png?raw=true\">\n</p>\n\n<br>\n\n위 그림을 보면 HTTP 요청시 POST요청과 본문이 존재한다. 그리고 요청에 대한 응답은 301 Moved Permanently로 /new-event로 리다이렉트 하는 응답을 반환했다.\n\n때문에 HTTP 요청은 GET 메서드로 변경되었고, 본문은 제거 되었다.\n\n<br><br><br><br><br><br>\n\n## ✅ 308 Permanent Redirect\n\n- 301 Moved Permanently와 기능적으로는 같다.\n- 리다이렉트시 요청 메서드와 본문이 그대로 유지된다.\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/redirect3.png?raw=true\">\n</p>\n\n\n<br><br><br><br><br><br>\n\n## ✅ 일시적인 리다이렉션 - 302, 303, 307\n\n**리소스의 URI가 일시적으로 변경된다.**\n\n\n- **302 Found**\n\t- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다.\n- **303 See Other**\n\t- 302와 기능은 같고 요청메서드가 GET으로 변경된다.\n- **307 Temporary Redirect**\n\t- 302와 기능은 같으나 요청메서드와 본문을 반드시 유지해야 한다.\n\n\n<br><br><br><br><br><br>\n\n## ✅ RPG : Post/Redirect/Get\n\n**만약 POST요청으로 물건을 주문한뒤에 웹 브라우저를 새로고침하면 어떻게 될까? 새로고침은 POST요청을 다시 요청하게 되고 중복 주문이 발생한다.**\n\n**때문에 POST요청 후에 GET요청으로 변경해주는 Redirect 작업이 필요하다!**\n\n<br>\n\n### 📌 RPG 적용 전\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/rpg1.png?raw=true\">\n</p>\n\n1. POST요청으로 주문작업 실행\n2. 주문 데이터 1개 저장\n3. 그냥 200 OK로 성공 반환\n4. 결과 화면에서 웹페이지 새로고침\n5. 다시 POST요청으로 주문작업 실행\n6. 같은 주문 데이터 1개 또 저장\n7. 주문이 중복되는 문제 발생!\n\n<br><br>\n### 📌 RPG 적용 후\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/rpg2.png?raw=true\">\n</p>\n\n1. POST 요청으로 주문작업 실행\n2. 주문 데이터 1개 저장\n3. 302 Found로 임시적인 리다이렉션 반환\n4. 결과화면에서 웹페이지 새로고침\n5. 기존 POST요청에서 GET요청으로 HTTP 메서드 변경\n6. 주문 데이터 조회 요청\n7. 주문 데이터 조회 반환\n\n<br><br><br><br><br><br>\n\n## ✅ 실무 적용 방법\n- **임시 리다이렉션 정리**\n\t- 302 Found -> GET으로 변할 수 있음\n\t- 303 See Other -> 메서드가 GET으로 변경\n\t- 307 Temporart Redirect -> 메서드가 변경될 수 없음\n\n- **역사**\n\t- 처음 302 스펙의 의도는 HTTP 메서드를 유지하는것\n\t- 그러나 웹브라우저들이 대부분 GET으로 바꿔버림\n\t- 그래서 모호한 302대신 명확한 303,307이 등장\n\n- **현실**\n\t- 307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용중\n\t- 자동 리다이렉션시에 GET으로 변해도 되면 그냥 302 사용해도 문제없음\n","properties":"\n","discussions":{},"comments":{},"hash":84187449}},"syncHistory":{"main":[84187449,null,null]},"v":1,"hash":1710111672018,"tx":291},"kRBjdpE8Q87pKDBk/content":{"id":"kRBjdpE8Q87pKDBk/content","type":"content","text":"---\npermalink: /2023-02-24-HTTP 상태코드(3) - 4xx ( Client Error ), 5xx ( Server Error )\ntitle: \"[HTTP] HTTP 상태코드(3) - 4xx ( Client Error ), 5xx ( Server Error )\"\ndate: 2023-02-24 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- HTTP 상태코드\n---\n<br><br><br><br>\n\n## ✅ HTTP 상태코드\n**HTTP 상태코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 의미합니다.** 1xx 부터 5xx 까지 존재하고 각 상태코드 마다 처리 상태에 대한 결과를 알려줍니다.\n\n- 1xx ( Informational ) : 요청이 수신되어 처리중 ( 거의 사용 x )\n- 2xx ( Successful ) : 요청 정상 처리\n- 3xx ( Redirection ) : 요청을 완료하면 추가 행동이 필요\n- 4xx ( Client Error ) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음\n- 5xx ( Server Error ) : 서버 오류, 서버가 정상 요청을 처리하지 못함.\n\n이번 포스팅은 **4xx, 5xx 상태코드**에 대해서 알아보도록 하겠습니다.\n\n<br><br><br><br><br><br>\n\n## ✅ 4xx 상태 코드 ( Client Error )\n\n- 클라이언트가 잘못된 요청을 보내서 서버가 이를 수행할 수 없음.\n- 오류의 원인이 클라이언트에게 있음.\n- 클라이언트가 잘못된 요청 및 데이터를 보내고 있기 때문에 똑같은 재시도는 계속 실패함.\n\n\n<br><br><br><br><br><br>\n\n## ✅ 400 Bad Request\n- 클라이언트가 잘못된 요청을 해서 서버가 이를 처리할 수 없음\n- 요청 구문, 메시지 등의 오류\n- 예 ) 요청파라미터가 잘못되었거나, API스펙이 맞지 않을때 발생\n\n<br><br><br><br><br><br>\n\n## ✅ 401 Unauthorized\n- 클라이언트가 해당 리소스에 대한 인증이 필요함\n- 인증(Authentication) 되지 않음\n- 401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증방법 설명\n\n<br><br><br><br><br><br>\n\n## ✅ 403 Forbidden\n- 서버가 요청을 이해했지만 승인을 거부함\n- 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우\n- 예 ) admin 등급이 아닌 사용자가 로그인은 했지만, admin 리소스에 접근하는 경우\n\n<br><br><br><br><br><br>\n\n## ✅ 404 Not Found\n- 요청 리소스를 찾을 수 없음\n- 요청 리소스가 서버에 없음\n- 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을때\n\n\n<br><br><br><br><br><br>\n\n## ✅ 5xx 상태 코드 ( Server Error )\n\n- 서버 문제로 오류가 발생한 경우 5xx 에러를 반환한다.\n- 서버 문제기 때문에 재시도하면 성공할 수도 있다. ( 복구가 된 경우 )\n\n<br><br><br><br><br><br>\n\n## ✅ 500 Internal Server Error\n- 서버 내부 문제로 오류 발생\n- 보통 애매하면 500 오류를 반환한다.\n\n\n<br><br><br><br><br><br>\n\n## ✅ 503 Service Unavailable\n- 서비스 이용 불가\n- 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음\n- Retry-After 헤더필드로 얼마뒤에 복구되는지 보낼 수 있음.\n","properties":"\n","discussions":{},"comments":{},"hash":-2069828085,"tx":292},"kRBjdpE8Q87pKDBk/syncedContent":{"id":"kRBjdpE8Q87pKDBk/syncedContent","type":"syncedContent","historyData":{"-2069828085":{"id":"kRBjdpE8Q87pKDBk/content","type":"content","text":"---\npermalink: /2023-02-24-HTTP 상태코드(3) - 4xx ( Client Error ), 5xx ( Server Error )\ntitle: \"[HTTP] HTTP 상태코드(3) - 4xx ( Client Error ), 5xx ( Server Error )\"\ndate: 2023-02-24 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTTP\"\ncategories:\n- HTTP\ntags:\n- HTTP\n- HTTP 상태코드\n---\n<br><br><br><br>\n\n## ✅ HTTP 상태코드\n**HTTP 상태코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 의미합니다.** 1xx 부터 5xx 까지 존재하고 각 상태코드 마다 처리 상태에 대한 결과를 알려줍니다.\n\n- 1xx ( Informational ) : 요청이 수신되어 처리중 ( 거의 사용 x )\n- 2xx ( Successful ) : 요청 정상 처리\n- 3xx ( Redirection ) : 요청을 완료하면 추가 행동이 필요\n- 4xx ( Client Error ) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음\n- 5xx ( Server Error ) : 서버 오류, 서버가 정상 요청을 처리하지 못함.\n\n이번 포스팅은 **4xx, 5xx 상태코드**에 대해서 알아보도록 하겠습니다.\n\n<br><br><br><br><br><br>\n\n## ✅ 4xx 상태 코드 ( Client Error )\n\n- 클라이언트가 잘못된 요청을 보내서 서버가 이를 수행할 수 없음.\n- 오류의 원인이 클라이언트에게 있음.\n- 클라이언트가 잘못된 요청 및 데이터를 보내고 있기 때문에 똑같은 재시도는 계속 실패함.\n\n\n<br><br><br><br><br><br>\n\n## ✅ 400 Bad Request\n- 클라이언트가 잘못된 요청을 해서 서버가 이를 처리할 수 없음\n- 요청 구문, 메시지 등의 오류\n- 예 ) 요청파라미터가 잘못되었거나, API스펙이 맞지 않을때 발생\n\n<br><br><br><br><br><br>\n\n## ✅ 401 Unauthorized\n- 클라이언트가 해당 리소스에 대한 인증이 필요함\n- 인증(Authentication) 되지 않음\n- 401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증방법 설명\n\n<br><br><br><br><br><br>\n\n## ✅ 403 Forbidden\n- 서버가 요청을 이해했지만 승인을 거부함\n- 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우\n- 예 ) admin 등급이 아닌 사용자가 로그인은 했지만, admin 리소스에 접근하는 경우\n\n<br><br><br><br><br><br>\n\n## ✅ 404 Not Found\n- 요청 리소스를 찾을 수 없음\n- 요청 리소스가 서버에 없음\n- 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을때\n\n\n<br><br><br><br><br><br>\n\n## ✅ 5xx 상태 코드 ( Server Error )\n\n- 서버 문제로 오류가 발생한 경우 5xx 에러를 반환한다.\n- 서버 문제기 때문에 재시도하면 성공할 수도 있다. ( 복구가 된 경우 )\n\n<br><br><br><br><br><br>\n\n## ✅ 500 Internal Server Error\n- 서버 내부 문제로 오류 발생\n- 보통 애매하면 500 오류를 반환한다.\n\n\n<br><br><br><br><br><br>\n\n## ✅ 503 Service Unavailable\n- 서비스 이용 불가\n- 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음\n- Retry-After 헤더필드로 얼마뒤에 복구되는지 보낼 수 있음.\n","properties":"\n","discussions":{},"comments":{},"hash":-2069828085}},"syncHistory":{"main":[-2069828085,null,null]},"v":1,"hash":1710111672943,"tx":292},"x2LBqte2UHd95dF6":{"id":"x2LBqte2UHd95dF6","type":"file","name":"Welcome file","parentId":"trash","hash":-1648545240,"tx":293},"vCSdbkmBz8WS1NuE":{"id":"vCSdbkmBz8WS1NuE","type":"file","name":"Welcome file","parentId":"trash","hash":-1648545240,"tx":294},"vCSdbkmBz8WS1NuE/contentState":{"id":"vCSdbkmBz8WS1NuE/contentState","type":"contentState","selectionStart":492,"selectionEnd":492,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710111939470,"tx":296},"1hoxohbjUViggy6d/syncedContent":{"id":"1hoxohbjUViggy6d/syncedContent","type":"syncedContent","historyData":{"568030896":{"id":"1hoxohbjUViggy6d/content","type":"content","text":"---\npermalink: /2023-07-14-의존관계 자동 주입/\npublished: true\ntitle: \"[스프링] 의존관계 자동 주입\"\ndate: 2023-07-14 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"의존관계 자동 주입\"\ncategories:\n- Spring\ntags:\n- Spring\n- 카카오 클라우드 스쿨\n---\n\n<br><br>\n\n\n## ✅ 의존관계 주입 방법\n\n###  📌 생성자 주입\n생성자를 통해 의존관계를 주입받는 방식으로 생성자 호출 시점에 딱 1번 호출되는 것이 보장된다. \n\n**불변, 필수** 의존관계에 사용된다.\n\n- 불변한 외부 의존성 : 의존하는 객체가 외부에서 생성되고 한번 주입된 후에는 변경되지 않아야 하는 경우\n- 의존성 주입 후 변경이 불필요한 의존성 : 읽기 전용 데이터베이스 연결, 로깅 구성\n\n- 필수적인 의존성 : 해당 의존성이 없으면 어플리케이션의 실행이나 기능이 제대로 동작하지 않는 경우\n\n- 의존성을 외부에서 주입받는 경우 : 객체 생성 시 외부에서 의존성을 주입받아야 하는 경우 \n\n \n\n \n```java\npublic class OrderServiceImpl implements OrderService{  \n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;  \n\n\t@Autowired \n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  \n\t\tthis.memberRepository = memberRepository;  \n\t\tthis.discountPolicy = discountPolicy;  \n\t}  \n}\n```\n\n```java\n@Configuration  // 설정 정보 등록\npublic class AppConfig {  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemberService memberService(){  \n\t\treturn new MemberServiceImpl(memoryMemberRepository());  // 의존성 주입\n\t}  \n    \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemoryMemberRepository memoryMemberRepository(){  \n\t\treturn new MemoryMemberRepository();  \n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic DiscountPolicy discountPolicy(){  \n\t\treturn new FixDiscountPolicy();  \n\t}  \n}\n```\n위 코드를 보면 `AppConfig` 라는 설정정보를 갖고있는 클래스에서 `MemberService`, `MemoryMemberRepository`, `DiscountPolicy` 에 DI를 적용하고 스프링 빈으로 등록했다.\n\n그리고 `OrderServiceImpl` 클래스에서는 `MemberRepository` 와 `DiscountPolicy` 에 대한 DI를 적용했는데 이때는 `@Autowired` 어노테이션을 통해 DI를 적용한 것이다.\n\n**DI된 스프링 빈**들이 final 키워드를 붙혀 필수값인 경우에 생성자 주입을 통해 의존관계를 주입한다.\n\n이 때 반드시!! **DI가 완료된 스프링 빈**을 생성자의 파라미터로 DI해야만 한다. \n\n**이는 스프링의 의존성 주입 원칙과 관련이 있는데 스프링은 의존성 주입을 통해 객체간의 결합도를 낮추고 유연성을 높이는 것을 지향한다. 이를 위해 스프링은 생성자를 통해 DI를 할때 객체의 생성과 동시에 의존성이 주입되어야 한다는 원칙을 따른다.**\n\n**또한 생성자는 컴파일시에 호출되기 때문에 생성자를 통해 주입할 의존성은 빈으로 등록되어 있어야 생성자를 통한 DI가 가능한 이유도 있다.**\n\n**중요! 생성자가 단 하나인경우에는 `@Autowired` 어노테이션이 생략가능하다.**\n\n<br><br>\n\n굳이 `OrderServiceImpl` 클래스에서 `@Autowired`태그를 이용한 DI 말고 기존 `AppConfig` 클래스에서 `@Bean` 어노테이션을 사용해 DI를 주입할 수도 있다.\n\n```java\n@Configuration  // 설정 정보 등록\npublic class AppConfig {  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemberService memberService(){  \n\t\treturn new MemberServiceImpl(memoryMemberRepository());  // 의존성 주입\n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic MemoryMemberRepository memoryMemberRepository(){  \n\t\treturn new MemoryMemberRepository();  \n\t}  \n  \n\t@Bean  // 스프링 빈으로 등록\n\tpublic DiscountPolicy discountPolicy(){  \n\t\treturn new FixDiscountPolicy();  \n\t}\n\n\t@Bean  // 스프링 빈으로 등록\n\tpublic OrderService orderService(){  \n\t\treturn new OrderServiceImpl(memoryMemberRepository(), discountPolicy());  // 의존성 주입\n\t}  \n}\n```\n\n코드 마지막 부분을 보면 `OrderService`에 `OrderServiceImpl` 를 DI해주고 , `OrderServiceImpl` 에 다시 `memoryMemberRepository, discountPolicy` 를 DI해준걸 볼 수 있다. 앞서 언급한 `@Autowired` DI와 같은 역할을 하는 코드이다.\n\n\n<br><br><br>\n\n###  📌 수정자(Setter) 주입\n자바 빈 규약에 따라 Setter를 통해 필드의 값을 수정할 수 있는 수정자 메서드를 통해 의존관계를 주입할 수 있다.\n\n**선택, 변경** 가능성이 있는 의존관계에 사용된다.\n\n```java\npublic class OrderServiceImpl implements OrderService{  \n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;  \n\n\t@Autowired \n\tpublic void setMemberRepository(MemberRepository memberRepository) {\n\t\tthis.memberRepository = memberRepository;\n\t}\n\n\t@Autowired\n\tpublic void setDiscountPolicy(DiscountPolicy discountPolicy) {\n\t\tthis.discountPolicy = discountPolicy;\n\t}\n}\n```\n\n각각의 수정자(Setter) 메서드에 `@Autowired` 어노테이션을 붙여 의존관계를 주입한다.\n\n수정자 주입은 생성자 주입과는 다르게 의존 관계로 주입되어야 할 객체가 스프링 빈으로 등록되지 않아도 사용이 가능하다. \n\n그러나 `@Autowired` 어노테이션은 주입 할 대상이 없으면 오류가 발생하는데, 오류가 발생하지 않게 하려면 속성으로 (`required = false`) 를 지정하면 된다.\n\n<br><br><Br>\n\n###  📌 필드 주입\n필드에 바로 의존성을 주입하는 방식도 있다.\n\n```java\n@Component\npublic class OrderServiceImpl implements OrderService{  \n\t\n\t@Autowired\n\tprivate final MemberRepository memberRepository;\n\t\n\t@Autowired\n\tprivate final DiscountPolicy discountPolicy;  \n```\n\n접근제어자가 `private` 인 경우 외부에서 값을 변경하거나 접근하는게 불가능하지만 `@Autowired`를 사용하면 문제없이 DI가 가능하다.\n\n**그러나 외부에서의 변경 및 테스트가 어렵다는 큰 단점이 있다.**\n\n<br>\n\n❗❗ **왜 테스트가 어려울까 ?**\n\n간단한 예시를 통해 알아보자.\n\nUserService\n\n-   매우 간단한 기능만 가지고 있음\n-   그럼에도 불구하고 세 가지 타입의 의존 오브젝트가 필요\n    1.  UserDao : DB 처리 **( 필드를 통한 DI를 했다고 가정 )**\n    2.  MailSender : 메일 처리 **( 필드를 통한 DI를 했다고 가정 )**\n    3.  PlatformTransactionManager : 트랜잭션 처리 **( 필드를 통한 DI를 했다고 가정 )**\n\nUserServiceTest\n\n-   본래의 목적 : UserService에 대한 테스트\n-   세 가지 의존관계를 갖고 있으므로 테스트가 진행되는 동안 세 가지 오브젝트가 모두 정상이어야 한다.\n-   실제로는 해당 오브젝트의 뒤에 존재하는 훨씬 더 많은 오브젝트와 환경, 서비스, 서버 등을 함께 테스트하는 것\n\n이런 상황이 있을 때, 우리는 UserService의 간단한 기능만 테스트 하고 싶다. 그러나 DB, 메일, 트랜젝션을 처리하는 메소드들이 존재하기 때문에 이를 제외하고 테스트를 하는 편이 훨씬 효율적이다.\n\n만약 생성자를 통한 DI를 활용해 세가지 기능에 대한 DI를 했다면, 우리는 스프링이 제공하는 `mock` 라이브러리를 통해 세가지 기능을 제외하거나, 임의의 값을 넣어준다던가, 생성자에 가상 오브젝트를 주입하여 복잡한 로직을 간단하게 처리가 가능하다.\n\n그러나 필드 단위에 DI를 적용해놓은 경우에는, 이미 세가지 기능에 대한 DI가 서비스 단위에 적용되었기 때문에, 앞서 언급한 여러 간단한 처리가 불가능하고, 모든 로직을 다 확인해야만 한다.\n\n때문에 간단한 로직만을 테스트 하고싶어도 포함된 모든 로직을 테스트 해야만 하는 상황이 벌어질수 밖에없다. **그래서 필드에 DI를 하는건 권장하지 않는다.**\n\n<br><Br><Br>\n\n###  📌 일반 메서드 주입\n일반 메서드를 통해서 주입받을 수도 있다.\n\n생성자처럼 한번에 여러 필드를 주입받을수도 있는데, 일반적으로 사용되지는 않는다.\n(생성자 주입이나 수정자주입으로 다 해결되기 때문이다.)\n\n 더하여, 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 한다. 스프링 빈으로 등록되지 않은 클래스(ex: Member와 같은 Domain ) 는 주입받을 수 없다.\n\n```java\n@Component \npublic class OrderServiceImpl implements OrderService { \n\tprivate MemberRepository memberRepository; \n\tprivate DiscountPolicy discountPolicy; \n\n\t@Autowired \n\tpublic void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) { \n\t\tthis.memberRepository = memberRepository; this.discountPolicy = discountPolicy; \n\t} \n}\n```\n\n<br><br><br><br>\n\n## ✅ 생성자 주입 방식을 선택해라!\n\n- 대부분의 의존관계 주입은 한번 일어나면 어플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 어플리케이션 종료 전까지 변하면 안된다.\n- 수정자 주입을 사용하면 setXXX메서드를 public으로 열어두어야 하는데 이로인해 누군가 변경할 수있게되고 이는 좋은 설계 방법이 아니다.\n- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출될 일이 없다. 따라서 불변하게 설계할 수 있다.\n\n\n<br><Br><Br>\n\n###  📌 final 키워드를 사용해라\n\n생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.\n\n```java\n@Component\npublic class OrderServiceImpl implements OrderService {\n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;\n \n\t@Autowired // 생략가능\n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {\n\t\tthis.memberRepository = memberRepository;\n\t}\n //...\n}\n```\n\n위 코드를 보면 `discountPolicy`에 값을 설정하는 부분이 누락되었다. 자바는 이를 컴파일 오류를 발생시킨다. `java: variable discountPolicy might not have been initialized`\n\n또한 생성자 주입을 제외한 나머지 주입 방식은 생성자 이후에 호출되기 때문에 필드에 `final` 키워드를 사용할 수 없다. 오직 생성자 주입 방식만 `final`키워드를 사용 할 수 있다.\n\n<br><br><br>\n\n###  📌 롬복을 활용해라\n\n최근 프로젝트를 진행하며 배운점인데, 실제로 개발단계에서는 생성자 주입방식을 거의 대부분 사용하고 불변했다. 그래서 실제로 `final`키워드를 사용했다. 그리고 롬복을 활용하여 코드를 최적화 했는데 다음 코드들을 비교하며 어떤 방식으로 최적화가 되는지 살펴보자.\n\n<br><br>\n\n⭐**기본코드**\n```java\n@Component\npublic class OrderServiceImpl implements OrderService {\n\n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;\n \n\t@Autowired\n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {\n\t\tthis.memberRepository = memberRepository;\n\t\tthis.discountPolicy = discountPolicy;\n\t}\n}\n```\n<br><br>\n\n\n**⭐ Autowired 생략 코드**\n```java\n@Component\npublic class OrderServiceImpl implements OrderService {\n\n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;\n \n\tpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {\n\t\tthis.memberRepository = memberRepository;\n\t\tthis.discountPolicy = discountPolicy;\n\t}\n}\n```\n\n<br><br>\n\n**⭐ 롬복 적용 코드**\n```java\n@Component\n@RequiredArgsConstructor\npublic class OrderServiceImpl implements OrderService {\n\n\tprivate final MemberRepository memberRepository;\n\tprivate final DiscountPolicy discountPolicy;\n}\n```\n\n롬복 라이브러리가 제공하는 `@RequiredArgsConstructor` 기능을 사용하면 `final`이 붙은 필드를 모아서 생성자를 자동으로 만들어준다. 이를 활용하면 정말 깔끔한 코드를 만들 수 있다!\n","properties":"\n","discussions":{},"comments":{},"hash":568030896}},"syncHistory":{"main":[568030896,568030896,null]},"v":1,"hash":1710112017220,"tx":310},"ZRhtnSudyGKoaxuf":{"id":"ZRhtnSudyGKoaxuf","type":"folder","name":"ERP","parentId":null,"hash":-1217854062,"tx":522},"06MckntYpMDISZ8b/contentState":{"id":"06MckntYpMDISZ8b/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710718819743,"tx":4214},"ZrlBGkPkFqYFyKak/syncedContent":{"id":"ZrlBGkPkFqYFyKak/syncedContent","type":"syncedContent","historyData":{"2113864203":{"id":"ZrlBGkPkFqYFyKak/content","type":"content","text":"AWS 웹 관리 콘솔 -> ID/PW로 인증\nAWS CLI나머지는 -> 키로 인증\n\n\n## EC2 인스턴스 -> S3로 요청을 보낼때\n노트에 대충 적어놧음\n\n\n\n## EC2 인스턴스 Role 수임하는 과정 매우 중요\n\n\n\n## 정적 웹페이지 작성 및 S3배포 프로젝트\n\n\n## ✅ EC2의 구조도\n <p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec27.png?raw=true\">\n</p>\n\n<br>\n\n위의 그림은 AWS에서 EC2가 어떻게 작동하고 구성되는지를 보여주는 그림이다. 내가 이해한 대로 그림의 흐름을 따라가면서 EC2의 구조를 살펴보겠다.\n\n1. AWS에 접근하는 방법은 크게 3가지가 있다. 이를 이용해 AWS에 접근한다.\n\n\tAWS 웹 관리 콘솔 : 웹페이지에서 로그인 하여 사용하는 일반적인 방법\n\t프로그래밍적 접근 : `java`, `.NET`, `python` 등의 언어를 사용하여 커맨드로 접근\n\tAWS CLI : AWS 서비스를 관리하는 통합 도구\n\n2. \n","properties":"\n","discussions":{},"comments":{},"hash":2113864203}},"syncHistory":{"main":[2113864203,2113864203,null]},"v":1,"hash":1710719521028,"tx":4250},"QCDOYp9baGlX0tfx":{"id":"QCDOYp9baGlX0tfx","type":"file","name":"2024-03-11-ERP(Enterprise Resource Planning)란","parentId":"ZRhtnSudyGKoaxuf","hash":227589682,"tx":4315},"wTK8ucAfkpXnll6C":{"id":"wTK8ucAfkpXnll6C","type":"file","name":"2023-08-15-DAO, DTO, VO, Entity란","parentId":"ilIvoK9bdEIgCIvn","hash":-565878985,"tx":4459},"ZQ1P22aGt9pYBZQY/syncedContent":{"id":"ZQ1P22aGt9pYBZQY/syncedContent","type":"syncedContent","historyData":{"655151792":{"id":"ZQ1P22aGt9pYBZQY/content","type":"content","text":"---\npermalink: /2023-08-30-외부 프로퍼티 적용/\npublished: true\ntitle: \"[스프링] 외부 프로퍼티 적용\"\ndate: 2023-08-30 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"외부 프로퍼티 적용\"\ncategories:\n- Spring\ntags:\n- Spring\n- 카카오 클라우드 스쿨\n---\n\n<br><br>\n\n카카오 클라우드 스쿨에서 프로젝트를 진행하며 CI/CD를 진행했다. github action을 사용해서 AWS EC2 서버에 jar파일 형태로 배포를 진행했다. 그런데 배포 중 프로퍼티 값 관련 오류가 너무나도 많이 발생했다. 로컬환경에서는 OS에 환경변수를 등록하고 사용했기 때문에 문제없이 동작했지만, EC2에서는 리눅스에 환경변수를 직접 등록해도, 원하지 않는 값들이 호출되거나, 아예 값이 안넘어오는 상황이 많이 발생했다.\n\n문제의 원인은 외부 프로퍼티를 적용할 때 우선순위가 존재하기 때문이였다. 스프링부트는 프로퍼티 값을 적용 할 수 있는 방법이 정말 많기 때문에, 이 방법들에 우선순위를 매겨 우선순위가 높은 방법이 최우선 적용되게끔 설계되어 있다.\n\n이러한 우선순위와, 주로 사용하는 방법들에 대해서 자세히 알아보도록 하자.\n\n<br><Br><br>\n\n## ✅ Property 우선순위\n1. **유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties**\n2.  **테스트에 있는 @TestPropertySource**\n3.  **@SpringBootTest 애노테이션의 properties 애트리뷰트**\n4.  **커맨드 라인 아규먼트**\n5.  SPRING_APPLICATION_JSON (환경 변수 또는 시스템 프로퍼티) 에 들어있는 프로퍼티\n6.  ServletConfig 파라미터\n7.  ServletContext 파라미터\n8.  java:comp/env JNDI 애트리뷰트\n9.  System.getProperties() 자바 시스템 프로퍼티\n10.  **OS 환경 변수**\n11.  RandomValuePropertySource\n12.  **JAR 밖에 있는 특정 프로파일용 application properties**\n13.  **JAR 안에 있는 특정 프로파일용 application properties**\n14.  JAR 밖에 있는 application properties\n15.  **JAR 안에 있는 application properties**\n16.  @PropertySource\n17.  기본 프로퍼티 (SpringApplication.setDefaultProperties)\n\n\n\n<br><Br>\n많이 사용되는 방법 위주로 예제와 함께 살펴보도록 하겠다.\n<br><br>\n\n1. **유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties**\n```java\n# application.properties 파일\n\nspring.datasource.username=아이디 \nspring.datasource.password=비밀번호 \nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\nproperties파일에 값을 노출시키지 않기 위해 JVM에 값을 등록하고 properties파일에서 참조하는 방식으로 사용하려면 다음과 같이 쓰면된다.\n\n```\nspring.datasource.username=${DB_ID}}\n \n","properties":"\n","discussions":{},"comments":{},"hash":655151792}},"syncHistory":{"main":[655151792,655151792,null]},"v":1,"hash":1710725526846,"tx":4481},"GOOIxoNi3E7Gqydq":{"id":"GOOIxoNi3E7Gqydq","type":"folder","name":"KCC","parentId":null,"hash":614592570,"tx":4482},"jeNuMwclaWKHJJjy":{"id":"jeNuMwclaWKHJJjy","type":"file","name":"2024-03-18-트러블슈팅","parentId":"GOOIxoNi3E7Gqydq","hash":-486387373,"tx":4483},"jeNuMwclaWKHJJjy/content":{"id":"jeNuMwclaWKHJJjy/content","type":"content","text":"<br><br>\n\n## console.log에서 보이는 오류\n\n```\n<Error> <HTTP> <BEA-101216> <Servlet: \"action\" failed to preload on startup in Web application: \"WebContent\".\norg.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter] for bean with name 'FileUploadChannelAdapter' defined in ServletContext resource [/WEB-INF/action-servlet.xml]; nested exception is java.lang.ClassNotFoundException: kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1136)\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:282)\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:689)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:358)\n\tat org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:329)\n\tTruncated. see log file for complete stacktrace\nCaused By: java.lang.ClassNotFoundException: kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter\n\tat weblogic.utils.classloaders.GenericClassLoader.findLocalClass(GenericClassLoader.java:1029)\n\tat weblogic.utils.classloaders.GenericClassLoader.findClass(GenericClassLoader.java:990)\n\tat weblogic.utils.classloaders.ChangeAwareClassLoader.findClass(ChangeAwareClassLoader.java:104)\n\tat weblogic.utils.classloaders.GenericClassLoader.doFindClass(GenericClassLoader.java:611)\n\tat weblogic.utils.classloaders.GenericClassLoader.loadClass(GenericClassLoader.java:543)\n\tTruncated. see log file for complete stacktrace\n> \n<2024. 3. 18 오전 10시 32분 48,974초 KST> <Error> <Deployer> <BEA-149231> <Unable to set the activation state to true for the application \"WebContent\".\nweblogic.application.ModuleException: java.lang.ClassNotFoundException: kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter\n\tat weblogic.application.internal.ExtensibleModuleWrapper.start(ExtensibleModuleWrapper.java:140)\n\tat weblogic.application.internal.flow.ModuleListenerInvoker.start(ModuleListenerInvoker.java:124)\n\tat weblogic.application.internal.flow.ModuleStateDriver$3.next(ModuleStateDriver.java:233)\n\tat weblogic.application.internal.flow.ModuleStateDriver$3.next(ModuleStateDriver.java:228)\n\tat weblogic.application.utils.StateMachineDriver.nextState(StateMachineDriver.java:45)\n\tTruncated. see log file for complete stacktrace\nCaused By: java.lang.ClassNotFoundException: kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter\n\tat weblogic.utils.classloaders.GenericClassLoader.findLocalClass(GenericClassLoader.java:1029)\n\tat weblogic.utils.classloaders.GenericClassLoader.findClass(GenericClassLoader.java:990)\n\tat weblogic.utils.classloaders.ChangeAwareClassLoader.findClass(ChangeAwareClassLoader.java:104)\n\tat weblogic.utils.classloaders.GenericClassLoader.doFindClass(GenericClassLoader.java:611)\n\tat weblogic.utils.classloaders.GenericClassLoader.loadClass(GenericClassLoader.java:543)\n\tTruncated. see log file for complete stacktrace\n```\n\n\n<br><br><br>\n\n## Eclipse 오류\n```\norg.eclipse.core.runtime.CoreException: Plug-in com.inswave.websquare was unable to load class com.inswave.websquare.views.style.WqStyleView.\n\tat org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:194)\n\tat org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:176)\n\tat org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)\n\tat org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)\n\tat org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)\n\tat org.eclipse.ui.internal.registry.ViewDescriptor.createView(ViewDescriptor.java:63)\n\tat org.eclipse.ui.internal.ViewReference.createPart(ViewReference.java:108)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPart(CompatibilityPart.java:265)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:303)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)\n\tat org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$6.run(PartRenderingEngine.java:547)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:531)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:69)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1246)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:185)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:185)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:185)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:103)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:77)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:185)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:663)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1078)\n\tat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)\n\tat org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)\n\tat org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)\n\tat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)\n\tat org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)\n\tat org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)\n\tat org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)\n\tat org.eclipse.equinox.launcher.Main.run(Main.java:1465)\n\tat org.eclipse.equinox.launcher.Main.main(Main.java:1438)\nCaused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.inswave.websquare (843).\n\tat org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:116)\n\tat org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)\n\tat org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)\n\tat org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:320)\n\tat org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:395)\n\tat org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:345)\n\tat org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:337)\n\tat org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:358)\n\tat org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:568)\n\tat org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:174)\n\tat org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)\n\tat org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)\n\tat org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)\n\tat org.eclipse.ui.internal.navigator.extensions.CommonDragAssistantDescriptor$1.run(CommonDragAssistantDescriptor.java:50)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.ui.internal.navigator.extensions.CommonDragAssistantDescriptor.createDragAssistant(CommonDragAssistantDescriptor.java:48)\n\tat org.eclipse.ui.internal.navigator.dnd.NavigatorDnDService.initializeDragAssistants(NavigatorDnDService.java:92)\n\tat org.eclipse.ui.internal.navigator.dnd.NavigatorDnDService.getCommonDragAssistants(NavigatorDnDService.java:79)\n\tat org.eclipse.ui.navigator.CommonDragAdapter.getSupportedDragTransfers(CommonDragAdapter.java:92)\n\tat org.eclipse.ui.navigator.CommonViewer.initDragAndDrop(CommonViewer.java:171)\n\tat org.eclipse.ui.navigator.CommonViewer.init(CommonViewer.java:111)\n\tat org.eclipse.ui.navigator.CommonViewer.<init>(CommonViewer.java:97)\n\tat org.eclipse.ui.navigator.CommonNavigator.createCommonViewerObject(CommonNavigator.java:504)\n\tat org.eclipse.ui.navigator.CommonNavigator.createCommonViewer(CommonNavigator.java:486)\n\tat org.eclipse.ui.navigator.CommonNavigator.createPartControl(CommonNavigator.java:193)\n\tat org.eclipse.ui.navigator.resources.ProjectExplorer.createPartControl(ProjectExplorer.java:93)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:141)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:327)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)\n\tat org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$6.run(PartRenderingEngine.java:547)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:531)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:69)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1246)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)\n\t... 76 more\nCaused by: org.osgi.framework.BundleException: Exception in com.inswave.websquare.WebSquareActivator.start() of bundle com.inswave.websquare.\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:792)\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721)\n\tat org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:936)\n\tat org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:319)\n\tat org.eclipse.osgi.container.Module.doStart(Module.java:571)\n\tat org.eclipse.osgi.container.Module.start(Module.java:439)\n\tat org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)\n\tat org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)\n\t... 136 more\nCaused by: java.lang.IllegalArgumentException: Argument cannot be null\n\tat org.eclipse.swt.SWT.error(SWT.java:4422)\n\tat org.eclipse.swt.SWT.error(SWT.java:4356)\n\tat org.eclipse.swt.SWT.error(SWT.java:4327)\n\tat org.eclipse.swt.widgets.Dialog.error(Dialog.java:198)\n\tat org.eclipse.swt.widgets.Dialog.checkParent(Dialog.java:164)\n\tat org.eclipse.swt.widgets.Dialog.<init>(Dialog.java:127)\n\tat org.eclipse.swt.widgets.MessageBox.<init>(MessageBox.java:97)\n\tat com.inswave.websquare.webapp.EngineInitializer.initialize(Unknown Source)\n\tat com.inswave.websquare.WebSquareActivator.initEngine(Unknown Source)\n\tat com.inswave.websquare.WebSquareActivator.start(Unknown Source)\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771)\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764)\n\t... 143 more\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":2103678661,"tx":4572},"fxktNjN7Qbqln352":{"id":"fxktNjN7Qbqln352","type":"file","name":"2023-09-12-NamedParameterJdbcTemplate 이란","parentId":"ilIvoK9bdEIgCIvn","hash":1563382647,"tx":4671},"jeNuMwclaWKHJJjy/syncedContent":{"id":"jeNuMwclaWKHJJjy/syncedContent","type":"syncedContent","historyData":{"2103678661":{"id":"jeNuMwclaWKHJJjy/content","type":"content","text":"<br><br>\n\n## console.log에서 보이는 오류\n\n```\n<Error> <HTTP> <BEA-101216> <Servlet: \"action\" failed to preload on startup in Web application: \"WebContent\".\norg.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter] for bean with name 'FileUploadChannelAdapter' defined in ServletContext resource [/WEB-INF/action-servlet.xml]; nested exception is java.lang.ClassNotFoundException: kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1136)\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:282)\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:689)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:358)\n\tat org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:329)\n\tTruncated. see log file for complete stacktrace\nCaused By: java.lang.ClassNotFoundException: kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter\n\tat weblogic.utils.classloaders.GenericClassLoader.findLocalClass(GenericClassLoader.java:1029)\n\tat weblogic.utils.classloaders.GenericClassLoader.findClass(GenericClassLoader.java:990)\n\tat weblogic.utils.classloaders.ChangeAwareClassLoader.findClass(ChangeAwareClassLoader.java:104)\n\tat weblogic.utils.classloaders.GenericClassLoader.doFindClass(GenericClassLoader.java:611)\n\tat weblogic.utils.classloaders.GenericClassLoader.loadClass(GenericClassLoader.java:543)\n\tTruncated. see log file for complete stacktrace\n> \n<2024. 3. 18 오전 10시 32분 48,974초 KST> <Error> <Deployer> <BEA-149231> <Unable to set the activation state to true for the application \"WebContent\".\nweblogic.application.ModuleException: java.lang.ClassNotFoundException: kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter\n\tat weblogic.application.internal.ExtensibleModuleWrapper.start(ExtensibleModuleWrapper.java:140)\n\tat weblogic.application.internal.flow.ModuleListenerInvoker.start(ModuleListenerInvoker.java:124)\n\tat weblogic.application.internal.flow.ModuleStateDriver$3.next(ModuleStateDriver.java:233)\n\tat weblogic.application.internal.flow.ModuleStateDriver$3.next(ModuleStateDriver.java:228)\n\tat weblogic.application.utils.StateMachineDriver.nextState(StateMachineDriver.java:45)\n\tTruncated. see log file for complete stacktrace\nCaused By: java.lang.ClassNotFoundException: kais.s02.sfadev.framework.controller.channel.FileUploadChannelAdapter\n\tat weblogic.utils.classloaders.GenericClassLoader.findLocalClass(GenericClassLoader.java:1029)\n\tat weblogic.utils.classloaders.GenericClassLoader.findClass(GenericClassLoader.java:990)\n\tat weblogic.utils.classloaders.ChangeAwareClassLoader.findClass(ChangeAwareClassLoader.java:104)\n\tat weblogic.utils.classloaders.GenericClassLoader.doFindClass(GenericClassLoader.java:611)\n\tat weblogic.utils.classloaders.GenericClassLoader.loadClass(GenericClassLoader.java:543)\n\tTruncated. see log file for complete stacktrace\n```\n\n\n<br><br><br>\n\n## Eclipse 오류\n```\norg.eclipse.core.runtime.CoreException: Plug-in com.inswave.websquare was unable to load class com.inswave.websquare.views.style.WqStyleView.\n\tat org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:194)\n\tat org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:176)\n\tat org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)\n\tat org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)\n\tat org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)\n\tat org.eclipse.ui.internal.registry.ViewDescriptor.createView(ViewDescriptor.java:63)\n\tat org.eclipse.ui.internal.ViewReference.createPart(ViewReference.java:108)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPart(CompatibilityPart.java:265)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:303)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)\n\tat org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$6.run(PartRenderingEngine.java:547)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:531)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:69)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1246)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:185)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:185)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:185)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:49)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:103)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:77)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:185)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:69)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:663)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1078)\n\tat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)\n\tat org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)\n\tat org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)\n\tat org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)\n\tat org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)\n\tat org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)\n\tat org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)\n\tat org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)\n\tat org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)\n\tat org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)\n\tat org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)\n\tat org.eclipse.equinox.launcher.Main.run(Main.java:1465)\n\tat org.eclipse.equinox.launcher.Main.main(Main.java:1438)\nCaused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.inswave.websquare (843).\n\tat org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:116)\n\tat org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)\n\tat org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)\n\tat org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:320)\n\tat org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:395)\n\tat org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:345)\n\tat org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:337)\n\tat org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:358)\n\tat org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:568)\n\tat org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:174)\n\tat org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)\n\tat org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)\n\tat org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)\n\tat org.eclipse.ui.internal.navigator.extensions.CommonDragAssistantDescriptor$1.run(CommonDragAssistantDescriptor.java:50)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.ui.internal.navigator.extensions.CommonDragAssistantDescriptor.createDragAssistant(CommonDragAssistantDescriptor.java:48)\n\tat org.eclipse.ui.internal.navigator.dnd.NavigatorDnDService.initializeDragAssistants(NavigatorDnDService.java:92)\n\tat org.eclipse.ui.internal.navigator.dnd.NavigatorDnDService.getCommonDragAssistants(NavigatorDnDService.java:79)\n\tat org.eclipse.ui.navigator.CommonDragAdapter.getSupportedDragTransfers(CommonDragAdapter.java:92)\n\tat org.eclipse.ui.navigator.CommonViewer.initDragAndDrop(CommonViewer.java:171)\n\tat org.eclipse.ui.navigator.CommonViewer.init(CommonViewer.java:111)\n\tat org.eclipse.ui.navigator.CommonViewer.<init>(CommonViewer.java:97)\n\tat org.eclipse.ui.navigator.CommonNavigator.createCommonViewerObject(CommonNavigator.java:504)\n\tat org.eclipse.ui.navigator.CommonNavigator.createCommonViewer(CommonNavigator.java:486)\n\tat org.eclipse.ui.navigator.CommonNavigator.createPartControl(CommonNavigator.java:193)\n\tat org.eclipse.ui.navigator.resources.ProjectExplorer.createPartControl(ProjectExplorer.java:93)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:141)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)\n\tat org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:327)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)\n\tat org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)\n\tat org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)\n\tat org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$6.run(PartRenderingEngine.java:547)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:531)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:69)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)\n\tat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1246)\n\tat org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:103)\n\tat org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)\n\t... 76 more\nCaused by: org.osgi.framework.BundleException: Exception in com.inswave.websquare.WebSquareActivator.start() of bundle com.inswave.websquare.\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:792)\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721)\n\tat org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:936)\n\tat org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:319)\n\tat org.eclipse.osgi.container.Module.doStart(Module.java:571)\n\tat org.eclipse.osgi.container.Module.start(Module.java:439)\n\tat org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)\n\tat org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)\n\t... 136 more\nCaused by: java.lang.IllegalArgumentException: Argument cannot be null\n\tat org.eclipse.swt.SWT.error(SWT.java:4422)\n\tat org.eclipse.swt.SWT.error(SWT.java:4356)\n\tat org.eclipse.swt.SWT.error(SWT.java:4327)\n\tat org.eclipse.swt.widgets.Dialog.error(Dialog.java:198)\n\tat org.eclipse.swt.widgets.Dialog.checkParent(Dialog.java:164)\n\tat org.eclipse.swt.widgets.Dialog.<init>(Dialog.java:127)\n\tat org.eclipse.swt.widgets.MessageBox.<init>(MessageBox.java:97)\n\tat com.inswave.websquare.webapp.EngineInitializer.initialize(Unknown Source)\n\tat com.inswave.websquare.WebSquareActivator.initEngine(Unknown Source)\n\tat com.inswave.websquare.WebSquareActivator.start(Unknown Source)\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771)\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764)\n\t... 143 more\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":2103678661}},"syncHistory":{"main":[2103678661,2103678661,null]},"v":1,"hash":1710726781083,"tx":4702},"1hoxohbjUViggy6d/contentState":{"id":"1hoxohbjUViggy6d/contentState","type":"contentState","selectionStart":3315,"selectionEnd":3315,"scrollPosition":{"sectionIdx":72,"posInSection":0.15},"hash":1710728117554,"tx":4853},"N72RguIezt8KuflR/syncedContent":{"id":"N72RguIezt8KuflR/syncedContent","type":"syncedContent","historyData":{"1850828839":{"id":"N72RguIezt8KuflR/content","type":"content","text":"---\npermalink: /2023-07-04-빈 스코프 - 싱글톤, 프로토타입/\npublished: true\ntitle: \"[스프링] 빈 스코프 - 싱글톤, 프로토타입\"\ndate: 2023-07-04 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"빈 스코프 - 싱글톤, 프로토타입\"\ncategories:\n- Spring\ntags:\n- Spring\n- 카카오 클라우드 스쿨\n---\n\n<br><br>\n\n\n## ✅ 빈(Bean) 스코프\n\n빈 스코프는 우리가 빈을 생성할 때, 빈을 공유하기 위한 인스턴스를 하나만 만들지(싱글턴 스코프), 아니면 빈이 요청될 때마다 새로운 빈 인스턴스를 생성할지(프로토타입 스코프) 여부를 제어하고자 할때 사용하는 개념이다.\n\n빈의 스코프를 정의하는 방식은 스프링 버전에 따라 다를 수 있고 여러가지가 있지만 대표적으로 두가지 방식이 존재한다. 첫번째로는 **설정정보를 담고있는 XML파일에서 <bean>엘리먼트의 scope속성을 사용하는 방법**이 있다. 두번째로는 **`@Scope` 어노테이션을 활용해 빈 스코프를 정의해주는 방법**이 있다.\n\n위와 같은 방식으로 빈 스코프를 따로 정의해주지 않았다면 빈 스코프는 자동으로 싱글턴 스코프를 가지게 된다.\n\n빈 스코프의 종류는 **Singleton, Prototype**, Request, Session, Application 등이 있는데 우리는 자주 사용하는 **Singleton과 Prototype**에 대해서만 다루도록 하겠다.\n\n<br><Br><Br><br>\n\n## ✅ 싱글턴 (Singleton) 스코프\n싱글턴 스코프는 XML파일에 정의된 모든 빈의 디폴트 스코프이다. **싱글턴 스코프 빈의 인스턴스는 스프링 컨테이너가 생성될 때 함께 생성되고, 스프링 컨테이너가 파괴될 때 함께 파괴된다. 또한 싱글턴 스코프 빈은 호출이 한번되든 여러번되든 상관없이 단일 스프링 컨테이너 내에서는 단 한개만 생성되고, 그 빈에 의존하는 모든 빈에 유일한 인스턴스를 공유한다.**\n\n너무너무 중요한 설명이니 위의 내용을 완벽하게 이해하고 넘어가야만 한다. xml방식과 클래스방식으로 설정정보를 저장하는 두가지 예제를 통해 좀더 자세히 알아보자.\n\n<br><br>\n\n###  📌 XML 파일로 bean 설정\n```xml\n// bankapp이라는 프로젝트의 applicationContext.xml\n\n<beans ...>  \n\t<bean id=\"controller\" class=\"bankapp.controller.FixedDepositControllerImpl\">  \n\t\t<property name=\"fixedDepositService\" ref=\"service\" />  \n\t</bean>  \n  \n\t<bean id=\"service\" class=\"bankapp.service.FixedDepositServiceImpl\">  \n\t\t<property name=\"fixedDepositDao\" ref=\"dao\"/>  \n\t</bean>  \n  \n\t<bean id=\"dao\" class=\"bankapp.dao.FixedDepositDaoImpl\" />\n\t...\n</beans>\n```\n\ncontroller, service, dao 빈은 스코프 지정을 해주지 않았기 때문에 싱글턴 스코프를 가진다. 때문에 스프링 컨테이너는 FixedDepositControllerImpl, FixedDepositServiceImpl, FixedDepositDaoImpl 클래스의 인스턴스를 단 하나씩만 만들게 된다. \n\n<br><br><br>\n\n###  📌 자바 클래스로 bean 설정\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Scope;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    @Scope(\"singleton\")\n    public FixedDepositController fixedDepositController() {\n        FixedDepositControllerImpl controller = new FixedDepositControllerImpl();\n        controller.setFixedDepositService(fixedDepositService());\n        return controller;\n    }\n\n    @Bean\n    @Scope(\"singleton\")\n    public FixedDepositService fixedDepositService() {\n        FixedDepositServiceImpl service = new FixedDepositServiceImpl();\n        service.setFixedDepositDao(fixedDepositDao());\n        return service;\n    }\n\n    @Bean\n    @Scope(\"singleton\")\n    public FixedDepositDao fixedDepositDao() {\n        return new FixedDepositDaoImpl();\n    }\n\n    // 다른 빈 정의 및 설정...\n\n}\n\n```\nxml의 `<bean>` 형태로 설정정보를 저장할 수도 있지만 설정정보를 담당하는 새로운 **클래스**를 만들수도 있다. `AppConfig` 라는 클래스를 만들고 `@Configuration` 처리를 하면 설정정보를 담당하는 클래스로 지정된다. 이후 각각의 빈에 `@Scope()`와 함께 `\"singleton\"` , `\"prototype\"` 등 값을 넣어주면 빈 스코프를 지정할 수 있다.\n\n<br><br>\n \n###  📌 싱글턴 스코프 테스트\n```java\npublic class SingletonTest {\n\n\tprivate static ApplicationContext context;  \n  \n\t@BeforeClass  \n\tpublic static void init() {  \n\t\tcontext = new ClassPathXmlApplicationContext(  \n\t\t\"classpath:META-INF/spring/applicationContext.xml\");  \n\t}  \n  \n\t@Test  \n\tpublic void testInstances() {  \n\t\tFixedDepositController controller1 \n\t\t= (FixedDepositController)context.getBean(\"controller\");\n\t\t\n\t\tFixedDepositController controller2 \n\t\t= (FixedDepositController)context.getBean(\"controller\");  \n  \n\t\tassertSame(\"Different FixedDepositController instances\", controller1,controller2);\n\t}\n\t...\n}\n```\nApplicationContext를 하나 생성하고 FixedDepositController 클래스의 서로 다른 객체 두개(controller1, controller2)를 생성했다. 각각의 객체는 `getBean()` 메소드를 통해 `controller` 라는 이름을 가진 빈을 가져온다. 그리고 이를 `assertSame` 메소드를 통해 같은 값을 반환하는지 확인했다. 이러한 테스트코드를 실행하면 오류없이 잘 작동하는 것을 볼 수 있다. 정리하면 서로 다른 객체에서 각자 빈을 호출했을 때 동일한 빈을 가져왔음을 의미하고 이는 싱글턴 스코프 빈이 잘 적용됐다는 뜻이다.\n\n<br><br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/beanscope1.png?raw=true\">\n</p>\n위 그림을 보면 싱글턴 스코프 빈을 여러번 요청해도 항상 동일한 빈을 반환하는 것을 알 수 있다.\n\n<br><br><br>\n\n### 📌 의존관계 빈들의 싱글턴 스코프\n싱글턴 스코프 빈 인스턴스는 의존관계에 있는 모든 빈 사이에서도 공유된다. 바로 예제를 통해 살펴보자.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/beanscope2.png?raw=true\">\n</p>\n\n```java\npublic class SingletonTest {  \nprivate static ApplicationContext context;  \n  \n\t@BeforeClass  \n\tpublic static void init() {  \n\t\tcontext = new ClassPathXmlApplicationContext(  \n\t\t\"classpath:META-INF/spring/applicationContext.xml\");  \n\t}  \n  \n\t@Test  \n\tpublic void testReference() {  \n\t\tFixedDepositController controller \n\t\t= (FixedDepositController) context.getBean(\"controller\");\n\t\t\n\t\tFixedDepositDao fixedDepositDao1 \n\t\t= controller.getFixedDepositService().getFixedDepositDao();\n\t\t \n\t\tFixedDepositDao fixedDepositDao2 \n\t\t= (FixedDepositDao) context.getBean(\"dao\");  \n  \n\t\tassertSame(\"Different FixedDepositDao instances\",\n\t\tfixedDepositDao1, fixedDepositDao2);\n\t}  \n}\n```\n그림에 기반해서 코드를 살펴보면, `FixedDepositController`빈이 참조하는 `FixedDepositDao` 인스턴스를 읽고(fixedDepositDao1), 이후 `getBean()` 메서드를 사용해 `FixedDepositDao` 빈의 다른 인스턴스를 읽었다(fixedDepositDao2). 테스트를 실행해보면 두 인스턴스가 같음을 알 수 있다.\n\n<br><br><br>\n\n### 📌 싱글턴 스코프는 같은 스프링 컨테이너 내에서만 유지된다!\n앞서 계속 싱글턴 스코프 빈은 인스턴스를 한개만 생성하고 호출될 때마다 해당 빈을 공유한다고 설명했다. 그러나 이는 하나의 스프링 컨테이너 내에서만 해당하는 얘기이다. 스프링 컨테이너를 두개이상 만들고 각 스프링 컨테이너마다 싱글턴 빈 인스턴스를 만들면, 각 컨테이너의 싱글턴 인스턴스는 서로 다른 빈이 된다.\n\n<br><Br><br><br>\n\n\n\n## ✅ 프로토타입 (Prototype) 스코프\n프로토타입 스코프 빈이 싱글턴 스코프 빈과 다른점은 스프링 컨테이너가 **항상 프로토타입 스코프 빈의 새로운 인스턴스를 반환한다**는 점이다.\n\n```java\n// ApplicationContext.xml\n<bean id=\"fixedDepositDetails\"  \n\tclass=\"sample.spring.chapter02.bankapp.domain.FixedDepositDetails\" \n\tscope=\"prototype\" />  \n</beans>\n```\n\n정의하는 방법은 싱글턴과 동일하다. `<bean>` 엘리먼트에 `scope=\"prototype\"` 을 추가해주면 된다. 어려운 개념은 없다. 싱글턴 스코프 빈은 단 한개의 인스턴스만 생성되는 것이고, 프로토타입 스코프 빈은 호출될 때마다 새로운 인스턴스를 생성하는 것이다.\n","properties":"\n","discussions":{},"comments":{},"hash":1850828839}},"syncHistory":{"main":[1850828839,1850828839,null]},"v":1,"hash":1710728133855,"tx":4863},"14iOQ0JTNwFklzQv":{"id":"14iOQ0JTNwFklzQv","type":"file","name":"2024-03-18-퍼사드(Facade) 패턴","parentId":"Q6xmU68w98wuNklY","hash":-1055952409,"tx":6410},"LOPgwVDwC6boRNzS/content":{"id":"LOPgwVDwC6boRNzS/content","type":"content","text":"---\npermalink: /2022-08-17-디자인 패턴/\npublished: true\ntitle: \"[Design Pattern] 디자인 패턴의 종류 \"\ndate: 2022-08-17 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"디자인 패턴 종류\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n---\n<br><br><br>\n\n## ✅ 디자인 패턴이란\n**소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들을 해결하기 위한 해결책**\n\n<br><br><br><br>\n\n## ✅ 디자인 패턴의 분류\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/pattern1.png?raw=true\">\n</p>\n\n1. **생성(Creational) 패턴**\n**객체 생성**에 관련된 패턴\n객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.\n\n2. **구조(Structural) 패턴**\n**클래스나 객체를 조합해 더 큰 구조를 만드는 패턴**\n예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.\n\n3. **행위(Behavioral) 패턴**\n**객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴**\n한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.\n\n<br><br><br><br>\n\n\n\n\n## ✅ 디자인 패턴의 종류\n\n\n### 📌 생성(Creational) 패턴\n- **추상 팩토리 (Abstract Factory)**\n- 빌더 (Builder)\n- **팩토리 메소드 (Factory Methods)**\n- 프로토타입 (Prototype)\n\n<br>\n\n### 📌 구조(Structural) 패턴\n- 어댑터 (Adapter)\n- 브리지 (Bridge)\n- **컴포지트 (Composite)**\n- **데코레이터 (Decorator)**\n- 퍼사드 (Facade)\n- 플라이웨이트 (Flyweight)\n- 프록시 (Proxy)\n\n<br>\n\n### 📌 행위(Behavioral) 패턴\n- 책임 연쇄 (Chain of Responsibility)\n- **커맨드 (Command)**\n- 인터프리터 (Interpreter)\n- 반복자 (iterator)\n- 메멘토 (Memento)\n- **옵저버 (Observer)**\n- **상태 (State)**\n- **전략 (Strategy)**\n- **템플릿 메소드 (Template Method)**\n- 비지터 (Visitor)\n","properties":"\n","discussions":{},"comments":{},"hash":-1386190483,"tx":6500},"LOPgwVDwC6boRNzS/syncedContent":{"id":"LOPgwVDwC6boRNzS/syncedContent","type":"syncedContent","historyData":{"-697777392":{"id":"LOPgwVDwC6boRNzS/content","type":"content","text":"---\npermalink: /2022-08-17-디자인 패턴/\npublished: true\ntitle: \"[Design Pattern] 디자인 패턴의 종류 \"\ndate: 2022-08-17 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"디자인 패턴 종류\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n---\n<br><br><br>\n\n## ⭐ 디자인 패턴이란\n**소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들을 해결하기 위한 해결책**\n\n<br><br><br><br>\n\n## ⭐ 디자인 패턴의 분류\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/pattern1.png?raw=true\">\n</p>\n\n1. **생성(Creational) 패턴**\n**객체 생성**에 관련된 패턴\n객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.\n\n2. **구조(Structural) 패턴**\n**클래스나 객체를 조합해 더 큰 구조를 만드는 패턴**\n예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.\n\n3. **행위(Behavioral) 패턴**\n**객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴**\n한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.\n\n<br><br><br><br>\n\n\n\n\n## ⭐ 디자인 패턴의 종류\n\n\n### 🌙 생성(Creational) 패턴\n- **추상 팩토리 (Abstract Factory)**\n- 빌더 (Builder)\n- **팩토리 메소드 (Factory Methods)**\n- 프로토타입 (Prototype)\n\n<br>\n\n### 🌙 구조(Structural) 패턴\n- 어댑터 (Adapter)\n- 브리지 (Bridge)\n- **컴포지트 (Composite)**\n- **데코레이터 (Decorator)**\n- 퍼사드 (Facade)\n- 플라이웨이트 (Flyweight)\n- 프록시 (Proxy)\n\n<br>\n\n### 🌙 행위(Behavioral) 패턴\n- 책임 연쇄 (Chain of Responsibility)\n- **커맨드 (Command)**\n- 인터프리터 (Interpreter)\n- 반복자 (iterator)\n- 메멘토 (Memento)\n- **옵저버 (Observer)**\n- **상태 (State)**\n- **전략 (Strategy)**\n- **템플릿 메소드 (Template Method)**\n- 비지터 (Visitor)\n","properties":"\n","discussions":{},"comments":{},"hash":-697777392},"-1386190483":{"id":"LOPgwVDwC6boRNzS/content","type":"content","text":"---\npermalink: /2022-08-17-디자인 패턴/\npublished: true\ntitle: \"[Design Pattern] 디자인 패턴의 종류 \"\ndate: 2022-08-17 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"디자인 패턴 종류\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n---\n<br><br><br>\n\n## ✅ 디자인 패턴이란\n**소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들을 해결하기 위한 해결책**\n\n<br><br><br><br>\n\n## ✅ 디자인 패턴의 분류\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/pattern1.png?raw=true\">\n</p>\n\n1. **생성(Creational) 패턴**\n**객체 생성**에 관련된 패턴\n객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.\n\n2. **구조(Structural) 패턴**\n**클래스나 객체를 조합해 더 큰 구조를 만드는 패턴**\n예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.\n\n3. **행위(Behavioral) 패턴**\n**객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴**\n한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.\n\n<br><br><br><br>\n\n\n\n\n## ✅ 디자인 패턴의 종류\n\n\n### 📌 생성(Creational) 패턴\n- **추상 팩토리 (Abstract Factory)**\n- 빌더 (Builder)\n- **팩토리 메소드 (Factory Methods)**\n- 프로토타입 (Prototype)\n\n<br>\n\n### 📌 구조(Structural) 패턴\n- 어댑터 (Adapter)\n- 브리지 (Bridge)\n- **컴포지트 (Composite)**\n- **데코레이터 (Decorator)**\n- 퍼사드 (Facade)\n- 플라이웨이트 (Flyweight)\n- 프록시 (Proxy)\n\n<br>\n\n### 📌 행위(Behavioral) 패턴\n- 책임 연쇄 (Chain of Responsibility)\n- **커맨드 (Command)**\n- 인터프리터 (Interpreter)\n- 반복자 (iterator)\n- 메멘토 (Memento)\n- **옵저버 (Observer)**\n- **상태 (State)**\n- **전략 (Strategy)**\n- **템플릿 메소드 (Template Method)**\n- 비지터 (Visitor)\n","properties":"\n","discussions":{},"comments":{},"hash":-1386190483}},"syncHistory":{"main":[-1386190483,-697777392,-1386190483]},"v":1,"hash":1710740832151,"tx":6504},"2OTxNzpMQajxUPNa/content":{"id":"2OTxNzpMQajxUPNa/content","type":"content","text":"---\npermalink: /2022-08-17-싱글톤(Singleton)패턴/\npublished: true\ntitle: \"[Design Pattern] 싱글톤(Singleton)패턴 \"\ndate: 2022-08-17 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"싱글톤(Singleton)패턴\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n- 생성 패턴\n---\n<br><br><br>\n\n## ✅ 싱글톤 패턴 (Singleton Pattern)\n애플리케이션이 시작될 때, 어떤 클래스가 **최초 한번만 메모리를 할당(static)** 하고 해당 메모리에 인스턴스를 만들어 사용하는 패턴이다. 디자인 패턴 중 가장 자주 활용되는 패턴이기도 하지만 가장 많은 비판을 받는 패턴이기도 하다.\n\n싱글톤 패턴은 **어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 주로 하나만 존재하도록 강제하는 패턴**이다. 이런 단일 오브젝트는 애플리케이션 내에서 **전역적으로 접근이 가능하다**. 단일 오브젝트로만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다. \n\n<br><br><br><br>\n\n## ✅ 싱글톤 패턴 사용 이유\n객체는 생성할 때마다 메모리 영역을 할당받아야 한다. 하지만 싱글톤 패턴을 사용하면 단 한번의 new를 통해 객체를 한번만 생성하고 활용함으로써 **메모리 낭비를 방지**할 수 있다. 또한 싱글톤 패턴으로 구현한 인스턴스는 전역변수이므로 **다른 클래스의 인스턴스들이 데이터를 공유 할 수 있다**.\n\n<br><br><br><br>\n\n## ✅ 싱글톤 패턴 장점\n- 고정된 메모리 영역을 얻으면서 한번의 new로 인해 메모리 낭비 방지\n\n- 전역 인스턴스이므로 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.\n\n- 인스턴스가 절대적으로 한 개만 존재하는 것을 보증한다.\n\n- 두번째 이용시 부터는 객체 로딩시간이 줄어 성능이 좋아진다.\n\n<br><br><br><br>\n\n## ✅ 싱글톤 패턴 단점\n- 싱글톤 인스턴스가 너무 많은 책임을 가진 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 \"개방-폐쇄 원칙\"을 위배하게 된다.\n\t> 개방폐쇄원칙 : ' 클래스나 모듈은 확장에는 열려있어야 하고 변경에는 닫혀있어야 한다. ' \n\n- 멀티 스레드 환경에서 동기화 처리를 하지 않은 경우, 인스턴스가 2개가 생성 될 수도 있다.\n\n- 반드시 싱글톤이 필요한 상황이 아니면 사용을 지양하는 것이 좋다.\n<br><br><br><br>\n\n## ✅ 싱글톤 패턴 예제\n```java\npublic class Singleton {\n\n    private static Singleton instance = new Singleton();\n    \n    private Singleton() {\n        // 생성자는 외부에서 호출못하게 private 으로 지정해야 한다.\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n\n    public void say() {\n        System.out.println(\"hi, there\");\n    }\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-417076915,"tx":6532},"2OTxNzpMQajxUPNa/syncedContent":{"id":"2OTxNzpMQajxUPNa/syncedContent","type":"syncedContent","historyData":{"-417076915":{"id":"2OTxNzpMQajxUPNa/content","type":"content","text":"---\npermalink: /2022-08-17-싱글톤(Singleton)패턴/\npublished: true\ntitle: \"[Design Pattern] 싱글톤(Singleton)패턴 \"\ndate: 2022-08-17 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"싱글톤(Singleton)패턴\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n- 생성 패턴\n---\n<br><br><br>\n\n## ✅ 싱글톤 패턴 (Singleton Pattern)\n애플리케이션이 시작될 때, 어떤 클래스가 **최초 한번만 메모리를 할당(static)** 하고 해당 메모리에 인스턴스를 만들어 사용하는 패턴이다. 디자인 패턴 중 가장 자주 활용되는 패턴이기도 하지만 가장 많은 비판을 받는 패턴이기도 하다.\n\n싱글톤 패턴은 **어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 주로 하나만 존재하도록 강제하는 패턴**이다. 이런 단일 오브젝트는 애플리케이션 내에서 **전역적으로 접근이 가능하다**. 단일 오브젝트로만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다. \n\n<br><br><br><br>\n\n## ✅ 싱글톤 패턴 사용 이유\n객체는 생성할 때마다 메모리 영역을 할당받아야 한다. 하지만 싱글톤 패턴을 사용하면 단 한번의 new를 통해 객체를 한번만 생성하고 활용함으로써 **메모리 낭비를 방지**할 수 있다. 또한 싱글톤 패턴으로 구현한 인스턴스는 전역변수이므로 **다른 클래스의 인스턴스들이 데이터를 공유 할 수 있다**.\n\n<br><br><br><br>\n\n## ✅ 싱글톤 패턴 장점\n- 고정된 메모리 영역을 얻으면서 한번의 new로 인해 메모리 낭비 방지\n\n- 전역 인스턴스이므로 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.\n\n- 인스턴스가 절대적으로 한 개만 존재하는 것을 보증한다.\n\n- 두번째 이용시 부터는 객체 로딩시간이 줄어 성능이 좋아진다.\n\n<br><br><br><br>\n\n## ✅ 싱글톤 패턴 단점\n- 싱글톤 인스턴스가 너무 많은 책임을 가진 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 \"개방-폐쇄 원칙\"을 위배하게 된다.\n\t> 개방폐쇄원칙 : ' 클래스나 모듈은 확장에는 열려있어야 하고 변경에는 닫혀있어야 한다. ' \n\n- 멀티 스레드 환경에서 동기화 처리를 하지 않은 경우, 인스턴스가 2개가 생성 될 수도 있다.\n\n- 반드시 싱글톤이 필요한 상황이 아니면 사용을 지양하는 것이 좋다.\n<br><br><br><br>\n\n## ✅ 싱글톤 패턴 예제\n```java\npublic class Singleton {\n\n    private static Singleton instance = new Singleton();\n    \n    private Singleton() {\n        // 생성자는 외부에서 호출못하게 private 으로 지정해야 한다.\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n\n    public void say() {\n        System.out.println(\"hi, there\");\n    }\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-417076915}},"syncHistory":{"main":[-417076915,-417076915,null]},"v":1,"hash":1710740985280,"tx":6547},"ADbe6HrECGC5ROmU/syncedContent":{"id":"ADbe6HrECGC5ROmU/syncedContent","type":"syncedContent","historyData":{"1104898847":{"id":"ADbe6HrECGC5ROmU/content","type":"content","text":"---\npermalink: /2023-11-10-생산자&소비자(Producer&Consumer) 패턴/\npublished: true\ntitle: \"[Design Pattern] 생산자&소비자(Producer&Consumer) 패턴 \"\ndate: 2023-11-10 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"생산자&소비자(Producer&Consumer) 패턴\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n- 생산자&소비자(Producer&Consumer) 패턴\n---\n<br><br><br>\n\n## ✅ 생산자 소비자 패턴이란?\n\n생산자-소비자 패턴은 **멀티스레드 환경에서 여러 스레드가 공유 자원에 접근할 때 발생하는 동기화 문제를 해결하기 위한** 디자인 패턴이다.\n\n생산자-소비자 패턴은 멀티스레드 환경에서 **생산자(Producer) 스레드가 데이터를 생성하고, 소비자(Consumer) 스레드가 해당 데이터를 소비**하도록 구성되고, 효율적으로 자원을 관리할 수 있도록 한다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/producerconsumer.png?raw=true\">\n</p>\n\n<br>\n\n위 그림처럼 작업을 생성하는 **생산자 스레드**와 Queue로 설계된 **공유자원**, 그리고 작업을 수행하는 **소비자 스레드**로 구성되어 있는것이 일반적인 생산자-소비자 패턴의 구조이다.\n\n<br><br><br><br>\n\n## ✅ 생산자 소비자 패턴의 구성 요소\n\n1. **생산자(Producer)**\n\n\t데이터를 생성하고 공유자원에 저장하는 역할을 수행한다. 생산자는 새로운 데이터를 생성하여 공유자원에 추가하거나 기존의 데이터를 갱신한다.\n\n\n2. **소비자(Consumer)**\n\n\t공유 자원에서 데이터를 가져와서 처리하는 역할을 수행한다.\n\n\n3. **공유 자원(Buffer 또는 Queue)**\n\n\t생산자와 소비자 간의 데이터 교환을 위한 공유 자원이다. 일반적으로 버퍼(Buffer)나 큐(Queue)로 구현된다.\n\n4. **동기화 메커니즘**\n\n\t생산자와 소비자 간의 동기화를 이루기 위한 메커니즘이 존재한다. 생산자측은 공유자원이 가득 차있는지 확인하고 데이터를 추가하기 위해 대기해야 하고, 소비자측은 공유자원이 비어 있는지 확인하고 데이터를 가져오기 위해 대기하는 등의 동작을 수행한다. 일반적으로 **뮤텍스(Mutex), 세마포어(Semaphore), 조건 변수(Condition Variable)** 등이 있다.\n\n<br>\n\n> **뮤텍스 : 상호 배제를 통해 한번에 한 스레드만 공유자원에 접근 가능하도록 함**  \n> **세마포어 : 공유 자원에 접근할 수 있는 스레드의 수를 제어**  \n> **조건변수 : 특정 조건을 만족할 때 까지 스레드를 대기시킴** \n\n<br><br><br><br>\n\n\n## ✅ 생산자 소비자 패턴을 사용하는 이유\n\n1. **자원관리**\n\n\t여러 스레드가 공유자원에 동시에 접근하는 상황에서 자원을 효율적으로 관리할 수 있다. 한마디로 자원의 공유 및 동시 접근 문제를 효과적으로 해결할 수 있다.\n\n2. **동기화**\n\n\t멀티 스레드 환경에서 생성자와 소비자 간의 데이터 접근을 동기화하여 데이터의 **일관성**과 **안정성**을 보장할 수 있다. 동기화 메커니즘을 통해 생산자 작업을 생성 할 때 소비자가 이를 가져오고, 소비자가 작업을 처리할 때 다른 소비자가 동일한 데이터를 중복으로 처리하지 않도록 보장한다.\n\n3. **효율성**\n\n\t생산자-소비자 간의 작업을 비동기적으로 처리하여 시스템의 성능을 향상시킬 수 있다. 생산자는 데이터를 생성하고 버퍼에 추가하는 동안 다른 작업을 수행할 수 있고, 소비자 역시 데이터를 처리하는 동안 다른 작업을 수행할 수 있다.\n\n4. **작업 속도 조절 가능**\n\n\t버퍼, 큐의 크기나 생산자의 생산속도를 조절하여 시스템의 작업 속도를 조절할 수 있다. 이를 통해 안정성과 효율성을 최적화 할 수 있다.\n\t\n\n<br><br><br><br>\n\n\n## ✅ 생산자 소비자 패턴 적용 상황\n\n1. **스레드 풀 ( Thread Pool )**\n\n\t생산자는 작업을 생성하고 버퍼,큐에 추가하며, 소비자는 버퍼에서 작업을 가져와 처리한다. 이를 통해 작업을 비동기적으로 처리하여 시스템의 처리량을 향상시킬 수 있다.\n\n```java\nimport java.util.concurrent.*;\n\nclass Producer implements Runnable {\n    private BlockingQueue<Integer> buffer;\n    private int data = 0;\n\n    public Producer(BlockingQueue<Integer> buffer) {\n        this.buffer = buffer;\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                produce(data++);\n                Thread.sleep(1000); // 생산 간격을 조절하기 위해 잠시 멈춤\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private void produce(int i) throws InterruptedException {\n        System.out.println(\"Producing: \" + i);\n        buffer.put(i); // 데이터를 생산하여 버퍼에 추가\n    }\n}\n\nclass Consumer implements Runnable {\n    private BlockingQueue<Integer> buffer;\n\n    public Consumer(BlockingQueue<Integer> buffer) {\n        this.buffer = buffer;\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                int data = consume();\n                Thread.sleep(2000); // 소비 간격을 조절하기 위해 잠시 멈춤\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private int consume() throws InterruptedException {\n        int data = buffer.take(); // 버퍼에서 데이터를 가져옴\n        System.out.println(\"Consuming: \" + data);\n        return data;\n    }\n}\n\npublic class ThreadPoolProducerConsumer {\n    public static void main(String[] args) {\n        // 버퍼로 사용할 BlockingQueue 생성\n        BlockingQueue<Integer> buffer = new ArrayBlockingQueue<>(10);\n\n        // 스레드 풀 생성\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        // 생산자 및 소비자 스레드 생성 및 스레드 풀에 제출\n        executor.submit(new Producer(buffer));\n        executor.submit(new Consumer(buffer));\n\n        // 스레드 풀 종료\n        executor.shutdown();\n    }\n}\n```\n\n위의 예제에서는 BlockingQueue를 사용하여 공유 버퍼를 구현했다. 그리고 Producer 클래스와 Consumer 클래스는 각각 Runnable을 구현하여 생산자 스레드와 소비자 스레드를 정의한다.\n\n생산자는 데이터를 생성하여 BlockingQueue에 추가하고, 소비자는 BlockingQueue에서 데이터를 가져와서 처리한다. 이 두가지 작업은 스레드 풀을 사용하여 병렬적으로 실행된다.\n\n마지막으로 main 메서드에서는 스레드 풀을 생성하고, 생산자 및 소비자 스레드를 스레드 풀에 제출한다. 모든 작업이 완료된 후에는 스레드 풀을 종료한다.\n<br><br>\n\n\n\n2. **이벤트 기반 시스템 ( Event-Driven Systems )**\n\n\t이벤트 발생 시 생산자는 해당 이벤트를 생성하고 큐에 추가하는 역할을 수행하며, 소비자는 큐에서 이벤트를 가져와 처리한다.\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n// 생산자 이벤트 클래스\nclass ProduceEvent {\n    private int data;\n\n    public ProduceEvent(int data) {\n        this.data = data;\n    }\n\n    public int getData() {\n        return data;\n    }\n}\n\n// 소비자 이벤트 클래스\nclass ConsumeEvent {\n    private int data;\n\n    public ConsumeEvent(int data) {\n        this.data = data;\n    }\n\n    public int getData() {\n        return data;\n    }\n}\n\n// 생산자 클래스\nclass Producer implements Runnable {\n    private BlockingQueue<ProduceEvent> produceQueue;\n    private int data = 0;\n\n    public Producer(BlockingQueue<ProduceEvent> produceQueue) {\n        this.produceQueue = produceQueue;\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                ProduceEvent event = new ProduceEvent(data++);\n                produceQueue.put(event);\n                System.out.println(\"Producing: \" + event.getData());\n                Thread.sleep(1000); // 생산 간격을 조절하기 위해 잠시 멈춤\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\n// 소비자 클래스\nclass Consumer implements Runnable {\n    private BlockingQueue<ProduceEvent> produceQueue;\n    private BlockingQueue<ConsumeEvent> consumeQueue;\n\n    public Consumer(BlockingQueue<ProduceEvent> produceQueue, BlockingQueue<ConsumeEvent> consumeQueue) {\n        this.produceQueue = produceQueue;\n        this.consumeQueue = consumeQueue;\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                ProduceEvent event = produceQueue.take();\n                ConsumeEvent consumeEvent = new ConsumeEvent(event.getData());\n                consumeQueue.put(consumeEvent);\n                System.out.println(\"Consuming: \" + consumeEvent.getData());\n                Thread.sleep(2000); // 소비 간격을 조절하기 위해 잠시 멈춤\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\npublic class EventDrivenProducerConsumer {\n    public static void main(String[] args) {\n        BlockingQueue<ProduceEvent> produceQueue = new LinkedBlockingQueue<>();\n        BlockingQueue<ConsumeEvent> consumeQueue = new LinkedBlockingQueue<>();\n\n        // 생산자와 소비자 객체 생성\n        Producer producer = new Producer(produceQueue);\n        Consumer consumer = new Consumer(produceQueue, consumeQueue);\n\n        // 생산자와 소비자를 각각 스레드로 실행\n        Thread producerThread = new Thread(producer);\n        Thread consumerThread = new Thread(consumer);\n        producerThread.start();\n        consumerThread.start();\n    }\n}\n```\n\n생산자가 생산한 데이터를 이벤트 객체로 담아서 큐에 넣고, 소비자는 이벤트를 큐에서 가져와서 처리한다. \n\n<br><br>\n\n\n3. **생산자-소비자 문제 해결**\n\n\t공유자원에 접근하는 여러 스레드간의 동기화 문제를 해결하기 위해 사용된다. 생산자는 버퍼에 데이터를 추가하고, 소비자는 버퍼에서 데이터를 가져와 처리함으로써 동기화된 데이터 접근을 보장한다.\n\n\n<br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1104898847}},"syncHistory":{"main":[1104898847,1104898847,null]},"v":1,"hash":1710743462691,"tx":6711},"vVPdin3FmpSihQxj/contentState":{"id":"vVPdin3FmpSihQxj/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710747881252,"tx":7539},"vVPdin3FmpSihQxj":{"id":"vVPdin3FmpSihQxj","type":"file","name":"실습관련","parentId":"trash","hash":-536505815,"tx":7540},"aJrzklaPe7FlmPv5/contentState":{"id":"aJrzklaPe7FlmPv5/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710747887851,"tx":7542},"aJrzklaPe7FlmPv5":{"id":"aJrzklaPe7FlmPv5","type":"file","name":"temp","parentId":"trash","hash":1703094190,"tx":7543},"VhXoCDuP9kB8fjSR/contentState":{"id":"VhXoCDuP9kB8fjSR/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710747905916,"tx":7551},"VhXoCDuP9kB8fjSR":{"id":"VhXoCDuP9kB8fjSR","type":"file","name":"2023-06-27-트랜젝션","parentId":"trash","hash":-342833628,"tx":7552},"bHqTE0XjV1KS586A/contentState":{"id":"bHqTE0XjV1KS586A/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710747919884,"tx":7559},"bHqTE0XjV1KS586A":{"id":"bHqTE0XjV1KS586A","type":"file","name":"2023-05-15-CSS(3)","parentId":"trash","hash":1332832744,"tx":7560},"VCnzbwtUALknf6h2/contentState":{"id":"VCnzbwtUALknf6h2/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710747927261,"tx":7562},"VCnzbwtUALknf6h2":{"id":"VCnzbwtUALknf6h2","type":"file","name":"2023-05-26-nodejs","parentId":"trash","hash":2061585656,"tx":7563},"JbeDoZUm857e8fdL":{"id":"JbeDoZUm857e8fdL","type":"file","name":"2022-05-31-프로그래머스_위장","parentId":"trash","hash":-162888804,"tx":7572},"xJpL045jRDmgWJHa/contentState":{"id":"xJpL045jRDmgWJHa/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710747952101,"tx":7574},"xJpL045jRDmgWJHa":{"id":"xJpL045jRDmgWJHa","type":"file","name":"리액트 토이프로젝트","parentId":"trash","hash":399489278,"tx":7575},"C0Q29ajZZPzh3Jcv/contentState":{"id":"C0Q29ajZZPzh3Jcv/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710747954085,"tx":7576},"C0Q29ajZZPzh3Jcv":{"id":"C0Q29ajZZPzh3Jcv","type":"file","name":"2023-06-09-React Router DOM 총정리","parentId":"trash","hash":433435335,"tx":7577},"27FCLunQqiKehP51/contentState":{"id":"27FCLunQqiKehP51/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710748650928,"tx":8051},"14iOQ0JTNwFklzQv/syncedContent":{"id":"14iOQ0JTNwFklzQv/syncedContent","type":"syncedContent","historyData":{"502730339":{"id":"14iOQ0JTNwFklzQv/content","type":"content","text":"---\npermalink: /2024-03-18-퍼사드(Facade) 패턴/\npublished: true\ntitle: \"[Design Pattern] 퍼사드(Facade) 패턴 \"\ndate: 2024-03-18 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"퍼사드(Facade) 패턴\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n- 퍼사드(Facade) 패턴\n---\n<br><br><br>\n\n## ✅ 퍼사드 패턴이란?\n\n퍼사드(Facade) 패턴은 **복잡한 시스템이나 서브시스템을 간략한 인터페이스를 통해 제공하여 시스템의 복잡성을 감소시키고 사용하기 편리하게 만들어주는 패턴이다.** 복잡한 시스템을 감싸고 있는 외부 인터페이스를 제공하여 시스템 간의 의존성을 낮추고, 클라이언트가 시스템의 내부 구조에 대해 알 필요 없이 사용할 수 있게 해준다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/facade.png?raw=true\">\n</p>\n\n<br>\n\n퍼사드 패턴의 핵심 요소는 \"퍼사드\" 클래스이다. 퍼사드 클래스를 통해 시스템의 복잡한 부분을 캡슐화하고, 간단한 인터페이스를 제공한다. 클라이언트는 이 퍼사드 클래스를 사용하여 서브시스템과 상호작용 한다.\n\n<br><br><br><br>\n\n\n\n## ✅ 퍼사드 패턴의 구성 요소\n\n1. **Facade**\n\n\t클라이언트와 내부 시스템 간의 중간 계층으로 작용하는 인터페이스를 제공한다. 복잡한 서브 시스템에 대한 단순한 메소드들로 구성된다.\n\n2. **Subsystem Classes**\n\n\t퍼사드 클래스에 의해 감싸지는 복잡한 서브시스템의 클래스들을 의미한다. 이 클래스들이 시스템의 핵심 로직을 구현한다.\n\n3. **Client**\n\n\tFacade를 사용하여 복잡한 시스템을 간편하게 사용하는 클라이언트이다.\n\n<br><Br><br><Br>\n\n## ✅ 퍼사드 패턴의 구조\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/facade2.png?raw=true\">\n</p>\n\n<br>\n\n1. 퍼사드 패턴을 사용하면 하위 시스템 기능들의 특정 부분에 편리하게 접근할 수 있다.\n2. 추가적인 퍼사드 클래스는 관련없는 기능들이 포함되어 복잡한 구조로 퍼사드 클래스가 변질되는 것을 방지할 수 있다.\n3. 복잡한 하위 시스템은 수십 개의 다양한 객체들로 구성된다. 모든 객체가 의미있는 작업을 수행하도록 하려면, 하위 시스템의 세부적인 구현 정보를 깊이 있게 알아야 한다. 이때 하위 시스템 클래스들은 퍼사드 클래스의 존재를 인식하지 못한다.\n4. 클라이언트는 하위 시스템 객체를 직접 호출하는 것 대신 퍼사드 클래스를 통해 하위 시스템 객체를 사용한다.\n\n<br>\n\n### 📌 퍼사드 패턴 의사코드\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/facade3.png?raw=true\">\n</p>\n\n<br>\n\n```java\n// 복잡한 비디오 변환 프레임워크 클래스의 일부이다. \n// 해당 프레임워크 코드는 우리가 제어할 수 없기 때문에 단순화할 수 없다.\n\nclass VideoFile\n// …\n\nclass OggCompressionCodec\n// …\n\nclass MPEG4CompressionCodec\n// …\n\nclass CodecFactory\n// …\n\nclass BitrateReader\n// …\n\nclass AudioMixer\n// …\n\n// 퍼사드 클래스를 만들어 프레임워크의 복잡성을 간단한 인터페이스 뒤에 숨길 수\n// 있다. 기능성과 단순함을 상호보완한다.\nclass VideoConverter is\n    method convert(filename, format):File is\n        file = new VideoFile(filename)\n        sourceCodec = (new CodecFactory).extract(file)\n        if (format == \"mp4\")\n            destinationCodec = new MPEG4CompressionCodec()\n        else\n            destinationCodec = new OggCompressionCodec()\n        buffer = BitrateReader.read(filename, sourceCodec)\n        result = BitrateReader.convert(buffer, destinationCodec)\n        result = (new AudioMixer()).fix(result)\n        return new File(result)\n\n// 애플리케이션 클래스들은 복잡한 프레임워크에서 제공하는 수많은 클래스에 의존하지\n// 않는다. 또한 프레임워크의 전환을 결정한 경우에는 퍼사드 클래스만 다시 작성하면 된다.\nclass Application is\n    method main() is\n        convertor = new VideoConverter()\n        mp4 = convertor.convert(\"funny-cats-video.ogg\", \"mp4\")\n        mp4.save()\n```\n\n<br><br><br><br>\n\n\n## ✅ 퍼사드 패턴을 사용하는 이유\n\n1. **단순한 인터페이스 제공**\n\n\t복잡한 시스템에 대해 단순한 인터페이스를 제공하여 클라이언트가 시스템의 내부 동작을 이해할 필요 없이 사용할 수 있다.\n\n2. **시스템 간의 의존성 낮춤**\n\n\tFacade 패턴은 시스템의 내부 구조를 숨기기 때문에, 시스템 간의 의존성을 줄여서 시스템을 변경하거나 유지보수 하기 쉽게 만든다.\n\n3. **구조적 복잡성 감소**\n\n\t복잡한 시스템을 여러 개의 간단한 서브시스템으로 분할하고, 이를 Facade를 통해 조합함으로써 구조적 복잡성을 줄일 수 있다.\n\n<br><br><br><br>\n\n\n## ✅ 퍼사드 패턴 적용 상황\n\n1. **라이브러리의 사용**\n\n\t자주 사용하는 기능을 라이브러리로 제공할 때, 라이브러리 내부의 복잡한 기능을 Facade를 통해 단순화하여 사용자가 쉽게 사용할 수 있게 한다.\n\n<br>\n\n```java\n// 서브시스템 1: 가계부 데이터 관리\nclass AccountBook {\n    public void addExpense(String category, double amount) {\n        // 가계부에 지출 내역 추가\n        System.out.println(\"Added expense of $\" + amount + \" to category: \" + category);\n    }\n\n    public void addIncome(String source, double amount) {\n        // 가계부에 수입 내역 추가\n        System.out.println(\"Added income of $\" + amount + \" from source: \" + source);\n    }\n}\n\n// 서브시스템 2: 가계부 보고서 생성\nclass ReportGenerator {\n    public void generateMonthlyReport() {\n        // 월간 보고서 생성\n        System.out.println(\"Generated monthly report\");\n    }\n\n    public void generateYearlyReport() {\n        // 연간 보고서 생성\n        System.out.println(\"Generated yearly report\");\n    }\n}\n\n// 퍼사드 클래스: 클라이언트에게 단순한 인터페이스를 제공\nclass AccountFacade {\n    private AccountBook accountBook;\n    private ReportGenerator reportGenerator;\n\n    public AccountFacade() {\n        this.accountBook = new AccountBook();\n        this.reportGenerator = new ReportGenerator();\n    }\n\n    // 가계부에 지출 추가 메서드\n    public void addExpense(String category, double amount) {\n        accountBook.addExpense(category, amount);\n    }\n\n    // 가계부에 수입 추가 메서드\n    public void addIncome(String source, double amount) {\n        accountBook.addIncome(source, amount);\n    }\n\n    // 월간 보고서 생성 메서드\n    public void generateMonthlyReport() {\n        reportGenerator.generateMonthlyReport();\n    }\n\n    // 연간 보고서 생성 메서드\n    public void generateYearlyReport() {\n        reportGenerator.generateYearlyReport();\n    }\n}\n\n// 클라이언트\npublic class Client {\n    public static void main(String[] args) {\n        // 퍼사드를 통해 간단한 인터페이스로 서브시스템을 사용\n        AccountFacade accountFacade = new AccountFacade();\n\n        // 가계부 작업\n        accountFacade.addExpense(\"Groceries\", 50.00);\n        accountFacade.addIncome(\"Salary\", 2000.00);\n\n        // 보고서 생성\n        accountFacade.generateMonthlyReport();\n        accountFacade.generateYearlyReport();\n    }\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":502730339}},"syncHistory":{"main":[502730339,502730339,null]},"v":1,"hash":1710812478364,"tx":9342},"QCDOYp9baGlX0tfx/syncedContent":{"id":"QCDOYp9baGlX0tfx/syncedContent","type":"syncedContent","historyData":{"-1048238512":{"id":"QCDOYp9baGlX0tfx/content","type":"content","text":"---\npermalink: /2024-03-11-ERP(Enterprise Resource Planning)란\npublished: true\ntitle: \"[ERP] ERP(Enterprise Resource Planning)란?\"\ndate: 2024-03-11 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"ERP(Enterprise Resource Planning)란?\"\ncategories:\n- ERP\ntags:\n- ERP\n---\n\n<br><br>\n\n\n## ✅ ERP(Enterprise Resource Planning) 란?\n\nERP는 Enterprise Resource Planning의 약자로, **기업 내 모든 부문에 걸쳐 자원을 효과적으로 관리하기 위한 통합 솔루션이다.** EPR 시스템은 주문 처리, 재고 관리, 생산 계획, 구매, 판매, 회계, 인사 등 조직 내의 다양한 업무 영역을 포함하며 조직의 다양한 기능을 통합하여 효율성과 생산성을 향상시키고 의사 결정을 지원하기 위해 실시간 데이터를 제공한다.\n\n일반적으로 ERP 시스템은 다양한 모듈을 제공하며, 비즈니스를 효율적으로 운영하는 데 필수적인 자동화와 통합 등을 제공한다. 예를 들어 판매 모듈에서는 판매계획, 주문관리, 실적관리 등의 판매 관련 서비스를 제공하고, 인사 모듈에서는 인사관리, 근태관리, 평가관리 등의 서비스를 제공한다.\n\nERP시스템은 DB와 함께 작동하여 모든 부서와 사용자가 하나의 통합된 시스템에서 작업할 수 있도록 해주며 이러한 통합은 데이터의 일관성과 신뢰성을 보장하여 중복된 작업을 피하고 정보를 쉽게 공유할 수 있도록 도와준다.\n\n\n<br><br><br><br>\n\n## ✅ ERP 시스템 필수 요소\n현대 ERP 시스템에는 관련 산업과 제공하는 모듈에 따라 다양한 기능을 포함하고 있지만, 아래 10가지 기본 기능은 ERP 시스템의 필수 요소이다.\n\n1. **공통 데이터 베이스**\n\n\t정보 및 단일 데이터 버전을 중앙화해 일관성 있는 데이터를 제공하고 회사의 각 기능을 종합적으로 사용할 수 있다.\n\n2. **내장형 분석**\n\n\t보고 및 규제 준수, 셀프 BI, 분석 툴이 내장되어 비즈니스의 모든 영역에 대해 인사이트를 제공할 수 있다.\n\n3. **데이터 시각화**\n\n\t대시보드, KPI(핵심성과지표) 등의 분석을 통해 주요 정보를 시각적으로 표시함으로써 빠른 의사결정을 가능하게 한다.\n\n4. **자동화**\n\n\tAI, 머신러닝을 통해 반복업무를 자동화하고 고급 RPA를 제공한다.\n\n5. **일관성 있는 UI/UX**\n\n\t여러 모듈들이 동일한 모양과 느낌을 이루고, 프로세스, 사용자, 사업부, 사업장, 제품 라인에 손쉽게 사용 가능한 구성과 툴을 제공한다.\n\t\n6. **통합**\n\n\t비즈니스 프로세스와 워크플로우를  완벽 통합하고 다른 SW 솔루션 및 데이터와 쉽게 통합된다.\n\t\n7. **새로운 기술 지원**\n\n\tAI 및 머신러닝, IoT, RPA, 보안 및 개인정보 보호 기능, 모바일을 지원한다.\n\t\n8. **안정적이고 검증된 기술 플랫폼**\n\n\t빠르고 안정적이며 입증된 기술스택을 지원한다.\n\t\n9. **다국어 지원**\n\n\t다양한 언어를 지원한다. \n\t\n10. **다양한 배포 옵션** \n\n\t클라우드, 온프레미스 또는 하이브리드 중에서 선택할 수 있다.\n\n\n<br><br><br><br>\n\n\n\n## ✅ ERP의 장점\n\n1. **생산성 제고**\n\t\n\t핵심 비즈니스 프로세스를 합리화, 자동화해 조직의 모든 인력이 더 적은 리소스로 더 많은 작업을 수행 할 수 있다.\n\n2. **시간 단축**\n\t\n\t업무 보고 속도를 향상시키고 결과를 손쉽게 공유 할 수 있어 불필요한 업무 시간을 단축 할 수 있다.\n\n3. **쉬운 정보 접근**\n\t\n\t통합 데이터베이스 관리 시스템을 통해 지속적이고 정확한 데이터를 제공하고 중복 데이터 생성을 방지한다. 이를 통해 모든 부서의 사용자들이 실시간으로 업무와 관련된 정보에 쉽게 접근 할 수 있다.\n\n4. **높은 확장성**\n\n\tERP는 기업의 성장과 함께 시스템 변경 및 적용이 용이하며, Add-On 모듈을 통해 기능을 쉽게 확장 할 수 있다. 이는 변화하는 비즈니스 요구에 유연하게 대응할 수 있도록 해준다.\n\n5. **비용 절감**\n\n\tERP는 시간 단축과 업무 향상을 통해 비용 절감 효과를 얻을 수 있다. 일관된 데이터와 프로세스 통합으로 인해 인력 및 자원의 효율성이 향상되고, 재고 관리, 생산 계획, 구매 등 비즈니스 프로세스의 최적화가 가능해진다.\n\n<br><br><br><br>\n\n\n## ✅ ERP의 단점\n\n1. **구축 시간**\n\n\tERP 시스템을 구축하기 위해서는 정확한 업무 파악과 적합한 ERP 시스템의 선택이 필요하다. 업무 프로세스를 분석하고 시스템을 설계하고 구현하는 과정은 많은 시간과 노력이 필요하다.\n\n2. **구축 비용**\n\n\tERP 시스템을 구축하는 비용은 기업의 사업 규모와 필요에 따라 다양하다. ERP 시스템을 구축하거나 ASP(애플리케이션 서비스 공급자) 형태의 ERP 시스템을 적용하는 경우에는 상당한 비용이 소요될 수 있다.\n\n3. **복잡한 기능**\n\n\tERP 시스템은 다양한 기능을 가지고 있기 때문에 이러한 기능에 익숙해지고 효과적으로 사용할 수 있도록 지속적인 교육과 지원이 필요하다.\n\n4. **제품 옵션 관리**\n\n\t다양한 모듈에서 사용하는 제품군의 옵션이 많거나 특별히 자주 변경되는 경우, 이를 관리하기 어려울 수 있다. ERP 시스템은 이러한 다양한 제품 옵션을 효과적으로 관리하기 위한 유연성이 필요하다.\n\n\n\n<br><br><br><br>\n\n## ✅ ERP의 미래\n\n본인은 클라우드 ERP를 통해 더 효율적인 차세대 ERP 시스템을 구축할 수 있을것으로 생각한다. 관련자료를 다양하게 찾아봤는데 클라우드 ERP의 이점에 대해 자세히 설명해주는 삼성SDS의 인사이트 리포트가 있어 링크를 첨부한다.\n\n[참고 자료 : 왜 클라우드 ERP인가? ](https://www.samsungsds.com/kr/insights/cloud_erp.html)\n\n\n<br><br>\n\n또한 클라우드 ERP에 생성형 AI를 도입하여 고객 운영, 영업 마케팅, 소프트웨어 엔지니어링, 연구개발(R&D) 등에 혁신적인 생산성 증대에 일조하는 관련 인사이트도 첨부하도록 하겠다.\n\n[참고 자료 : 생성 AI, 진정한 지능형 클라우드 ERP의 완성](https://news.sap.com/korea/2023/10/%EC%83%9D%EC%84%B1-ai-%EC%A7%84%EC%A0%95%ED%95%9C-%EC%A7%80%EB%8A%A5%ED%98%95-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-erp%EC%9D%98-%EC%99%84%EC%84%B1/)\n","properties":"\n","discussions":{},"comments":{},"hash":-1048238512}},"syncHistory":{"main":[-1048238512,-1048238512,null]},"v":1,"hash":1710829391964,"tx":10368},"sXFUuwDsSBfhbhTA":{"id":"sXFUuwDsSBfhbhTA","type":"file","name":"2023-03-19-SFA(Sales Force Automation)란","parentId":"ZRhtnSudyGKoaxuf","hash":2088949104,"tx":10504},"sXFUuwDsSBfhbhTA/syncedContent":{"id":"sXFUuwDsSBfhbhTA/syncedContent","type":"syncedContent","historyData":{"242318855":{"id":"sXFUuwDsSBfhbhTA/content","type":"content","text":"---\npermalink: /2024-03-19-SFA(Sales Force Automation)란/\npublished: true\ntitle: \"[ERP] SFA(Sales Force Automation)란?\"\ndate: 2024-03-19 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"SFA(Sales Force Automation)란?\"\ncategories:\n- ERP\ntags:\n- ERP\n- SFA\n---\n\n<br><br>\n\n\n## ✅ SFA(Sales Force Automation)란?\n\nSFA는 Sales Force Automation의 약어로 사용되며, 기업이 영업 활동을 관리하고 자동화하기 위해 사용되는 시스템을 의미한다. SFA 시스템의 주요 목적은 영업직원의 동선 및 고객 상담의 진행 상황과 같은 정보를 수집하고 이를 관리하여 실질적인 매출로 이어지도록 돕는 것이며, 영업 프로세스를 효율적으로 실행하여 영업팀의 생산성을 높이고 매출을 증대하는 것이다.\n\n\n<br><br><br><Br>\n\n## ✅ SFA 사용 이유\n1. **영업 조직 효율화**\n\t\n\t조직 내 영업활동으로 취득한 고객 정보를 일원화해 관리하고, 실시간으로 업데이트 한다면 영업 조직은 물론 업체 타 부서 직원들까지 항상 최신 정보를 바탕으로 고객을 응대할 수 있게 된다. 특히 업무 미팅 이전에 고객업체는 물론이고 관련 업계 현황까지 미리 확인하여 고객의 요구사항을 파악해 선제적으로 상품과 서비스를 제안하는것이 가능해진다.\n\n\t또한 전체 영업현황을 꿰뚫는 인사이트를 유지할 수 있고 영업조직 내부적으로도 개별 직원 각각의 업무 진척 상황을 빠르게 파악하는 것이 가능해진다. \n\n\n2. **영업 업무 구조화**\n\n\t전통적으로 영업 업무는 개별직원의 역량과 경험에 의지하는 경우가 많다. 높은 실적을 올려온 소수의 직원과 나머지 평균 수준의 직원을 비교하면 업무 처리 효율은 물론, 실적에서도 큰 격차를 드러내기 마련이다. \n\n\t이러한 뛰어난 영업직원의 영업 노하우를 메뉴얼화, 구조화해 다른 동료와 협업하도록 한다면 기존 조직의 한정적인 시간과 비용, 인력으로 최상의 결과를 얻어낼 수 있다.\n\n\t또한 실시간으로 업데이트 된 영업 프로세스 현황은 비단 영업부서를 넘어 재고 관리, 인사, 자금 조달 등 기업 내 모든 타 부서에서 활용돼 보다 효과적인 전략을 세울 수 있게 된다. \n\n<br><br><br><br>\n\n## ✅ SFA의 주요 기능\n\n1. **안건관리 기능**\n\n\t영업 담당자가 담당하고 있는 안건이 어떤 상황에 있는지, 상담상 정체나 장애가 없는지, 계약이 확정될 확률이 어느정도인지, 이러한 각각의 안건과 관련된 정보를 관리한다.\n\n\t영업 업무는 잠재고객 발굴부터 계약 성사에 이르기 까지 몇 가지 단계를 거친다. 그리고, 각각의 단계에서 어느정도 상담이 진행되었는지를 관리하고 개별 안건에 맞는 액션을 위하는 것이 확실한 매출을 확보하는 수단이 된다.\n\n2. **활동관리 기능**\n\n\t영업사원에게 있어 한정된 시간을 유효하게 사용하여 고객과의 커뮤니케이션을 하는 것은 필수이다. 그러나 안건에 따라 방문 빈도에 차이가 나거나 방문할 수 없어 방치를 하게 되면 안건의 타이밍이 어긋나기 때문에 유망한 잠재 고객을 경쟁사에게 빼앗기는 일이 발생하기도 한다.\n\n\t이를 보완해주는 기능이 활동관리 기능이다. 영업 담당자가 얼마나 계약에 공헌하고 있는지, 매출에 공헌하고 있는지 보다 정확하게 평가하는 것이 가능하여 낭비없이 영업 활동을 전개할 수 있다.\n\n3. **고객관리 기능**\n\n\t일반적으로 기업 전체 매출의 상당 부분은 소수 핵심고객에게서 발생한다. \"전체 20%의 고객이 전체 매출의 80%를 차지한다\"는 파레토 법칙이 그대로 적용된다는 것이다. 따라서 SFA를 통해 핵심고객을 기업 규모와 업종, 형태 등으로 분석하고 실시간 업데이트 된 데이터를 기반으로 새로운 상품과 서비스를 선제적으로 제안해 고객업체를 만족시키고 매출 역시 향상시킬 수 있다.\n\n4. **보고서 및 대시보드**\n\n\tSFA 시스템은 영업팀의 실적 및 성과를 모니터링 할 수 있는 다양한 보고서 및 대시보드를 제공한다. 판매 동향, 목표 달성 여부, 판매 리드 등의 정보를 시각적으로 표시하여 판매활동을 평가하고 의사 결정을 내리는 데 도움을 준다. 이를 통해 영업 조직은 성과를 분석하고 개선할 수 있는 영역을 식별 할 수 있다.\n\n<br><br><br><br>\n\n## ✅ SFA의 장점\n\n1. **고객 관리 및 관계 강화**\n\n\tSFA 시스템은 고객 정보를 중앙 집중식으로 관리하고 추적하여 영업팀이 고객과의 관계를 효과적으로 관리할 수 있다. 이를 통해 고객에 대한 개별화된 서비스를 제공하고 고객과의 관계를 강화할 수 있다.\n\t\n2. **영업 활동 효율성 증대**\n\n\tSFA 시스템은 영업 프로세스를 자동화하여 영업 팀이 시간을 절약하고 생산성을 높일 수 있도록 돕는다. 주문 처리, 견적 작성, 계약 관리 등의 반복적인 작업을 자동화함으로써 영업 팀은 더 많은 시간을 고객과의 상호 작용에 집중할 수 있다.\n\n\n3. **실시간 데이터 및 분석 제공**\n\n\tSFA 시스템은 실시간으로 영업 데이터를 수집하고 분석하여 영업 팀이 실시간으로 성과를 모니터링하고 의사 결정을 내릴 수 있도록 돕는다. 이를 통해 영업 전략을 신속하게 수정하고 조정할 수 있으며, 시장 동향을 파악하여 적절한 대응을 할 수 있다.\n\n\n4. **고객 서비스 향상**\n\n\tSFA 시스템은 고객 서비스를 개선하는 데 도움을 준다. 고객의 요청이나 문의사항을 신속하게 처리하고 추적함으로써 고객 만족도를 향상시킬 수 있다.\n\n\n5. **정확한 예측과 분석**\n\n\tSFA 시스템은 데이터를 기반으로 판매 예측 및 성과 분석을 제공하여 영업 팀이 향후 수익을 예측하고 영업 전략을 개선할 수 있도록 돕는다.\n\t\n","properties":"\n","discussions":{},"comments":{},"hash":242318855}},"syncHistory":{"main":[242318855,242318855,null]},"v":1,"hash":1710890334916,"tx":10787},"wmLsksMuEWVovfap/syncedContent":{"id":"wmLsksMuEWVovfap/syncedContent","type":"syncedContent","historyData":{"-843394477":{"id":"wmLsksMuEWVovfap/content","type":"content","text":"---\npermalink: /2022-05-13-스프링 입문_정적컨텐츠/\ntitle: \"[스프링부트] [JAVA] [입문] 2.1 정적컨텐츠\"\ndate: 2022-05-13 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"스프링부트\"\ncategories:\n- Spring Boot\ntags:\n- Spring Boot\n---\nSpring으로 웹을 개발한다는 건 크게 3가지 정도로 나눌 수 있다.\n\n> 첫번째로 **정적 컨텐츠**  \n> 두번째로 **MVC와 템플릿엔진**  \n> 세번째로 **API**  \n\n오늘은 **정적 컨텐츠**에 대해 알아보고 공부해보도록 하겠다!\n<br><br><br><br><br><br>\n\n## 정적 컨텐츠\n- 정적 컨텐츠는 말 그대로 멈춰있는 웹 페이지를 말한다. \n- 우리가 작성한 html 파일을 그대로 사용자에게 전달해줘서 보여준다.\n- 서버에서 별 다른 작업 없이 html 파일을 그대로 전달해준다.\n- Spring boot에서는 static resource에 대한 기본 매핑 설정과 커스텀을 지원해준다.\n- Spring Boot의 [관련 레퍼런스 참고](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content)\n\n<br><br><br>\n\n**[```resources/static/hello-static.html```]**\n\n```html\n<!DOCTYPE HTML>\n<html>\n<head>\n    <title>static content</title>\n\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n</head>\n\t<body>\n\t\t정적 컨텐츠 입니다.\n\t</body>\n</html>\n```\n\n<br><br><br>\n**실행**  \nhttp://localhost:8080/hello-static.html\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/static1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n### 정적 컨텐츠 동작 환경\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/static2.png?raw=true\">\n</p>\n\n1. 웹브라우저에 http://localhost:8080/hello-static.html 을 입력한다. ( 일반적으로는 hello-static.html 자리에 본인의 파일명을 넣어주면 된다)\n2. **내장 톰켓 서버**에서 요청을 받는다.\n3. 스프링에서는 먼저 **관련 컨트롤러** (hello-static)가 존재하는지 확인한다.\n4. 관련 컨트롤러가 없으므로 ```resources/static/hello-static.html``` 에 접근해서 파일을 가져온다.\n5. ```hello-static.html```을 웹 브라우저에 띄워준다!\n\n<br><br><br><br><br><br>\n\n여기까지 **[스프링부트] [JAVA] [입문] 2. 정적컨텐츠** 포스팅을 마치겠습니다.\n","properties":"\n","discussions":{},"comments":{},"hash":-843394477}},"syncHistory":{"main":[-843394477,-843394477,null]},"v":1,"hash":1710890427539,"tx":10791},"Q630m9jJvuuKh53I/content":{"id":"Q630m9jJvuuKh53I/content","type":"content","text":"---\npermalink: /2023-03-03-알고리즘_Arrays.sort와 Collections.sort/\ntitle: \"[알고리즘] [JAVA] Arrays.sort와 Collections.sort\"\ndate: 2023-03-03 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Arrays.sort와 Collections.sort\"\ncategories:\n- Algorithm\ntags:\n- 알고리즘\n- 정렬\n---\n<br><br>\n\n\n오늘은 코딩테스트 문제풀이중 계속 헷갈리고 어려운 정렬에 대해서 쭉 정리해보려고 한다. `Arrays.sort`, `Collections.sort` 그리고 오름차순, 내림차순, 마지막으로 `Comparator`를 사용한 `compare` 재정의 까지 알아보도록 하겠다.\n\n\n\n## ✅ Arrays.sort\n\nArrays.sort는 배열을 정렬해주는 기능을 합니다. 배열에 Integer가 있든, String이 있든 상관없이 정렬이 가능합니다.\n\n기본적으로 객체는 `Comparable`이 구현되어있습니다. `sort()`는 `Comparable`에 의해 리턴되는 값을 비교하여 오름차순 또는 내림차순으로 배열을 정렬합니다.\n\n대부분의 경우의수를 구현해보면서 사용법을 알아보도록 하겠습니다.\n\n- int 배열 오름차순, 내림차순 정렬\n- String 배열 오름차순, 내림차순 정렬\n- String 배열 문자 길이 순서대로 정렬\n- 객체 배열 정렬\n\n<br><br><br><br><br>\n\n### 📌 **int 배열 (오름차순)**\n기본적으로 Arrays.sort는 오름차순을 기본값으로 합니다.\n```java\nint[] arr = {1,20,254,13,76,22};\n\nArrays.sort(arr);\n\nSystem.out.println(Arrays.toString(arr));\n```\n\n<br>\n\n**Output :**\n```\n[1, 13, 20, 22, 76, 254]\n```\n\n<br><br><br><br><br>\n\n### 📌 **int 배열 (내림차순)**\n내림차순으로 정렬하기 위해서는 `sort()`인자에 `Collections.reverseOrder()`를 추가하면 됩니다.\n\n```java\nInteger[] arr = {1, 26, 17, 25, 99, 44, 303};\n\nArrays.sort(arr, Collections.reverseOrder());\n\nSystem.out.println(\"Sorted arr[] : \" + Arrays.toString(arr));\n```\n\n**Output :**\n```java\n[303, 99, 44, 26, 25, 17, 1]\n```\n\n<br><br>\n\n`Collections.reverseOrder()`는 Comparator 객체입니다. 일반적으로 Comparator는 직접 구현해서 사용하지만 내림차순 같은 경우는 많이 사용되므로 Collections에서 기본으로 제공해주고 있습니다.\n\n이를 직접 구현하면 아래와 같습니다.\n```\nInteger[] arr = {1, 26, 17, 25, 99, 44, 303};\n\nArrays.sort(arr, Comparator<Integer>(){\n\t@Override\n\tpublic int compare(Integer i1, Integer i2){\n\t\treturn i2-i1;\n\t}\n});\n\nSystem.out.println(Arrays.toString(arr));\n```\n<br><br><br><br><br>\n### 📌 **String 배열 (오름차순 & 내림차순)**\nString배열도 int배열과 별반 다르지 않습니다.\n```java\nString[] arr = { Apple, Banana, Pineapple, Cherry, Orange }\n\nArrays.sort(arr)\n\nSystem.out.println(Arrays.toString(arr));\n```\n\n\n**Output :** \n```java\n[ Apple, Banana, Cherry, Orange, Pineapple ]\n```\n<br>\n\n내림차순 역시 동일합니다.\n```java\nString[] arr = { Apple, Banana, Pineapple, Cherry, Orange }\n\nArrays.sort(arr,Collections.reverseOrder());\n\nSystem.out.println(Arrays.toString(arr));\n```\n**Output :** \n```java\n[ Pineapple, Orange, Cherry, Banana, Apple ]\n```\n<br><br><br><br><br>\n\n### 📌 **String 배열, 문자열 길이 순서대로 정렬**\nString배열의 문자열 길이 순서대로 정렬하고 싶다면 Comparator를 구현해야 합니다.\n```java\nString[] arr = { Apple, Banana, Pineapple, Cherry, Orange }\n\nArrays.sort(arr, new Comparator<String>(){\n\t@Override\n\tpublic int compare(String s1, String s2){\n\t\treturn s1.length()-s2.length();\n\t}\n});\n\nSystem.out.println(Arrays.toString(arr));\n```\n**Output :** \n```java\n[ Apple, Orange, Cherry, Banana, Pineapple ]\n```\n\n<br><br><br><br><br>\n\n### 📌 **객체 정렬 - Comparable 인터페이스**\n\n\n객체 정렬 방법은 여러가지가 있습니다. 그중 흔하게 쓰이는 `Comparable`을 사용한 객체 정렬부터 알아보도록 하겠습니다. \n\n먼저 사람이름과 점수를 갖고 있는 객체를 하나 생성해보고 이를 정렬해보도록 하겠습니다.\n\n\n```java\npublic class Player {\n    private String name;\n    private int score;\n\n    public Player(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n}\n```\n\n그리고 5명의 사람이 갖고 있는 점수를 생성해서 리스트에 담아보도록 하겠습니다.\n```java\nList<Player> players = new ArrayList<>();\nplayers.add(new Player(\"Alice\", 80));\nplayers.add(new Player(\"Bob\", 90));\nplayers.add(new Player(\"Chloe\", 100));\nplayers.add(new Player(\"Dale\", 70));\nplayers.add(new Player(\"Eric\", 50));\n```\n이제 다섯명의 사람을 점수별로 오름차순,내림차순 정렬해보겠습니다. `Comparable` 을 사용해서 정렬하면 다음과 같습니다.\n\n```java\npublic class Player implements Comparable<Player> {\n    private String name;\n    private int score;\n\n    public Player(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n\n\t// 오름차순 정렬\n\t@Override\n\tpublic int compareTo(Player p1){\n\t\treturn this.score - p1.score;\n\t}\n\t\n\t// 내림차순 정렬\n\t@Override\n\tpublic int compareTo(Player p1){\n\t\treturn p1.score - this.score;\n\t}\n}\n```\n\n```java\nCollections.sort(players);\n```\n\n<br><br><br><br><br>\n\n### 📌 **객체 정렬 - Comparator 인터페이스 사용**\n정렬대상 클래스의 코드를 직접 수정할 수 없는 경우, 혹은 정렬하고자 하는 객체에 이미 존재하는 정렬기준과 다른 정렬 기주으로 정렬하고 싶은 경우 `Comparator` 인터페이스를 사용해 정렬할 수 있습니다.\n\n`Comparator` 인터페이스 구현체를 `Arrays.sort()`나 `Collections.sort()` 같은 정렬 메서드의 추가 인자로 넘기면 새로운 기준으로 객체를 정렬할 수 있습니다.\n\n```java\nComparator<Player> comparator = new Comparator<Player>(){\n\n\t// 점수기준 오름차순\n\t@Override\n\tpublic int compare(Player a, Player b){\n\t\treturn a.score - b.score;\n\t}\n\n\t// 점수 기준 내림차순\n\t@Override\n\tpublic int compare(Player a, Player b){\n\t\treturn b.score - a.score;\n\t}\n```\n\n<br><br><br><br><br>\n\n### 📌 **Compare 과 CompareTo**\n","properties":"\n","discussions":{},"comments":{},"hash":962145358,"tx":10804},"7LHwr5vMhDvsF6qJ":{"id":"7LHwr5vMhDvsF6qJ","type":"file","name":"2022-08-17-자바 빈(JAVA Bean)","parentId":"AAphmch3Ge6p9ZRi","hash":-728470845,"tx":10823},"WuPlnrI0KwyoPStA":{"id":"WuPlnrI0KwyoPStA","type":"folder","name":"Front-end","parentId":null,"hash":-1147569050,"tx":10877},"jfStBciYCU0re8LF":{"id":"jfStBciYCU0re8LF","type":"file","name":"2023-06-07-React 기본 총정리","parentId":"WuPlnrI0KwyoPStA","hash":-440547963,"tx":10882},"MviwGZUVucL3T4n8":{"id":"MviwGZUVucL3T4n8","type":"file","name":"2022-12-20-CSS 이미지 (절대경로 vs 상대경로)","parentId":"WuPlnrI0KwyoPStA","hash":1958157591,"tx":10889},"5xTVal0mYmIYU6Hk":{"id":"5xTVal0mYmIYU6Hk","type":"file","name":"2023-05-11-CSS 기본 선택자, 캐스케이딩(Cascading), 박스 모델, 레이아웃","parentId":"WuPlnrI0KwyoPStA","hash":547602361,"tx":10890},"1nZnksY9YPlL4cyi":{"id":"1nZnksY9YPlL4cyi","type":"file","name":"2023-05-12-CSS 연결 선택자, 속성 선택자, 가상 클래스","parentId":"WuPlnrI0KwyoPStA","hash":719377565,"tx":10891},"yCviR51sRbUk47WF":{"id":"yCviR51sRbUk47WF","type":"file","name":"2023-05-16-JS 인터프리터언어, 기본 문법","parentId":"WuPlnrI0KwyoPStA","hash":-787832311,"tx":10902},"nOITFWSLtVkWensy":{"id":"nOITFWSLtVkWensy","type":"file","name":"2023-05-17-JS 변수, 예약어, 함수 표현식, 이벤트, 이벤트핸들러","parentId":"WuPlnrI0KwyoPStA","hash":-1182430455,"tx":10903},"B30uFDwmYERr6MWH":{"id":"B30uFDwmYERr6MWH","type":"file","name":"2023-05-18-브라우저 렌더링 과정","parentId":"WuPlnrI0KwyoPStA","hash":-1103474593,"tx":10904},"toS351vpmJre9cYC":{"id":"toS351vpmJre9cYC","type":"file","name":"2023-05-18-JS 내장 객체, 브라우저 객체, JS 삽입위치","parentId":"WuPlnrI0KwyoPStA","hash":-185651982,"tx":10905},"6L2BLz0U8N7KSVN2":{"id":"6L2BLz0U8N7KSVN2","type":"file","name":"2023-05-19-JS","parentId":"trash","hash":-1355319522,"tx":10909},"5xTVal0mYmIYU6Hk/content":{"id":"5xTVal0mYmIYU6Hk/content","type":"content","text":"---\npermalink: /2023-05-11-CSS 기본 선택자, 캐스케이딩(Cascading), 박스 모델, 레이아웃/\ntitle: \"[CSS] CSS 기본 선택자, 캐스케이딩(Cascading), 박스 모델, 레이아웃\"\ndate: 2023-05-11 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CSS 기본 선택자, 캐스케이딩(Cascading), 박스 모델, 레이아웃\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- CSS\n- HTML\n---\n<br><br>\n\n\n## ✅ CSS 기본 선택자 (Selector)\n\n### 📌 1. 전체 선택자\n**HTML페이지 내부의 모든 태그를 선택합니다.**\n\n{% include codepen.html hash=\"vYVzEJP\" title=\"css\" %}\n\n<Br>\n\n전체선택자는 HTML 페이지 내부의 모든 요소에 같은 CSS 속성을 적용합니다. 때문에 margin이나 padding값을 초기화하는 등 기본값을 정해둘 때 사용합니다. \n\n<br><br>\n\n### 📌 2. 태그 선택자 ( Type Selector )\n**HTML요소를 직접 지칭하는 가장 간단한 선택자**\n{% include codepen.html hash=\"qBJMEPy\" title=\"css\" %}\n\n<BR><BR>\n\n### 📌 3. 클래스 선택자 ( Class Selector )\n**class 속성값을 가진 HTML요소를 찾아 CSS를 적용하는 선택자**\n\n{% include codepen.html hash=\"eYPLmeE\" title=\"css\" %}\n<Br><br>\n\n### 📌 4. ID 선택자 ( ID Selector )\n**id 속성값을 가진 HTML요소를 찾아 CSS를 적용하는 선택자**\n\n{% include codepen.html hash=\"PoydwEY\" title=\"css\" %}\n<BR><BR>\n\n\n### 🔔 클래스 선택자와 ID 선택자를 어떻게 구분해서 쓸까?\n\n그냥 딱 결론만 말하면\n\n**한 페이지내에서 여러번 반복되는 스타일은 클래스 선택자!**\n**한 페이지내에서 단한번 쓰이는 스타일은 ID 선택자!**\n\n클래스 선택자는 글자색이나 굵기 등 나중에 다른곳에서도 쓰일수 있는 스타일을 지정하고, ID선택자는 요소의 배치 방법을 지정할 때 자주 사용합니다.\n\nclass 속성은 두개이상의 속성값을 가질 수 있고, ID 선택자는 하나의 속성값만 가질 수 있습니다.\n\n또한 ID 선택자의 우선순위가 클래스 선택자의 우선순위보다 높기때문에, 우선으로 적용되어야 할 스타일을 ID선택자를 사용하여 정의하는게 좋습니다.\n\n<br><br>\n\n### 📌 5. 그룹 선택자\n**같은 스타일을 사용하는 선택자를 한꺼번에 정의하는 선택자**\n**쉼표(,)로 구분해 여러 선택자를 나열**\n\n```css\nh1{ text-align : center; }\np { text-align : center; }\n```\n\n```css\n/* 그룹 선택자로 변환 */\nh1, p { texxt-align : center; }\n```\n\n<BR><BR><Br><br>\n\n\n\n## ✅ 캐스케이딩 ( Cascading )\n\n\n### 📌 캐스케이딩이란 ?\n위에서 아래로 흐른다, 즉 계단식으로 적용된다는 의미로 사용됩니다.\n선택자에 따라 여러 스타일이 적용될 때 스타일 충돌을 막기위해 우선순위에 따라 스타일을 결정할 수 있습니다.\n\n<br><br>\n\n### 📌 스타일 충돌을 막는 캐스케이딩의 원칙\n1. **스타일 우선순위** : 스타일 규칙의 중요도와 적용 범위에 따라 우선순위가 결정되고 그 우선순위에 따라 위에서 아래로 스타일 적용\n\n\t🚩 `!important` 태그를 붙여주면 어떤 스타일보다 우선적용 된다! \n\n2. **스타일 상속** - 태그들의 포함 관계에 따라 부모 요소의 스타일을 자식 요소로, 위에서 아래로 전달\n\n\n<BR><BR><br><br>\n\n\n\n## ✅ CSS의 레벨 요소\n\n### 📌 블록 레벨 요소 (Block Element)\n요소를 삽입했을 때 혼자 한줄을 차지하는 요소.\n요소의 너비가 100% -> 줄바꿈이 됨\nex ) `<div>, <p>` 등\n\n```html\n<div> div태그는 블록레벨 요소입니다. </div>\n<p> p태그는 블록레벨 요소입니다.</p>\n```\n\n<br><br>\n\n### 📌 인라인 레벨 요소 (Inline Element)\n줄을 차지하지 않는 요소.\n화면에 표시되는 콘텐츠 만큼만 영역을 차지하고 나머지 공간에는 다른 요소가 올 수 있음\nex ) `<img>, <string>, <span>` 등\n```html\n<div> div태그는 블록레벨 요소입니다. </div>\n<p> p태그는 블록레벨 요소입니다. \n<span>그러나 span 태그는 인라인 레벨 요소이므로 블록 레벨 요소 중간에 넣을 수 있습니다.</span>\n</p>\n```\n\n<br><br><br><br>\n\n## ✅ CSS와 박스 모델\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/box-model.png?raw=true\">\n</p>\n\n웹페이지에 배치하는 모든 HTML 요소는 3개의 층을 가진 사각형 구조를 띄고 있습니다. \n가장 외곽의 층을 `margin` 영역이라고 부르고 보통 주변에 위치한 다른 요소와의 상하좌우 간격을 두기위해 사용합니다.\n그 바로 아래층을 `border` 영역이라고 부르고 요소의 테두리를 의미합니다. 색깔, 두께, 모양 등을 설정 가능합니다.\n그 아래층은 `padding` 영역이라고 부르고 컨텐츠와 `border` 사이의 간격을 지정하기 위해 사용합니다.\n마지막으로 `content` 영역은 컨텐츠의 `width`와 `height`를 지정할 수 있습니다. \n\n\n{% include codepen.html hash=\"xxyabYz\" title=\"css\" %}\n\n\n<br><br><br><br>\n\n## ✅ 레이아웃\n\n### 📌 display 속성\n 요소의 배치 방법을 결정합니다.\n \n|종류|설명  |\n|--|--|\n|block  | 인라인 레벨 요소를 블록 레벨 요소로 변경 |\n|inline  | 블록 레벨 요소를 인라인 레벨 요소로 변경 |\n|inline-block  |인라인 레벨 요소와 블록 레벨 요소의 속성을 모두 가지고 있고, 마진과 패딩 지정 가능  |\n|none  |  해당 요소를 화면에 표시하지 않음  |\n\n<br><br>\n\n### 📌 float 속성\n요소를 왼쪽이나 오른쪽에 떠있게 만듦\n\n기본형 -  ``` float : left || right || none ```\n\n| 속성값  | 설명 |\n|--|--|\n| left | 해당 요소를 문서의 왼쪽으로 배치합니다. |\n| right | 해당 요소를 문서의 오른쪽으로 배치합니다. |\n| none | 좌우 어느쪽으로도 배치하지 않습니다. |\n\n<br><br>\n### 📌 position 속성\n웹 문서 안에 요소들을 배치하기 위한 속성\n\n기본형 -  ``` position : static || relative || absolute || fixed ```\n\n| 속성 값 | 설명 |\n|--|--|\n| *static | *요소를 문서의 흐름에 맞춰 배치합니다 |\n| relative | 이전 요소에 자연스럽게 연결해 배치하되 위치를 지정할 수 있습니다. |\n| absolute | 원하는 위치를 지정해 배치합니다. |\n| fixed | 지정한 위치에 고정해 배치합니다. 화면에서 요소가 잘릴 수도 있습니다. |\n\n","properties":"\n","discussions":{},"comments":{},"hash":169604087,"tx":10924},"yCviR51sRbUk47WF/content":{"id":"yCviR51sRbUk47WF/content","type":"content","text":"---\npermalink: /2023-05-16-JS 인터프리터언어, 기본 문법/\ntitle: \"[JavaScript] JS 인터프리터언어, 기본 문법\"\ndate: 2023-05-16 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 인터프리터언어, 기본 문법\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n## ✅ JavaScript - 인터프리터 언어? 컴파일 언어?\n\n\n### 📌 인터프리터 언어\n인터프리터 언어는 원시코드(소스코드)를 기계어로 변환하는 과정 없이 한줄 한줄 해석하여 명령어를 실행하는 언어를 말합니다. R, Python, Ruby와 같은 언어들이 대표적인 인터프리터 언어입니다.\n\n인터프리터가 한 줄씩 읽고 따로 기계어로 변환하지 않기 때문에 빌드시간이 없습니다. 런타임 상황에서는 한 줄씩 실시간으로 코드를 읽어서 실행하기 때문에 컴파일 언어에 비해 속도가 느립니다.\n\n실행속도는 느리지만 코드 변경시 빌드 과정 없이 바로 실행이 가능하다는 장점이 있습니다.\n\n<br><br>\n\n### 📌 컴파일 언어\n\n컴파일 언어는 원시코드(소스코드)를 기계어로 변환한 후에 코드를 실행합니다. 소스코드를 기계어로 번역하는 빌드 과정에서 인터프리터 언어에 비해 시간이 소요됩니다. 그러나 런타임 상황에서는 모든 소스코드가 기계어로 변환되어 있기 때문에 더 빠르게 실행가능합니다. 대표적인 언어로 C,C++,C# 등이 있습니다. `exam.c` -> `exam.exe` 로 변경되는 것을 컴파일 이라고 합니다.\n\n<br><br>\n\n### 🔔 하이브리드 언어\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/java.png?raw=true\">\n</p>\n\n예외적으로 Java는 하이브리드 언어로 불립니다. 즉, 컴파일 언어이면서 인터프리터 언어이기도 합니다. `.java`로 표현되는 소스코드는 Java Compiler를 통해 `.class` 파일로 변환 됩니다. `.class`파일은 JVM은 이해할 수 있지만 아직 컴퓨터가 읽을 수는 없는 바이트 코드 파일입니다. 이후 컴파일된 바이트 코드를 JVM의 Class Loader에 전달합니다. Class Loader는 이를 JVM의 메모리에 올리고, 실행엔진(Execution Engine)이 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다. 이때 실행엔진은 인터프리터와 컴파일 방식, 두가지 방식으로 실행됩니다.\n\n<br><br>\n\n### 📌 JS는 인터프리터 언어이다!\nJS는 웹 브라우저에서 실행한다. 모든 웹 브라우저에는 JS 인터프리터가 탑재되어 있고, JS 인터프리터를 통해 JS 코드를 한줄 한줄 읽고 실행한다. \n\n[웹 브라우저 별 JS 인터프리터]\n- 크롬 : V8 -> 이걸 따로 떼어내서 출시한 JS 인터프리터가 Node.js\n- 엣지 : Chakra\n- 사파리 : Webkit\n- 파이어폭스 : SpiderMonkey\n<br>\n\nJS를 웹브라우저 없이 서버딴에서 실행이 가능한데 이러면 인터프리터를 설치해줘야 한다. 그때 Node.js를 설치해서 사용하면 된다..! \n\n<br><br><br><br>\n\n## ✅ JS 기본 문법\n\n### 📌 JS 코드 작성 요령\n1. 코드 들여쓰기\n2. 세미콜론으로 구분하자. JS는 세미콜론을 붙이지 않아도 실행되긴 한다. 그러나 디버깅을 위해 세미콜론을 반드시 붙이는 습관을 들이자.\n3. 공백을 넣어 읽기 쉽게 작성하자.\n4. 소스코드를 설명하는 주석을 작성하자.\n5. 식별자는 규칙을 지켜 작성하자. 반드시 영문자나 `_` , `$` 로 시작하고 대소문자를 구분하며 단어사이에 공백을 넣지말자.\n\n<br><br>\n\n### 📌 JS 기본 입출력 방법\n\n- **알림창** : 웹 브라우저에 알림창을 띄워줍니다.  \n\n\t> **기본형 - alert(메시지);**\n\n{% include codepen.html hash=\"qBJMbPy\" title=\"JS\" %}\n\n<br><br>\n\n- **확인창** : 메시지를 보여주고 확인/취소 버튼을 클릭할 수 있습니다.  \n\n\t> **기본형 - confirm(메시지);**  \n\n{% include codepen.html hash=\"LYgJGeJ\" title=\"JS\" %}\n\n<br><br>\n\n- **프롬프트 창** : 텍스트 필드가 있는 창을 제공합니다.  \n\n\t> **기본형 - prompt(메시지) 또는 prompt(메시지, 기본값)**  \n\n{% include codepen.html hash=\"wvYEMmK\" title=\"JS\" %}\n\n<br><br>\n\n- **`document.write()`** : 웹 문서(document)에서 괄호안의 내용을 표시하는 명령문  \n\n\t> **기본형 - document.write(\"메시지\" 또는 '메시지' 또는 <HTML태그> 내용 </HTML태그>**\n\n{% include codepen.html hash=\"MWPqKGo\" title=\"JS\" %}\n\n<br><br>\n\n- **`console.log()`** :  괄호안의 내용을 콘솔 창에 표시합니다.  \n\n\t> **기본형 -  console.log(변수 || 텍스트);**  \n\n{% include codepen.html hash=\"xxyaZQa\" title=\"JS\" %}\n\n<br><br><br>\n\n웹브라우저에서 개발자도구를 통해 콘솔을 보면 아래 사진처럼 console.log에 입력한 내용이 출력됩니다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/console2.png?raw=true\">\n</p>\n\n<br><br><br><br>\n\n\n\n\n## ✅ 개발자 도구로 디버깅하기\n\n1. 웹 브라우저에서 소스 코드 실행\n2. F12눌러서 개발자 도구 실행\n3. Console 탭으로 이동 후 에러 확인\n4. 에러를 클릭하면 에러가 발생한 코드로 이동!\n<br>\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/console1.png?raw=true\">\n</p>\n","properties":"\n","discussions":{},"comments":{},"hash":205511356,"tx":10952},"B30uFDwmYERr6MWH/content":{"id":"B30uFDwmYERr6MWH/content","type":"content","text":"---\npermalink: /2023-05-18-브라우저 렌더링 과정/\ntitle: \"[JavaScript] 브라우저 렌더링 과정\"\ndate: 2023-05-18 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"브라우저 렌더링 과정\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n## ✅ 브라우저 렌더링 과정\n\n\n### 📌 렌더링이란?\n\nJavaScript를 공부하면서 `<script>`의 삽입 위치에 따라 코드가 제대로 작동 안할 수도 있다는 사실을 알았는데 이게 브라우저 렌더링 과정과 깊은 연관이 있다고 하여 이에 대해 확실하게 알아두고 넘어갈 필요성이 느껴져 관련 포스팅을 한다.\n\n브라우저는 서버와의 통신 이후, 데이터를 사용자에게 보여주기 위해 **렌더링** 이라는 과정을 수행한다.\n\n웹 페이지는 사용자에게 보여질 때 미리 만들어져 있는 페이지를 가져오는게 아니라 실시간으로 그려지는 것에 가깝다. **실시간으로 웹사이트가 그려지는 과정, 이 과정을 웹 브라우저의 렌더링 이라고 말한다.**\n\n대부분의 웹 브라우저는 두개의 엔진이 들어가 있다. 하나는 **렌더링 엔진**으로 사용자가 볼 화면을 그려내는 역할을 수행하고 다른 하나는 **자바스크립트 엔진**으로 자바스크립트 코드를 읽어내 기능을 수행하는 역할을 한다.\n\n렌더링 엔진은 HTML, CSS, JavaScript 세가지 언어를 가지고 웹사이트의 소스코드를 읽어, 실제 어떤 요소들이 어떤 크기, 너비로 배치되는지, 텍스트의 크기는 어떠한지, 색상은 어때야 하는지 등을 계산해 실시간으로 그려준다.\n\n이러한 렌더링 엔진이 수행하는 일련의 과정을 **렌더링**이라고 한다.\n\n<br><br>\n\n### 📌 브라우저 렌더링 동작 과정\n\n그렇다면 렌더링은 어떻게 동작하는지 알아보도록 하겠다.\n\n1. **HTML 파일과 CSS 파일을 파싱해서 각각 Tree를 만든다 ( Parsing )**\n\n브라우저가 페이지를 렌더링하려면 가장 먼저 HTML 파일을 해석해야 한다. Parsing 단계는 HTML 파일을 해석하여 DOM ( Document Object Model ) Tree를 구성하는 단계이다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/dom.png?raw=true\">\n</p>\n\n<br>\n\n또한 HTML에 CSS에 포함되어 있다면 CSSOM(CSS Object Model) Tree도 함께 구성한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/cssom.png?raw=true\">\n</p>\n<br><br>\n\n\n2. **두 Tree를 결합하여 Rendering Tree를 만든다 ( Style )**\nParsing 단계에서 생성된 DOM Tree와 CSSOM Tree를 매칭시켜 Rendering Tree를 구성한다. Rendering Tree는 실제로 화면에 그려질 Tree이다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/rendering.png?raw=true\">\n</p>\n\n<br><br>\n\n3. **Rendering Tree에서 각 노드의 위치와 크기를 계산한다 ( Layout )**\nRendering Tree의 루트노드부터 모든 노드를 순회하며 노드의 정확한 크기와 위치를 계산하고 Rendering Tree에 반영한다. 이를 통해 각 요소의 정확한 위치를 구체화 한다.\n\n<br><br>\n\n4. **계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다 ( Paint)**\n\n<br><br>\n\n5. **레이어를 합성하여 실제 화면에 나타낸다 ( Composite )**\n\n\n<br><br><Br><Br>\n\n## ✅ 마무리\n브라우저 렌더링 과정을 살펴봄으로써 웹 페이지가 어떻게 생성되는지 알 수 있었다. 이런 과정을 하나하나 알아가며 동작 원리를 파악하는게 웹 개발을 하는데 있어 도움이 많이 된다고 생각한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-2016400467,"tx":10958},"toS351vpmJre9cYC/content":{"id":"toS351vpmJre9cYC/content","type":"content","text":"---\npermalink: /2023-05-18-JS 내장 객체, 브라우저 객체, JS 삽입위치/\ntitle: \"[JavaScript] JS 내장 객체, 브라우저 객체, JS 삽입위치\"\ndate: 2023-05-18 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 내장 객체, 브라우저 객체, JS 삽입위치\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n\n## ✅ 자바스크립트 내장 객체\n\n\n### 📌 Array 객체\n자바스크립트에는 배열을 쉽게 만들고 다룰수 있는 Array 객체가 내장되어 있다. 객체를 만들기 위해서는 인스턴스가 필요하기 때문에 new 예약어와 함께 사용하면 된다.\n\n```js\n// 초기값을 지정하지 않는 경우\nvar numbers = new Array();\t\t// 배열의 크기를 지정하지 않음\nvar numbers = new Array(4);\t\t// 배열의 크기를 지정함\n\n// 초기값이 있는 경우\nvar numbers = [\"one\", \"two\", \"three\", \"four\"];\t\t// 배열선언\nvar numbers = Array(\"one\",\"two\",\"three\",\"four\");\t// Array객체 사용 배열 선언\n```\n\n<br><br>\n\n### 📌 Array 객체의 메서드\nArray 객체는 여러가지 메서드가 있다. 간단하게 표로 정리해보자.\n\n| 종류 | 설명 |\n|--|--|\n| concat | 기존 배열에 요소를 추가해 새로운 배열을 만듭니다 |\n| every | 배열의 모든 요소가 주어진 함수에 대해 참이면 true, 그렇지 않으면 false를 반환한다 |\n| filter | 배열 요소 중에서 주어진 필터링 함수에 대해 true인 요소만 골라 새로운 배열을 만든다 |\n| forEach | 배열의 모든 요소에 대해 주어진 함수를 실행한다 |\n| indexOf | 주어진 값과 일치하는 값이 있는 배열 요소의 첫 인덱스를 찾는다 |\n| join | 배열 요소를 문자열로 합친다. 이때 구분자를 지정할 수 있다 |\n| push | 배열의 맨 끝에 새로운 요소를 추가한 후 새로운 length를 반환한다 |\n| unshift | 배열의 시작 부분에 새로운 요소를 추가한다 |\n| pop | 배열의 마지막 요소를 꺼내 그 값을 결과로 반환한다 |\n| shift | 배열의 첫번째 요소를 꺼내 그 값을 결과로 반환한다 |\n| splice | 배열의 요소를 추가하거나 삭제한다 |\n| slice | 배열에서 특정한 부분만 잘라낸다 |\n| reverse | 배열의 배치 순서를 역순으로 바꾼다 |\n| sort | 배열 요소를 지정한 조건에 따라 정렬한다 |\n| toString | 배열에서 지정한 부분을 문자열로 반환한다. 이때 각 요소는 쉼표(,)로 구분한다 |\n\n<Br><br>\n\n### 📌 JS의 삽입 위치\nJS코드는 `<header>` 에 포함될 수도 있고, `<body>`에 포함될 수도 있다. 그러나 대부분의 경우 JS코드는 `<body>` 내부에 포함시켜 작성된다. `<header>` 에 위치하는 것과 `<body>`에 위치하는게 어떤 차이가 있고 왜 `<body>`에 대부분 작성하는지 알아보자.\n\n \n브라우저는 HTML의 구조와 CSS 스타일을 렌더링하는 도중 자바 스크립트를 만나게 되면 이에 대한 해석과 구현이 완료될때까지 브라우저 렌더링을 중단한다. 이후 포스팅을 이해하기 위해서는 브라우저 렌더링이 어떤 것이고, 어떤 과정을 거치는지 알 필요가 있기 때문에 [브라우저 렌더링 과정](https://idkim97.github.io/2023-05-18-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%A0%8C%EB%8D%94%EB%A7%81%20%EA%B3%BC%EC%A0%95/) 포스팅을 참고하길 바란다.\n\n한마디로, 자바스크립트의 삽입 위치가 브라우저 렌더링에 영향을 미친다는 것이다.\n\n```js\n<header>\n(..생략..)\n\t<script>\n\t\tdocument.querySelector(\"#aa\").onclick = function(){\n\t\t\talert(\"aa 선택됨\");\n\t\t}\n\t</script>\n(...생략...)\n</header>\n\n<body>\n\t(...생략...)\n</body>\n```\n\n위의 코드는 `aa`라는 아이디를 가진 요소를 클릭했을 때 \"aa 선택됨\" 이라는 경고창을 띄워주는 코드이다. 그러나 위 코드는 정상적으로 작동하지 못한다. `<script>` 코드가 `<body>` 코드보다 앞서 존재하기 때문에 아직 브라우저 렌더링이 시작되지 않았고, 이로인해 `document` 객체가 HTML요소를 가지고 있지 않기 때문에 `#aa` 라는 아이디를 가진 요소를 찾을 수가 없다. \n\n<br>\n\n이런 코드를 실행시키면 alert창이 안뜨게 된다. 왜냐하면 **document**라는 객체는 **HTML 문서의 정보**를 가지는 객체인데,  HTML요소는 body에 선언되어 있고 , header는 body보다 위쪽에 선언되어 있기때문에 document에는 아직 아무런 요소가 들어있지 않다. 즉, document가 `aa`라는 요소를 찾지 못하기때문에 발생하는 오류이다.\n\n<br>\n\n그렇다고 `<header>` 부분에 `<script>` 코드를 절대 작성하지 못하는 것은 아니다. 언제나 그렇듯 방법은 존재하기 마련이다..\n\nJS의 최상단 객체인 `window` 객체의 `onload` 메서드를 사용하면 된다. `window`객체는 브라우저 창이 열릴 때 마다 생성되는 객체이고 JS의 모든 객체의 부모노드라고 볼 수 있다. \n\n`onload` 메서드는 페이지의 모든 요소들이 로드되면 실행되는 전역 콜백 함수이다. 한 페이지에서 하나의 `window.onload()` 함수만 적용되는 특징이 있다. 때문에 자바스크립트 코드에 `window.onload` 를 붙여주면 모든 요소가 로드 된 후에 자바스크립트 코드를 실행하기 때문에 정상적으로 사용 가능하다. 아래는 예시 코드이다.\n\n\n```js\n<header>\n\t<script>\n\t\twindow.onload = function(){\n\t\t\tdocument.querySelector(\"#aa\").onclick = function(){\n\t\t\talert(\"aa 선택됨\");\n\t\t}\n\t<script>\n<header>\n```\n\n<br><br><br><br>\n\n## ✅ 브라우저 관련 객체\n\n웹 브라우저가 화면에 나타나는 순간 브라우저는 관련 객체를 만들어 낸다. 가장 먼저 window라는 최상단 객체가 만들어지고 그 밑으로 하위요소에 해당하는 객체들이 생성된다. 이는 계층구조로 나타낼 수 있고 아래 이미지 처럼 구성된다.\n<Br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/window.png?raw=true\">\n</p>\n\n<Br>\n\n관련 객체들을 간단하게 표로 정리해보겠다.\n\n|종류|설명|\n|--|--|\n| window | 브라우저 창이 열릴 때마다 하나씩 만들어진다. 브라우저 창 안의 요소 중 최상단에 위치한다 |\n| document | 웹 문서마다 하나씩 있으며 <body> 태그를 만나면 만들어진다. HTML 문서의 정보가 담겨있다 |\n| navigator | 현재 사용하는 브라우저의 정보가 들어있다 |\n| history | 현재 창에서 사용자의 방문 기록을 저장한다 |\n| location | 현재 페이지의 URL 정보가 담겨있다 |\n| screen | 현재 사용하는 화면 정보를 다룬다 |\n\n<br>\n\n이 외에도 정말 많은 객체, 프로퍼티, 메서드가 있지만 많이 사용하는 편은 아니고 굳이 다 외워둘 필요 없기때문에 작성하지 않겠다. 필요하다면 다른 블로그 게시물을 확인하면 되겠다.\n\n참고 : [자바스크립트 내장 객체 & 브라우저 객체 메서드와 프로퍼티 정리 ](https://velog.io/@kim_unknown_/JavaScript-Objects)\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-757487084,"tx":10960},"jfStBciYCU0re8LF/content":{"id":"jfStBciYCU0re8LF/content","type":"content","text":"---\npermalink: /2023-06-07-React 기본 총정리/\ntitle: \"[React] React 기본 총정리!\"\ndate: 2023-06-08 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"React 기본 총정리\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- React\n---\n<br><br>\n\n이번 포스팅은 React를 처음 공부할때 필요한 모든 지식을 총 집합해서 정리해보려고 한다. React란 무엇이고, 왜 사용하는지 부터 기초문법까지 다뤄보도록 하겠다. 세세한 문법까지 모두 다룰수는 없겠지만 꼭 기억해야하는 문법을 통해 간단한 토이프로젝트 까지 진행해볼 수 있을 정도의 개념을 정리해보자..! 작성이후에도 추가적으로 필요한 내용은 추가하면서 이 포스팅만 보면 React 개발을 어느정도 할 수 있을만큼의 도움이 되는 글을 작성하는것을 목표로 하겠다..!\n\n<br><br><br><Br><Br>\n\n\n## ✅ React란?\n\n리액트는 **사용자 인터페이스 (UI)**를 구축하기 위한 선언적이고 효율적이며 유연한 **자바스크립트 라이브러리**이다. `Augular`, `Vue`와 달리 자바스크립트 문법을 그대로 사용하기 때문에 자바스크립트를 알고있다면 학습하는데 어려움이 많이 없다.\n\n리액트를 사용하지 않아도, HTML/CSS 그리고 JavaScript를 사용해서 웹페이지를 충분히 만들 수 있지만 우리는 리액트를 사용한다. 도대체 왜 리액트를 사용하는 걸까 ?\n\n<br><Br><Br>\n\n### 📌 React를 사용하는 이유\n1. **데이터 바인딩이 쉽게 가능하다!** \n\n**데이터 바인딩**이란 화면상에 보여지는 데이터(View)와 브라우저 메모리에 있는 데이터(Model)을 일치시키는 것을 말한다. 좀 쉽게 설명하면 데이터를 HTML 요소에 꽂아넣어주는거라고 볼 수 있다.\n\n일반적으로 JS를 사용하면 `document.getElementById(\"변수명\").innerHTML = \"수정\"` 이런식으로 바인딩해서 HTML내용을 바꿔주곤 한다. 근데 이런 방식은 코드가 길기때문에 보기에도 불편하고 수정도 불편하다. \n\n그런데 리액트에서는 이런 데이터 바인딩을 매우 쉽게 할 수 있다. 변수에 데이터를 담아주고 `{ }` 안에 넣어 사용하면 끝이다!\n\n```js\nfunction App(){\n  var data = \"안녕하세요\";\n  return (\n\t<>\n\t  <p> { data } </p>\t// 안녕하세요\n\t</>\n  )\n}\n```\n<br><br><br>\n\n2. **컴포넌트 단위 개발**\n\n리액트는 컴포넌트 단위로 개발을 할 수 있다. 기존의 웹 프레임워크는 MVC 방식으로 분리해서 관리했기 때문에 각 요소의 의존성이 높아 재사용이 어렵다는 단점이 있었는데, 컴포넌트는 MVC의 뷰를 독립적으로 구성해서 재사용이 가능하게 하고 이를 통해 새로운 컴포넌트를 쉽게 만들 수 있게 한다.\n\n**리액트는 사용자 정의 태그를 만드는 기술이다** 라고 표현할 수 있을 정도로 컴포넌트의 사용이 리액트를 사용하는 가장 큰 이유라고 볼 수 있다. 여러 태그들을 하나의 컴포넌트로 만들어 독립된 부품으로 만들 수 있고, 더 적은 복잡도로 소프트웨어를 만들수 있다. \n<br><br><br>\n\n3. **JSX를 지원한다!**\n\nJSX는 JavaScript + XML 로 구성된 자바스크립트 확장 구문인데, JS에서 HTML을 작성하듯 코드를 작성할 수 있는 큰 장점이 있다.\n```js\nconst hello = () => { \n  return ( \n\t<div>\n\t\t<h1>안녕하세요.</h1>\n\t</div>\n  ); \n};\n```\n위의 코드처럼 작성하는것이 JSX이고 약간의 규칙이 존재한다.\n- 컴포넌트에 여러 요소가 있을때 반드시 부모 요소 하나가 감싸는 형태여야 한다.\n- 자바스크립트의 값을 JSX안에서 랜더링 할 수 있다. `{ 변수명 }` 의 형태로 사용가능하다.\n- if문을 사용할 수 없고 조건부 연산자를 사용한다.\n\n<br>\n\n```js\nfunction  App()  {\n\tconst  name  =  '리액트';  \n\t\treturn  (  \n\t\t\t<div>  { \n\t\t\t\t\tname  ===  '리액트'?  \n\t\t\t\t\t(<h1>리액트</h1>) : (<h2>리액트가 아님</h2>)\n\t\t\t\t\t}  \n\t\t\t</div>\n\t);  \n}\n``` \n- 기존 CSS 스타일 지정할때 background-color와 같이 `-` 문자가 포함된 이름을 `-`를 없애고 카멜 표기법으로 작성해야 한다! ex ) background-color -> backgroundColor\n-  기존 클래스명을 선언할때 `class=\"title\"`처럼 선언하던것을 `className=\"title\"` 의 형식으로 선언해야 한다.\n- 태그 사용시 반드시 닫아주는 태그를 사용해야만 한다!\n- JSX에 style속성을 넣으려면 무조건 `style= { 스타일 }` 처럼 중괄호 사용해야한다. 그리고 스타일은 무조건 object 자료형으로 만든 스타일을 사용해야 한다. ` <div style = { { color : 'blue' } } > 개발 블로그 </div>`\n\n<br><br><br><br><br>\n\n## ✅ React 개발 환경 설정\n\n### 📌 사전 개발 환경\n- node.js 설치\n- IDE - VS Code ( 쓰고싶은거 쓰면됨 )\n\n<br><br><br>\n \n### 📌 프로젝트 생성 및 실행\n프로젝트를 진행 할 폴더를 생성하고 VS Code 폴더열기를 통해 폴더에 접근한뒤 해당 폴더 위치로 터미널을 켜줍니다.\n\n이후 아래 명령어를 터미널에 입력해줍니다.\n```react\nnpx create-react-app [디렉토리명]\ncd [디렉토리명]\nnpm start\n\n==========================================================================\n// 예시\nnpx create-react-app basic-app\t// basic-app이라는 폴더에 리액트 환경 설치\ncd basic-app\t\t\t// 설치후에 터미널 경로를 basic-app폴더로 이동\nnpm start\t\t\t\t// 리액트 실행!\n```\n\n이렇게 하면 프로젝트가 실행된다! 결과창은 보통 자동으로 웹브라우저로 나타나고 localhost:3000으로 접속하면 볼 수 있다.\n<Br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react1.png?raw=true\">\n</p>\n\n<br><Br><br><Br><Br>\n\n## ✅ React 프로젝트 구조 \n  \n터미널 명령어 `create-react-app`을 통해 생성한 리액트 프로젝트의 구조는 아래와 같다. \n```\t\t\t\t\t\n  basic-app\t\t\t\t\t\n\t├─ node_modules\n\t├─ package-lock.json\n\t├─ package.json\n\t├─ public\n\t│ \t├─ favicon.ico\n\t│ \t├─ index.html\n\t│ \t├─ logo192.png\n\t│ \t├─ logo512.png\n\t│ \t├─ manifest.json\n\t│ \t└─ robots.txt\n\t├─ README.md\n\t└─ src\n\t\t├─ App.css\n\t\t├─ App.js\n\t\t├─ App.test.js\n\t\t├─ index.css\n\t\t├─ index.js\n\t\t├─ logo.svg\n\t\t├─ reportWebVitals.js\n\t\t└─ setupTests.js\n\n```\n\n- node_modules : 현재 프로젝트에 포함된 라이브러리들이 설치되어 있는 폴더\n- package.json : 프로젝트 이름, 버전 등에 대한 정보와 라이브러리 목록이 포함되어 있다.\n- public : 정적 파일이 모여 있는 폴더로 변할 일이 없는 이미지를 주로 넣는다\n- src : 리액트 내부에서 작성하는 거의 모든 파일들이 들어있는 폴더이다.\n\t- App.js : 메인페이지라고 보면된다.\n\t- App.css : App.js에 대한 css파일이다.\n\t- index.js : App.js를 실행해주는 JS파일이다.\n\n<BR>\n이정도로만 알고있으면 문제없이 리액트를 다룰 수 있을거라고 생각한다. 각 폴더, 파일마다 더 세세하게 들어갈 수 있지만, 프론트엔드 개발자를 희망하는 사람이 아니라면 이정도만 알고 가도 리액트 개발하는데 큰 문제는 없어 보인다.\n\n<BR><bR><bR><Br><Br>\n\n## ✅ 컴포넌트란 ?\n\n컴포넌트의 사용은 리액트의 본질이라고 표현 할 수 있을 정도로 중요하다. 리액트는 화면에서 UI 요소를 구분할 때 '컴포넌트'라는 단위를 사용하는데, 쉽게 말하면 리액트에서 앱을 이루는 가장 작은 조각이라고 할 수 있고, 레고 블록으로 집을 쌓게 된 경우 하나의 블록이 '컴포넌트'라고 할 수 있다. 컴포넌트는 새로운 컴포넌트를 생성할 수 도 있고, MVC 의 뷰를 독립적으로 구성하여 재사용할 수도 있다.\n\n<br><br>\n\n🚩 **[예제 1] 일반적인 컴포넌트 사용법**\n\n컴포넌트를 모아두기위한 폴더 `component`를 생성하고 컴포넌트 JS를 생성한다. \n\n`파일경로 : src/component/Component1.js`\n```js\nexport default function Component1(){\n\treturn (\n\t\t<div> 컴포넌트 1 출력 </div>\n\t)\n}\n```\n<br>\n이제 컴포넌트로 만들어준 `Component1.js`를 `App.js`에서 사용해보자!\n<br><br>\n\n\n`파일경로 : src/App.js`\n```js\nimport './App.css';\nimport Component1 from './component/Component1';\t// 컴포넌트를 import해준다\n\nfunction App() {\n  return (\n    <div className=\"App\">\n        <Component1/> \t\t\t// 컴포넌트 1 출력\n    </div>\n  );\n}\nexport default App;\n```\n\n컴포넌트를 다른 JS파일에서 사용하기 위해선 해당 컴포넌트를 import 해줘야만 한다.\n`import 컴포넌트명 from 컴포넌트위치;` 형태로 import 할 수 있다. 이때 작성한 `컴포넌트명`을 변수명처럼 사용하면 된다. 위의 코드에서는 `컴포넌트명`을 `Component1` 로 지정해줬으므로 `<Component1/>` 이라고 작성하면 해당 컴포넌트를 사용할 수 있다.\n\n<br><br>\n\n보통 컴포넌트 폴더를 만들고 그안에 컴포넌트 JS파일을 만들어서 컴포넌트별로 관리해 import해서 사용하지만, **하나의 JS파일에서 코드를 정리하기 위해 컴포넌트를 사용할 수도 있다**.\n\n```js\nfunction Header() {\n  return (\n\t<header>\n\t\t<h1> 리액트 재밌다 </h1>\n\t</header>\n  }\n}\n\n\nfunction App(){\n  return (\n\t<Header/>\n\t<Header></Header>\t\t// Header를 컴포넌트로 사용함\n\t<Header></Header>\n  )\n}\n```\n\n<br>\n위의 코드는 하나의 파일내에서 컴포넌트를 사용한 예제이다. \n\n<br><Br><Br>\n\n🚩 **[예제 2] 컴포넌트 안에 컴포넌트 사용하기**\n\n컴포넌트 내에서도 다른 컴포넌트를 불러와 사용할 수 있다. 코드로 보자.\n\n`파일경로 : src/component/SubComponent.js`\n\n```js\nexport default function SubComponent(){\n    return (\n        <div> Welcome! This is SubComponent! </div>\n    )\n}\n```\n\n<br>\n\n`파일경로 : src/component/Component1.js`\n\n```js\nimport SubComponent from \"./SubComponent\"\n\nexport default function Component1(){\n    return (\n        <div> \n            <h1>Hello</h1> \t\t\t// Hello\n             <SubComponent/> \t\t// Welcome! This is SubComponent!\n        </div>\n    )\n}\n```\n\n<br><br><br>\n🚩 **컴포넌트 사용시 주의사항**\n- 컴포넌트 이름은 반드시 **대문자**로 시작해야하고 **CamelCase**를 사용하는게 좋다.\n- 컴포넌트에서 JSX 리턴시에는 반드시 **하나의 태그**로 전체를 감싸서 리턴해야 한다. 태그로 감싸지 않거나, 두개이상의 태그를 사용할 수 없다!\n\t- ex ) `return ( <div> 리턴값 </div> )`\n\t-  ex ) `return ( <> 리턴값 </>`\n\t-  ex ) `return ( <div> </div> <div> </div> )` 이런 경우는 안됨!\n- 리액트에서 **html태그**는 반드시 **소문자**로!\n\n<br><Br><br>\n\n\n\n\n<br><br><br><br><Br>\n\n\n## ✅ CSS 적용\n\n리액트에서 CSS를 적용하는 방법은 크게 3가지이다. 첫번째는 **인라인 스타일**, 두번째는 **외부 CSS파일 import**, 마지막으로는 **CSS 모듈** 사용 이다. 각각의 경우를 예제를 통해 알아보도록 하겠다.\n\n<br><br>\n### 📌 인라인 스타일 CSS\n일반적으로 인라인 스타일 CSS 적용은 잘 사용하지 않고 권장하지 않는다. 코드 가독성이 떨어지고 관리하기도 불편하기 때문이다. 그럼에도 언급하는 이유는 JSX에서 CSS는 반드시 **객체형태**로 작성해야 하는 차이점이 있기 때문이다. 예제를 통해 알아보자. <br>\n\n\n```js\nimport Message from \"./Message\"\n\nexport default function Hello(){\n    return (\n        <div> \n            <h1 style = {\n                 {  color : '#f00',                  //객체이기 때문에 ; 아니고 , \n                    borderRight : '2px solid #000',  // - 쓰지 말고 카멜케이스\n                    marginButtom : \"30px\",\n                    opacity : 0.5                    // 숫자는 그대로\n                 }\n            } \n\t\t\t<h1> Hello</h1> \n            <Message/>\t\t\t// Welcome! 카카오 클라우드 컴퓨팅\n            <Message/>\t\t\t// Welcome! 카카오 클라우드 컴퓨팅\n            <Message/>\t\t\t// Welcome! 카카오 클라우드 컴퓨팅\n        </div>\n    )\n}\n```\nCSS스타일을 보면 중괄호가 두개인것을 볼 수 있다. 첫번째 중괄호는 데이터 바인딩을 위한 중괄호이고, 두번째 중괄호는 객체형식선언을 위한 중괄호이다. 그리고 각 스타일 속성은 객체형식이므로 `=`이 아닌 `:`을 사용해 선언한다.\n\n다음과 같이 적용된다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react2.png?raw=true\">\n</p>\n\n<br><Br><br>\n\n### 📌 외부 CSS\n기본 리액트 프로젝트의 CSS파일은 두가지가 있다. 첫번째로 `index.css`는 전체 프로젝트에 영향을 미치는 스타일을 작성할 수 있고 , 두번째 `App.css` 에는 App.js 컴포넌트에 한정된 스타일이 작성되어 있다. 그러나 App.js 컴포넌트에만 적용되는건 또 아니기도 하다. 때문에 이후 설명할 CSS 모듈이 필요하다.\n\n <br><Br>\n \n 🚩 **[예제 1]**\n\n`경로 : src/App.css`\n```css\n.csstest { color : red ; }\n```\n<br>\n\n\n`경로 : src/App.js`\n```js\nimport './App.css';\nimport Hello  from './component/Hello';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n       <p className=\"csstest\"> AppCssTest </p>\t// CSS적용\n       <Hello /> \n    </div>\n  );\n}\nexport default App;\n``` \n<br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react3.png?raw=true\">\n</p>\n\n\n<Br><br><br>\n\n🚩 **[예제 2] 외부 CSS import**\n\n`경로 : src/component/Hello.js`\n```js\nimport Message from \"./Message\"\nimport '../App.css'; \n\nexport default function Hello(){\n    return (\n        <div>\n            <h1 className=\"csstest\">Hello</h1>\n            <Message/>\n            <Message/>\n            <Message/>\n        </div>\n    )\n}\n```\n\n앞서 작성한 `App.css`를 import해서 사용하는 방법이다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react4.png?raw=true\">\n</p>\n\n\n<br><Br><br>\n\n🚩 **[예제 3]  CSS 모듈**\n컴포넌트 별로 CSS 스타일을 별도로 관리하고 싶을 때 사용한다. 보통 `컴포넌트이름.module.css`로 사용한다.\n\n`경로 : src/component/Hello.module.css`\n\n<br>\n\n```js\nimport Message from \"./Message\"\nimport styles from \"./Hello.module.css\";\n \n\nexport default function Hello(){\n    return (\n        <div>  \n            <h1 className= {styles.csstest}> Hello</h1>\n            <Message/>\n            <Message/>\n            <Message/>\n        </div>\n    )\n}\n```\n\n<Br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react6.png?raw=true\">\n</p>\n\n<Br><Br><br><Br><Br>\n\n## ✅ Props ( 속성 ) \n\n리액트에서 컴포넌트들을 만들면 컴포넌트는 다양한 HTML태그로 구성되어 있을것이다. 그런데 HTML 태그는 src, width, height 등과 같은 속성들을 가지고 있고 이에 따라 HTML태그의 상태가 다르게 적용된다. 그래서 리액트에서도 이러한 HTML 속성값들을 부여할 수 있는 기술이 존재하는데 바로 `PROP` 이다.\n\n아주 쉬운 예제를 통해 props를 적용하는 방법을 직접 보면서 설명해보도록 하겠다. 먼저 기본 틀을 만들어놓고 설명하도록 하겠다.\n\n```js\nimport  './App.css';\n\nfunction  Header() {\n\treturn (\n\t\t<h1> REACT</h1>\n\t\t)\n\t}\n\n\nfunction  Nav() {\n\treturn (\n\t\t<nav>\n\t\t\t<ol>\n\t\t\t\t<li><a  href=\"/read/2\">css</a></li>\n\t\t\t\t<li><a  href=\"/read/2\">css</a></li>\n\t\t\t\t<li><a  href=\"/read/3\">js</a></li>\n\t\t\t</ol>\n\t\t</nav>\n\t)\n}\n\n \nfunction  Article() {\n\treturn (\n\t\t<article>\n\t\t\t<h2> Welcome </h2>\n\t\t\tHello, WEB\n\t\t</article>\n\t)\n}\n\n\nfunction  App() {\n\treturn (\n\t\t<div>\n\t\t\t<Header></Header>\n\t\t\t<Nav></Nav>\n\t\t\t<Article></Article>\n\t\t</div>\n\t);\n}\n\nexport  default  App;\n```\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react10.png?raw=true\">\n</p>\n\n\n<br><br><Br>\n\n🚩 **[예제 1]  컴포넌트에 props 전달하기**\n```js\nfunction  Header(props) {\t// 함수에 매개변수로 props를 넣어준다\n\treturn (\n\t\t<header>\n\t\t\t<h1>  <a  href=\"/\">{props.title}</a></h1>\t// 중괄호에 속성을 넣어준다\n\t\t</header>\n\t)\n}\n\nfunction  App() {\n\treturn (\n\t\t<div>\n\t\t\t<Header title=\"REACT\"></Header>\t// props로 보내줄 속성을 설정한다\n\t\t\t<Nav></Nav>\n\t\t\t<Article></Article>\n\t\t</div>\n\t);\n}\n```\n\n`<Header>` 함수에 파라미터를 지정하고 이름은 **props** 라고 지정한다. 파라미터 이름은 어떤걸 설정해도 문제가 없지만, 대부분의 코드에서 **props**라고 지정하기때문에 우리도 **props** 라고 설정하도록 하자.\n\n그리고 이 **props**를 가져오려면 return문 안에 중괄호에 넣어준 형태로 가져올 수 있다. `<h1>  <a  href=\"/\">{props.title}</a></h1>` 위의 코드에서는 App.js에서 Header의 title을 지정해줬으므로 `{props.title}`의 형태로 가져왔다.\n\n**props**를 설정하는 순서가 좀 헷갈릴거 같아서 정리해보면,\n1. `컴포넌트`에 매개변수 **props**를 추가해준다. ` function  Header(props) `\n2. 속성값을 사용하려면 return문에 `{props.속성}` 의 형태로 넣어준다. \n`<h1>  <a  href=\"/\">{props.title}</a></h1>`\n4. `App.js`에 해당 태그에 속성을 부여한다.\n`<Header title=\"REACT\"></Header>`\n\n이렇게 하면 처음과 똑같은 결과를 볼 수 있다.\n\n<br><br><br>\n\n🚩 **[예제 2] 하나의 props로 여러개의 태그 만들기**\n\n**props**를 이용하면 하나의 props만으로 내용이 다른 여러개의 태그를 만들 수 있다.\n\n```js\nfunction  Article(props) {\t// 함수에 매개변수로 props를 넣어준다\n  return (\n\t<article>\n\t\t<h2> {props.title} </h2>\t// 중괄호에 속성을 넣어준다\n\t\t{props.body}\n\t</article>\n  )\n}\n\nfunction  App() {\n  return (\n\t<div>\n\t\t<Header title=\"REACT\"></Header>\t// props로 보내줄 속성을 설정한다\n\t\t<Nav></Nav>\n\t\t<Article title=\"Welcome\" body=\"Hello,Web\"></Article>\t// article 태그\n\t\t<Article title=\"Hi\" body=\"Hello,REACT\"></Article>\t// article 태그2\n\t</div>\n  );\n}\n```\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react11.png?raw=true\">\n</p>\n\n결과를 보면 Article태그를 두번 작성한것만으로 하나의 props를 통해 출력된것을 볼 수 있다. 이렇게 props를 활용해서 코드의 재사용을 높일 수 있다!\n\n<br><br><br>\n\n🚩 **[예제 3] props에 객체 담기**\n\nprops에는 객체형태로 변수를 담아서 전달할 수도 있다. \n\n```js\nfunction  Nav(props) {\n  const  listProps = [];\n\n  for(let  i=0;i<props.topics.length;i++){\n\tlet  t = props.topics[i];\n\tlistProps.push(<li  key={t.id}>  {t.title}</li>) // li는 key값 설정 필요\n  }\n  \n  return (\n    <nav>\n\t  <ol>\n\t    {listProps}\n\t  </ol>\n    </nav>\n  )\n}\n\nfunction  App() {\n  return (\n  \n\tconst  topics = [\n\t  {id:1, title:\"html\", body:\"html is ...\"},\n\t  {id:2, title:\"css\", body:\"css is ...\"},\n\t  {id:3, title:\"javascript\", body:\"javascript is ...\"}\n\t]\n\t\n\t<div>\n\t\t<Header title=\"REACT\"></Header>\t// props로 보내줄 속성을 설정한다\n\t\t<Nav topics={topics}></Nav>\n\t\t<Article title=\"Welcome\" body=\"Hello,Web\"></Article>\t// article 태그\n\t\t<Article title=\"Hi\" body=\"Hello,REACT\"></Article>\t// article 태그2\n\t</div>\n  );\n}\n```\n코드가 좀 복잡한데 하나하나 순서대로 설명을 해보면\n1. 기존 Nav는 리스트 형태로 구성되어 있다.\n2. 각각의 list에 대한 title, body를 topics라는 배열에 담는다. 이때 id를 반드시 설정해줘야만 한다! ( key에 대한 설명은 너무 길기때문에 그냥 알아만 두자 )\n3. Nav 컴포넌트에 props로 넘어온 list의 속성을 담아줄 배열을 선언한다.\n4. for문을 사용해 listProps 배열에 list속성을 담아준다.\n5. return문에 listProps를 출력한다.\n\n이런 형태로 props를 활용해 객체를 전달해줄 수도 있다!\n\n\n\n<br><br><br><br><br>\n\n## ✅ 이벤트 처리\n리액트의 이벤트 처리는 HTML 이벤트 처리와 거의 같다. 이벤트 역시 props를 활용해 전달해주는 원리이다. 기본적인 사용방법은 다음과 같다.\n\n- `onClick = { 함수 }`\n- `onClick = () => { 실행할 내용 } }`\n\n<br>\n\n🚩 **[예제 1]  이벤트 핸들러 등록**\n\n```js\nexport default function Message(){\n\n    function onClickHandle(){\n        console.log(\"clicked\");\n        alert(\"clicked\");\n    }\n\n    return (\n        <div> Welcome! 카카오클라우드컴퓨팅 \n            <button onClick={onClickHandle}>Click</button>\n        </div>\n    )\n}\n```\n<br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react7.png?raw=true\">\n</p>\n<Br>\n어렵지 않다. 이벤트를 함수로 선언하고 데이터바인딩해주면 된다.\n\n<br><Br><Br>\n\n🚩 **[예제 2]  이벤트 핸들러 등록, event 객체 활용**\n```js\nexport default function Message(){\n    function onClickHandle(){\n        console.log(\"clicked\");\n        alert(\"clicked\");\n    }\n    function onChangeName(event){\t\t\t// text를 입력하면 console에 출력\n        console.log(event.target.value); \t// \n    }\n    return (\n        <div> \n             Welcome! \n             <input type=\"text\" onChange={onChangeName} /> \n             카카오클라우드컴퓨팅 \n            <button onClick={onClickHandle}>Click</button>\n        </div>\n    )\n}\n```\n\n<Br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react8.png?raw=true\">\n</p>\n\n<Br>\n\n`input`태그에 텍스트가 입력될 때마다 console.log를 찍어주는 이벤트이다. event객체를 활용했다.\n\n<br><Br><br>\n\n🚩 **[예제 3]  익명 함수로 이벤트 핸들러 등록**\n```js\nexport default function Message(){\n    function onClickHandle(){\n        console.log(\"clicked\");\n        alert(\"clicked\");\n    }\n    function onChangeName(event){\n        console.log(event.target.value); \n    }\n    return (\n        <div> \n             Welcome! \n             <input type=\"text\" onChange={onChangeName} /> \n             <input type=\"text\" onChange={(event) => {\n                    console.log(event.target.value);        \n             } } />\n             카카오클라우드컴퓨팅 \n            <button onClick={onClickHandle}>Click</button>\n        </div>\n    )\n}\n```\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react9.png?raw=true\">\n</p>\n\n이벤트를 함수로 따로 작성하지 않고 익명함수 형태로 바로 지정해준 방식이다.\n\n<Br><Br><Br><Br><Br>\n\n## ✅ State\n리액트에서는 State역시 정말 중요한 요소이다. props와 거의 유사하지만 약간의 차이가 있는데 이를 공식문서에는 어떻게 정의했는지 알아보자.\n\n> **props와 state는 일반 자바스크립트 객체다. 두 객체 모두 렌더링 결과물에 영향을 주는 정보를 갖고 있는데 한 가지 중요한 방식에서 차이가 있다. props는 (함수 매개변수처럼) 컴포넌트에 전달되는 반면 state는 (함수 내 선언된 변수처럼) 컴포넌트 안에서 관리한다. React에서 this.props와 this.state는 모두 렌더링된 값을 나타낸다. 다시 말해 현재 화면에 보이는 걸 말한다**\n\n<br>\n또 다른 문서에 따르면 이러하다.\n\n> **state는 컴포넌트의 현재 상황에 대한 정보를 나타내기 위해 리액트에서 쓰는 일반 자바스크립트 객체다.** 함수에 선언된 모든 변수와 마찬가지로 **컴포넌트에서 관리된다.** 차이점은 일반 변수는 함수가 종료될 때 사라지지만 state 변수는 리액트에 의해 보존된다는 것이다. **컴포넌트의 역할은 원시 데이터를 HTML로 바꾸는 것**이기 때문에 이 원시 데이터는 props, state 객체로 구성돼 있다고 생각할 수 있다. props와 state가 render()의 입력 데이터라고 말할 수도 있다. 따라서 **state는 컴포넌트의 동작을 제어하는 일부 속성을 나타낸다.**\n\n위의 정의들을 정리해보면, state는 UI에 나타나는 요소들을 **비동기방식**으로 변환시켜주기 위해 사용하고, 컴포넌트의 동작을 제어하는 일부 속성이다.\n\n이제 state를 사용하는 기본예제를 통해 사용법을 알아보자.\n\n<br><br><br>\n\n🚩 **[예제 1]  이벤트 핸들러 등록, event 객체 활용**\n\n```js\nimport { useState } from \"react\";\n\nexport default function Message(){ \n    const [no, setNo] = useState(3) ;   //배열 형태 [ state속성명,  setter ] \n\n    function changeNum(){\n        setNo(no+1) ;    // setter 호출 하면 자동으로 no값 부분 화면 갱신 \n    }\n    return (\n        <div> \n             Welcome!  \n             <input type=\"text\"  />  \n             카카오 클라우드 컴퓨팅   \n             <span id=\"no\">{no}</span>기 \n             <button onClick={changeNum}> +1 Num </button> \n        </div>\n    )\n}\n```\n\n<Br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react12.png?raw=true\">\n</p>\n\n\n\n1. 먼저 state를 사용하기 위해서는 `import {usestate} from 'react'` 선언해줘야 한다.\n2. `useState(데이터) ` -> 이함수를 실행하고 나면 [a,b] 이런 배열이 하나 생기는데, a에는 데이터가 들어가고, b에는 state를 수정하기 위한 함수가 들어간다.\n3. `let [ a, b ] = useState('데이터')` 이런식으로 보통 사용한다.\n4. b에 들어간 함수는 a를 변경시기키 위한 함수인데 `b('데이터2')` 이렇게 사용하면 a의 데이터가 데이터2로 변경된다.\n5. 위의 코드는 버튼을 누르면 기존 '3기' 라는 텍스트에서 +1씩 상태를 변화시키는 코드이다.\n\n<br>\nstate에 데이터를 저장해서 쓰는 이유는 웹이 App처럼 동작하게 만들고 싶어서 쓰는것이기도 하다.  state가 변경되면 HTML이 자동으로 **재렌더링**이 되는데 그냥 일반 변수에 저장된건 새로고침을 해줘야만 재렌더링이 된다. 그러나 state에 저장된 내용은 비동기로 동작하기 때문에 곧바로 재렌더링되어 새로고침 없이 변할 수 있다. **즉 자주바뀌는, 중요한 데이터는 변수말고 state로 저장해서 사용해야 한다!**\n\n<br><br><br>\n\n\n### 📌 State 데이터 수정시 주의할 점! 굉장히 중요!!!!!\n\nstate는 자주 바뀌는 데이터를 저장해서 UI상에 비동기적 변화를 주기위해 사용할 수 있는데, `setState`를 사용하면 state의 값을 바꿀수 있다고 했다. 그럼 일반적으로 `setState`를 사용해서 state의 값을 바꿔보도록 하자.\n\n```js\nimport { useState } from \"react\" ; \n\nexport default function Hello() {\n   const [user, setUser] = useState({id:1,name:\"kim\"}) ;\n   function test(){\n      user.name=\"lee\"; \n      setUser(user);//user로 하면 화면 갱신 안됨.\n      // user 객체의 주소값이 동일하여 변화가 없는 것으로 인식 \n   }\n   return (\n      <button onClick={test}>{user.name} </button>\n   )\n}\n```\n\nuseState를 사용해 위 코드처럼 값을 변경하려고 하면 값이 갱신이 안될 것이다. 지금 state에 저장된 데이터는 **객체** 형태를 띄는데 자바스크립트에서 객체와 배열의 특징을 알면 왜 값이 갱신이 안되는지 잘 알수 있다.\n\n**JS에서는 객체나 배열을 어떤 변수에 저장하면 변수에는 그 값 자체가 아니라 객체나 배열의 주소값이 저장된다.**\n\n```js\nlet arr = [1,2,3]\n```\n\n위와 같은 배열이 선언됐을때 `arr`에는 `[1,2,3]`이 저장되는것이 아니라 `[1,2,3]`이 참조하고 있는 주소값이 저장된다. 한마디로 `[1,2,3]`의 위치가 저장된 것이다. \n\n이를 배경지식으로 가진채 `useState` 변경함수의 특징까지 고려해야한다. **`useState` 함수는 객체나 배열이 가지고 있는 주소값이 일치하다면 값을 굳이 변경해주지 않는 매커니즘을 가지고 있다.**\n\n그렇다면 위의 코드에서 기존에 `user.name=\"kim\"` 이라고 저장돼있는 상태에서 `user.name=\"lee\"` 라고 코드를 작성했을때, 실제로 `user.name`의 데이터는 `\"kim`\"에서 `\"lee\"`로 변경되지만, `user.name`의 주소값은 변경되지 않고 그대로일 것이다. 그렇다면 `setUser(user)` 입장에서 user의 데이터는 변경됐을지라도 주소값은 여전히 똑같기 때문에 값을 변경해주지 않게된다.\n\n때문에 객체나 배열의 데이터값을 변경하기 위해서는 아예 **새로운 변수를 만들고, 주소값까지 달리한다음, 기존 객체나 배열을 복사한뒤 `useState`의 변경함수를 사용해야 한다.**\n\n```js\nimport { useState } from \"react\" ; \n\nexport default function Hello() {\n   const [user, setUser] = useState({id:1,name:\"kim\"}) ;\n   function test(){\n      // 아래와 같이 수정하면 화면이 갱신됩니다. \n      let NewUser = {...user, name:\"lee\"};  //새로운 객체 생성\n      setUser(NewUser); \n\n   }\n   return (\n      <button onClick={test}>{user.name} </button>\n   )\n}\n```\n\n`...`은 Destructing을 의미하는데 객체나 배열을 쪼개서 개별적인 변수에 할당한다는 의미이다. 이를 통해 기존 객체나 배열이 쪼개져서 각각의 데이터가 하나의 변수를 가지게 되고 이 과정을 거친 후 다시 새로운 변수`(NewUser)` 를 선언하고 담아줌으로써 주소값이 다른 새로운 객체를 만들수 있다. 이런 과정을 Deep Copy를 한다고 표현한다.\n\n\n\n\n```\tjs\nlet [글제목,글제목변경] =  useState(['남자 코트 추천','여자 코트 추천', '남녀공용 코트 추천']); // [state 데이터, state 데이터 변경 함수]\n\nfunction  제목바꾸기(){\n\tvar newArray = 글제목;\t\t\t// 이건 복사가 아니라 값 공유\n\tvar newArray = [...글제목];\t\t// 이게 deep copy\n\t\t\t\t\t\t\t\t\t// ...뜻이 모든 중,대괄호를 없애달라\n\t\t\t\t\t\t\t\t\t// 그러고 [] 를 다시 만들어달라\n\t\t\t\t\t\t\t\t\t// 즉 copy하겠다.\n\tnewArray[0] =  '여자 코트 추천';\n\tnewArray[1] =  '남자 코트 추천';\n\t글제목변경(newArray);\n\t}\n```\n\n<br><br><br><br><br>\n\n여기 까지하면 리액트의 기본에 대해서는 거의 다 다룬것 같다. React가 무엇인지, React를 왜쓰는지, 컴포넌트, CSS, Props, State, 이벤트까지 다뤄봤고 이후 포스팅에서는 React Router DOM에 대해서 알아보도록 하겠다.\n","properties":"\n","discussions":{},"comments":{},"hash":1354164374,"tx":10962},"yCviR51sRbUk47WF/syncedContent":{"id":"yCviR51sRbUk47WF/syncedContent","type":"syncedContent","historyData":{"205511356":{"id":"yCviR51sRbUk47WF/content","type":"content","text":"---\npermalink: /2023-05-16-JS 인터프리터언어, 기본 문법/\ntitle: \"[JavaScript] JS 인터프리터언어, 기본 문법\"\ndate: 2023-05-16 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 인터프리터언어, 기본 문법\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n## ✅ JavaScript - 인터프리터 언어? 컴파일 언어?\n\n\n### 📌 인터프리터 언어\n인터프리터 언어는 원시코드(소스코드)를 기계어로 변환하는 과정 없이 한줄 한줄 해석하여 명령어를 실행하는 언어를 말합니다. R, Python, Ruby와 같은 언어들이 대표적인 인터프리터 언어입니다.\n\n인터프리터가 한 줄씩 읽고 따로 기계어로 변환하지 않기 때문에 빌드시간이 없습니다. 런타임 상황에서는 한 줄씩 실시간으로 코드를 읽어서 실행하기 때문에 컴파일 언어에 비해 속도가 느립니다.\n\n실행속도는 느리지만 코드 변경시 빌드 과정 없이 바로 실행이 가능하다는 장점이 있습니다.\n\n<br><br>\n\n### 📌 컴파일 언어\n\n컴파일 언어는 원시코드(소스코드)를 기계어로 변환한 후에 코드를 실행합니다. 소스코드를 기계어로 번역하는 빌드 과정에서 인터프리터 언어에 비해 시간이 소요됩니다. 그러나 런타임 상황에서는 모든 소스코드가 기계어로 변환되어 있기 때문에 더 빠르게 실행가능합니다. 대표적인 언어로 C,C++,C# 등이 있습니다. `exam.c` -> `exam.exe` 로 변경되는 것을 컴파일 이라고 합니다.\n\n<br><br>\n\n### 🔔 하이브리드 언어\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/java.png?raw=true\">\n</p>\n\n예외적으로 Java는 하이브리드 언어로 불립니다. 즉, 컴파일 언어이면서 인터프리터 언어이기도 합니다. `.java`로 표현되는 소스코드는 Java Compiler를 통해 `.class` 파일로 변환 됩니다. `.class`파일은 JVM은 이해할 수 있지만 아직 컴퓨터가 읽을 수는 없는 바이트 코드 파일입니다. 이후 컴파일된 바이트 코드를 JVM의 Class Loader에 전달합니다. Class Loader는 이를 JVM의 메모리에 올리고, 실행엔진(Execution Engine)이 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다. 이때 실행엔진은 인터프리터와 컴파일 방식, 두가지 방식으로 실행됩니다.\n\n<br><br>\n\n### 📌 JS는 인터프리터 언어이다!\nJS는 웹 브라우저에서 실행한다. 모든 웹 브라우저에는 JS 인터프리터가 탑재되어 있고, JS 인터프리터를 통해 JS 코드를 한줄 한줄 읽고 실행한다. \n\n[웹 브라우저 별 JS 인터프리터]\n- 크롬 : V8 -> 이걸 따로 떼어내서 출시한 JS 인터프리터가 Node.js\n- 엣지 : Chakra\n- 사파리 : Webkit\n- 파이어폭스 : SpiderMonkey\n<br>\n\nJS를 웹브라우저 없이 서버딴에서 실행이 가능한데 이러면 인터프리터를 설치해줘야 한다. 그때 Node.js를 설치해서 사용하면 된다..! \n\n<br><br><br><br>\n\n## ✅ JS 기본 문법\n\n### 📌 JS 코드 작성 요령\n1. 코드 들여쓰기\n2. 세미콜론으로 구분하자. JS는 세미콜론을 붙이지 않아도 실행되긴 한다. 그러나 디버깅을 위해 세미콜론을 반드시 붙이는 습관을 들이자.\n3. 공백을 넣어 읽기 쉽게 작성하자.\n4. 소스코드를 설명하는 주석을 작성하자.\n5. 식별자는 규칙을 지켜 작성하자. 반드시 영문자나 `_` , `$` 로 시작하고 대소문자를 구분하며 단어사이에 공백을 넣지말자.\n\n<br><br>\n\n### 📌 JS 기본 입출력 방법\n\n- **알림창** : 웹 브라우저에 알림창을 띄워줍니다.  \n\n\t> **기본형 - alert(메시지);**\n\n{% include codepen.html hash=\"qBJMbPy\" title=\"JS\" %}\n\n<br><br>\n\n- **확인창** : 메시지를 보여주고 확인/취소 버튼을 클릭할 수 있습니다.  \n\n\t> **기본형 - confirm(메시지);**  \n\n{% include codepen.html hash=\"LYgJGeJ\" title=\"JS\" %}\n\n<br><br>\n\n- **프롬프트 창** : 텍스트 필드가 있는 창을 제공합니다.  \n\n\t> **기본형 - prompt(메시지) 또는 prompt(메시지, 기본값)**  \n\n{% include codepen.html hash=\"wvYEMmK\" title=\"JS\" %}\n\n<br><br>\n\n- **`document.write()`** : 웹 문서(document)에서 괄호안의 내용을 표시하는 명령문  \n\n\t> **기본형 - document.write(\"메시지\" 또는 '메시지' 또는 <HTML태그> 내용 </HTML태그>**\n\n{% include codepen.html hash=\"MWPqKGo\" title=\"JS\" %}\n\n<br><br>\n\n- **`console.log()`** :  괄호안의 내용을 콘솔 창에 표시합니다.  \n\n\t> **기본형 -  console.log(변수 || 텍스트);**  \n\n{% include codepen.html hash=\"xxyaZQa\" title=\"JS\" %}\n\n<br><br><br>\n\n웹브라우저에서 개발자도구를 통해 콘솔을 보면 아래 사진처럼 console.log에 입력한 내용이 출력됩니다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/console2.png?raw=true\">\n</p>\n\n<br><br><br><br>\n\n\n\n\n## ✅ 개발자 도구로 디버깅하기\n\n1. 웹 브라우저에서 소스 코드 실행\n2. F12눌러서 개발자 도구 실행\n3. Console 탭으로 이동 후 에러 확인\n4. 에러를 클릭하면 에러가 발생한 코드로 이동!\n<br>\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/console1.png?raw=true\">\n</p>\n","properties":"\n","discussions":{},"comments":{},"hash":205511356},"1352589608":{"id":"yCviR51sRbUk47WF/content","type":"content","text":"---\npermalink: /2023-05-16-JS 인터프리터언어, 기본 문법/\ntitle: \"[JavaScript] JS 인터프리터언어, 기본 문법\"\ndate: 2023-05-16 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 인터프리터언어, 기본 문법\"\ncategories:\n- JavaScript\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n## ✅ JavaScript - 인터프리터 언어? 컴파일 언어?\n\n\n### 📌 인터프리터 언어\n인터프리터 언어는 원시코드(소스코드)를 기계어로 변환하는 과정 없이 한줄 한줄 해석하여 명령어를 실행하는 언어를 말합니다. R, Python, Ruby와 같은 언어들이 대표적인 인터프리터 언어입니다.\n\n인터프리터가 한 줄씩 읽고 따로 기계어로 변환하지 않기 때문에 빌드시간이 없습니다. 런타임 상황에서는 한 줄씩 실시간으로 코드를 읽어서 실행하기 때문에 컴파일 언어에 비해 속도가 느립니다.\n\n실행속도는 느리지만 코드 변경시 빌드 과정 없이 바로 실행이 가능하다는 장점이 있습니다.\n\n<br><br>\n\n### 📌 컴파일 언어\n\n컴파일 언어는 원시코드(소스코드)를 기계어로 변환한 후에 코드를 실행합니다. 소스코드를 기계어로 번역하는 빌드 과정에서 인터프리터 언어에 비해 시간이 소요됩니다. 그러나 런타임 상황에서는 모든 소스코드가 기계어로 변환되어 있기 때문에 더 빠르게 실행가능합니다. 대표적인 언어로 C,C++,C# 등이 있습니다. `exam.c` -> `exam.exe` 로 변경되는 것을 컴파일 이라고 합니다.\n\n<br><br>\n\n### 🔔 하이브리드 언어\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/java.png?raw=true\">\n</p>\n\n예외적으로 Java는 하이브리드 언어로 불립니다. 즉, 컴파일 언어이면서 인터프리터 언어이기도 합니다. `.java`로 표현되는 소스코드는 Java Compiler를 통해 `.class` 파일로 변환 됩니다. `.class`파일은 JVM은 이해할 수 있지만 아직 컴퓨터가 읽을 수는 없는 바이트 코드 파일입니다. 이후 컴파일된 바이트 코드를 JVM의 Class Loader에 전달합니다. Class Loader는 이를 JVM의 메모리에 올리고, 실행엔진(Execution Engine)이 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다. 이때 실행엔진은 인터프리터와 컴파일 방식, 두가지 방식으로 실행됩니다.\n\n<br><br>\n\n### 📌 JS는 인터프리터 언어이다!\nJS는 웹 브라우저에서 실행한다. 모든 웹 브라우저에는 JS 인터프리터가 탑재되어 있고, JS 인터프리터를 통해 JS 코드를 한줄 한줄 읽고 실행한다. \n\n[웹 브라우저 별 JS 인터프리터]\n- 크롬 : V8 -> 이걸 따로 떼어내서 출시한 JS 인터프리터가 Node.js\n- 엣지 : Chakra\n- 사파리 : Webkit\n- 파이어폭스 : SpiderMonkey\n<br>\n\nJS를 웹브라우저 없이 서버딴에서 실행이 가능한데 이러면 인터프리터를 설치해줘야 한다. 그때 Node.js를 설치해서 사용하면 된다..! \n\n<br><br><br><br>\n\n## ✅ JS 기본 문법\n\n### 📌 JS 코드 작성 요령\n1. 코드 들여쓰기\n2. 세미콜론으로 구분하자. JS는 세미콜론을 붙이지 않아도 실행되긴 한다. 그러나 디버깅을 위해 세미콜론을 반드시 붙이는 습관을 들이자.\n3. 공백을 넣어 읽기 쉽게 작성하자.\n4. 소스코드를 설명하는 주석을 작성하자.\n5. 식별자는 규칙을 지켜 작성하자. 반드시 영문자나 `_` , `$` 로 시작하고 대소문자를 구분하며 단어사이에 공백을 넣지말자.\n\n<br><br>\n\n### 📌 JS 기본 입출력 방법\n\n- **알림창** : 웹 브라우저에 알림창을 띄워줍니다.  \n\n\t> **기본형 - alert(메시지);**\n\n{% include codepen.html hash=\"qBJMbPy\" title=\"JS\" %}\n\n<br><br>\n\n- **확인창** : 메시지를 보여주고 확인/취소 버튼을 클릭할 수 있습니다.  \n\n\t> **기본형 - confirm(메시지);**  \n\n{% include codepen.html hash=\"LYgJGeJ\" title=\"JS\" %}\n\n<br><br>\n\n- **프롬프트 창** : 텍스트 필드가 있는 창을 제공합니다.  \n\n\t> **기본형 - prompt(메시지) 또는 prompt(메시지, 기본값)**  \n\n{% include codepen.html hash=\"wvYEMmK\" title=\"JS\" %}\n\n<br><br>\n\n- **`document.write()`** : 웹 문서(document)에서 괄호안의 내용을 표시하는 명령문  \n\n\t> **기본형 - document.write(\"메시지\" 또는 '메시지' 또는 <HTML태그> 내용 </HTML태그>**\n\n{% include codepen.html hash=\"MWPqKGo\" title=\"JS\" %}\n\n<br><br>\n\n- **`console.log()`** :  괄호안의 내용을 콘솔 창에 표시합니다.  \n\n\t> **기본형 -  console.log(변수 || 텍스트);**  \n\n{% include codepen.html hash=\"xxyaZQa\" title=\"JS\" %}\n\n<br><br><br>\n\n웹브라우저에서 개발자도구를 통해 콘솔을 보면 아래 사진처럼 console.log에 입력한 내용이 출력됩니다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/console2.png?raw=true\">\n</p>\n\n<br><br><br><br>\n\n\n\n\n## ✅ 개발자 도구로 디버깅하기\n\n1. 웹 브라우저에서 소스 코드 실행\n2. F12눌러서 개발자 도구 실행\n3. Console 탭으로 이동 후 에러 확인\n4. 에러를 클릭하면 에러가 발생한 코드로 이동!\n<br>\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/console1.png?raw=true\">\n</p>\n","properties":"\n","discussions":{},"comments":{},"hash":1352589608}},"syncHistory":{"main":[205511356,1352589608,205511356]},"v":1,"hash":1710890986564,"tx":10968},"MviwGZUVucL3T4n8/content":{"id":"MviwGZUVucL3T4n8/content","type":"content","text":"---\npermalink: /2022-12-20-CSS 이미지 (절대경로vs상대경로) /\ntitle: \"[HTML] [CSS]  CSS 이미지 ( 절대경로 vs 상대경로 )\"\ndate: 2022-12-20 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CSS 이미지 ( 절대경로 vs 상대경로 )\"\ncategories:\n- Front-end\ntags:\n- HTML & CSS\n---\n<br><br><br>\n\n개인 프로젝트를 진행하면서 html에 이미지를 삽입 할때, 이미지 경로 설정하는데 어려움이 있어 따로 기억도 할 겸 정리한다.\n\n<br><br><br>\n\n## ✅ 이미지 경로\n\n📌 **절대 경로**\n\n```html\n\t<img src=\"http://www.naver.com/images/logo.jpg\">\t// 서버 호스트에 저장된 이미지\n\t<img src=\"C:\\Users\\사용자이름\\Pictures\\MyImg.jpg\"> \t// 로컬 PC에 저장된 이미지\n```\n\n- 파일 시스템의 루트부터 시작해 명시해주는 것을 절대경로 라고 한다.\n- 인터넷 파일(서버호스트에 저장된 이미지)의 경우 전체url을 파일 경로로 설정한다.\n\n<br><br><br>\n\n📌 **상대 경로**\n- 이미지를 삽입할 HTML 문서를 기준으로 경로를 인식하는 방법\n- 이미지 파일이 HTML 문서와 **같은 폴더에 있는지**, **상위 폴더에 있는지**, **하위폴더에 있는지**를 따져보고 경로를 지정.\n\n<br><br>\n\n📌 **1. 이미지 파일과 HTML 문서가 같은 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css1.gif?raw=true\">\n</p>\n\n```html\n<img src=\"favicon.png\">\n```\n\n- 단순하게 파일명과 확장자만 명시해주면 된다.\n\n\n<br><br><br>\n\n📌 **2. 이미지 파일이 HTML 문서보다 하위 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css2.gif?raw=true\">\n</p>\n\n```html\n<img src=\"images/logo.gif\">\n```\n\n- 폴더에 하나 들어갈때 마다 슬래쉬(/) 기호를 사용해 접근한다.\n\n<br><br><br>\n\n📌 **3. 이미지 파일이 HTML 문서보다 상위 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css3.gif?raw=true\">\n</p>\n\n```html\n<img src=\"../images/logo.gif\">\n```\n- 현재 파일(style.css)을 기준으로 상위 폴더로 이동한 후 이미지가 있는 폴더로 다시 접근한다.\n- 상위 폴더로 이동 할때는 ```../``` 를 사용한다. \n","properties":"\n","discussions":{},"comments":{},"hash":1344639622,"tx":10986},"MviwGZUVucL3T4n8/syncedContent":{"id":"MviwGZUVucL3T4n8/syncedContent","type":"syncedContent","historyData":{"797710272":{"id":"MviwGZUVucL3T4n8/content","type":"content","text":"---\npermalink: /2022-12-20-CSS 이미지 (절대경로vs상대경로) /\ntitle: \"[HTML] [CSS]  CSS 이미지 ( 절대경로 vs 상대경로 )\"\ndate: 2022-12-20 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"HTML & CSS\"\ncategories:\n- Front-end\ntags:\n- HTML & CSS\n---\n<br><br><br>\n\n개인 프로젝트를 진행하면서 html에 이미지를 삽입 할때, 이미지 경로 설정하는데 어려움이 있어 따로 기억도 할 겸 정리한다.\n\n<br><br><br>\n\n## ✅ 이미지 경로\n\n📌 **절대 경로**\n\n```html\n\t<img src=\"http://www.naver.com/images/logo.jpg\">\t// 서버 호스트에 저장된 이미지\n\t<img src=\"C:\\Users\\사용자이름\\Pictures\\MyImg.jpg\"> \t// 로컬 PC에 저장된 이미지\n```\n\n- 파일 시스템의 루트부터 시작해 명시해주는 것을 절대경로 라고 한다.\n- 인터넷 파일(서버호스트에 저장된 이미지)의 경우 전체url을 파일 경로로 설정한다.\n\n<br><br><br>\n\n📌 **상대 경로**\n- 이미지를 삽입할 HTML 문서를 기준으로 경로를 인식하는 방법\n- 이미지 파일이 HTML 문서와 **같은 폴더에 있는지**, **상위 폴더에 있는지**, **하위폴더에 있는지**를 따져보고 경로를 지정.\n\n<br><br>\n\n📌 **1. 이미지 파일과 HTML 문서가 같은 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css1.gif?raw=true\">\n</p>\n\n```html\n<img src=\"favicon.png\">\n```\n\n- 단순하게 파일명과 확장자만 명시해주면 된다.\n\n\n<br><br><br>\n\n📌 **2. 이미지 파일이 HTML 문서보다 하위 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css2.gif?raw=true\">\n</p>\n\n```html\n<img src=\"images/logo.gif\">\n```\n\n- 폴더에 하나 들어갈때 마다 슬래쉬(/) 기호를 사용해 접근한다.\n\n<br><br><br>\n\n📌 **3. 이미지 파일이 HTML 문서보다 상위 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css3.gif?raw=true\">\n</p>\n\n```html\n<img src=\"../images/logo.gif\">\n```\n- 현재 파일(style.css)을 기준으로 상위 폴더로 이동한 후 이미지가 있는 폴더로 다시 접근한다.\n- 상위 폴더로 이동 할때는 ```../``` 를 사용한다. \n","properties":"\n","discussions":{},"comments":{},"hash":797710272},"1344639622":{"id":"MviwGZUVucL3T4n8/content","type":"content","text":"---\npermalink: /2022-12-20-CSS 이미지 (절대경로vs상대경로) /\ntitle: \"[HTML] [CSS]  CSS 이미지 ( 절대경로 vs 상대경로 )\"\ndate: 2022-12-20 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CSS 이미지 ( 절대경로 vs 상대경로 )\"\ncategories:\n- Front-end\ntags:\n- HTML & CSS\n---\n<br><br><br>\n\n개인 프로젝트를 진행하면서 html에 이미지를 삽입 할때, 이미지 경로 설정하는데 어려움이 있어 따로 기억도 할 겸 정리한다.\n\n<br><br><br>\n\n## ✅ 이미지 경로\n\n📌 **절대 경로**\n\n```html\n\t<img src=\"http://www.naver.com/images/logo.jpg\">\t// 서버 호스트에 저장된 이미지\n\t<img src=\"C:\\Users\\사용자이름\\Pictures\\MyImg.jpg\"> \t// 로컬 PC에 저장된 이미지\n```\n\n- 파일 시스템의 루트부터 시작해 명시해주는 것을 절대경로 라고 한다.\n- 인터넷 파일(서버호스트에 저장된 이미지)의 경우 전체url을 파일 경로로 설정한다.\n\n<br><br><br>\n\n📌 **상대 경로**\n- 이미지를 삽입할 HTML 문서를 기준으로 경로를 인식하는 방법\n- 이미지 파일이 HTML 문서와 **같은 폴더에 있는지**, **상위 폴더에 있는지**, **하위폴더에 있는지**를 따져보고 경로를 지정.\n\n<br><br>\n\n📌 **1. 이미지 파일과 HTML 문서가 같은 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css1.gif?raw=true\">\n</p>\n\n```html\n<img src=\"favicon.png\">\n```\n\n- 단순하게 파일명과 확장자만 명시해주면 된다.\n\n\n<br><br><br>\n\n📌 **2. 이미지 파일이 HTML 문서보다 하위 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css2.gif?raw=true\">\n</p>\n\n```html\n<img src=\"images/logo.gif\">\n```\n\n- 폴더에 하나 들어갈때 마다 슬래쉬(/) 기호를 사용해 접근한다.\n\n<br><br><br>\n\n📌 **3. 이미지 파일이 HTML 문서보다 상위 폴더에 있는 경우**\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/css3.gif?raw=true\">\n</p>\n\n```html\n<img src=\"../images/logo.gif\">\n```\n- 현재 파일(style.css)을 기준으로 상위 폴더로 이동한 후 이미지가 있는 폴더로 다시 접근한다.\n- 상위 폴더로 이동 할때는 ```../``` 를 사용한다. \n","properties":"\n","discussions":{},"comments":{},"hash":1344639622}},"syncHistory":{"main":[1344639622,797710272,1344639622]},"v":1,"hash":1710891036238,"tx":10988},"5xTVal0mYmIYU6Hk/syncedContent":{"id":"5xTVal0mYmIYU6Hk/syncedContent","type":"syncedContent","historyData":{"169604087":{"id":"5xTVal0mYmIYU6Hk/content","type":"content","text":"---\npermalink: /2023-05-11-CSS 기본 선택자, 캐스케이딩(Cascading), 박스 모델, 레이아웃/\ntitle: \"[CSS] CSS 기본 선택자, 캐스케이딩(Cascading), 박스 모델, 레이아웃\"\ndate: 2023-05-11 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CSS 기본 선택자, 캐스케이딩(Cascading), 박스 모델, 레이아웃\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- CSS\n- HTML\n---\n<br><br>\n\n\n## ✅ CSS 기본 선택자 (Selector)\n\n### 📌 1. 전체 선택자\n**HTML페이지 내부의 모든 태그를 선택합니다.**\n\n{% include codepen.html hash=\"vYVzEJP\" title=\"css\" %}\n\n<Br>\n\n전체선택자는 HTML 페이지 내부의 모든 요소에 같은 CSS 속성을 적용합니다. 때문에 margin이나 padding값을 초기화하는 등 기본값을 정해둘 때 사용합니다. \n\n<br><br>\n\n### 📌 2. 태그 선택자 ( Type Selector )\n**HTML요소를 직접 지칭하는 가장 간단한 선택자**\n{% include codepen.html hash=\"qBJMEPy\" title=\"css\" %}\n\n<BR><BR>\n\n### 📌 3. 클래스 선택자 ( Class Selector )\n**class 속성값을 가진 HTML요소를 찾아 CSS를 적용하는 선택자**\n\n{% include codepen.html hash=\"eYPLmeE\" title=\"css\" %}\n<Br><br>\n\n### 📌 4. ID 선택자 ( ID Selector )\n**id 속성값을 가진 HTML요소를 찾아 CSS를 적용하는 선택자**\n\n{% include codepen.html hash=\"PoydwEY\" title=\"css\" %}\n<BR><BR>\n\n\n### 🔔 클래스 선택자와 ID 선택자를 어떻게 구분해서 쓸까?\n\n그냥 딱 결론만 말하면\n\n**한 페이지내에서 여러번 반복되는 스타일은 클래스 선택자!**\n**한 페이지내에서 단한번 쓰이는 스타일은 ID 선택자!**\n\n클래스 선택자는 글자색이나 굵기 등 나중에 다른곳에서도 쓰일수 있는 스타일을 지정하고, ID선택자는 요소의 배치 방법을 지정할 때 자주 사용합니다.\n\nclass 속성은 두개이상의 속성값을 가질 수 있고, ID 선택자는 하나의 속성값만 가질 수 있습니다.\n\n또한 ID 선택자의 우선순위가 클래스 선택자의 우선순위보다 높기때문에, 우선으로 적용되어야 할 스타일을 ID선택자를 사용하여 정의하는게 좋습니다.\n\n<br><br>\n\n### 📌 5. 그룹 선택자\n**같은 스타일을 사용하는 선택자를 한꺼번에 정의하는 선택자**\n**쉼표(,)로 구분해 여러 선택자를 나열**\n\n```css\nh1{ text-align : center; }\np { text-align : center; }\n```\n\n```css\n/* 그룹 선택자로 변환 */\nh1, p { texxt-align : center; }\n```\n\n<BR><BR><Br><br>\n\n\n\n## ✅ 캐스케이딩 ( Cascading )\n\n\n### 📌 캐스케이딩이란 ?\n위에서 아래로 흐른다, 즉 계단식으로 적용된다는 의미로 사용됩니다.\n선택자에 따라 여러 스타일이 적용될 때 스타일 충돌을 막기위해 우선순위에 따라 스타일을 결정할 수 있습니다.\n\n<br><br>\n\n### 📌 스타일 충돌을 막는 캐스케이딩의 원칙\n1. **스타일 우선순위** : 스타일 규칙의 중요도와 적용 범위에 따라 우선순위가 결정되고 그 우선순위에 따라 위에서 아래로 스타일 적용\n\n\t🚩 `!important` 태그를 붙여주면 어떤 스타일보다 우선적용 된다! \n\n2. **스타일 상속** - 태그들의 포함 관계에 따라 부모 요소의 스타일을 자식 요소로, 위에서 아래로 전달\n\n\n<BR><BR><br><br>\n\n\n\n## ✅ CSS의 레벨 요소\n\n### 📌 블록 레벨 요소 (Block Element)\n요소를 삽입했을 때 혼자 한줄을 차지하는 요소.\n요소의 너비가 100% -> 줄바꿈이 됨\nex ) `<div>, <p>` 등\n\n```html\n<div> div태그는 블록레벨 요소입니다. </div>\n<p> p태그는 블록레벨 요소입니다.</p>\n```\n\n<br><br>\n\n### 📌 인라인 레벨 요소 (Inline Element)\n줄을 차지하지 않는 요소.\n화면에 표시되는 콘텐츠 만큼만 영역을 차지하고 나머지 공간에는 다른 요소가 올 수 있음\nex ) `<img>, <string>, <span>` 등\n```html\n<div> div태그는 블록레벨 요소입니다. </div>\n<p> p태그는 블록레벨 요소입니다. \n<span>그러나 span 태그는 인라인 레벨 요소이므로 블록 레벨 요소 중간에 넣을 수 있습니다.</span>\n</p>\n```\n\n<br><br><br><br>\n\n## ✅ CSS와 박스 모델\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/box-model.png?raw=true\">\n</p>\n\n웹페이지에 배치하는 모든 HTML 요소는 3개의 층을 가진 사각형 구조를 띄고 있습니다. \n가장 외곽의 층을 `margin` 영역이라고 부르고 보통 주변에 위치한 다른 요소와의 상하좌우 간격을 두기위해 사용합니다.\n그 바로 아래층을 `border` 영역이라고 부르고 요소의 테두리를 의미합니다. 색깔, 두께, 모양 등을 설정 가능합니다.\n그 아래층은 `padding` 영역이라고 부르고 컨텐츠와 `border` 사이의 간격을 지정하기 위해 사용합니다.\n마지막으로 `content` 영역은 컨텐츠의 `width`와 `height`를 지정할 수 있습니다. \n\n\n{% include codepen.html hash=\"xxyabYz\" title=\"css\" %}\n\n\n<br><br><br><br>\n\n## ✅ 레이아웃\n\n### 📌 display 속성\n 요소의 배치 방법을 결정합니다.\n \n|종류|설명  |\n|--|--|\n|block  | 인라인 레벨 요소를 블록 레벨 요소로 변경 |\n|inline  | 블록 레벨 요소를 인라인 레벨 요소로 변경 |\n|inline-block  |인라인 레벨 요소와 블록 레벨 요소의 속성을 모두 가지고 있고, 마진과 패딩 지정 가능  |\n|none  |  해당 요소를 화면에 표시하지 않음  |\n\n<br><br>\n\n### 📌 float 속성\n요소를 왼쪽이나 오른쪽에 떠있게 만듦\n\n기본형 -  ``` float : left || right || none ```\n\n| 속성값  | 설명 |\n|--|--|\n| left | 해당 요소를 문서의 왼쪽으로 배치합니다. |\n| right | 해당 요소를 문서의 오른쪽으로 배치합니다. |\n| none | 좌우 어느쪽으로도 배치하지 않습니다. |\n\n<br><br>\n### 📌 position 속성\n웹 문서 안에 요소들을 배치하기 위한 속성\n\n기본형 -  ``` position : static || relative || absolute || fixed ```\n\n| 속성 값 | 설명 |\n|--|--|\n| *static | *요소를 문서의 흐름에 맞춰 배치합니다 |\n| relative | 이전 요소에 자연스럽게 연결해 배치하되 위치를 지정할 수 있습니다. |\n| absolute | 원하는 위치를 지정해 배치합니다. |\n| fixed | 지정한 위치에 고정해 배치합니다. 화면에서 요소가 잘릴 수도 있습니다. |\n\n","properties":"\n","discussions":{},"comments":{},"hash":169604087}},"syncHistory":{"main":[169604087,169604087,null]},"v":1,"hash":1710891043780,"tx":10993},"1nZnksY9YPlL4cyi/content":{"id":"1nZnksY9YPlL4cyi/content","type":"content","text":"---\npermalink: /2023-05-12-CSS 연결 선택자, 속성 선택자, 가상 클래스/\ntitle: \"[CSS] CSS 연결 선택자, 속성 선택자, 가상 클래스\"\ndate: 2023-05-12 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CSS 연결 선택자, 속성 선택자, 가상 클래스\"\ncategories:\n- Front-end\ntags:\n- TIL\n- CSS\n- HTML\n---\n<br><br>\n\n\n## ✅ CSS 연결 선택자\n연결 선택자는 둘 이상의 선택자를 연결해서 스타일이 적용될 요소가 어느 부분인지 지정합니다. 선택자를 둘 이상 조합하므로, '조합 선택자'라고도 하고, '콤비네이션 선택자' 라고도 부릅니다.\n\n<br><br>\n\n### 📌 하위 선택자\n\n> **기본형 : 상위요소 하위요소**  \n```css\nsection p { ... }\t/\tdiv p { ... } 등\n```\n\n부모 요소에 포함된 하위 요소를 모두 선택하여 스타일을 적용합니다. **공백**으로 상위요소와 하위요소를 구분합니다. \n\n{% include codepen.html hash=\"eYPLZjx\" title=\"css\" %}\n\n\n<br><br>\n\n\n### 📌 자식 선택자\n\n> **기본형 : 부모요소 > 자식요소**  \n```css\nsection > p { ... }\t  /   div > p { ... } 등\n```\n하위 선택자와 다르게 자식요소에만 스타일을 적용하는 선택자입니다. 두 요소 사이에 '>' 기호를 표시해 부모요소와 자식요소를 구분합니다.\n\n{% include codepen.html hash=\"mdzGPQW\" title=\"css\" %}\n\n<br><br>\n\n\n### 📌 인접 형제 선택자\n\n> **기본형 : 요소1 + 요소2**  \n\n형제 요소 중에서 첫 번째 동생 요소만 선택하는 선택자입니다.  인접 형제 선택자를 정의할 때는 요소1과 요소2 사이에 '+'기호를 표시합니다.\n\n```css\nh1 + p { color : blue; } // h1의 형제인 p요소중 첫번째 p\n```\n\n{% include codepen.html hash=\"oNaPxRx\" title=\"css\" %}\n\n<br><br>\n\n### 📌 형제 선택자\n\n> **기본형 : 요소1 ~ 요소2**  \n\n형제 요소의 스타일을 정의하는 선택자입니다. 요소1과 형제인 요소2를 전부 선택하여 스타일을 정의하고, 요소1과 요소2 사이에 '~'기호를 표시합니다.\n\n```css\nh1 ~ p { color : blue; }\n```\n\n{% include codepen.html hash=\"qBJMNdZ\" title=\"css\" %}\n\n<br><br><br><br>\n\n## ✅ CSS 속성 선택자\nHTML태그를 작성 할 때 여러 속성을 함께 사용하는데 속성값에 따라 원하는 요소를 선택할 수도 있습니다. 이를 [속성] 선택자 라고하는데, 대괄호 '[ ]' 사이에 원하는 속성을 입력해서 사용합니다. \n\n### 📌 [속성] 선택자\n\n> **기본형 : 요소[속성]**  \n\n```css\na[href] { ... } // a요소 중에서 href 속성이 있는 요소 선택\n```\n\n{% include codepen.html hash=\"gOBdMro\" title=\"css\" %}\n\n<br><br>\n\n### 📌 [속성=속성값] 선택자\n\n> **기본형 : 요소[속성 = 속성값]**  \n\n주어진 속성과 속성값이 일치하는 요소를 찾아 스타일을 지정할 때 사용합니다.  대괄호안에 속성과 속성값을 넣고 그 사이에 '=' 기호를 표시합니다.\n\n```css\na[target=_black] { ... } // <a target = \"_blank\"> 인 요소\n```\n{% include codepen.html hash=\"PoydGYV\" title=\"css\" %}\n\n<br><br><br><br>\n \n\n## ✅ 가상 클래스 선택자\n사용자의 동작에 반응하는 선택자!\n```css\n:link - 방문하지 않은 링크에 스타일 적용\n:visited - 방문한 링크에 스타일 적용\n:active - 웹 요소를 활성화 했을때의 스타일 적용\n:hover - 웹 요소에 마우스 커서를 올려놓을 때의 스타일 적용\n:focus - 웹 요소에 초점이 맞추어졌을 때의 스타일 적용\n```\n\n#### 구조 가상 클래스\n`nth-child(n)` : 부모 안에있는 모든 요소중에서 n번재 자식요소를 선택\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1312876364,"tx":11008},"1nZnksY9YPlL4cyi/syncedContent":{"id":"1nZnksY9YPlL4cyi/syncedContent","type":"syncedContent","historyData":{"-2105501131":{"id":"1nZnksY9YPlL4cyi/content","type":"content","text":"---\npermalink: /2023-05-12-CSS 연결 선택자, 속성 선택자, 가상 클래스/\ntitle: \"[TIL] [CSS] CSS 연결 선택자, 속성 선택자, 가상 클래스\"\ndate: 2023-05-12 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CSS 연결 선택자, 속성 선택자, 가상 클래스\"\ncategories:\n- Front-end\ntags:\n- TIL\n- CSS\n- HTML\n---\n<br><br>\n\n\n## ✅ CSS 연결 선택자\n연결 선택자는 둘 이상의 선택자를 연결해서 스타일이 적용될 요소가 어느 부분인지 지정합니다. 선택자를 둘 이상 조합하므로, '조합 선택자'라고도 하고, '콤비네이션 선택자' 라고도 부릅니다.\n\n<br><br>\n\n### 📌 하위 선택자\n\n> **기본형 : 상위요소 하위요소**  \n```css\nsection p { ... }\t/\tdiv p { ... } 등\n```\n\n부모 요소에 포함된 하위 요소를 모두 선택하여 스타일을 적용합니다. **공백**으로 상위요소와 하위요소를 구분합니다. \n\n{% include codepen.html hash=\"eYPLZjx\" title=\"css\" %}\n\n\n<br><br>\n\n\n### 📌 자식 선택자\n\n> **기본형 : 부모요소 > 자식요소**  \n```css\nsection > p { ... }\t  /   div > p { ... } 등\n```\n하위 선택자와 다르게 자식요소에만 스타일을 적용하는 선택자입니다. 두 요소 사이에 '>' 기호를 표시해 부모요소와 자식요소를 구분합니다.\n\n{% include codepen.html hash=\"mdzGPQW\" title=\"css\" %}\n\n<br><br>\n\n\n### 📌 인접 형제 선택자\n\n> **기본형 : 요소1 + 요소2**  \n\n형제 요소 중에서 첫 번째 동생 요소만 선택하는 선택자입니다.  인접 형제 선택자를 정의할 때는 요소1과 요소2 사이에 '+'기호를 표시합니다.\n\n```css\nh1 + p { color : blue; } // h1의 형제인 p요소중 첫번째 p\n```\n\n{% include codepen.html hash=\"oNaPxRx\" title=\"css\" %}\n\n<br><br>\n\n### 📌 형제 선택자\n\n> **기본형 : 요소1 ~ 요소2**  \n\n형제 요소의 스타일을 정의하는 선택자입니다. 요소1과 형제인 요소2를 전부 선택하여 스타일을 정의하고, 요소1과 요소2 사이에 '~'기호를 표시합니다.\n\n```css\nh1 ~ p { color : blue; }\n```\n\n{% include codepen.html hash=\"qBJMNdZ\" title=\"css\" %}\n\n<br><br><br><br>\n\n## ✅ CSS 속성 선택자\nHTML태그를 작성 할 때 여러 속성을 함께 사용하는데 속성값에 따라 원하는 요소를 선택할 수도 있습니다. 이를 [속성] 선택자 라고하는데, 대괄호 '[ ]' 사이에 원하는 속성을 입력해서 사용합니다. \n\n### 📌 [속성] 선택자\n\n> **기본형 : 요소[속성]**  \n\n```css\na[href] { ... } // a요소 중에서 href 속성이 있는 요소 선택\n```\n\n{% include codepen.html hash=\"gOBdMro\" title=\"css\" %}\n\n<br><br>\n\n### 📌 [속성=속성값] 선택자\n\n> **기본형 : 요소[속성 = 속성값]**  \n\n주어진 속성과 속성값이 일치하는 요소를 찾아 스타일을 지정할 때 사용합니다.  대괄호안에 속성과 속성값을 넣고 그 사이에 '=' 기호를 표시합니다.\n\n```css\na[target=_black] { ... } // <a target = \"_blank\"> 인 요소\n```\n{% include codepen.html hash=\"PoydGYV\" title=\"css\" %}\n\n<br><br><br><br>\n \n\n## ✅ 가상 클래스 선택자\n사용자의 동작에 반응하는 선택자!\n```css\n:link - 방문하지 않은 링크에 스타일 적용\n:visited - 방문한 링크에 스타일 적용\n:active - 웹 요소를 활성화 했을때의 스타일 적용\n:hover - 웹 요소에 마우스 커서를 올려놓을 때의 스타일 적용\n:focus - 웹 요소에 초점이 맞추어졌을 때의 스타일 적용\n```\n\n#### 구조 가상 클래스\n`nth-child(n)` : 부모 안에있는 모든 요소중에서 n번재 자식요소를 선택\n\n","properties":"\n","discussions":{},"comments":{},"hash":-2105501131},"-1312876364":{"id":"1nZnksY9YPlL4cyi/content","type":"content","text":"---\npermalink: /2023-05-12-CSS 연결 선택자, 속성 선택자, 가상 클래스/\ntitle: \"[CSS] CSS 연결 선택자, 속성 선택자, 가상 클래스\"\ndate: 2023-05-12 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CSS 연결 선택자, 속성 선택자, 가상 클래스\"\ncategories:\n- Front-end\ntags:\n- TIL\n- CSS\n- HTML\n---\n<br><br>\n\n\n## ✅ CSS 연결 선택자\n연결 선택자는 둘 이상의 선택자를 연결해서 스타일이 적용될 요소가 어느 부분인지 지정합니다. 선택자를 둘 이상 조합하므로, '조합 선택자'라고도 하고, '콤비네이션 선택자' 라고도 부릅니다.\n\n<br><br>\n\n### 📌 하위 선택자\n\n> **기본형 : 상위요소 하위요소**  \n```css\nsection p { ... }\t/\tdiv p { ... } 등\n```\n\n부모 요소에 포함된 하위 요소를 모두 선택하여 스타일을 적용합니다. **공백**으로 상위요소와 하위요소를 구분합니다. \n\n{% include codepen.html hash=\"eYPLZjx\" title=\"css\" %}\n\n\n<br><br>\n\n\n### 📌 자식 선택자\n\n> **기본형 : 부모요소 > 자식요소**  \n```css\nsection > p { ... }\t  /   div > p { ... } 등\n```\n하위 선택자와 다르게 자식요소에만 스타일을 적용하는 선택자입니다. 두 요소 사이에 '>' 기호를 표시해 부모요소와 자식요소를 구분합니다.\n\n{% include codepen.html hash=\"mdzGPQW\" title=\"css\" %}\n\n<br><br>\n\n\n### 📌 인접 형제 선택자\n\n> **기본형 : 요소1 + 요소2**  \n\n형제 요소 중에서 첫 번째 동생 요소만 선택하는 선택자입니다.  인접 형제 선택자를 정의할 때는 요소1과 요소2 사이에 '+'기호를 표시합니다.\n\n```css\nh1 + p { color : blue; } // h1의 형제인 p요소중 첫번째 p\n```\n\n{% include codepen.html hash=\"oNaPxRx\" title=\"css\" %}\n\n<br><br>\n\n### 📌 형제 선택자\n\n> **기본형 : 요소1 ~ 요소2**  \n\n형제 요소의 스타일을 정의하는 선택자입니다. 요소1과 형제인 요소2를 전부 선택하여 스타일을 정의하고, 요소1과 요소2 사이에 '~'기호를 표시합니다.\n\n```css\nh1 ~ p { color : blue; }\n```\n\n{% include codepen.html hash=\"qBJMNdZ\" title=\"css\" %}\n\n<br><br><br><br>\n\n## ✅ CSS 속성 선택자\nHTML태그를 작성 할 때 여러 속성을 함께 사용하는데 속성값에 따라 원하는 요소를 선택할 수도 있습니다. 이를 [속성] 선택자 라고하는데, 대괄호 '[ ]' 사이에 원하는 속성을 입력해서 사용합니다. \n\n### 📌 [속성] 선택자\n\n> **기본형 : 요소[속성]**  \n\n```css\na[href] { ... } // a요소 중에서 href 속성이 있는 요소 선택\n```\n\n{% include codepen.html hash=\"gOBdMro\" title=\"css\" %}\n\n<br><br>\n\n### 📌 [속성=속성값] 선택자\n\n> **기본형 : 요소[속성 = 속성값]**  \n\n주어진 속성과 속성값이 일치하는 요소를 찾아 스타일을 지정할 때 사용합니다.  대괄호안에 속성과 속성값을 넣고 그 사이에 '=' 기호를 표시합니다.\n\n```css\na[target=_black] { ... } // <a target = \"_blank\"> 인 요소\n```\n{% include codepen.html hash=\"PoydGYV\" title=\"css\" %}\n\n<br><br><br><br>\n \n\n## ✅ 가상 클래스 선택자\n사용자의 동작에 반응하는 선택자!\n```css\n:link - 방문하지 않은 링크에 스타일 적용\n:visited - 방문한 링크에 스타일 적용\n:active - 웹 요소를 활성화 했을때의 스타일 적용\n:hover - 웹 요소에 마우스 커서를 올려놓을 때의 스타일 적용\n:focus - 웹 요소에 초점이 맞추어졌을 때의 스타일 적용\n```\n\n#### 구조 가상 클래스\n`nth-child(n)` : 부모 안에있는 모든 요소중에서 n번재 자식요소를 선택\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1312876364}},"syncHistory":{"main":[-1312876364,-2105501131,-1312876364]},"v":1,"hash":1710891070084,"tx":11012},"B30uFDwmYERr6MWH/syncedContent":{"id":"B30uFDwmYERr6MWH/syncedContent","type":"syncedContent","historyData":{"-2016400467":{"id":"B30uFDwmYERr6MWH/content","type":"content","text":"---\npermalink: /2023-05-18-브라우저 렌더링 과정/\ntitle: \"[JavaScript] 브라우저 렌더링 과정\"\ndate: 2023-05-18 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"브라우저 렌더링 과정\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n## ✅ 브라우저 렌더링 과정\n\n\n### 📌 렌더링이란?\n\nJavaScript를 공부하면서 `<script>`의 삽입 위치에 따라 코드가 제대로 작동 안할 수도 있다는 사실을 알았는데 이게 브라우저 렌더링 과정과 깊은 연관이 있다고 하여 이에 대해 확실하게 알아두고 넘어갈 필요성이 느껴져 관련 포스팅을 한다.\n\n브라우저는 서버와의 통신 이후, 데이터를 사용자에게 보여주기 위해 **렌더링** 이라는 과정을 수행한다.\n\n웹 페이지는 사용자에게 보여질 때 미리 만들어져 있는 페이지를 가져오는게 아니라 실시간으로 그려지는 것에 가깝다. **실시간으로 웹사이트가 그려지는 과정, 이 과정을 웹 브라우저의 렌더링 이라고 말한다.**\n\n대부분의 웹 브라우저는 두개의 엔진이 들어가 있다. 하나는 **렌더링 엔진**으로 사용자가 볼 화면을 그려내는 역할을 수행하고 다른 하나는 **자바스크립트 엔진**으로 자바스크립트 코드를 읽어내 기능을 수행하는 역할을 한다.\n\n렌더링 엔진은 HTML, CSS, JavaScript 세가지 언어를 가지고 웹사이트의 소스코드를 읽어, 실제 어떤 요소들이 어떤 크기, 너비로 배치되는지, 텍스트의 크기는 어떠한지, 색상은 어때야 하는지 등을 계산해 실시간으로 그려준다.\n\n이러한 렌더링 엔진이 수행하는 일련의 과정을 **렌더링**이라고 한다.\n\n<br><br>\n\n### 📌 브라우저 렌더링 동작 과정\n\n그렇다면 렌더링은 어떻게 동작하는지 알아보도록 하겠다.\n\n1. **HTML 파일과 CSS 파일을 파싱해서 각각 Tree를 만든다 ( Parsing )**\n\n브라우저가 페이지를 렌더링하려면 가장 먼저 HTML 파일을 해석해야 한다. Parsing 단계는 HTML 파일을 해석하여 DOM ( Document Object Model ) Tree를 구성하는 단계이다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/dom.png?raw=true\">\n</p>\n\n<br>\n\n또한 HTML에 CSS에 포함되어 있다면 CSSOM(CSS Object Model) Tree도 함께 구성한다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/cssom.png?raw=true\">\n</p>\n<br><br>\n\n\n2. **두 Tree를 결합하여 Rendering Tree를 만든다 ( Style )**\nParsing 단계에서 생성된 DOM Tree와 CSSOM Tree를 매칭시켜 Rendering Tree를 구성한다. Rendering Tree는 실제로 화면에 그려질 Tree이다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/rendering.png?raw=true\">\n</p>\n\n<br><br>\n\n3. **Rendering Tree에서 각 노드의 위치와 크기를 계산한다 ( Layout )**\nRendering Tree의 루트노드부터 모든 노드를 순회하며 노드의 정확한 크기와 위치를 계산하고 Rendering Tree에 반영한다. 이를 통해 각 요소의 정확한 위치를 구체화 한다.\n\n<br><br>\n\n4. **계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다 ( Paint)**\n\n<br><br>\n\n5. **레이어를 합성하여 실제 화면에 나타낸다 ( Composite )**\n\n\n<br><br><Br><Br>\n\n## ✅ 마무리\n브라우저 렌더링 과정을 살펴봄으로써 웹 페이지가 어떻게 생성되는지 알 수 있었다. 이런 과정을 하나하나 알아가며 동작 원리를 파악하는게 웹 개발을 하는데 있어 도움이 많이 된다고 생각한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-2016400467}},"syncHistory":{"main":[-2016400467,-2016400467,null]},"v":1,"hash":1710891079814,"tx":11018},"5xTVal0mYmIYU6Hk/contentState":{"id":"5xTVal0mYmIYU6Hk/contentState","type":"contentState","selectionStart":63,"selectionEnd":63,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710891096667,"tx":11028},"B30uFDwmYERr6MWH/contentState":{"id":"B30uFDwmYERr6MWH/contentState","type":"contentState","selectionStart":283,"selectionEnd":283,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710891104755,"tx":11032},"jfStBciYCU0re8LF/syncedContent":{"id":"jfStBciYCU0re8LF/syncedContent","type":"syncedContent","historyData":{"1354164374":{"id":"jfStBciYCU0re8LF/content","type":"content","text":"---\npermalink: /2023-06-07-React 기본 총정리/\ntitle: \"[React] React 기본 총정리!\"\ndate: 2023-06-08 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"React 기본 총정리\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- React\n---\n<br><br>\n\n이번 포스팅은 React를 처음 공부할때 필요한 모든 지식을 총 집합해서 정리해보려고 한다. React란 무엇이고, 왜 사용하는지 부터 기초문법까지 다뤄보도록 하겠다. 세세한 문법까지 모두 다룰수는 없겠지만 꼭 기억해야하는 문법을 통해 간단한 토이프로젝트 까지 진행해볼 수 있을 정도의 개념을 정리해보자..! 작성이후에도 추가적으로 필요한 내용은 추가하면서 이 포스팅만 보면 React 개발을 어느정도 할 수 있을만큼의 도움이 되는 글을 작성하는것을 목표로 하겠다..!\n\n<br><br><br><Br><Br>\n\n\n## ✅ React란?\n\n리액트는 **사용자 인터페이스 (UI)**를 구축하기 위한 선언적이고 효율적이며 유연한 **자바스크립트 라이브러리**이다. `Augular`, `Vue`와 달리 자바스크립트 문법을 그대로 사용하기 때문에 자바스크립트를 알고있다면 학습하는데 어려움이 많이 없다.\n\n리액트를 사용하지 않아도, HTML/CSS 그리고 JavaScript를 사용해서 웹페이지를 충분히 만들 수 있지만 우리는 리액트를 사용한다. 도대체 왜 리액트를 사용하는 걸까 ?\n\n<br><Br><Br>\n\n### 📌 React를 사용하는 이유\n1. **데이터 바인딩이 쉽게 가능하다!** \n\n**데이터 바인딩**이란 화면상에 보여지는 데이터(View)와 브라우저 메모리에 있는 데이터(Model)을 일치시키는 것을 말한다. 좀 쉽게 설명하면 데이터를 HTML 요소에 꽂아넣어주는거라고 볼 수 있다.\n\n일반적으로 JS를 사용하면 `document.getElementById(\"변수명\").innerHTML = \"수정\"` 이런식으로 바인딩해서 HTML내용을 바꿔주곤 한다. 근데 이런 방식은 코드가 길기때문에 보기에도 불편하고 수정도 불편하다. \n\n그런데 리액트에서는 이런 데이터 바인딩을 매우 쉽게 할 수 있다. 변수에 데이터를 담아주고 `{ }` 안에 넣어 사용하면 끝이다!\n\n```js\nfunction App(){\n  var data = \"안녕하세요\";\n  return (\n\t<>\n\t  <p> { data } </p>\t// 안녕하세요\n\t</>\n  )\n}\n```\n<br><br><br>\n\n2. **컴포넌트 단위 개발**\n\n리액트는 컴포넌트 단위로 개발을 할 수 있다. 기존의 웹 프레임워크는 MVC 방식으로 분리해서 관리했기 때문에 각 요소의 의존성이 높아 재사용이 어렵다는 단점이 있었는데, 컴포넌트는 MVC의 뷰를 독립적으로 구성해서 재사용이 가능하게 하고 이를 통해 새로운 컴포넌트를 쉽게 만들 수 있게 한다.\n\n**리액트는 사용자 정의 태그를 만드는 기술이다** 라고 표현할 수 있을 정도로 컴포넌트의 사용이 리액트를 사용하는 가장 큰 이유라고 볼 수 있다. 여러 태그들을 하나의 컴포넌트로 만들어 독립된 부품으로 만들 수 있고, 더 적은 복잡도로 소프트웨어를 만들수 있다. \n<br><br><br>\n\n3. **JSX를 지원한다!**\n\nJSX는 JavaScript + XML 로 구성된 자바스크립트 확장 구문인데, JS에서 HTML을 작성하듯 코드를 작성할 수 있는 큰 장점이 있다.\n```js\nconst hello = () => { \n  return ( \n\t<div>\n\t\t<h1>안녕하세요.</h1>\n\t</div>\n  ); \n};\n```\n위의 코드처럼 작성하는것이 JSX이고 약간의 규칙이 존재한다.\n- 컴포넌트에 여러 요소가 있을때 반드시 부모 요소 하나가 감싸는 형태여야 한다.\n- 자바스크립트의 값을 JSX안에서 랜더링 할 수 있다. `{ 변수명 }` 의 형태로 사용가능하다.\n- if문을 사용할 수 없고 조건부 연산자를 사용한다.\n\n<br>\n\n```js\nfunction  App()  {\n\tconst  name  =  '리액트';  \n\t\treturn  (  \n\t\t\t<div>  { \n\t\t\t\t\tname  ===  '리액트'?  \n\t\t\t\t\t(<h1>리액트</h1>) : (<h2>리액트가 아님</h2>)\n\t\t\t\t\t}  \n\t\t\t</div>\n\t);  \n}\n``` \n- 기존 CSS 스타일 지정할때 background-color와 같이 `-` 문자가 포함된 이름을 `-`를 없애고 카멜 표기법으로 작성해야 한다! ex ) background-color -> backgroundColor\n-  기존 클래스명을 선언할때 `class=\"title\"`처럼 선언하던것을 `className=\"title\"` 의 형식으로 선언해야 한다.\n- 태그 사용시 반드시 닫아주는 태그를 사용해야만 한다!\n- JSX에 style속성을 넣으려면 무조건 `style= { 스타일 }` 처럼 중괄호 사용해야한다. 그리고 스타일은 무조건 object 자료형으로 만든 스타일을 사용해야 한다. ` <div style = { { color : 'blue' } } > 개발 블로그 </div>`\n\n<br><br><br><br><br>\n\n## ✅ React 개발 환경 설정\n\n### 📌 사전 개발 환경\n- node.js 설치\n- IDE - VS Code ( 쓰고싶은거 쓰면됨 )\n\n<br><br><br>\n \n### 📌 프로젝트 생성 및 실행\n프로젝트를 진행 할 폴더를 생성하고 VS Code 폴더열기를 통해 폴더에 접근한뒤 해당 폴더 위치로 터미널을 켜줍니다.\n\n이후 아래 명령어를 터미널에 입력해줍니다.\n```react\nnpx create-react-app [디렉토리명]\ncd [디렉토리명]\nnpm start\n\n==========================================================================\n// 예시\nnpx create-react-app basic-app\t// basic-app이라는 폴더에 리액트 환경 설치\ncd basic-app\t\t\t// 설치후에 터미널 경로를 basic-app폴더로 이동\nnpm start\t\t\t\t// 리액트 실행!\n```\n\n이렇게 하면 프로젝트가 실행된다! 결과창은 보통 자동으로 웹브라우저로 나타나고 localhost:3000으로 접속하면 볼 수 있다.\n<Br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react1.png?raw=true\">\n</p>\n\n<br><Br><br><Br><Br>\n\n## ✅ React 프로젝트 구조 \n  \n터미널 명령어 `create-react-app`을 통해 생성한 리액트 프로젝트의 구조는 아래와 같다. \n```\t\t\t\t\t\n  basic-app\t\t\t\t\t\n\t├─ node_modules\n\t├─ package-lock.json\n\t├─ package.json\n\t├─ public\n\t│ \t├─ favicon.ico\n\t│ \t├─ index.html\n\t│ \t├─ logo192.png\n\t│ \t├─ logo512.png\n\t│ \t├─ manifest.json\n\t│ \t└─ robots.txt\n\t├─ README.md\n\t└─ src\n\t\t├─ App.css\n\t\t├─ App.js\n\t\t├─ App.test.js\n\t\t├─ index.css\n\t\t├─ index.js\n\t\t├─ logo.svg\n\t\t├─ reportWebVitals.js\n\t\t└─ setupTests.js\n\n```\n\n- node_modules : 현재 프로젝트에 포함된 라이브러리들이 설치되어 있는 폴더\n- package.json : 프로젝트 이름, 버전 등에 대한 정보와 라이브러리 목록이 포함되어 있다.\n- public : 정적 파일이 모여 있는 폴더로 변할 일이 없는 이미지를 주로 넣는다\n- src : 리액트 내부에서 작성하는 거의 모든 파일들이 들어있는 폴더이다.\n\t- App.js : 메인페이지라고 보면된다.\n\t- App.css : App.js에 대한 css파일이다.\n\t- index.js : App.js를 실행해주는 JS파일이다.\n\n<BR>\n이정도로만 알고있으면 문제없이 리액트를 다룰 수 있을거라고 생각한다. 각 폴더, 파일마다 더 세세하게 들어갈 수 있지만, 프론트엔드 개발자를 희망하는 사람이 아니라면 이정도만 알고 가도 리액트 개발하는데 큰 문제는 없어 보인다.\n\n<BR><bR><bR><Br><Br>\n\n## ✅ 컴포넌트란 ?\n\n컴포넌트의 사용은 리액트의 본질이라고 표현 할 수 있을 정도로 중요하다. 리액트는 화면에서 UI 요소를 구분할 때 '컴포넌트'라는 단위를 사용하는데, 쉽게 말하면 리액트에서 앱을 이루는 가장 작은 조각이라고 할 수 있고, 레고 블록으로 집을 쌓게 된 경우 하나의 블록이 '컴포넌트'라고 할 수 있다. 컴포넌트는 새로운 컴포넌트를 생성할 수 도 있고, MVC 의 뷰를 독립적으로 구성하여 재사용할 수도 있다.\n\n<br><br>\n\n🚩 **[예제 1] 일반적인 컴포넌트 사용법**\n\n컴포넌트를 모아두기위한 폴더 `component`를 생성하고 컴포넌트 JS를 생성한다. \n\n`파일경로 : src/component/Component1.js`\n```js\nexport default function Component1(){\n\treturn (\n\t\t<div> 컴포넌트 1 출력 </div>\n\t)\n}\n```\n<br>\n이제 컴포넌트로 만들어준 `Component1.js`를 `App.js`에서 사용해보자!\n<br><br>\n\n\n`파일경로 : src/App.js`\n```js\nimport './App.css';\nimport Component1 from './component/Component1';\t// 컴포넌트를 import해준다\n\nfunction App() {\n  return (\n    <div className=\"App\">\n        <Component1/> \t\t\t// 컴포넌트 1 출력\n    </div>\n  );\n}\nexport default App;\n```\n\n컴포넌트를 다른 JS파일에서 사용하기 위해선 해당 컴포넌트를 import 해줘야만 한다.\n`import 컴포넌트명 from 컴포넌트위치;` 형태로 import 할 수 있다. 이때 작성한 `컴포넌트명`을 변수명처럼 사용하면 된다. 위의 코드에서는 `컴포넌트명`을 `Component1` 로 지정해줬으므로 `<Component1/>` 이라고 작성하면 해당 컴포넌트를 사용할 수 있다.\n\n<br><br>\n\n보통 컴포넌트 폴더를 만들고 그안에 컴포넌트 JS파일을 만들어서 컴포넌트별로 관리해 import해서 사용하지만, **하나의 JS파일에서 코드를 정리하기 위해 컴포넌트를 사용할 수도 있다**.\n\n```js\nfunction Header() {\n  return (\n\t<header>\n\t\t<h1> 리액트 재밌다 </h1>\n\t</header>\n  }\n}\n\n\nfunction App(){\n  return (\n\t<Header/>\n\t<Header></Header>\t\t// Header를 컴포넌트로 사용함\n\t<Header></Header>\n  )\n}\n```\n\n<br>\n위의 코드는 하나의 파일내에서 컴포넌트를 사용한 예제이다. \n\n<br><Br><Br>\n\n🚩 **[예제 2] 컴포넌트 안에 컴포넌트 사용하기**\n\n컴포넌트 내에서도 다른 컴포넌트를 불러와 사용할 수 있다. 코드로 보자.\n\n`파일경로 : src/component/SubComponent.js`\n\n```js\nexport default function SubComponent(){\n    return (\n        <div> Welcome! This is SubComponent! </div>\n    )\n}\n```\n\n<br>\n\n`파일경로 : src/component/Component1.js`\n\n```js\nimport SubComponent from \"./SubComponent\"\n\nexport default function Component1(){\n    return (\n        <div> \n            <h1>Hello</h1> \t\t\t// Hello\n             <SubComponent/> \t\t// Welcome! This is SubComponent!\n        </div>\n    )\n}\n```\n\n<br><br><br>\n🚩 **컴포넌트 사용시 주의사항**\n- 컴포넌트 이름은 반드시 **대문자**로 시작해야하고 **CamelCase**를 사용하는게 좋다.\n- 컴포넌트에서 JSX 리턴시에는 반드시 **하나의 태그**로 전체를 감싸서 리턴해야 한다. 태그로 감싸지 않거나, 두개이상의 태그를 사용할 수 없다!\n\t- ex ) `return ( <div> 리턴값 </div> )`\n\t-  ex ) `return ( <> 리턴값 </>`\n\t-  ex ) `return ( <div> </div> <div> </div> )` 이런 경우는 안됨!\n- 리액트에서 **html태그**는 반드시 **소문자**로!\n\n<br><Br><br>\n\n\n\n\n<br><br><br><br><Br>\n\n\n## ✅ CSS 적용\n\n리액트에서 CSS를 적용하는 방법은 크게 3가지이다. 첫번째는 **인라인 스타일**, 두번째는 **외부 CSS파일 import**, 마지막으로는 **CSS 모듈** 사용 이다. 각각의 경우를 예제를 통해 알아보도록 하겠다.\n\n<br><br>\n### 📌 인라인 스타일 CSS\n일반적으로 인라인 스타일 CSS 적용은 잘 사용하지 않고 권장하지 않는다. 코드 가독성이 떨어지고 관리하기도 불편하기 때문이다. 그럼에도 언급하는 이유는 JSX에서 CSS는 반드시 **객체형태**로 작성해야 하는 차이점이 있기 때문이다. 예제를 통해 알아보자. <br>\n\n\n```js\nimport Message from \"./Message\"\n\nexport default function Hello(){\n    return (\n        <div> \n            <h1 style = {\n                 {  color : '#f00',                  //객체이기 때문에 ; 아니고 , \n                    borderRight : '2px solid #000',  // - 쓰지 말고 카멜케이스\n                    marginButtom : \"30px\",\n                    opacity : 0.5                    // 숫자는 그대로\n                 }\n            } \n\t\t\t<h1> Hello</h1> \n            <Message/>\t\t\t// Welcome! 카카오 클라우드 컴퓨팅\n            <Message/>\t\t\t// Welcome! 카카오 클라우드 컴퓨팅\n            <Message/>\t\t\t// Welcome! 카카오 클라우드 컴퓨팅\n        </div>\n    )\n}\n```\nCSS스타일을 보면 중괄호가 두개인것을 볼 수 있다. 첫번째 중괄호는 데이터 바인딩을 위한 중괄호이고, 두번째 중괄호는 객체형식선언을 위한 중괄호이다. 그리고 각 스타일 속성은 객체형식이므로 `=`이 아닌 `:`을 사용해 선언한다.\n\n다음과 같이 적용된다.\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react2.png?raw=true\">\n</p>\n\n<br><Br><br>\n\n### 📌 외부 CSS\n기본 리액트 프로젝트의 CSS파일은 두가지가 있다. 첫번째로 `index.css`는 전체 프로젝트에 영향을 미치는 스타일을 작성할 수 있고 , 두번째 `App.css` 에는 App.js 컴포넌트에 한정된 스타일이 작성되어 있다. 그러나 App.js 컴포넌트에만 적용되는건 또 아니기도 하다. 때문에 이후 설명할 CSS 모듈이 필요하다.\n\n <br><Br>\n \n 🚩 **[예제 1]**\n\n`경로 : src/App.css`\n```css\n.csstest { color : red ; }\n```\n<br>\n\n\n`경로 : src/App.js`\n```js\nimport './App.css';\nimport Hello  from './component/Hello';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n       <p className=\"csstest\"> AppCssTest </p>\t// CSS적용\n       <Hello /> \n    </div>\n  );\n}\nexport default App;\n``` \n<br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react3.png?raw=true\">\n</p>\n\n\n<Br><br><br>\n\n🚩 **[예제 2] 외부 CSS import**\n\n`경로 : src/component/Hello.js`\n```js\nimport Message from \"./Message\"\nimport '../App.css'; \n\nexport default function Hello(){\n    return (\n        <div>\n            <h1 className=\"csstest\">Hello</h1>\n            <Message/>\n            <Message/>\n            <Message/>\n        </div>\n    )\n}\n```\n\n앞서 작성한 `App.css`를 import해서 사용하는 방법이다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react4.png?raw=true\">\n</p>\n\n\n<br><Br><br>\n\n🚩 **[예제 3]  CSS 모듈**\n컴포넌트 별로 CSS 스타일을 별도로 관리하고 싶을 때 사용한다. 보통 `컴포넌트이름.module.css`로 사용한다.\n\n`경로 : src/component/Hello.module.css`\n\n<br>\n\n```js\nimport Message from \"./Message\"\nimport styles from \"./Hello.module.css\";\n \n\nexport default function Hello(){\n    return (\n        <div>  \n            <h1 className= {styles.csstest}> Hello</h1>\n            <Message/>\n            <Message/>\n            <Message/>\n        </div>\n    )\n}\n```\n\n<Br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react6.png?raw=true\">\n</p>\n\n<Br><Br><br><Br><Br>\n\n## ✅ Props ( 속성 ) \n\n리액트에서 컴포넌트들을 만들면 컴포넌트는 다양한 HTML태그로 구성되어 있을것이다. 그런데 HTML 태그는 src, width, height 등과 같은 속성들을 가지고 있고 이에 따라 HTML태그의 상태가 다르게 적용된다. 그래서 리액트에서도 이러한 HTML 속성값들을 부여할 수 있는 기술이 존재하는데 바로 `PROP` 이다.\n\n아주 쉬운 예제를 통해 props를 적용하는 방법을 직접 보면서 설명해보도록 하겠다. 먼저 기본 틀을 만들어놓고 설명하도록 하겠다.\n\n```js\nimport  './App.css';\n\nfunction  Header() {\n\treturn (\n\t\t<h1> REACT</h1>\n\t\t)\n\t}\n\n\nfunction  Nav() {\n\treturn (\n\t\t<nav>\n\t\t\t<ol>\n\t\t\t\t<li><a  href=\"/read/2\">css</a></li>\n\t\t\t\t<li><a  href=\"/read/2\">css</a></li>\n\t\t\t\t<li><a  href=\"/read/3\">js</a></li>\n\t\t\t</ol>\n\t\t</nav>\n\t)\n}\n\n \nfunction  Article() {\n\treturn (\n\t\t<article>\n\t\t\t<h2> Welcome </h2>\n\t\t\tHello, WEB\n\t\t</article>\n\t)\n}\n\n\nfunction  App() {\n\treturn (\n\t\t<div>\n\t\t\t<Header></Header>\n\t\t\t<Nav></Nav>\n\t\t\t<Article></Article>\n\t\t</div>\n\t);\n}\n\nexport  default  App;\n```\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react10.png?raw=true\">\n</p>\n\n\n<br><br><Br>\n\n🚩 **[예제 1]  컴포넌트에 props 전달하기**\n```js\nfunction  Header(props) {\t// 함수에 매개변수로 props를 넣어준다\n\treturn (\n\t\t<header>\n\t\t\t<h1>  <a  href=\"/\">{props.title}</a></h1>\t// 중괄호에 속성을 넣어준다\n\t\t</header>\n\t)\n}\n\nfunction  App() {\n\treturn (\n\t\t<div>\n\t\t\t<Header title=\"REACT\"></Header>\t// props로 보내줄 속성을 설정한다\n\t\t\t<Nav></Nav>\n\t\t\t<Article></Article>\n\t\t</div>\n\t);\n}\n```\n\n`<Header>` 함수에 파라미터를 지정하고 이름은 **props** 라고 지정한다. 파라미터 이름은 어떤걸 설정해도 문제가 없지만, 대부분의 코드에서 **props**라고 지정하기때문에 우리도 **props** 라고 설정하도록 하자.\n\n그리고 이 **props**를 가져오려면 return문 안에 중괄호에 넣어준 형태로 가져올 수 있다. `<h1>  <a  href=\"/\">{props.title}</a></h1>` 위의 코드에서는 App.js에서 Header의 title을 지정해줬으므로 `{props.title}`의 형태로 가져왔다.\n\n**props**를 설정하는 순서가 좀 헷갈릴거 같아서 정리해보면,\n1. `컴포넌트`에 매개변수 **props**를 추가해준다. ` function  Header(props) `\n2. 속성값을 사용하려면 return문에 `{props.속성}` 의 형태로 넣어준다. \n`<h1>  <a  href=\"/\">{props.title}</a></h1>`\n4. `App.js`에 해당 태그에 속성을 부여한다.\n`<Header title=\"REACT\"></Header>`\n\n이렇게 하면 처음과 똑같은 결과를 볼 수 있다.\n\n<br><br><br>\n\n🚩 **[예제 2] 하나의 props로 여러개의 태그 만들기**\n\n**props**를 이용하면 하나의 props만으로 내용이 다른 여러개의 태그를 만들 수 있다.\n\n```js\nfunction  Article(props) {\t// 함수에 매개변수로 props를 넣어준다\n  return (\n\t<article>\n\t\t<h2> {props.title} </h2>\t// 중괄호에 속성을 넣어준다\n\t\t{props.body}\n\t</article>\n  )\n}\n\nfunction  App() {\n  return (\n\t<div>\n\t\t<Header title=\"REACT\"></Header>\t// props로 보내줄 속성을 설정한다\n\t\t<Nav></Nav>\n\t\t<Article title=\"Welcome\" body=\"Hello,Web\"></Article>\t// article 태그\n\t\t<Article title=\"Hi\" body=\"Hello,REACT\"></Article>\t// article 태그2\n\t</div>\n  );\n}\n```\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react11.png?raw=true\">\n</p>\n\n결과를 보면 Article태그를 두번 작성한것만으로 하나의 props를 통해 출력된것을 볼 수 있다. 이렇게 props를 활용해서 코드의 재사용을 높일 수 있다!\n\n<br><br><br>\n\n🚩 **[예제 3] props에 객체 담기**\n\nprops에는 객체형태로 변수를 담아서 전달할 수도 있다. \n\n```js\nfunction  Nav(props) {\n  const  listProps = [];\n\n  for(let  i=0;i<props.topics.length;i++){\n\tlet  t = props.topics[i];\n\tlistProps.push(<li  key={t.id}>  {t.title}</li>) // li는 key값 설정 필요\n  }\n  \n  return (\n    <nav>\n\t  <ol>\n\t    {listProps}\n\t  </ol>\n    </nav>\n  )\n}\n\nfunction  App() {\n  return (\n  \n\tconst  topics = [\n\t  {id:1, title:\"html\", body:\"html is ...\"},\n\t  {id:2, title:\"css\", body:\"css is ...\"},\n\t  {id:3, title:\"javascript\", body:\"javascript is ...\"}\n\t]\n\t\n\t<div>\n\t\t<Header title=\"REACT\"></Header>\t// props로 보내줄 속성을 설정한다\n\t\t<Nav topics={topics}></Nav>\n\t\t<Article title=\"Welcome\" body=\"Hello,Web\"></Article>\t// article 태그\n\t\t<Article title=\"Hi\" body=\"Hello,REACT\"></Article>\t// article 태그2\n\t</div>\n  );\n}\n```\n코드가 좀 복잡한데 하나하나 순서대로 설명을 해보면\n1. 기존 Nav는 리스트 형태로 구성되어 있다.\n2. 각각의 list에 대한 title, body를 topics라는 배열에 담는다. 이때 id를 반드시 설정해줘야만 한다! ( key에 대한 설명은 너무 길기때문에 그냥 알아만 두자 )\n3. Nav 컴포넌트에 props로 넘어온 list의 속성을 담아줄 배열을 선언한다.\n4. for문을 사용해 listProps 배열에 list속성을 담아준다.\n5. return문에 listProps를 출력한다.\n\n이런 형태로 props를 활용해 객체를 전달해줄 수도 있다!\n\n\n\n<br><br><br><br><br>\n\n## ✅ 이벤트 처리\n리액트의 이벤트 처리는 HTML 이벤트 처리와 거의 같다. 이벤트 역시 props를 활용해 전달해주는 원리이다. 기본적인 사용방법은 다음과 같다.\n\n- `onClick = { 함수 }`\n- `onClick = () => { 실행할 내용 } }`\n\n<br>\n\n🚩 **[예제 1]  이벤트 핸들러 등록**\n\n```js\nexport default function Message(){\n\n    function onClickHandle(){\n        console.log(\"clicked\");\n        alert(\"clicked\");\n    }\n\n    return (\n        <div> Welcome! 카카오클라우드컴퓨팅 \n            <button onClick={onClickHandle}>Click</button>\n        </div>\n    )\n}\n```\n<br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react7.png?raw=true\">\n</p>\n<Br>\n어렵지 않다. 이벤트를 함수로 선언하고 데이터바인딩해주면 된다.\n\n<br><Br><Br>\n\n🚩 **[예제 2]  이벤트 핸들러 등록, event 객체 활용**\n```js\nexport default function Message(){\n    function onClickHandle(){\n        console.log(\"clicked\");\n        alert(\"clicked\");\n    }\n    function onChangeName(event){\t\t\t// text를 입력하면 console에 출력\n        console.log(event.target.value); \t// \n    }\n    return (\n        <div> \n             Welcome! \n             <input type=\"text\" onChange={onChangeName} /> \n             카카오클라우드컴퓨팅 \n            <button onClick={onClickHandle}>Click</button>\n        </div>\n    )\n}\n```\n\n<Br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react8.png?raw=true\">\n</p>\n\n<Br>\n\n`input`태그에 텍스트가 입력될 때마다 console.log를 찍어주는 이벤트이다. event객체를 활용했다.\n\n<br><Br><br>\n\n🚩 **[예제 3]  익명 함수로 이벤트 핸들러 등록**\n```js\nexport default function Message(){\n    function onClickHandle(){\n        console.log(\"clicked\");\n        alert(\"clicked\");\n    }\n    function onChangeName(event){\n        console.log(event.target.value); \n    }\n    return (\n        <div> \n             Welcome! \n             <input type=\"text\" onChange={onChangeName} /> \n             <input type=\"text\" onChange={(event) => {\n                    console.log(event.target.value);        \n             } } />\n             카카오클라우드컴퓨팅 \n            <button onClick={onClickHandle}>Click</button>\n        </div>\n    )\n}\n```\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react9.png?raw=true\">\n</p>\n\n이벤트를 함수로 따로 작성하지 않고 익명함수 형태로 바로 지정해준 방식이다.\n\n<Br><Br><Br><Br><Br>\n\n## ✅ State\n리액트에서는 State역시 정말 중요한 요소이다. props와 거의 유사하지만 약간의 차이가 있는데 이를 공식문서에는 어떻게 정의했는지 알아보자.\n\n> **props와 state는 일반 자바스크립트 객체다. 두 객체 모두 렌더링 결과물에 영향을 주는 정보를 갖고 있는데 한 가지 중요한 방식에서 차이가 있다. props는 (함수 매개변수처럼) 컴포넌트에 전달되는 반면 state는 (함수 내 선언된 변수처럼) 컴포넌트 안에서 관리한다. React에서 this.props와 this.state는 모두 렌더링된 값을 나타낸다. 다시 말해 현재 화면에 보이는 걸 말한다**\n\n<br>\n또 다른 문서에 따르면 이러하다.\n\n> **state는 컴포넌트의 현재 상황에 대한 정보를 나타내기 위해 리액트에서 쓰는 일반 자바스크립트 객체다.** 함수에 선언된 모든 변수와 마찬가지로 **컴포넌트에서 관리된다.** 차이점은 일반 변수는 함수가 종료될 때 사라지지만 state 변수는 리액트에 의해 보존된다는 것이다. **컴포넌트의 역할은 원시 데이터를 HTML로 바꾸는 것**이기 때문에 이 원시 데이터는 props, state 객체로 구성돼 있다고 생각할 수 있다. props와 state가 render()의 입력 데이터라고 말할 수도 있다. 따라서 **state는 컴포넌트의 동작을 제어하는 일부 속성을 나타낸다.**\n\n위의 정의들을 정리해보면, state는 UI에 나타나는 요소들을 **비동기방식**으로 변환시켜주기 위해 사용하고, 컴포넌트의 동작을 제어하는 일부 속성이다.\n\n이제 state를 사용하는 기본예제를 통해 사용법을 알아보자.\n\n<br><br><br>\n\n🚩 **[예제 1]  이벤트 핸들러 등록, event 객체 활용**\n\n```js\nimport { useState } from \"react\";\n\nexport default function Message(){ \n    const [no, setNo] = useState(3) ;   //배열 형태 [ state속성명,  setter ] \n\n    function changeNum(){\n        setNo(no+1) ;    // setter 호출 하면 자동으로 no값 부분 화면 갱신 \n    }\n    return (\n        <div> \n             Welcome!  \n             <input type=\"text\"  />  \n             카카오 클라우드 컴퓨팅   \n             <span id=\"no\">{no}</span>기 \n             <button onClick={changeNum}> +1 Num </button> \n        </div>\n    )\n}\n```\n\n<Br>\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/react12.png?raw=true\">\n</p>\n\n\n\n1. 먼저 state를 사용하기 위해서는 `import {usestate} from 'react'` 선언해줘야 한다.\n2. `useState(데이터) ` -> 이함수를 실행하고 나면 [a,b] 이런 배열이 하나 생기는데, a에는 데이터가 들어가고, b에는 state를 수정하기 위한 함수가 들어간다.\n3. `let [ a, b ] = useState('데이터')` 이런식으로 보통 사용한다.\n4. b에 들어간 함수는 a를 변경시기키 위한 함수인데 `b('데이터2')` 이렇게 사용하면 a의 데이터가 데이터2로 변경된다.\n5. 위의 코드는 버튼을 누르면 기존 '3기' 라는 텍스트에서 +1씩 상태를 변화시키는 코드이다.\n\n<br>\nstate에 데이터를 저장해서 쓰는 이유는 웹이 App처럼 동작하게 만들고 싶어서 쓰는것이기도 하다.  state가 변경되면 HTML이 자동으로 **재렌더링**이 되는데 그냥 일반 변수에 저장된건 새로고침을 해줘야만 재렌더링이 된다. 그러나 state에 저장된 내용은 비동기로 동작하기 때문에 곧바로 재렌더링되어 새로고침 없이 변할 수 있다. **즉 자주바뀌는, 중요한 데이터는 변수말고 state로 저장해서 사용해야 한다!**\n\n<br><br><br>\n\n\n### 📌 State 데이터 수정시 주의할 점! 굉장히 중요!!!!!\n\nstate는 자주 바뀌는 데이터를 저장해서 UI상에 비동기적 변화를 주기위해 사용할 수 있는데, `setState`를 사용하면 state의 값을 바꿀수 있다고 했다. 그럼 일반적으로 `setState`를 사용해서 state의 값을 바꿔보도록 하자.\n\n```js\nimport { useState } from \"react\" ; \n\nexport default function Hello() {\n   const [user, setUser] = useState({id:1,name:\"kim\"}) ;\n   function test(){\n      user.name=\"lee\"; \n      setUser(user);//user로 하면 화면 갱신 안됨.\n      // user 객체의 주소값이 동일하여 변화가 없는 것으로 인식 \n   }\n   return (\n      <button onClick={test}>{user.name} </button>\n   )\n}\n```\n\nuseState를 사용해 위 코드처럼 값을 변경하려고 하면 값이 갱신이 안될 것이다. 지금 state에 저장된 데이터는 **객체** 형태를 띄는데 자바스크립트에서 객체와 배열의 특징을 알면 왜 값이 갱신이 안되는지 잘 알수 있다.\n\n**JS에서는 객체나 배열을 어떤 변수에 저장하면 변수에는 그 값 자체가 아니라 객체나 배열의 주소값이 저장된다.**\n\n```js\nlet arr = [1,2,3]\n```\n\n위와 같은 배열이 선언됐을때 `arr`에는 `[1,2,3]`이 저장되는것이 아니라 `[1,2,3]`이 참조하고 있는 주소값이 저장된다. 한마디로 `[1,2,3]`의 위치가 저장된 것이다. \n\n이를 배경지식으로 가진채 `useState` 변경함수의 특징까지 고려해야한다. **`useState` 함수는 객체나 배열이 가지고 있는 주소값이 일치하다면 값을 굳이 변경해주지 않는 매커니즘을 가지고 있다.**\n\n그렇다면 위의 코드에서 기존에 `user.name=\"kim\"` 이라고 저장돼있는 상태에서 `user.name=\"lee\"` 라고 코드를 작성했을때, 실제로 `user.name`의 데이터는 `\"kim`\"에서 `\"lee\"`로 변경되지만, `user.name`의 주소값은 변경되지 않고 그대로일 것이다. 그렇다면 `setUser(user)` 입장에서 user의 데이터는 변경됐을지라도 주소값은 여전히 똑같기 때문에 값을 변경해주지 않게된다.\n\n때문에 객체나 배열의 데이터값을 변경하기 위해서는 아예 **새로운 변수를 만들고, 주소값까지 달리한다음, 기존 객체나 배열을 복사한뒤 `useState`의 변경함수를 사용해야 한다.**\n\n```js\nimport { useState } from \"react\" ; \n\nexport default function Hello() {\n   const [user, setUser] = useState({id:1,name:\"kim\"}) ;\n   function test(){\n      // 아래와 같이 수정하면 화면이 갱신됩니다. \n      let NewUser = {...user, name:\"lee\"};  //새로운 객체 생성\n      setUser(NewUser); \n\n   }\n   return (\n      <button onClick={test}>{user.name} </button>\n   )\n}\n```\n\n`...`은 Destructing을 의미하는데 객체나 배열을 쪼개서 개별적인 변수에 할당한다는 의미이다. 이를 통해 기존 객체나 배열이 쪼개져서 각각의 데이터가 하나의 변수를 가지게 되고 이 과정을 거친 후 다시 새로운 변수`(NewUser)` 를 선언하고 담아줌으로써 주소값이 다른 새로운 객체를 만들수 있다. 이런 과정을 Deep Copy를 한다고 표현한다.\n\n\n\n\n```\tjs\nlet [글제목,글제목변경] =  useState(['남자 코트 추천','여자 코트 추천', '남녀공용 코트 추천']); // [state 데이터, state 데이터 변경 함수]\n\nfunction  제목바꾸기(){\n\tvar newArray = 글제목;\t\t\t// 이건 복사가 아니라 값 공유\n\tvar newArray = [...글제목];\t\t// 이게 deep copy\n\t\t\t\t\t\t\t\t\t// ...뜻이 모든 중,대괄호를 없애달라\n\t\t\t\t\t\t\t\t\t// 그러고 [] 를 다시 만들어달라\n\t\t\t\t\t\t\t\t\t// 즉 copy하겠다.\n\tnewArray[0] =  '여자 코트 추천';\n\tnewArray[1] =  '남자 코트 추천';\n\t글제목변경(newArray);\n\t}\n```\n\n<br><br><br><br><br>\n\n여기 까지하면 리액트의 기본에 대해서는 거의 다 다룬것 같다. React가 무엇인지, React를 왜쓰는지, 컴포넌트, CSS, Props, State, 이벤트까지 다뤄봤고 이후 포스팅에서는 React Router DOM에 대해서 알아보도록 하겠다.\n","properties":"\n","discussions":{},"comments":{},"hash":1354164374}},"syncHistory":{"main":[1354164374,1354164374,null]},"v":1,"hash":1710891272888,"tx":11036},"wTK8ucAfkpXnll6C/content":{"id":"wTK8ucAfkpXnll6C/content","type":"content","text":"---\npermalink: /2023-08-15-DAO, DTO, VO, Entity란/\npublished: true\ntitle: \"[스프링] DAO, DTO, VO, Entity란?\"\ndate: 2023-08-15 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"DAO, DTO, VO, Entity란?\"\ncategories:\n- Spring\ntags:\n- Spring\n- Java\n---\n\n<br><br>\n\n## ✅ DAO ( Data Access Object )\n\n- Data Access Object의 약자로, DB 데이터에 접근하기 위한 객체\n- **프로젝트의 Service에 해당하는 부분과 DB를 연결하는 기능 수행**\n- CRUD 작업을 수행하는 클래스. 즉, 데이터에 대한 CRUD를 전담하는 오브젝트\n- SpringBoot에서는 Repository 클래스가 DAO의 역할을 수행한다.\n\n```java\npublic class TestDao {\npublic void add(TestDto dto) throws ClassNotFoundException, SQLException {\n\t\tprivate static final String DRIVER = \"com.mysql.jdbc.Driver\";\n    private static final String URL = \"jdbc:mysql://localhost:3306/dao_Db\";\n    private static final String USER = \"root\";\n    private static final String PASSWORD = \"1234\";   \n\t\t\n\t\tString sql = \"SELECT * FROM vouchers\";\n\n        try {\n            con = DriverManager.getConnection(URL, USER, PASSWORD);\n            stmt = con.createStatement();\n            res = stmt.executeQuery(sql);\n            while (res.next()) {\n                System.out.println(res.getString(\"id\") + \" \");\n                System.out.println(res.getString(\"value\") + \" \");\n            }\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        }\n\n    preparedStatement.setString(1, dto.getName());\n    preparedStatement.setInt(2, dto.getValue());\n    preparedStatement.setString(3, dto.getData());\n    preparedStatement.executeUpdate();\n    preparedStatement.close();\n\n    connection.close();\n\n\t}\n}\n```\n\n\n<br><br><br><br>\n\n## ✅ DTO ( Data Transfer Object )\n\n- Data Transfer Object의 약자로, 계층간(MVC) **데이터 전달**을 위한 객체\n- 비즈니스 로직을 가지지 않고 getter, setter 메소드만 가진다.\n- 주로 View와 Controller 사이에서 활용된다.\n\n```java\npublic class personDTO {\n\tprivate String name;\n\tprivate int age;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n```\n\n\n<br><br><br><br>\n\n## ✅ VO ( Value Object )\n- Value Object의 약자로, 값 자체를 표현하는 객체\n- DTO와 유사하지만, setter 메서드를 가지지 않는다.\n- getter 메서드와 이외의 비즈니스 로직을 포함할 수 있다.\n- setter 메서드는 없고, getter 메서드만 존재하기 때문에 **오로지 읽기만 가능하다!**\n- 객체 간 \"필드값\"이 같다면 해당 객체들은 같은 객체로 여긴다.\n- 때문에 주소값이 달라도 필드값만 같으면 같은 객체로 여긴다.\n- [참고 자료](https://tecoble.techcourse.co.kr/post/2020-06-11-value-object/)\n\n\n<br><br><br><br>\n\n## ✅ Entity\n- **실제 DB와 매핑되는 클래스**\n- Entity를 기준으로 테이블을 형성하거나, 형성한 테이블을 기준으로 Entity를 설정해줘야한다.\n- 한마디로 DB 컬럼과 일치하게끔 변수들을 설정해줘야 한다.\n- Entity를 데이터 전달하는 용도로 사용해선 절대 안된다.\n- JPA를 활용한다면 @Entity 어노테이션과 함께 사용하고, 기본 생성자를 필수로 생성해야 한다.\n- 보통 Builder패턴을 활용해서 생성자를 만드는게 일반적이다.\n\n<br>\n\n- 일반적인 Entity 예제\n\n```java\npublic class Person {\n\tprivate final Long id;\n\tprivate final String name;\n\tprivate final int value;\n\n\tpublic Person(Long id, String name, int value) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.value = value;\n\t}\n}\n```\n\n<br>\n\n- JPA 활용 Entity 예제\n\n```java\n\n@Entity\n@Table(name=\"Aim\")\n@Getter\n@Setter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Aim {\n\t @Id\n    @Column(name=\"instance_id\", updatable = false, nullable = false)\n    private String instanceId;\n\n    @Column(name=\"user_id\", nullable = false)\n    private Integer userId;\n\n    @Column(name=\"aim_state\", nullable = false)\n    private Integer aimState;\n\n    @Column(name=\"server_ip\", nullable = true)\n    private String serverIp;\n\n    @Column(name=\"short_url\", nullable = true)\n    private String shortUrl;\n\n    @Column(name=\"subscribe_state\", nullable = false)\n    private Integer subscribeState;\n\n    @Column(name=\"created_date\" , nullable = false)\n    private LocalDateTime createdDate;\n\n    @Column(name=\"expired_date\", nullable = false)\n    private LocalDateTime expiredDate;\n\n    @Builder\n    public Aim(String instanceId, Integer userId, Integer aimState, String serverIp,\n               String shortUrl, Integer subscribeState,\n               LocalDateTime createdDate, LocalDateTime expiredDate){\n        this.instanceId = instanceId;\n        this.userId = userId;\n        this.aimState = aimState;\n        this.serverIp = serverIp;\n        this.shortUrl = shortUrl;\n        this.subscribeState = subscribeState;\n        this.createdDate = createdDate;\n        this.expiredDate = expiredDate;\n    }\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1817930387,"tx":11044},"wTK8ucAfkpXnll6C/syncedContent":{"id":"wTK8ucAfkpXnll6C/syncedContent","type":"syncedContent","historyData":{"1817930387":{"id":"wTK8ucAfkpXnll6C/content","type":"content","text":"---\npermalink: /2023-08-15-DAO, DTO, VO, Entity란/\npublished: true\ntitle: \"[스프링] DAO, DTO, VO, Entity란?\"\ndate: 2023-08-15 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"DAO, DTO, VO, Entity란?\"\ncategories:\n- Spring\ntags:\n- Spring\n- Java\n---\n\n<br><br>\n\n## ✅ DAO ( Data Access Object )\n\n- Data Access Object의 약자로, DB 데이터에 접근하기 위한 객체\n- **프로젝트의 Service에 해당하는 부분과 DB를 연결하는 기능 수행**\n- CRUD 작업을 수행하는 클래스. 즉, 데이터에 대한 CRUD를 전담하는 오브젝트\n- SpringBoot에서는 Repository 클래스가 DAO의 역할을 수행한다.\n\n```java\npublic class TestDao {\npublic void add(TestDto dto) throws ClassNotFoundException, SQLException {\n\t\tprivate static final String DRIVER = \"com.mysql.jdbc.Driver\";\n    private static final String URL = \"jdbc:mysql://localhost:3306/dao_Db\";\n    private static final String USER = \"root\";\n    private static final String PASSWORD = \"1234\";   \n\t\t\n\t\tString sql = \"SELECT * FROM vouchers\";\n\n        try {\n            con = DriverManager.getConnection(URL, USER, PASSWORD);\n            stmt = con.createStatement();\n            res = stmt.executeQuery(sql);\n            while (res.next()) {\n                System.out.println(res.getString(\"id\") + \" \");\n                System.out.println(res.getString(\"value\") + \" \");\n            }\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        }\n\n    preparedStatement.setString(1, dto.getName());\n    preparedStatement.setInt(2, dto.getValue());\n    preparedStatement.setString(3, dto.getData());\n    preparedStatement.executeUpdate();\n    preparedStatement.close();\n\n    connection.close();\n\n\t}\n}\n```\n\n\n<br><br><br><br>\n\n## ✅ DTO ( Data Transfer Object )\n\n- Data Transfer Object의 약자로, 계층간(MVC) **데이터 전달**을 위한 객체\n- 비즈니스 로직을 가지지 않고 getter, setter 메소드만 가진다.\n- 주로 View와 Controller 사이에서 활용된다.\n\n```java\npublic class personDTO {\n\tprivate String name;\n\tprivate int age;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n```\n\n\n<br><br><br><br>\n\n## ✅ VO ( Value Object )\n- Value Object의 약자로, 값 자체를 표현하는 객체\n- DTO와 유사하지만, setter 메서드를 가지지 않는다.\n- getter 메서드와 이외의 비즈니스 로직을 포함할 수 있다.\n- setter 메서드는 없고, getter 메서드만 존재하기 때문에 **오로지 읽기만 가능하다!**\n- 객체 간 \"필드값\"이 같다면 해당 객체들은 같은 객체로 여긴다.\n- 때문에 주소값이 달라도 필드값만 같으면 같은 객체로 여긴다.\n- [참고 자료](https://tecoble.techcourse.co.kr/post/2020-06-11-value-object/)\n\n\n<br><br><br><br>\n\n## ✅ Entity\n- **실제 DB와 매핑되는 클래스**\n- Entity를 기준으로 테이블을 형성하거나, 형성한 테이블을 기준으로 Entity를 설정해줘야한다.\n- 한마디로 DB 컬럼과 일치하게끔 변수들을 설정해줘야 한다.\n- Entity를 데이터 전달하는 용도로 사용해선 절대 안된다.\n- JPA를 활용한다면 @Entity 어노테이션과 함께 사용하고, 기본 생성자를 필수로 생성해야 한다.\n- 보통 Builder패턴을 활용해서 생성자를 만드는게 일반적이다.\n\n<br>\n\n- 일반적인 Entity 예제\n\n```java\npublic class Person {\n\tprivate final Long id;\n\tprivate final String name;\n\tprivate final int value;\n\n\tpublic Person(Long id, String name, int value) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.value = value;\n\t}\n}\n```\n\n<br>\n\n- JPA 활용 Entity 예제\n\n```java\n\n@Entity\n@Table(name=\"Aim\")\n@Getter\n@Setter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Aim {\n\t @Id\n    @Column(name=\"instance_id\", updatable = false, nullable = false)\n    private String instanceId;\n\n    @Column(name=\"user_id\", nullable = false)\n    private Integer userId;\n\n    @Column(name=\"aim_state\", nullable = false)\n    private Integer aimState;\n\n    @Column(name=\"server_ip\", nullable = true)\n    private String serverIp;\n\n    @Column(name=\"short_url\", nullable = true)\n    private String shortUrl;\n\n    @Column(name=\"subscribe_state\", nullable = false)\n    private Integer subscribeState;\n\n    @Column(name=\"created_date\" , nullable = false)\n    private LocalDateTime createdDate;\n\n    @Column(name=\"expired_date\", nullable = false)\n    private LocalDateTime expiredDate;\n\n    @Builder\n    public Aim(String instanceId, Integer userId, Integer aimState, String serverIp,\n               String shortUrl, Integer subscribeState,\n               LocalDateTime createdDate, LocalDateTime expiredDate){\n        this.instanceId = instanceId;\n        this.userId = userId;\n        this.aimState = aimState;\n        this.serverIp = serverIp;\n        this.shortUrl = shortUrl;\n        this.subscribeState = subscribeState;\n        this.createdDate = createdDate;\n        this.expiredDate = expiredDate;\n    }\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1817930387},"-301805485":{"id":"wTK8ucAfkpXnll6C/content","type":"content","text":"---\npermalink: /2023-08-15-DAO, DTO, VO, Entity란/\npublished: true\ntitle: \"[Spring] DAO, DTO, VO, Entity란?\"\ndate: 2023-08-15 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"DAO, DTO, VO, Entity란?\"\ncategories:\n- Spring\ntags:\n- Spring\n- Java\n---\n\n<br><br>\n\n## ✅ DAO ( Data Access Object )\n\n- Data Access Object의 약자로, DB 데이터에 접근하기 위한 객체\n- **프로젝트의 Service에 해당하는 부분과 DB를 연결하는 기능 수행**\n- CRUD 작업을 수행하는 클래스. 즉, 데이터에 대한 CRUD를 전담하는 오브젝트\n- SpringBoot에서는 Repository 클래스가 DAO의 역할을 수행한다.\n\n```java\npublic class TestDao {\npublic void add(TestDto dto) throws ClassNotFoundException, SQLException {\n\t\tprivate static final String DRIVER = \"com.mysql.jdbc.Driver\";\n    private static final String URL = \"jdbc:mysql://localhost:3306/dao_Db\";\n    private static final String USER = \"root\";\n    private static final String PASSWORD = \"1234\";   \n\t\t\n\t\tString sql = \"SELECT * FROM vouchers\";\n\n        try {\n            con = DriverManager.getConnection(URL, USER, PASSWORD);\n            stmt = con.createStatement();\n            res = stmt.executeQuery(sql);\n            while (res.next()) {\n                System.out.println(res.getString(\"id\") + \" \");\n                System.out.println(res.getString(\"value\") + \" \");\n            }\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        }\n\n    preparedStatement.setString(1, dto.getName());\n    preparedStatement.setInt(2, dto.getValue());\n    preparedStatement.setString(3, dto.getData());\n    preparedStatement.executeUpdate();\n    preparedStatement.close();\n\n    connection.close();\n\n\t}\n}\n```\n\n\n<br><br><br><br>\n\n## ✅ DTO ( Data Transfer Object )\n\n- Data Transfer Object의 약자로, 계층간(MVC) **데이터 전달**을 위한 객체\n- 비즈니스 로직을 가지지 않고 getter, setter 메소드만 가진다.\n- 주로 View와 Controller 사이에서 활용된다.\n\n```java\npublic class personDTO {\n\tprivate String name;\n\tprivate int age;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n```\n\n\n<br><br><br><br>\n\n## ✅ VO ( Value Object )\n- Value Object의 약자로, 값 자체를 표현하는 객체\n- DTO와 유사하지만, setter 메서드를 가지지 않는다.\n- getter 메서드와 이외의 비즈니스 로직을 포함할 수 있다.\n- setter 메서드는 없고, getter 메서드만 존재하기 때문에 **오로지 읽기만 가능하다!**\n- 객체 간 \"필드값\"이 같다면 해당 객체들은 같은 객체로 여긴다.\n- 때문에 주소값이 달라도 필드값만 같으면 같은 객체로 여긴다.\n- [참고 자료](https://tecoble.techcourse.co.kr/post/2020-06-11-value-object/)\n\n\n<br><br><br><br>\n\n## ✅ Entity\n- **실제 DB와 매핑되는 클래스**\n- Entity를 기준으로 테이블을 형성하거나, 형성한 테이블을 기준으로 Entity를 설정해줘야한다.\n- 한마디로 DB 컬럼과 일치하게끔 변수들을 설정해줘야 한다.\n- Entity를 데이터 전달하는 용도로 사용해선 절대 안된다.\n- JPA를 활용한다면 @Entity 어노테이션과 함께 사용하고, 기본 생성자를 필수로 생성해야 한다.\n- 보통 Builder패턴을 활용해서 생성자를 만드는게 일반적이다.\n\n<br>\n\n- 일반적인 Entity 예제\n\n```java\npublic class Person {\n\tprivate final Long id;\n\tprivate final String name;\n\tprivate final int value;\n\n\tpublic Person(Long id, String name, int value) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.value = value;\n\t}\n}\n```\n\n<br>\n\n- JPA 활용 Entity 예제\n\n```java\n\n@Entity\n@Table(name=\"Aim\")\n@Getter\n@Setter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Aim {\n\t @Id\n    @Column(name=\"instance_id\", updatable = false, nullable = false)\n    private String instanceId;\n\n    @Column(name=\"user_id\", nullable = false)\n    private Integer userId;\n\n    @Column(name=\"aim_state\", nullable = false)\n    private Integer aimState;\n\n    @Column(name=\"server_ip\", nullable = true)\n    private String serverIp;\n\n    @Column(name=\"short_url\", nullable = true)\n    private String shortUrl;\n\n    @Column(name=\"subscribe_state\", nullable = false)\n    private Integer subscribeState;\n\n    @Column(name=\"created_date\" , nullable = false)\n    private LocalDateTime createdDate;\n\n    @Column(name=\"expired_date\", nullable = false)\n    private LocalDateTime expiredDate;\n\n    @Builder\n    public Aim(String instanceId, Integer userId, Integer aimState, String serverIp,\n               String shortUrl, Integer subscribeState,\n               LocalDateTime createdDate, LocalDateTime expiredDate){\n        this.instanceId = instanceId;\n        this.userId = userId;\n        this.aimState = aimState;\n        this.serverIp = serverIp;\n        this.shortUrl = shortUrl;\n        this.subscribeState = subscribeState;\n        this.createdDate = createdDate;\n        this.expiredDate = expiredDate;\n    }\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-301805485}},"syncHistory":{"main":[1817930387,-301805485,1817930387]},"v":1,"hash":1710891355408,"tx":11046},"fxktNjN7Qbqln352/content":{"id":"fxktNjN7Qbqln352/content","type":"content","text":"---\npermalink: /2023-09-12-NamedParameterJdbcTemplate 이란/\npublished: true\ntitle: \"[스프링] NamedParameterJdbcTemplate 이란?\"\ndate: 2023-09-12 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"NamedParameterJdbcTemplate 이란?\"\ncategories:\n- Spring\ntags:\n- Spring\n---\n\n<br><br>\n\n\n\n\n\n\n## ✅ NamedParameterJdbcTemplate 이란?\n\n기존에 사용하던 JdbcTemplate 같은 경우는 우리가 데이터를 넣을 부분에 ?를 이용해서 처리를 했는데 이러한 방식은 인자 위치에 따라 값을 넣는 순서가 강제되기 떄문에 가독성을 떨어트리는 문제가 있다. 그래서 이를 보완하기 위해 NamedParameterJdbcTemplate가 나왔다.\n\nNamedParameterJdbcTemplate은 `?`대신 `:변수명`을 사용해서 인자에 대한 값을 넣어주기 때문에 가독성이 높고 순서에 강제되지 않는 이점이 있다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\tString sql = \"select count(*) from t_actor where first_name = :first_name\";\n\tSqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><Br>\n\n**Map**을 사용해서 처리도 가능하다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\tString sql = \"select count(*) from t_actor where first_name = :first_name\";\n\tMap<String, String> namedParameters = Collections.singletonMap(\"first_name\", firstName);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><br>\n\n**객체와 매핑**해서 사용도 가능하다.\n```java\npublic class Actor {\n\tprivate Long id;\n\tprivate String firstName;\n\tprivate String lastName;\n\n\tpublic String getFirstName(){\n\t\treturn this.firstName;\n\t}\n\n\tpublic String getLastName(){\n\t\treturn this.lastName;\n\t}\n\n\tpublic Long getId(){\n\t\treturn this.id;\n\t}\n}\n```\n\n<br>\n\n위와 같은 Actor 객체가 존재한다고 할때 `BeanPropertySqlParameterSource`를 이용하면 아래와 같이 편하게 처리가 가능하다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActors(Actor exampleActor) {\n\t// notice how the named parameters match the properties of the above 'Actor' class\n\tString sql = \"select count(*) from t_actor where first_name = :firstName and last_name = :lastName\";\n\tSqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><br>\n\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-796006271,"tx":11050},"fxktNjN7Qbqln352/syncedContent":{"id":"fxktNjN7Qbqln352/syncedContent","type":"syncedContent","historyData":{"-2113356479":{"id":"fxktNjN7Qbqln352/content","type":"content","text":"---\npermalink: /2023-09-12-NamedParameterJdbcTemplate 이란/\npublished: true\ntitle: \"[Spring] NamedParameterJdbcTemplate 이란?\"\ndate: 2023-09-12 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"NamedParameterJdbcTemplate 이란?\"\ncategories:\n- Spring\ntags:\n- Spring\n---\n\n<br><br>\n\n\n\n\n\n\n## ✅ NamedParameterJdbcTemplate 이란?\n\n기존에 사용하던 JdbcTemplate 같은 경우는 우리가 데이터를 넣을 부분에 ?를 이용해서 처리를 했는데 이러한 방식은 인자 위치에 따라 값을 넣는 순서가 강제되기 떄문에 가독성을 떨어트리는 문제가 있다. 그래서 이를 보완하기 위해 NamedParameterJdbcTemplate가 나왔다.\n\nNamedParameterJdbcTemplate은 `?`대신 `:변수명`을 사용해서 인자에 대한 값을 넣어주기 때문에 가독성이 높고 순서에 강제되지 않는 이점이 있다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\tString sql = \"select count(*) from t_actor where first_name = :first_name\";\n\tSqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><Br>\n\n**Map**을 사용해서 처리도 가능하다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\tString sql = \"select count(*) from t_actor where first_name = :first_name\";\n\tMap<String, String> namedParameters = Collections.singletonMap(\"first_name\", firstName);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><br>\n\n**객체와 매핑**해서 사용도 가능하다.\n```java\npublic class Actor {\n\tprivate Long id;\n\tprivate String firstName;\n\tprivate String lastName;\n\n\tpublic String getFirstName(){\n\t\treturn this.firstName;\n\t}\n\n\tpublic String getLastName(){\n\t\treturn this.lastName;\n\t}\n\n\tpublic Long getId(){\n\t\treturn this.id;\n\t}\n}\n```\n\n<br>\n\n위와 같은 Actor 객체가 존재한다고 할때 `BeanPropertySqlParameterSource`를 이용하면 아래와 같이 편하게 처리가 가능하다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActors(Actor exampleActor) {\n\t// notice how the named parameters match the properties of the above 'Actor' class\n\tString sql = \"select count(*) from t_actor where first_name = :firstName and last_name = :lastName\";\n\tSqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><br>\n\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-2113356479},"-796006271":{"id":"fxktNjN7Qbqln352/content","type":"content","text":"---\npermalink: /2023-09-12-NamedParameterJdbcTemplate 이란/\npublished: true\ntitle: \"[스프링] NamedParameterJdbcTemplate 이란?\"\ndate: 2023-09-12 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"NamedParameterJdbcTemplate 이란?\"\ncategories:\n- Spring\ntags:\n- Spring\n---\n\n<br><br>\n\n\n\n\n\n\n## ✅ NamedParameterJdbcTemplate 이란?\n\n기존에 사용하던 JdbcTemplate 같은 경우는 우리가 데이터를 넣을 부분에 ?를 이용해서 처리를 했는데 이러한 방식은 인자 위치에 따라 값을 넣는 순서가 강제되기 떄문에 가독성을 떨어트리는 문제가 있다. 그래서 이를 보완하기 위해 NamedParameterJdbcTemplate가 나왔다.\n\nNamedParameterJdbcTemplate은 `?`대신 `:변수명`을 사용해서 인자에 대한 값을 넣어주기 때문에 가독성이 높고 순서에 강제되지 않는 이점이 있다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\tString sql = \"select count(*) from t_actor where first_name = :first_name\";\n\tSqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><Br>\n\n**Map**을 사용해서 처리도 가능하다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\tString sql = \"select count(*) from t_actor where first_name = :first_name\";\n\tMap<String, String> namedParameters = Collections.singletonMap(\"first_name\", firstName);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><br>\n\n**객체와 매핑**해서 사용도 가능하다.\n```java\npublic class Actor {\n\tprivate Long id;\n\tprivate String firstName;\n\tprivate String lastName;\n\n\tpublic String getFirstName(){\n\t\treturn this.firstName;\n\t}\n\n\tpublic String getLastName(){\n\t\treturn this.lastName;\n\t}\n\n\tpublic Long getId(){\n\t\treturn this.id;\n\t}\n}\n```\n\n<br>\n\n위와 같은 Actor 객체가 존재한다고 할때 `BeanPropertySqlParameterSource`를 이용하면 아래와 같이 편하게 처리가 가능하다.\n\n```java\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n\tthis.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActors(Actor exampleActor) {\n\t// notice how the named parameters match the properties of the above 'Actor' class\n\tString sql = \"select count(*) from t_actor where first_name = :firstName and last_name = :lastName\";\n\tSqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);\n\treturn this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n<br><br><br>\n\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-796006271}},"syncHistory":{"main":[-796006271,-2113356479,-796006271]},"v":1,"hash":1710891359050,"tx":11051},"9MtDBGhyQQWuisRx":{"id":"9MtDBGhyQQWuisRx","type":"file","name":"2022-08-12-객체지향 4대 특징","parentId":"AAphmch3Ge6p9ZRi","hash":-944260305,"tx":11150},"O7ZdI0GnNZ8IGhYW":{"id":"O7ZdI0GnNZ8IGhYW","type":"file","name":"2022-08-12-인터페이스","parentId":"AAphmch3Ge6p9ZRi","hash":1167918583,"tx":11151},"nZtkP309cM7hcqO2":{"id":"nZtkP309cM7hcqO2","type":"file","name":"2022-08-12-추상클래스","parentId":"AAphmch3Ge6p9ZRi","hash":1926168026,"tx":11152},"QO3PlLKwWnIiwVqK":{"id":"QO3PlLKwWnIiwVqK","type":"file","name":"2022-08-16-인터페이스vs추상클래스","parentId":"AAphmch3Ge6p9ZRi","hash":-419803291,"tx":11153},"hsMOxKWCChERUD8N":{"id":"hsMOxKWCChERUD8N","type":"file","name":"2022-09-01-익명 클래스","parentId":"AAphmch3Ge6p9ZRi","hash":1830740116,"tx":11154},"w6ADipsYQPt3OgNW":{"id":"w6ADipsYQPt3OgNW","type":"file","name":"2023-06-16-Static","parentId":"AAphmch3Ge6p9ZRi","hash":1538004554,"tx":11155},"omFvrSXYtukeVixH":{"id":"omFvrSXYtukeVixH","type":"file","name":"2023-06-16-예외처리 (try,catch, finally, throws)","parentId":"AAphmch3Ge6p9ZRi","hash":-1270418555,"tx":11156},"9MtDBGhyQQWuisRx/content":{"id":"9MtDBGhyQQWuisRx/content","type":"content","text":"---\npermalink: /2022-08-12-객체지향 4대 특징/\npublished : true\ntitle: \"[JAVA] 객체지향 4대 특징 \"\ndate: 2022-08-12 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n\n이번 포스팅은 **객체지향 한방에 정리하기**이다. 학교다니면서도 공부를 했고 평소에도 면접준비하면서 공부를 했지만 여전히 헷갈리고 모르는 개념이 있기 때문에 내가 모르는 부분을 중심으로 객체지향을 쭉 정리해보려고 한다.\n\n23.06.13 필요한 내용을 좀더 추가했다!\n\n\n<br><br><br><br>\n\n## ✅  객체지향 프로그래밍이란?\n객체지향 프로그래밍(Object-Oriented Programming)이란 컴퓨터 프로그램을 어떤 데이터를 입력받아 순서대로 처리하고 결과를 도출하는 명령어들의 목록으로 보는 시각에서 벗어나 **여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임을 의미한다.**\n\n<br><br><br><br>\n\n## ✅  객체지향 프로그래밍의 장점\n객체 지향적 설계는 많은 이점이 있는데, 가장 큰 장점중 하나는 **프로그램을 보다 유연하고 변경이 용이하게 만들수 있다는 점이다.** 마치 컴퓨터 부품을 갈아 끼울 때, 해당 부품만 교체하고 나머지 부품은 건드리지 않아도 되는 것처럼 소프트웨어 설계시 객체지향적 원리를 잘 적용해두면 각각의 부품들이 **독립적인 역할**을 지니기 때문에 **코드의 변경을 최소화하고 유지보수하는데 유리하다.**\n\n**코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현 할 수 있다.**\n\n**접근제어자와 메서드**를 이용해 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다. 이를 통해 **신뢰성이 높은 프로그래밍을 가능하게 한다.**\n\n간단하게 정리하면 **\"코드의 재사용성이 높고 유지보수가 용이하며, 중복된 코드의 제거가 가능하다\"** 이러한 장점은 객체지향의 4대 특징에서 비롯되는데 그 특징들에 대해 알아보자.\n\n<br><br><br><br>\n\n## ✅ 객체지향 4대 특징\n\n### 📌 추상화\n\n비슷한 역할을 하는 attribute나 method를 묶어서 하나의 모델로 만들어 내는 것. 한마디로 **공통성과 본질을 모아 추출하는 모델링**을 의미한다. 다형성, 상속 모두 추상화에 속한다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/객체1.png?raw=true\">\n</p>\n<br>\n위의 예시를 보면 **자동차와 오토바이는 모두 이동수단**이고, 이동수단은 **출발, 전진과 후진을 할 수 있다는 공통점**을 가진다. 이를 객체지향적 사고를 통해 표현하면 자동차와 오토바이라는 **하위클래스들의 공통적인 메소드를 추출하여 이동수단이라는 상위클래스에 정의**한 것이다. \n\n이를 코드로 표현하면 다음과 같다. 참고로 자바에서 추상화를 구현할 수 있는 문법 요소로는 **추상클래스**와 **인터페이스**가 있는데, 이번 예제에서는 인터페이스를 사용해보겠다.\n\n<br><br>\n\n```java\npublic interface Vehicle {\n\tpublic abstract void start();    // 추상메소드\n\tvoid moveForward();              // public abstract 키워드 생략 가능\n\tvoid moveBackward();\n}\n```\n\n가장 먼저 자동차와 오토바이의 공통적인 기능인 출발, 전진, 후진 기능을 추출해서 이동수단 인터페이스에 정의한다. \n\n<br><br>\n\n```java\npublic class Car implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"자동차 전진\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"자동차 후진\");\n\t}\n}\n```\n\n```java\npublic class MotorBike implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"오토바이 전진\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"오토바이 후진\");\n\t}\n}\n```\n\n위의 코드를 보면 인터페이스 Vehicle에서 선언한 `moveForward()`와 `moveBackward()` 를 각각의 클래스의 맥락에 맞게 구현한 것을 볼 수 있다. 자동차와 오토바이 모두 전진,후진의 기능을 공통적으로 가지기때문에 이동수단의 메소드를 가져와 사용하지만, 자동차 클래스는 자동차를 전진시켜야하고 오토바이 클래스는 오토바이를 전진시켜야 하기때문에 각 클래스마다 필요한 기능으로 달리 구현했다.\n\n이런 일련의 과정을 **역할과 구현의 분리**라고 표현하고, 객체지향의 특징인 **추상화** 이다.\n\n<br><br><br>\n\n### 📌 상속\n\n상위 클래스의 메소드, 변수등의 특징을 하위 클래스가 물려받는 것을 의미한다.\n\n앞서 살펴본 추상화의 연장선에서, 상속은 클래스 간 공유 될 수 있는 속성과 기능들을 상위클래스로 추상화시켜 **상위클래스로부터 확장된 여러개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 한다.**\n\n이를 통해 속성과 기능을 재사용할 수 있고 반복적인 코드를 최소화할 수 있다. JAVA에서는 **extends** 를 사용해 상속을 지원한다. 또한 **하나의 클래스는 한번의 상속만 가능하다.**  (= 하나의 상위클래스만 가질 수 있다)\n<br><br><br>\n\n\n### 📌 다형성\n다형성이란 **어떤 객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 성질을 의미한다.** \n\n비유적으로 표현하면 어떤 중년의 남성이 있다고 했을 때 그 남자의 역할이 아내에게는 남편, 자식에게는 아버지, 부모님에게는 자식, 회사에서는 회사원, 동아리에서는 리더 등 상황과 환경에 따라서 달라지는 것과 비슷하다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/객체2.png?raw=true\">\n</p>\n\n<br>\n객체지향에서의 다형성도 이와 비슷한데, **어떤 객체의 속성이나 기능이 맥락에 따라 다른역할을 수행할 수 있는 객체지향의 특성**을 의미한다. 대표적인 예로는 메서드 **오버라이딩(Override)과 오버로딩(Overload)**이 있다.\n\n<br><br>\n\n\n**Vehicle 인터페이스**\n\n```java\npublic interface Vehicle {\n\tpublic abstract void start();\n\tvoid moveForward();\n\tvoid moveBackward();\n}\n```\n\n<br>\n\n**Car 클래스**\n```java\npublic class Car implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"자동차가 앞으로 전진합니다\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"자동차가 뒤로 후진합니다\");\n\t}\n}\n```\n\n오버라이딩을 사용하면 같은 이름의 `moveForward()`와 `moveBackward()`를 각각의 클래스의 맥락에 맞게 재정의해서 사용할 수 있다. 즉, **같은 이름의 메소드가 상황에 따라 다른 역할을 수행하는 것**이다. 또한 **하나의 클래스 내에서 같은 이름의 메서드를 여러개 중복하여 정의하는 메서드 오버로딩** 역시 같은 맥락이다.\n\n둘다 다형성을 사용하는 개념이고 같은 이름의 다른 함수를 호출한다는 공통점이 있다.\n\n- **오버로딩(Overloading)** : 함수의 이름은 같지만 매개변수의 타입이나 갯수가 다른 메소드를 만드는 것을 의미한다. \n return 타입은 동일하거나 다를 수 있지만, return 타입만 다를 수는 없다. \n\n- **오버라이딩(Overriding)** : 상위클래스나 인터페이스에 있는 메소드를 재정의 하는 것을 의미한다.\n\n<br><br><br>\n\n### **📌 캡슐화(정보은닉)**\n\n특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶은것. 한마디로 **모듈화**를 의미한다.\n정보를 객체 안에 포함시키고, 정보에 대한 직접적인 접근은 허용하지 않으며, **접근제어자**를 통해 정보의 **공개정도**를 조절할 수 있다.\n\n자바의 캡슐화는 **외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출 될 수 있도록 하여 각 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적**이 있다.\n\n이러한 캡슐화는 크게 두가지 방법으로 자바에서 구현될 수 있다. 첫번째로는 **접근제어자**를 활용하는 것이다. 접근제어자는 **클래스나 클래스 멤버들에 사용되어 해당 클래스나 멤버들을 외부에서 접근하지 못하도록 접근을 제한하는 역할**을 한다.\n\n<br>\n\n- **Public : 접근 제한이 전혀 없다**\n\n- **Protected : 상속클래스 및 같은 패키지에서만 사용 가능**\n\n- **Default : 같은 패키지 내에서 사용 가능**\n\n- **Private : 정의된 클래스 내부에서만 사용 가능. Getter,Setter를 이용해 정보 접근 or 수정**\n\n<br>\n\n|접근제어자|같은 클래스| 같은 패키지| 하위클래스 | 전체| \n|--|--|--|--|--|\n|public  |  o |o |o |o |\n|protected  |  o |o |o |x |\n|default  |  o |o |x |x |\n|private  |  o |x |x |x |\n\n\n<br><br><br><br>\n\n**객체지향의 4대 특징은 굉장히 중요하다. 4가지 특징의 의미를 달달 외울게 아니라 그 특징을 실제 코드에 잘 녹여내리는 것이 중요하다. 코드를 짤 때 이 4가지 특징을 잘 이해하고 적용시키면 훨씬 효율적인 코드가 될 수 있음을 명심하자.**\n","properties":"\n","discussions":{},"comments":{},"hash":1042073771,"tx":11218},"O7ZdI0GnNZ8IGhYW/content":{"id":"O7ZdI0GnNZ8IGhYW/content","type":"content","text":"---\npermalink: /2022-08-12-인터페이스/\npublished: true\ntitle: \"[JAVA] 인터페이스\"\ndate: 2022-08-12 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n2023.06.15 내용보완\n<br><br>\n## ✅ 인터페이스란?\n\n자바 개발 뿐만아니라 자바기반 개발을 하면 인터페이스는 굉장히 중요하고 빈번하게 사용된다. 인터페이스란 뭘까?  \n\n\n **동일한  목적  하에  동일한  기능을  보장하게  하기  위함!**\n**자바의 다형성, 추상화를 이용하여 코드 수정을 줄이고 유지보수성을 높인다!**\n\n이렇게 크게 두가지 정도로 볼 수 있다. 좀더 자세하게 알아보자.\n<br><br><br>\n\n자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가질 수 있다.\n\n하지만 클래스를 이용하여 다중 상속을 할 경우  메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은  지원하지 않는다.\n\n하지만 다중 상속의 이점을 버릴 수는 없기에 자바에서는 인터페이스라는 것을  통해 다중 상속을 지원하고 있다.\n\n<br><br><br>\n\n**인터페이스(interface)란** **다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지  담당하는 일종의 추상 클래스를 의미한다.**\n\n<br><br><br>\n\n자바에서 **추상클래스**는 **추상메소드, 생성자, 변수, 심지어 일반 메소드(구현부 포함)** 도 포함 될 수 있다. \n그러나 **인터페이스**에서는 **추상메소드, 상수, 정적 메소드, 디폴트메소드** 를 포함 할 수 있다.\n\n<br><br><br><br>\n\n## ✅ 인터페이스 선언\n인터페이스는 추상클래스와 마찬가지로 자신이 직접 인스턴스를 생성 할 수 없다. **한마디로 다른 클래스에서 객체로 생성 될 수 없다는 뜻이다**. 때문에 다른 클래스에서 인터페이스를 사용하기 위해서는 다음과 같은 문법을 통해 구현한다.\n\n```java\npublic class 클래스이름 implements 인터페이스이름 {...}\n```\n\n<br><br><br><br>\n\n## ✅ 인터페이스 구현\n\n인터페이스에서 구현할 수 있는 **상수, 추상메소드, 디폴트메소드, 정적메소드** 4가지를 활용한 코드를 보자.\n<br>\n\n```java\npublic interface CalResult {\n\n\t// 계산기에서 입력될 수 있는 최대값\n\t// 상수\n\tpublic static final int MAX_INTEGER = 999999999;\n\n\t// 계산 결과 출력\n\t// 추상 메소드\n\t// public abstract는 생략가능하다\n\tpublic abstract void PrintResult(double result);\n\t\n\t// 연산 과정 출력\n\t// 추상 메소드\n\tvoid PrintProcess(StringBuffer sb);\n\t\n\n\t\n\t// 디폴트메소드 : 인터페이스에서 기본적으로 제공해주지만, \n\t// 각자 구현해서 쓸수 있다. (선택적)\n\tdefault void Display(StringBuffer sb, double result){\n\t\tPrintProcess(sb);\n\t\tPrintResult(result);\n\t\tPrintFinish();\n\t}\n\t\n\t// 정적메소드 : 인터페이스에서 제공해주는 것으로 무조건 사용 ( 절대적 )\n\tstatic void PrintFinish(){\n\t\tSystem.out.println(\"계산끝났당오예~!\");\n\t}\n}\n```\n<br>\n\n\n- **상수** : 인터페이스에서 값을 정해줄테니 함부로 바꾸지 말고 제공해주는 값만 참조하라 **(절대적)**\n\n- **추상메소드** : 가이드만 줄테니 추상메소드를 오버라이딩해서 재구현해라 **(강제적)**\n\n- **디폴트메소드** : 인터페이스에서 기본적으로 제공해주지만, 각자 구현해서 쓸수 있다. **(선택적)**\n\n- **정적메소드** : 인터페이스에서 제공해주는 있는 그대로 사용. 즉 오버라이딩 불가 **(절대적)**\n\n<br><br><br>\n\n\n### 📌 상수 \n\n인터페이스에서 선언한 상수는 항상 ```public static final``` 형태로 저장되므로 **다른 클래스에서 변경 할 수 없다**. 위에 (절대적)이라고 써놓은 이유이다. 그러나 자료를 찾아보니 인터페이스에서 상수를 선언하는 것은 **Anti-Pattern, 즉 사용을 지양해야하는 디자인 패턴** 이라는 주장이 많았다. 되도록 사용하지 않는게 좋아보인다.\n\n<br><br>\n\n### 📌추상메소드\n\n추상클래스의 추상메소드와 같다. ```접근제어자 abstract 반환 타입 클래스명 (자료형 변수명); ``` 의 형태로 선언하면 된다. 예를들면 `public abstract void Print(String str)` 이런식으로 선언할 수 있다. 이때 접근제어자와 abstract는 생략 가능하다. \n\n 추상메소드는 구현부는 따로 설정하지 않고 상속받은 클래스에서 **오버라이딩**해서 사용하도록 한다. **이때, 추상클래스든 인터페이스든 선언된 추상메소드는 반드시 오버라이딩을 통해 재구현 되어야만 한다!** 위에 (강제적) 이라고 써놓은 이유이다.\n\n<br><br>\n\n### 📌디폴트메소드\n\n원래 인터페이스에서는 추상메소드와 상수만 사용해서 제약을 많이 걸어뒀지만 JAVA8부터 디폴트메소드와 정적메소드를 추가하여 인터페이스의 범용성을 높였다. \n\n디폴트 메소드는 ```default 접근제어자 메소드명 ( 자료형 변수명 );``` 의 형태로 선언한다.  **디폴트 메소드는 상속받은 클래스에서 반드시 사용할 필요는 없다**. 필요에 따라 사용유무를 결정하면 된다. \n\n<Br>\n\n디폴트 메소드를 쓰는 경우의 예시를 들어보자. 내가 사칙연산 기능만 가지고 있는 계산기 프로그램을 만들어서 A,B,C 라는 사람에게 배포했다고 치자. 그런데 A라는 사람이 사칙연산 뿐만 아니라 공학용 계산기를 만들어달라고 한다. 공학용 계산기를 처음부터 다시 만드는건 어려우니 기존 사칙연산 계산기에 공학용 기능을 추가해서 배포하려고 한다. \n\n이때 인터페이스에 **추상메소드로 공학용 기능을 추가해서 배포하면 공학용 기능이 필요하지 않은 B,C도 공학용 메소드를 반드시 오버라이딩 해야 하는 불필요한 작업이 추가된다.** 때문에 **공학용 메소드를 디폴트 메소드로 정의하면 A만 따로 메소드를 추가해서 사용할 수 있는 이점이 생긴다.** 이런 이유로 위에 (선택적) 이라고 적어놓은 것이다.\n\n<br><br><br>\n\n### 📌정적 메소드\n\n인터페이스에서 제공한 메소드 그대로 사용해야만 한다. ```static 접근제어자 클래스명 (자료형 변수명)``` 형태로 사용한다. 반드시 써야하는 메소드는 아니고 필요에 따라 선언하면 된다.\n\t\n\n<br><br><br><br>\n\n## ✅ 인터페이스의 장점\n1. 대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화가 가능하다. \n-> **객체지향의 다형성**\n3. 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발시간을 단축할 수 있다.\n4. 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 상속구조 없이 독립적인 프로그래밍이 가능하다.\n","properties":"\n","discussions":{},"comments":{},"hash":1237047638,"tx":11222},"nZtkP309cM7hcqO2/content":{"id":"nZtkP309cM7hcqO2/content","type":"content","text":"---\npermalink: /2022-08-12-추상클래스/\npublished: true\ntitle: \"[JAVA] 추상클래스\"\ndate: 2022-08-12 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n2023.06.15 내용 추가\n<br><br>\n\n\n오늘은 추상클래스에 대해서 알아보자! 추상클래스에서 가장많이 사용하는것이 추상메소드이므로 추상메소드부터 차근차근 알아보자!\n\n<br><br><br><br>\n\n## ✅ 추상메소드란?\n**추상 메소드(abstract method)** 란 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미한다. \n\n자바에서 추상 메소드를 선언하여 사용하는 목적은 **추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함**이다.\n\n예를 들면 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 다 만들어진 것을 사용하고, 이를 받아 사용하는 쪽에서는 자신에게 필요한 부분만을 오버라이딩하여 사용함으로써 생산성이 향상되고 배포 등이 쉬워지기 때문이다. \n\n이러한 추상 메소드는 **선언부**만 존재하며, **구현부는 작성하지 않는다.**\n\n바로 이 **작성되어 있지 않은 구현부를 자식 클래스에서 오버라이딩하여 사용하는 것**이다.\n\n \n<br><br><br><br>\n## ✅ 추상메소드의 선언\n```java\n 접근제어자 abstract 반환타입 메소드이름();\n```\n```java\n // 예시\n public abstract void Calculate();\n public abstract String PrintResult();\n void Reset();      // 접근제어자와 abstract는 생략가능\n ```\n\n<br><br><br>\n\n## ✅ 추상 클래스란?\n**하나 이상**의 **추상메소드**를 포함하는 클래스를 추상 클래스라고 한다. **추상 클래스는 추상메소드를 포함하고 있는것을 제외하면 일반 클래스와 완전히 동일하다.**\n\n<br><br>\n\n### 📌 추상클래스의 특징\n\n - 추상메소드를 포함하고 있기 때문에 실체성, 구체성이 없어 인스턴스 (객체)를 생성할 수 없다. \n - 추상클래스와 실체 클래스는 상속관계! \n - 추상클래스에서 선언된 추상메소드는 여러개의 하위클래스에서 자유롭게 사용가능 하지만, 결국 모든 추상메소드는 반드시 오버라이딩이 되어있어야만 한다!\n\n<br><br><br><br>\n\n## ✅ 추상클래스 예제\n```java\nimport calculate_Ver_Adapter.CalResult;\nimport lombok.Data;\n\n@Data\npublic abstract class CalAbstract implements CalResult {\n\t\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\tprivate StringBuffer sb = new StringBuffer();\n\tprivate double result=0;\n\n\t\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic char judgeOp(String op) {\n\t\tif (op.equals(\"+\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"-\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"*\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"/\")) {\n\t\t\treturn op.charAt(0);\n\t\t}\n\t\treturn 'X';\n\t}\n\t\n\t// 실제 계산 수행\n\tpublic void calculate() {\n\t\tif (getOp().equals(\"+\")) {\n\t\t\tadd();\n\t\t} else if (getOp().equals(\"-\")) {\n\t\t\tsub();\n\t\t} else if (getOp().equals(\"*\")) {\n\t\t\tmul();\n\t\t} else if (getOp().equals(\"/\")) {\n\t\t\tdiv();\n\t\t}\n\t}\n\n\t// 입력받은게 숫자인지 기호인지 판단하는 객체\n\tpublic boolean judgeCal(boolean temp) {\n\t\tif (temp == true)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t// 숫자면 true, 기호면 false return\n\tpublic boolean judgeNumOrOp(String temp) {\n\t\treturn temp.matches(\"-?\\\\d+\");\n\t}\n\n\t\n\t// 추상메소드\n\tpublic abstract void cal();\n\t\n\t@Override\n\tpublic void PrintResult(double result) {\n\t\tSystem.out.println(\"결과 : \"+ result);\n\t}\n\t\n\t@Override\n\tpublic void PrintProcess(StringBuffer sb) {\n\t\tSystem.out.println(\"과정 : \" + sb);\n\t}\n}\n\n```\n<br>\n\n일반클래스처럼 보이지만.. **추상메소드가 단 한개!** 포함된 추상클래스이다. 이렇게 추상메소드가 단 한개만 있어도 우리는 이를 추상클래스라고 정의한다. 그러나 추상클래스에 반드시 추상메소드에 포함될 필요는 없다. `public abstract class CalAbstract implements CalResult` 처럼 선언부에 `abstract class` 를 선언하면 추상클래스라고 볼 수 있다.\n\n그렇다면 이 추상클래스를 상속받은 클래스를 한번 살펴보자.\n\n```java\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class ContinuousCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\tCalAdapter calAdapter = new CalAdapter();\n\t\n\n\t// 연속 계산 수행\n\t// 추상메소드 구현부\n\t@Override\n\tpublic void cal() {\n\t\twhile (true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\n\t\t\tStringTokenizer st = new StringTokenizer(str, \"\\\\+|\\\\-|\\\\*|\\\\/\", true);\n\n\t\t\tString temp = st.nextToken();\n\t\t\tif (temp.equals(\"=\")) {\n\t\t\t\t/////////// 얘를 res.result()로 하면 왜안됨???\n\t\t\t\t//res.result();\n\t\t\t\t//System.out.println(\"연산과정 : \" + getSb().toString());\n\t\t\t\t//System.out.println(\"결과 : \" + getResult());\n\t\t\t\t\n\t\t\t\tcalAdapter.Display(getSb(),getResult());\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tgetSb().setLength(0);\n\t\t\t\tsetResult(0);\n\t\t\t\tsetSum(0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 첫번째 문자가 숫자인지 기호인지를 판단하는 코드\n\t\t\t// 숫자면 true, 기호면 false\n\t\t\tboolean IntOrNot = judgeNumOrOp(temp);\n\n\t\t\t// StringBuffer가 비어있는 경우\n\t\t\tif (getSb().isEmpty()) {\n\t\t\t\tif (judgeCal(IntOrNot)) {\n\t\t\t\t\tint a = Integer.parseInt(temp);\n\t\t\t\t\t// a는 int형식으로 저장\n\t\t\t\t\tsetA(a);\n\t\t\t\t\t//System.out.println(\"a : \" + getA());\n\t\t\t\t\t\n\t\t\t\t\t// StringBuffer에 String형식으로 저장\n\t\t\t\t\tgetSb().append(temp);\n\t\t\t\t\tsetSum(getSum()+a);\n\t\t\t\t\t//System.out.println(\"sum : \" + getSum());\n\t\t\t\t\tsetResult(getResult()+a);\n\t\t\t\t\t//System.out.println(\"Result : \" + getResult());\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"숫자를 입력하세요!\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// StringBuffer가 비어있지 않은 경우\n\t\t\telse {\n\t\t\t\t// 첫번째 문자가 숫자일경우 그대로 연산 진행\n\t\t\t\t// 숫자인경우(int)\n\t\t\t\tif (judgeCal(IntOrNot)) {\n\t\t\t\t\tint a = Integer.parseInt(temp);\n\t\t\t\t\t// a는 int형식으로 저장\n\t\t\t\t\tsetA(a);\n\t\t\t\t\t// System.out.println(\"a : \" + getA());\n\t\t\t\t\t// StringBuffer에 String형식으로 저장\n\t\t\t\t\tgetSb().append(temp);\n\t\t\t\t\tcalculate();\n\t\t\t\t\t//System.out.println(\"sum : \" + getSum());\n\t\t\t\t\t//System.out.println(\"Result : \" + getResult());\n\t\t\t\t}\n\n\t\t\t\t// 첫번째 문자가 기호일 경우\n\t\t\t\telse if (!judgeCal(IntOrNot)) {\n\t\t\t\t\tString judgedOp = String.valueOf(judgeOp(temp));\n\t\t\t\t\t// judgedOp를 상위생성자에 넣어서 보내준다.\n\t\t\t\t\tsetOp(judgedOp);\n\t\t\t\t\t\n\t\t\t\t\t// judgedOp를 Is_A_Cal의 StringBuffer에 넣어준다.\n\t\t\t\t\tgetSb().append(judgedOp);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n<br>\n\n지금 인터페이스랑 추상클래스 등등 객체지향 공부를 다시하면서 만들고 있는 계산기 코드인데 좀 보기 지저분해 보일수 있다.. 아무튼 추상클래스에서 받아온 추상메소드 `cal()` 을 구현해놓은 것을 볼 수 있다.\n\n근데 여기서 하나 드는 의문점! 아니 애초에 추상클래스에 추상메소드로 선언해서 쓸 필요없이 그냥 일반클래스에 직접 코드를 작성하면 되는거 아닌가? \n\n물론 그래도 상관없다. 지금은 간단한 계산기 코드기 때문에 상관없지만, 메소드가 엄청나게 많아지게 되고, 디자인패턴이 적용되고, 반드시 써야하는 메소드, 선택적 메소드, 이렇게 코드가 복잡해지게 되면 정해진 틀에 맞춰 개발하는게 훨씬 편리해진다.\n\n<br>\n\n추상클래스는 **일종의 틀** 을 제공한다고 보면 된다. 추상메소드를 통해 사용해야만 하는 메소드를 강제하여 일종의 규격을 만들어주는 것이다.\n\n그런데 공부를 하다보면 추상클래스와 인터페이스의 차이점을 잘 모르겠다. 추상클래스가 인터페이스의 역할을 전부다 하고 있는데 인터페이스는 왜필요한걸까? 이는 다음포스팅에 다뤄보도록 하겠다..!\n","properties":"\n","discussions":{},"comments":{},"hash":-71673329,"tx":11224},"nZtkP309cM7hcqO2/syncedContent":{"id":"nZtkP309cM7hcqO2/syncedContent","type":"syncedContent","historyData":{"-1026760043":{"id":"nZtkP309cM7hcqO2/content","type":"content","text":"---\npermalink: /2022-08-12-추상클래스/\npublished: true\ntitle: \"[JAVA] 추상클래스\"\ndate: 2022-08-12 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n2023.06.15 내용 추가\n<br><br>\n\n\n오늘은 추상클래스에 대해서 알아보자! 추상클래스에서 가장많이 사용하는것이 추상메소드이므로 추상메소드부터 차근차근 알아보자!\n\n<br><br><br><br>\n\n## ✅ 추상메소드란?\n**추상 메소드(abstract method)** 란 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미한다. \n\n자바에서 추상 메소드를 선언하여 사용하는 목적은 **추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함**이다.\n\n예를 들면 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 다 만들어진 것을 사용하고, 이를 받아 사용하는 쪽에서는 자신에게 필요한 부분만을 오버라이딩하여 사용함으로써 생산성이 향상되고 배포 등이 쉬워지기 때문이다. \n\n이러한 추상 메소드는 **선언부**만 존재하며, **구현부는 작성하지 않는다.**\n\n바로 이 **작성되어 있지 않은 구현부를 자식 클래스에서 오버라이딩하여 사용하는 것**이다.\n\n \n<br><br><br><br>\n## ✅ 추상메소드의 선언\n```java\n 접근제어자 abstract 반환타입 메소드이름();\n```\n```java\n // 예시\n public abstract void Calculate();\n public abstract String PrintResult();\n void Reset();      // 접근제어자와 abstract는 생략가능\n ```\n\n<br><br><br>\n\n## ✅ 추상 클래스란?\n**하나 이상**의 **추상메소드**를 포함하는 클래스를 추상 클래스라고 한다. **추상 클래스는 추상메소드를 포함하고 있는것을 제외하면 일반 클래스와 완전히 동일하다.**\n\n<br><br>\n\n### 📌 추상클래스의 특징\n\n - 추상메소드를 포함하고 있기 때문에 실체성, 구체성이 없어 인스턴스 (객체)를 생성할 수 없다. \n - 추상클래스와 실체 클래스는 상속관계! \n - 추상클래스에서 선언된 추상메소드는 여러개의 하위클래스에서 자유롭게 사용가능 하지만, 결국 모든 추상메소드는 반드시 오버라이딩이 되어있어야만 한다!\n\n<br><br><br><br>\n\n## ✅ 추상클래스 예제\n```java\nimport calculate_Ver_Adapter.CalResult;\nimport lombok.Data;\n\n@Data\npublic abstract class CalAbstract implements CalResult {\n\t\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\tprivate StringBuffer sb = new StringBuffer();\n\tprivate double result=0;\n\n\t\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic char judgeOp(String op) {\n\t\tif (op.equals(\"+\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"-\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"*\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"/\")) {\n\t\t\treturn op.charAt(0);\n\t\t}\n\t\treturn 'X';\n\t}\n\t\n\t// 실제 계산 수행\n\tpublic void calculate() {\n\t\tif (getOp().equals(\"+\")) {\n\t\t\tadd();\n\t\t} else if (getOp().equals(\"-\")) {\n\t\t\tsub();\n\t\t} else if (getOp().equals(\"*\")) {\n\t\t\tmul();\n\t\t} else if (getOp().equals(\"/\")) {\n\t\t\tdiv();\n\t\t}\n\t}\n\n\t// 입력받은게 숫자인지 기호인지 판단하는 객체\n\tpublic boolean judgeCal(boolean temp) {\n\t\tif (temp == true)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t// 숫자면 true, 기호면 false return\n\tpublic boolean judgeNumOrOp(String temp) {\n\t\treturn temp.matches(\"-?\\\\d+\");\n\t}\n\n\t\n\t// 추상메소드\n\tpublic abstract void cal();\n\t\n\t@Override\n\tpublic void PrintResult(double result) {\n\t\tSystem.out.println(\"결과 : \"+ result);\n\t}\n\t\n\t@Override\n\tpublic void PrintProcess(StringBuffer sb) {\n\t\tSystem.out.println(\"과정 : \" + sb);\n\t}\n}\n\n```\n<br>\n\n일반클래스처럼 보이지만.. **추상메소드가 단 한개!** 포함된 추상클래스이다. 이렇게 추상메소드가 단 한개만 있어도 우리는 이를 추상클래스라고 정의한다. 그러나 추상클래스에 반드시 추상메소드에 포함될 필요는 없다. `public abstract class CalAbstract implements CalResult` 처럼 선언부에 `abstract class` 를 선언하면 추상클래스라고 볼 수 있다.\n\n그렇다면 이 추상클래스를 상속받은 클래스를 한번 살펴보자.\n\n```java\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class ContinuousCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\tCalAdapter calAdapter = new CalAdapter();\n\t\n\n\t// 연속 계산 수행\n\t// 추상메소드 구현부\n\t@Override\n\tpublic void cal() {\n\t\twhile (true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\n\t\t\tStringTokenizer st = new StringTokenizer(str, \"\\\\+|\\\\-|\\\\*|\\\\/\", true);\n\n\t\t\tString temp = st.nextToken();\n\t\t\tif (temp.equals(\"=\")) {\n\t\t\t\t/////////// 얘를 res.result()로 하면 왜안됨???\n\t\t\t\t//res.result();\n\t\t\t\t//System.out.println(\"연산과정 : \" + getSb().toString());\n\t\t\t\t//System.out.println(\"결과 : \" + getResult());\n\t\t\t\t\n\t\t\t\tcalAdapter.Display(getSb(),getResult());\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tgetSb().setLength(0);\n\t\t\t\tsetResult(0);\n\t\t\t\tsetSum(0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 첫번째 문자가 숫자인지 기호인지를 판단하는 코드\n\t\t\t// 숫자면 true, 기호면 false\n\t\t\tboolean IntOrNot = judgeNumOrOp(temp);\n\n\t\t\t// StringBuffer가 비어있는 경우\n\t\t\tif (getSb().isEmpty()) {\n\t\t\t\tif (judgeCal(IntOrNot)) {\n\t\t\t\t\tint a = Integer.parseInt(temp);\n\t\t\t\t\t// a는 int형식으로 저장\n\t\t\t\t\tsetA(a);\n\t\t\t\t\t//System.out.println(\"a : \" + getA());\n\t\t\t\t\t\n\t\t\t\t\t// StringBuffer에 String형식으로 저장\n\t\t\t\t\tgetSb().append(temp);\n\t\t\t\t\tsetSum(getSum()+a);\n\t\t\t\t\t//System.out.println(\"sum : \" + getSum());\n\t\t\t\t\tsetResult(getResult()+a);\n\t\t\t\t\t//System.out.println(\"Result : \" + getResult());\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"숫자를 입력하세요!\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// StringBuffer가 비어있지 않은 경우\n\t\t\telse {\n\t\t\t\t// 첫번째 문자가 숫자일경우 그대로 연산 진행\n\t\t\t\t// 숫자인경우(int)\n\t\t\t\tif (judgeCal(IntOrNot)) {\n\t\t\t\t\tint a = Integer.parseInt(temp);\n\t\t\t\t\t// a는 int형식으로 저장\n\t\t\t\t\tsetA(a);\n\t\t\t\t\t// System.out.println(\"a : \" + getA());\n\t\t\t\t\t// StringBuffer에 String형식으로 저장\n\t\t\t\t\tgetSb().append(temp);\n\t\t\t\t\tcalculate();\n\t\t\t\t\t//System.out.println(\"sum : \" + getSum());\n\t\t\t\t\t//System.out.println(\"Result : \" + getResult());\n\t\t\t\t}\n\n\t\t\t\t// 첫번째 문자가 기호일 경우\n\t\t\t\telse if (!judgeCal(IntOrNot)) {\n\t\t\t\t\tString judgedOp = String.valueOf(judgeOp(temp));\n\t\t\t\t\t// judgedOp를 상위생성자에 넣어서 보내준다.\n\t\t\t\t\tsetOp(judgedOp);\n\t\t\t\t\t\n\t\t\t\t\t// judgedOp를 Is_A_Cal의 StringBuffer에 넣어준다.\n\t\t\t\t\tgetSb().append(judgedOp);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n<br>\n\n지금 인터페이스랑 추상클래스 등등 객체지향 공부를 다시하면서 만들고 있는 계산기 코드인데 좀 보기 지저분해 보일수 있다.. 아무튼 추상클래스에서 받아온 추상메소드 `cal()` 을 구현해놓은 것을 볼 수 있다.\n\n근데 여기서 하나 드는 의문점! 아니 애초에 추상클래스에 추상메소드로 선언해서 쓸 필요없이 그냥 일반클래스에 직접 코드를 작성하면 되는거 아닌가? \n\n물론 그래도 상관없다. 지금은 간단한 계산기 코드기 때문에 상관없지만, 메소드가 엄청나게 많아지게 되고, 디자인패턴이 적용되고, 반드시 써야하는 메소드, 선택적 메소드, 이렇게 코드가 복잡해지게 되면 정해진 틀에 맞춰 개발하는게 훨씬 편리해진다.\n\n<br>\n\n추상클래스는 **일종의 틀** 을 제공한다고 보면 된다. 추상메소드를 통해 사용해야만 하는 메소드를 강제하여 일종의 규격을 만들어주는 것이다.\n\n그런데 공부를 하다보면 추상클래스와 인터페이스의 차이점을 잘 모르겠다. 추상클래스가 인터페이스의 역할을 전부다 하고 있는데 인터페이스는 왜필요한걸까? 이는 다음포스팅에 다뤄보도록 하겠다..!\n","properties":"\n","discussions":{},"comments":{},"hash":-1026760043},"-71673329":{"id":"nZtkP309cM7hcqO2/content","type":"content","text":"---\npermalink: /2022-08-12-추상클래스/\npublished: true\ntitle: \"[JAVA] 추상클래스\"\ndate: 2022-08-12 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n2023.06.15 내용 추가\n<br><br>\n\n\n오늘은 추상클래스에 대해서 알아보자! 추상클래스에서 가장많이 사용하는것이 추상메소드이므로 추상메소드부터 차근차근 알아보자!\n\n<br><br><br><br>\n\n## ✅ 추상메소드란?\n**추상 메소드(abstract method)** 란 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미한다. \n\n자바에서 추상 메소드를 선언하여 사용하는 목적은 **추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함**이다.\n\n예를 들면 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 다 만들어진 것을 사용하고, 이를 받아 사용하는 쪽에서는 자신에게 필요한 부분만을 오버라이딩하여 사용함으로써 생산성이 향상되고 배포 등이 쉬워지기 때문이다. \n\n이러한 추상 메소드는 **선언부**만 존재하며, **구현부는 작성하지 않는다.**\n\n바로 이 **작성되어 있지 않은 구현부를 자식 클래스에서 오버라이딩하여 사용하는 것**이다.\n\n \n<br><br><br><br>\n## ✅ 추상메소드의 선언\n```java\n 접근제어자 abstract 반환타입 메소드이름();\n```\n```java\n // 예시\n public abstract void Calculate();\n public abstract String PrintResult();\n void Reset();      // 접근제어자와 abstract는 생략가능\n ```\n\n<br><br><br>\n\n## ✅ 추상 클래스란?\n**하나 이상**의 **추상메소드**를 포함하는 클래스를 추상 클래스라고 한다. **추상 클래스는 추상메소드를 포함하고 있는것을 제외하면 일반 클래스와 완전히 동일하다.**\n\n<br><br>\n\n### 📌 추상클래스의 특징\n\n - 추상메소드를 포함하고 있기 때문에 실체성, 구체성이 없어 인스턴스 (객체)를 생성할 수 없다. \n - 추상클래스와 실체 클래스는 상속관계! \n - 추상클래스에서 선언된 추상메소드는 여러개의 하위클래스에서 자유롭게 사용가능 하지만, 결국 모든 추상메소드는 반드시 오버라이딩이 되어있어야만 한다!\n\n<br><br><br><br>\n\n## ✅ 추상클래스 예제\n```java\nimport calculate_Ver_Adapter.CalResult;\nimport lombok.Data;\n\n@Data\npublic abstract class CalAbstract implements CalResult {\n\t\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\tprivate StringBuffer sb = new StringBuffer();\n\tprivate double result=0;\n\n\t\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic char judgeOp(String op) {\n\t\tif (op.equals(\"+\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"-\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"*\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"/\")) {\n\t\t\treturn op.charAt(0);\n\t\t}\n\t\treturn 'X';\n\t}\n\t\n\t// 실제 계산 수행\n\tpublic void calculate() {\n\t\tif (getOp().equals(\"+\")) {\n\t\t\tadd();\n\t\t} else if (getOp().equals(\"-\")) {\n\t\t\tsub();\n\t\t} else if (getOp().equals(\"*\")) {\n\t\t\tmul();\n\t\t} else if (getOp().equals(\"/\")) {\n\t\t\tdiv();\n\t\t}\n\t}\n\n\t// 입력받은게 숫자인지 기호인지 판단하는 객체\n\tpublic boolean judgeCal(boolean temp) {\n\t\tif (temp == true)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t// 숫자면 true, 기호면 false return\n\tpublic boolean judgeNumOrOp(String temp) {\n\t\treturn temp.matches(\"-?\\\\d+\");\n\t}\n\n\t\n\t// 추상메소드\n\tpublic abstract void cal();\n\t\n\t@Override\n\tpublic void PrintResult(double result) {\n\t\tSystem.out.println(\"결과 : \"+ result);\n\t}\n\t\n\t@Override\n\tpublic void PrintProcess(StringBuffer sb) {\n\t\tSystem.out.println(\"과정 : \" + sb);\n\t}\n}\n\n```\n<br>\n\n일반클래스처럼 보이지만.. **추상메소드가 단 한개!** 포함된 추상클래스이다. 이렇게 추상메소드가 단 한개만 있어도 우리는 이를 추상클래스라고 정의한다. 그러나 추상클래스에 반드시 추상메소드에 포함될 필요는 없다. `public abstract class CalAbstract implements CalResult` 처럼 선언부에 `abstract class` 를 선언하면 추상클래스라고 볼 수 있다.\n\n그렇다면 이 추상클래스를 상속받은 클래스를 한번 살펴보자.\n\n```java\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class ContinuousCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\tCalAdapter calAdapter = new CalAdapter();\n\t\n\n\t// 연속 계산 수행\n\t// 추상메소드 구현부\n\t@Override\n\tpublic void cal() {\n\t\twhile (true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\n\t\t\tStringTokenizer st = new StringTokenizer(str, \"\\\\+|\\\\-|\\\\*|\\\\/\", true);\n\n\t\t\tString temp = st.nextToken();\n\t\t\tif (temp.equals(\"=\")) {\n\t\t\t\t/////////// 얘를 res.result()로 하면 왜안됨???\n\t\t\t\t//res.result();\n\t\t\t\t//System.out.println(\"연산과정 : \" + getSb().toString());\n\t\t\t\t//System.out.println(\"결과 : \" + getResult());\n\t\t\t\t\n\t\t\t\tcalAdapter.Display(getSb(),getResult());\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tgetSb().setLength(0);\n\t\t\t\tsetResult(0);\n\t\t\t\tsetSum(0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 첫번째 문자가 숫자인지 기호인지를 판단하는 코드\n\t\t\t// 숫자면 true, 기호면 false\n\t\t\tboolean IntOrNot = judgeNumOrOp(temp);\n\n\t\t\t// StringBuffer가 비어있는 경우\n\t\t\tif (getSb().isEmpty()) {\n\t\t\t\tif (judgeCal(IntOrNot)) {\n\t\t\t\t\tint a = Integer.parseInt(temp);\n\t\t\t\t\t// a는 int형식으로 저장\n\t\t\t\t\tsetA(a);\n\t\t\t\t\t//System.out.println(\"a : \" + getA());\n\t\t\t\t\t\n\t\t\t\t\t// StringBuffer에 String형식으로 저장\n\t\t\t\t\tgetSb().append(temp);\n\t\t\t\t\tsetSum(getSum()+a);\n\t\t\t\t\t//System.out.println(\"sum : \" + getSum());\n\t\t\t\t\tsetResult(getResult()+a);\n\t\t\t\t\t//System.out.println(\"Result : \" + getResult());\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"숫자를 입력하세요!\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// StringBuffer가 비어있지 않은 경우\n\t\t\telse {\n\t\t\t\t// 첫번째 문자가 숫자일경우 그대로 연산 진행\n\t\t\t\t// 숫자인경우(int)\n\t\t\t\tif (judgeCal(IntOrNot)) {\n\t\t\t\t\tint a = Integer.parseInt(temp);\n\t\t\t\t\t// a는 int형식으로 저장\n\t\t\t\t\tsetA(a);\n\t\t\t\t\t// System.out.println(\"a : \" + getA());\n\t\t\t\t\t// StringBuffer에 String형식으로 저장\n\t\t\t\t\tgetSb().append(temp);\n\t\t\t\t\tcalculate();\n\t\t\t\t\t//System.out.println(\"sum : \" + getSum());\n\t\t\t\t\t//System.out.println(\"Result : \" + getResult());\n\t\t\t\t}\n\n\t\t\t\t// 첫번째 문자가 기호일 경우\n\t\t\t\telse if (!judgeCal(IntOrNot)) {\n\t\t\t\t\tString judgedOp = String.valueOf(judgeOp(temp));\n\t\t\t\t\t// judgedOp를 상위생성자에 넣어서 보내준다.\n\t\t\t\t\tsetOp(judgedOp);\n\t\t\t\t\t\n\t\t\t\t\t// judgedOp를 Is_A_Cal의 StringBuffer에 넣어준다.\n\t\t\t\t\tgetSb().append(judgedOp);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n<br>\n\n지금 인터페이스랑 추상클래스 등등 객체지향 공부를 다시하면서 만들고 있는 계산기 코드인데 좀 보기 지저분해 보일수 있다.. 아무튼 추상클래스에서 받아온 추상메소드 `cal()` 을 구현해놓은 것을 볼 수 있다.\n\n근데 여기서 하나 드는 의문점! 아니 애초에 추상클래스에 추상메소드로 선언해서 쓸 필요없이 그냥 일반클래스에 직접 코드를 작성하면 되는거 아닌가? \n\n물론 그래도 상관없다. 지금은 간단한 계산기 코드기 때문에 상관없지만, 메소드가 엄청나게 많아지게 되고, 디자인패턴이 적용되고, 반드시 써야하는 메소드, 선택적 메소드, 이렇게 코드가 복잡해지게 되면 정해진 틀에 맞춰 개발하는게 훨씬 편리해진다.\n\n<br>\n\n추상클래스는 **일종의 틀** 을 제공한다고 보면 된다. 추상메소드를 통해 사용해야만 하는 메소드를 강제하여 일종의 규격을 만들어주는 것이다.\n\n그런데 공부를 하다보면 추상클래스와 인터페이스의 차이점을 잘 모르겠다. 추상클래스가 인터페이스의 역할을 전부다 하고 있는데 인터페이스는 왜필요한걸까? 이는 다음포스팅에 다뤄보도록 하겠다..!\n","properties":"\n","discussions":{},"comments":{},"hash":-71673329}},"syncHistory":{"main":[-71673329,-1026760043,-71673329]},"v":1,"hash":1710892090849,"tx":11224},"QO3PlLKwWnIiwVqK/content":{"id":"QO3PlLKwWnIiwVqK/content","type":"content","text":"---\npermalink: /2022-08-16-인터페이스 vs 추상클래스/\npublished: true\ntitle: \"[JAVA] 인터페이스 vs 추상클래스 \"\ndate: 2022-08-16 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n<br><br>\n2023.06.15 내용추가\n<br><br>\n\n이전 포스팅에서 [인터페이스](https://idkim97.github.io/2022-08-12-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/)와 [추상클래스](https://idkim97.github.io/2022-08-12-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/)에 대해서 알아봤다. 그런데 각각의 기능이나 역할은 잘 알겠는데 둘의 차이점을 설명하라고 하면 명확하게 할 수 있을까? 본인같은 경우에도 둘의 차이점을 제대로 설명해보라고 하면 헷갈릴 만한 부분이 분명히 있기 때문에 오늘은 **인터페이스와 추상클래스의 공통점과 차이점**에 대해서 자세히 포스팅 해보려고 한다!\n\n<br><br><br><br>\n\n## ✅ 인터페이스와 추상클래스의 공통점\n\n1. **객체지향의 다형성을 활용할 수 있다.**\n\n2. **추상메소드를 사용한다.**\n\n3. **구현부가 없는 추상메소드 때문에 인스턴스화( 객체생성 )가 불가능하다.**\n\n4. **상속받는 클래스 혹은 구현하는 인터페이스 안에 있는 추상메소드를 구현하도록 강제 한다.**\n\n<br>\n \n이렇게 네가지 정도의 공통점을 들 수 있다. 여기서 몇가지 의문이 든다.\n\n**인터페이스**는 일반적으로 **상수, 추상메소드, 디폴트메소드, 정적 메소드** 로 이루어진다. **추상클래스**는 단순히 **추상메소드를 한개이상 포함한 클래스**를 말한다.\n\n**그렇다면 추상클래스에 원하는 추상메소드를 여러개 선언해서 상속받아 사용하고, 상수, 디폴트메소드, 정적메소드 역시 그냥 추상클래스에 선언해서 사용하면 추상클래스가 인터페이스의 역할을 전부다 할 수 있게 되는것 아닌가?**\n\n반은 맞고 반은 틀린 말이다.\n\n**인터페이스와 추상클래스는 존재 목적이 다르다**. **추상클래스**는 **그 추상클래스를 상속받아서 기능을 이용하고, 확장**시키는 데 있다. 반면에 **인터페이스**는 구현부가 전혀없이 메소드의 껍데기만 있는데, 그 이유는 **메소드의 구현을 강제하기 위함**이다. **구현을 강제함으로써 구현 객체의 같은 동작을 보장** 할 수 있다.\n\n<br><Br><br><br>\n\n## 인터페이스와 추상클래스의 차이점\n\n\n\n### 📕 접근제어자\n\n\n**🔔 인터페이스**\n\n> **상수 : ```public static final```**\n\n> **추상메소드 : ```public abstract```**\n\n> **디폴트 메소드 : ```default```**\n\n> **정적메소드 : ```static```** \n\n<br><br>\n\n**🔔 추상클래스**\n\n>  **static , final 이 아닌 필드 사용가능**\n\n> **public, private, protected 모두 사용 가능** \n\n<br><br><br>\n\n\n인터페이스에서 사용되는 접근제어자는 위와 같다. \n\n인터페이스에서 **상수**는 항상 **고정값**으로 적용되기 때문에 **```final``` 필드**를 가지고 **객체생성 없이 사용**할 수 있게 끔 **```static``` 필드**를 가진다. \n\n그러나 **추상클래스**는 **```static```** 이나 **```final```** 필드를 가질 수 없고 **```public, private, protected```** 모두 사용 가능하다.\n\n<Br><br><br>\n\n### 📕 사용 의도의 차이\n\n**인터페이스는 HAS - A \" ~을 포함하는 / ~을 할 수 있는\"**\n**추상클래스는 IS - A \"~이다\"**\n\n일반적으로 인터페이스와 추상클래스를 구분할 때 **HAS -A** 와 **IS-A** 로 구분하곤 한다. **다중상속 가능 여부**에 따라 이렇게 구분한 것으로 보이는데, JAVA는 한개의 클래스만 상속이 가능하기 때문에 **추상클래스의 상속을 통해 필요한 기능을 사용, 확장**하고 **인터페이스를 통해 필요한(할수있는) 기능을 강제**한다.\n\n글로만 보면 어려우니 예제를 통해 알아보자.\n\n<br><br><br><br>\n\n**🔔 CalAbstract : 추상클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport lombok.Data;\n\n@Data\npublic abstract class CalAbstract {\n\t\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\tprivate StringBuffer sb = new StringBuffer();\n\tprivate double result=0;\n\t\n\t\n\tprivate CalResult calResult;\n\t\n\t\n\t// 추상클래스 내에 클래스를 하나 만들어서 인터페이스를 implements해줌으로써 \n\t// calResult를 초기화할 수 있음.\n\t// 이게 어댑터 패턴(클래스)이네.. (아님 x)\n\tclass DefaultCalResultDisplay implements CalResult{\n\t\t\n\t\t@Override\n\t\tpublic void PrintResult() {\n\t\t\tSystem.out.println(\"결과 : \" + getResult());\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void PrintProcess() {\n\t\t\tSystem.out.println(\"연산 과정 : \" + getSb());\n\t\t}\n\t}\n\t\n\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic char judgeOp(String op) {\n\t\tif (op.equals(\"+\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"-\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"*\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"/\")) {\n\t\t\treturn op.charAt(0);\n\t\t}\n\t\treturn 'X';\n\t}\n\t\n\t// 실제 계산 수행\n\tpublic void calculate() {\n\t\tif (getOp().equals(\"+\")) {\n\t\t\tadd();\n\t\t} else if (getOp().equals(\"-\")) {\n\t\t\tsub();\n\t\t} else if (getOp().equals(\"*\")) {\n\t\t\tmul();\n\t\t} else if (getOp().equals(\"/\")) {\n\t\t\tdiv();\n\t\t}\n\t}\n\n\t// 입력받은게 숫자인지 기호인지 판단하는 객체\n\tpublic boolean judgeCal(boolean temp) {\n\t\tif (temp == true)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t// 숫자면 true, 기호면 false return\n\tpublic boolean judgeNumOrOp(String temp) {\n\t\treturn temp.matches(\"-?\\\\d+\");\n\t}\n\n\t\n\t// 추상메소드\n\tpublic abstract void cal();\n\t\n\n\t\n\tpublic void addDisplayResult(CalResult calResult) {\n\t\tthis.calResult = calResult;\n\t}\n\t\n\tpublic void display() {\n\t\tif(this.calResult == null) {\n\t\t\tDefaultCalResultDisplay defaultCalResultDisplay = new DefaultCalResultDisplay();\n\t\t\tdefaultCalResultDisplay.PrintProcess();\n\t\t\tdefaultCalResultDisplay.PrintResult();\n\t\t}\n\t\telse {\n\t\t\tcalResult.PrintProcess();\n\t\t\tcalResult.PrintResult();\n\t\t}\n\t}\n\n}\n\n```\n\n<br>\n\n사칙연산을 계산해주는 계산기를 위한 추상클래스이다. 객체지향 공부를 목적으로 짜고있는 코드이므로 좀 복잡해보일 수 있다..  일단 위 코드의 최종 목적을 간단하게 설명해보면 추상클래스와 인터페이스를 활용해서 다른기능을 가진 2개의 계산기를 만드는 것이다. \n\n하나는 일반적인 계산을 수행한다. (ex. 1+1, 2x8, 10/2)\n다른 하나는 연속적인 계산을 수행한다. ( ex 5+8-9*2/3+8 ) ( 입력순서대로 )\n최종적으로 연산과정과 연산 결과를 공통적으로 출력한다.\n\n위와 같은 기능을 가진 2개의 계산기를 구현하기 위해 인터페이스와 추상클래스를 어떻게 활용했는지를 중심으로 살펴보자.\n\n\n<br><br><br>\n\n추상클래스에 **필요한 변수**나 **일반 메소드**를 먼저 구현해줬다.\n```java\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\t// 연산과정을 저장하는 StringBuffer\n\tprivate StringBuffer sb = new StringBuffer();\n\t// 계산 결과\n\tprivate double result=0;\n```\n\n```java\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\n... 이하생략\n```\n\n<br><br><br>\n일반 클래스와 다를게 아예없다. 단지 추상클래스에는 **추상메소드**가 포함되었을 뿐이다.\n \n```java\n\t// 추상메소드\n\tpublic abstract void cal();\n```\n**이 추상메소드는 이후에 상속받을 클래스에서 각각 재정의 되어 서로 다른 두개의 계산기능(일반계산, 연속계산)으로 구현될 것이다. 추상클래스의 확장 개념이 적용된 것이다.**\n\n<br><br><Br><br>\n\n**🔔 CalResult : 인터페이스**\n```java\npackage calculate_Ver_Interface;\n\npublic interface CalResult {\n\t// 결과출력 추상메소드\n\tvoid PrintResult();\n\t\n\t// 과정출력 추상메소드\n\tvoid PrintProcess();\n}\n```\n계산기는 **반드시 결과가 출력** 되어야만 한다. 위 코드에서는 연산과정과 계산결과를 출력하는게 목적이기 때문에 두개의 메소드를 인터페이스에 선언하였다. 두개의 메소드를 인터페이스에 선언함으로써 두개의 계산기 모두 위 인터페이스를 implements 하여 **동일한 형태의 결과출력을 강제하는 효과**를 가진다.\n\n<br><br><Br><br>\n\n**🔔 ContinuousCal : 추상클래스를 상속받는 연속계산 클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class ContinuousCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\n\t// 연속 계산 수행\n\t@Override\n\tpublic void cal() {\n\t\twhile (true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\n\t\t\t// 필요한 계산코드인데 생략\n\t\t\t\t\n\t\t\t\tdisplay();\n\t\t\t\t\n\t\t\t\t\n\t\t\t// 필요한 계산코드인데 생략\n\t\t}\n\t}\n\n```\n\n위의 코드는 연속계산을 수행하는 클래스로 추상클래스를 상속받아 ``` public void cal() ``` 을 오버라이딩 하여 사용했다. 코드는 너무 길어서 생략했다. \n\n<br><br><Br>\n\n**🔔 StandardCal : 추상클래스를 상속받는 일반계산 클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class StandardCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\n\t// 단일 계산 수행\n\t@Override\n\tpublic void cal() {\n\t\twhile(true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\t\t\t// 코드 이하 생략\n\t\t\t\t\tdisplay();\n\t\t\t// 코드 이하 생략\n\t\t}\n\t}\n```\n\n마찬가지로 추상클래스를 상속받아 ``` public void cal() ``` 을 오버라이딩 한 일반 계산 클래스이다. 코드를 지금 생략해놔서 그렇지 두 클래스의 ``` public void cal() ``` 코드는 서로 기능에 따라 다르게 구성되어 있다.\n\n다시 한번 언급하고 정리해보면 추상클래스에서 선언한 추상메소드 ```public abstract void cal()``` 을 두개의 계산기 클래스에서 **서로 기능에 맞게끔 다르게 오버라이딩 하여 확장 한 것이다**.\n\n그런데 계산기에서 결과를 출력해주는 인터페이스를 implements 하지 않았다. 원래는 그냥 implements 해버리고 결과출력 메소드 오버라이딩해서 결과출력 하면 되는데 그러면 너무 쉽게 해버리는거여서 살짝 공부도 해볼겸 다르게 해봤다.\n\n<br><br><br>\n\n**🔔 CalAbstract : 추상클래스내에 클래스 선언후 implements**\n```java\nprivate CalResult calResult;\n\t\n\t\n\t// 추상클래스 내에 클래스를 하나 만들어서 인터페이스를 implements해줌으로써 \n\t// calResult를 초기화할 수 있음.\n\tclass DefaultCalResultDisplay implements CalResult{\n\t\t\n\t\t@Override\n\t\tpublic void PrintResult() {\n\t\t\tSystem.out.println(\"결과 : \" + getResult());\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void PrintProcess() {\n\t\t\tSystem.out.println(\"연산 과정 : \" + getSb());\n\t\t}\n\t}\n```\n\n```java\n\tpublic void addDisplayResult(CalResult calResult) {\n\t\tthis.calResult = calResult;\n\t}\n\t\n\tpublic void display() {\n\t\tif(this.calResult == null) {\n\t\t\tDefaultCalResultDisplay defaultCalResultDisplay = new DefaultCalResultDisplay();\n\t\t\tdefaultCalResultDisplay.PrintProcess();\n\t\t\tdefaultCalResultDisplay.PrintResult();\n\t\t}\n\t\telse {\n\t\t\tcalResult.PrintProcess();\n\t\t\tcalResult.PrintResult();\n\t\t}\n\t}\n```\n**implements를 이런 방식으로도 할 수 있구나 정도로 알아두면 좋을것 같다. 실무에서는 이런방식으로 implements를 정말 많이 사용한다.**\n\n<br><br><br><br>\n\n## 정리\n**⚡ 인터페이스와 추상클래스는 둘다 추상메소드의 구현을 강제한다.**\n\n**⚡ 인터페이스와 추상클래스는 둘다 인스턴스화가 불가능하다**\n\n**⚡ 인터페이스와 추상클래스는 접근제어자의 사용범위가 다르다.**\n\n**⚡ 인터페이스는 메소드의 동일한 동작 강제, 추상클래스는 메소드의 기능 이용, 확장이 주된 목적이다.**\n\n**⚡ 인터페이스는 HAS-A, 추상클래스는 IS-A 개념**\n","properties":"\n","discussions":{},"comments":{},"hash":378031675,"tx":11225},"9MtDBGhyQQWuisRx/syncedContent":{"id":"9MtDBGhyQQWuisRx/syncedContent","type":"syncedContent","historyData":{"1042073771":{"id":"9MtDBGhyQQWuisRx/content","type":"content","text":"---\npermalink: /2022-08-12-객체지향 4대 특징/\npublished : true\ntitle: \"[JAVA] 객체지향 4대 특징 \"\ndate: 2022-08-12 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n\n이번 포스팅은 **객체지향 한방에 정리하기**이다. 학교다니면서도 공부를 했고 평소에도 면접준비하면서 공부를 했지만 여전히 헷갈리고 모르는 개념이 있기 때문에 내가 모르는 부분을 중심으로 객체지향을 쭉 정리해보려고 한다.\n\n23.06.13 필요한 내용을 좀더 추가했다!\n\n\n<br><br><br><br>\n\n## ✅  객체지향 프로그래밍이란?\n객체지향 프로그래밍(Object-Oriented Programming)이란 컴퓨터 프로그램을 어떤 데이터를 입력받아 순서대로 처리하고 결과를 도출하는 명령어들의 목록으로 보는 시각에서 벗어나 **여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임을 의미한다.**\n\n<br><br><br><br>\n\n## ✅  객체지향 프로그래밍의 장점\n객체 지향적 설계는 많은 이점이 있는데, 가장 큰 장점중 하나는 **프로그램을 보다 유연하고 변경이 용이하게 만들수 있다는 점이다.** 마치 컴퓨터 부품을 갈아 끼울 때, 해당 부품만 교체하고 나머지 부품은 건드리지 않아도 되는 것처럼 소프트웨어 설계시 객체지향적 원리를 잘 적용해두면 각각의 부품들이 **독립적인 역할**을 지니기 때문에 **코드의 변경을 최소화하고 유지보수하는데 유리하다.**\n\n**코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현 할 수 있다.**\n\n**접근제어자와 메서드**를 이용해 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다. 이를 통해 **신뢰성이 높은 프로그래밍을 가능하게 한다.**\n\n간단하게 정리하면 **\"코드의 재사용성이 높고 유지보수가 용이하며, 중복된 코드의 제거가 가능하다\"** 이러한 장점은 객체지향의 4대 특징에서 비롯되는데 그 특징들에 대해 알아보자.\n\n<br><br><br><br>\n\n## ✅ 객체지향 4대 특징\n\n### 📌 추상화\n\n비슷한 역할을 하는 attribute나 method를 묶어서 하나의 모델로 만들어 내는 것. 한마디로 **공통성과 본질을 모아 추출하는 모델링**을 의미한다. 다형성, 상속 모두 추상화에 속한다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/객체1.png?raw=true\">\n</p>\n<br>\n위의 예시를 보면 **자동차와 오토바이는 모두 이동수단**이고, 이동수단은 **출발, 전진과 후진을 할 수 있다는 공통점**을 가진다. 이를 객체지향적 사고를 통해 표현하면 자동차와 오토바이라는 **하위클래스들의 공통적인 메소드를 추출하여 이동수단이라는 상위클래스에 정의**한 것이다. \n\n이를 코드로 표현하면 다음과 같다. 참고로 자바에서 추상화를 구현할 수 있는 문법 요소로는 **추상클래스**와 **인터페이스**가 있는데, 이번 예제에서는 인터페이스를 사용해보겠다.\n\n<br><br>\n\n```java\npublic interface Vehicle {\n\tpublic abstract void start();    // 추상메소드\n\tvoid moveForward();              // public abstract 키워드 생략 가능\n\tvoid moveBackward();\n}\n```\n\n가장 먼저 자동차와 오토바이의 공통적인 기능인 출발, 전진, 후진 기능을 추출해서 이동수단 인터페이스에 정의한다. \n\n<br><br>\n\n```java\npublic class Car implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"자동차 전진\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"자동차 후진\");\n\t}\n}\n```\n\n```java\npublic class MotorBike implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"오토바이 전진\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"오토바이 후진\");\n\t}\n}\n```\n\n위의 코드를 보면 인터페이스 Vehicle에서 선언한 `moveForward()`와 `moveBackward()` 를 각각의 클래스의 맥락에 맞게 구현한 것을 볼 수 있다. 자동차와 오토바이 모두 전진,후진의 기능을 공통적으로 가지기때문에 이동수단의 메소드를 가져와 사용하지만, 자동차 클래스는 자동차를 전진시켜야하고 오토바이 클래스는 오토바이를 전진시켜야 하기때문에 각 클래스마다 필요한 기능으로 달리 구현했다.\n\n이런 일련의 과정을 **역할과 구현의 분리**라고 표현하고, 객체지향의 특징인 **추상화** 이다.\n\n<br><br><br>\n\n### 📌 상속\n\n상위 클래스의 메소드, 변수등의 특징을 하위 클래스가 물려받는 것을 의미한다.\n\n앞서 살펴본 추상화의 연장선에서, 상속은 클래스 간 공유 될 수 있는 속성과 기능들을 상위클래스로 추상화시켜 **상위클래스로부터 확장된 여러개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 한다.**\n\n이를 통해 속성과 기능을 재사용할 수 있고 반복적인 코드를 최소화할 수 있다. JAVA에서는 **extends** 를 사용해 상속을 지원한다. 또한 **하나의 클래스는 한번의 상속만 가능하다.**  (= 하나의 상위클래스만 가질 수 있다)\n<br><br><br>\n\n\n### 📌 다형성\n다형성이란 **어떤 객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 성질을 의미한다.** \n\n비유적으로 표현하면 어떤 중년의 남성이 있다고 했을 때 그 남자의 역할이 아내에게는 남편, 자식에게는 아버지, 부모님에게는 자식, 회사에서는 회사원, 동아리에서는 리더 등 상황과 환경에 따라서 달라지는 것과 비슷하다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/객체2.png?raw=true\">\n</p>\n\n<br>\n객체지향에서의 다형성도 이와 비슷한데, **어떤 객체의 속성이나 기능이 맥락에 따라 다른역할을 수행할 수 있는 객체지향의 특성**을 의미한다. 대표적인 예로는 메서드 **오버라이딩(Override)과 오버로딩(Overload)**이 있다.\n\n<br><br>\n\n\n**Vehicle 인터페이스**\n\n```java\npublic interface Vehicle {\n\tpublic abstract void start();\n\tvoid moveForward();\n\tvoid moveBackward();\n}\n```\n\n<br>\n\n**Car 클래스**\n```java\npublic class Car implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"자동차가 앞으로 전진합니다\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"자동차가 뒤로 후진합니다\");\n\t}\n}\n```\n\n오버라이딩을 사용하면 같은 이름의 `moveForward()`와 `moveBackward()`를 각각의 클래스의 맥락에 맞게 재정의해서 사용할 수 있다. 즉, **같은 이름의 메소드가 상황에 따라 다른 역할을 수행하는 것**이다. 또한 **하나의 클래스 내에서 같은 이름의 메서드를 여러개 중복하여 정의하는 메서드 오버로딩** 역시 같은 맥락이다.\n\n둘다 다형성을 사용하는 개념이고 같은 이름의 다른 함수를 호출한다는 공통점이 있다.\n\n- **오버로딩(Overloading)** : 함수의 이름은 같지만 매개변수의 타입이나 갯수가 다른 메소드를 만드는 것을 의미한다. \n return 타입은 동일하거나 다를 수 있지만, return 타입만 다를 수는 없다. \n\n- **오버라이딩(Overriding)** : 상위클래스나 인터페이스에 있는 메소드를 재정의 하는 것을 의미한다.\n\n<br><br><br>\n\n### **📌 캡슐화(정보은닉)**\n\n특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶은것. 한마디로 **모듈화**를 의미한다.\n정보를 객체 안에 포함시키고, 정보에 대한 직접적인 접근은 허용하지 않으며, **접근제어자**를 통해 정보의 **공개정도**를 조절할 수 있다.\n\n자바의 캡슐화는 **외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출 될 수 있도록 하여 각 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적**이 있다.\n\n이러한 캡슐화는 크게 두가지 방법으로 자바에서 구현될 수 있다. 첫번째로는 **접근제어자**를 활용하는 것이다. 접근제어자는 **클래스나 클래스 멤버들에 사용되어 해당 클래스나 멤버들을 외부에서 접근하지 못하도록 접근을 제한하는 역할**을 한다.\n\n<br>\n\n- **Public : 접근 제한이 전혀 없다**\n\n- **Protected : 상속클래스 및 같은 패키지에서만 사용 가능**\n\n- **Default : 같은 패키지 내에서 사용 가능**\n\n- **Private : 정의된 클래스 내부에서만 사용 가능. Getter,Setter를 이용해 정보 접근 or 수정**\n\n<br>\n\n|접근제어자|같은 클래스| 같은 패키지| 하위클래스 | 전체| \n|--|--|--|--|--|\n|public  |  o |o |o |o |\n|protected  |  o |o |o |x |\n|default  |  o |o |x |x |\n|private  |  o |x |x |x |\n\n\n<br><br><br><br>\n\n**객체지향의 4대 특징은 굉장히 중요하다. 4가지 특징의 의미를 달달 외울게 아니라 그 특징을 실제 코드에 잘 녹여내리는 것이 중요하다. 코드를 짤 때 이 4가지 특징을 잘 이해하고 적용시키면 훨씬 효율적인 코드가 될 수 있음을 명심하자.**\n","properties":"\n","discussions":{},"comments":{},"hash":1042073771},"-1315792411":{"id":"9MtDBGhyQQWuisRx/content","type":"content","text":"---\npermalink: /2022-08-12-객체지향 4대 특징/\npublished : true\ntitle: \"[JAVA] 객체지향 4대 특징 \"\ndate: 2022-08-12 01:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n\n이번 포스팅은 **객체지향 한방에 정리하기**이다. 학교다니면서도 공부를 했고 평소에도 면접준비하면서 공부를 했지만 여전히 헷갈리고 모르는 개념이 있기 때문에 내가 모르는 부분을 중심으로 객체지향을 쭉 정리해보려고 한다.\n\n23.06.13 필요한 내용을 좀더 추가했다!\n\n\n<br><br><br><br>\n\n## ✅  객체지향 프로그래밍이란?\n객체지향 프로그래밍(Object-Oriented Programming)이란 컴퓨터 프로그램을 어떤 데이터를 입력받아 순서대로 처리하고 결과를 도출하는 명령어들의 목록으로 보는 시각에서 벗어나 **여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임을 의미한다.**\n\n<br><br><br><br>\n\n## ✅  객체지향 프로그래밍의 장점\n객체 지향적 설계는 많은 이점이 있는데, 가장 큰 장점중 하나는 **프로그램을 보다 유연하고 변경이 용이하게 만들수 있다는 점이다.** 마치 컴퓨터 부품을 갈아 끼울 때, 해당 부품만 교체하고 나머지 부품은 건드리지 않아도 되는 것처럼 소프트웨어 설계시 객체지향적 원리를 잘 적용해두면 각각의 부품들이 **독립적인 역할**을 지니기 때문에 **코드의 변경을 최소화하고 유지보수하는데 유리하다.**\n\n**코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현 할 수 있다.**\n\n**접근제어자와 메서드**를 이용해 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다. 이를 통해 **신뢰성이 높은 프로그래밍을 가능하게 한다.**\n\n간단하게 정리하면 **\"코드의 재사용성이 높고 유지보수가 용이하며, 중복된 코드의 제거가 가능하다\"** 이러한 장점은 객체지향의 4대 특징에서 비롯되는데 그 특징들에 대해 알아보자.\n\n<br><br><br><br>\n\n## ✅ 객체지향 4대 특징\n\n### 📌 추상화\n\n비슷한 역할을 하는 attribute나 method를 묶어서 하나의 모델로 만들어 내는 것. 한마디로 **공통성과 본질을 모아 추출하는 모델링**을 의미한다. 다형성, 상속 모두 추상화에 속한다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/객체1.png?raw=true\">\n</p>\n<br>\n위의 예시를 보면 **자동차와 오토바이는 모두 이동수단**이고, 이동수단은 **출발, 전진과 후진을 할 수 있다는 공통점**을 가진다. 이를 객체지향적 사고를 통해 표현하면 자동차와 오토바이라는 **하위클래스들의 공통적인 메소드를 추출하여 이동수단이라는 상위클래스에 정의**한 것이다. \n\n이를 코드로 표현하면 다음과 같다. 참고로 자바에서 추상화를 구현할 수 있는 문법 요소로는 **추상클래스**와 **인터페이스**가 있는데, 이번 예제에서는 인터페이스를 사용해보겠다.\n\n<br><br>\n\n```java\npublic interface Vehicle {\n\tpublic abstract void start();    // 추상메소드\n\tvoid moveForward();              // public abstract 키워드 생략 가능\n\tvoid moveBackward();\n}\n```\n\n가장 먼저 자동차와 오토바이의 공통적인 기능인 출발, 전진, 후진 기능을 추출해서 이동수단 인터페이스에 정의한다. \n\n<br><br>\n\n```java\npublic class Car implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"자동차 전진\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"자동차 후진\");\n\t}\n}\n```\n\n```java\npublic class MotorBike implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"오토바이 전진\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"오토바이 후진\");\n\t}\n}\n```\n\n위의 코드를 보면 인터페이스 Vehicle에서 선언한 `moveForward()`와 `moveBackward()` 를 각각의 클래스의 맥락에 맞게 구현한 것을 볼 수 있다. 자동차와 오토바이 모두 전진,후진의 기능을 공통적으로 가지기때문에 이동수단의 메소드를 가져와 사용하지만, 자동차 클래스는 자동차를 전진시켜야하고 오토바이 클래스는 오토바이를 전진시켜야 하기때문에 각 클래스마다 필요한 기능으로 달리 구현했다.\n\n이런 일련의 과정을 **역할과 구현의 분리**라고 표현하고, 객체지향의 특징인 **추상화** 이다.\n\n<br><br><br>\n\n### 📌 상속\n\n상위 클래스의 메소드, 변수등의 특징을 하위 클래스가 물려받는 것을 의미한다.\n\n앞서 살펴본 추상화의 연장선에서, 상속은 클래스 간 공유 될 수 있는 속성과 기능들을 상위클래스로 추상화시켜 **상위클래스로부터 확장된 여러개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 한다.**\n\n이를 통해 속성과 기능을 재사용할 수 있고 반복적인 코드를 최소화할 수 있다. JAVA에서는 **extends** 를 사용해 상속을 지원한다. 또한 **하나의 클래스는 한번의 상속만 가능하다.**  (= 하나의 상위클래스만 가질 수 있다)\n<br><br><br>\n\n\n### 📌 다형성\n다형성이란 **어떤 객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 성질을 의미한다.** \n\n비유적으로 표현하면 어떤 중년의 남성이 있다고 했을 때 그 남자의 역할이 아내에게는 남편, 자식에게는 아버지, 부모님에게는 자식, 회사에서는 회사원, 동아리에서는 리더 등 상황과 환경에 따라서 달라지는 것과 비슷하다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/객체2.png?raw=true\">\n</p>\n\n<br>\n객체지향에서의 다형성도 이와 비슷한데, **어떤 객체의 속성이나 기능이 맥락에 따라 다른역할을 수행할 수 있는 객체지향의 특성**을 의미한다. 대표적인 예로는 메서드 **오버라이딩(Override)과 오버로딩(Overload)**이 있다.\n\n<br><br>\n\n\n**Vehicle 인터페이스**\n\n```java\npublic interface Vehicle {\n\tpublic abstract void start();\n\tvoid moveForward();\n\tvoid moveBackward();\n}\n```\n\n<br>\n\n**Car 클래스**\n```java\npublic class Car implements Vehicle {\n\t@Override\n\tpublic void moveForward(){\n\t\tSystem.out.println(\"자동차가 앞으로 전진합니다\");\n\t}\n\n\t@Override\n\tpublic void moveBackward(){\n\t\tSystem.out.println(\"자동차가 뒤로 후진합니다\");\n\t}\n}\n```\n\n오버라이딩을 사용하면 같은 이름의 `moveForward()`와 `moveBackward()`를 각각의 클래스의 맥락에 맞게 재정의해서 사용할 수 있다. 즉, **같은 이름의 메소드가 상황에 따라 다른 역할을 수행하는 것**이다. 또한 **하나의 클래스 내에서 같은 이름의 메서드를 여러개 중복하여 정의하는 메서드 오버로딩** 역시 같은 맥락이다.\n\n둘다 다형성을 사용하는 개념이고 같은 이름의 다른 함수를 호출한다는 공통점이 있다.\n\n- **오버로딩(Overloading)** : 함수의 이름은 같지만 매개변수의 타입이나 갯수가 다른 메소드를 만드는 것을 의미한다. \n return 타입은 동일하거나 다를 수 있지만, return 타입만 다를 수는 없다. \n\n- **오버라이딩(Overriding)** : 상위클래스나 인터페이스에 있는 메소드를 재정의 하는 것을 의미한다.\n\n<br><br><br>\n\n### **📌 캡슐화(정보은닉)**\n\n특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶은것. 한마디로 **모듈화**를 의미한다.\n정보를 객체 안에 포함시키고, 정보에 대한 직접적인 접근은 허용하지 않으며, **접근제어자**를 통해 정보의 **공개정도**를 조절할 수 있다.\n\n자바의 캡슐화는 **외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출 될 수 있도록 하여 각 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적**이 있다.\n\n이러한 캡슐화는 크게 두가지 방법으로 자바에서 구현될 수 있다. 첫번째로는 **접근제어자**를 활용하는 것이다. 접근제어자는 **클래스나 클래스 멤버들에 사용되어 해당 클래스나 멤버들을 외부에서 접근하지 못하도록 접근을 제한하는 역할**을 한다.\n\n<br>\n\n- **Public : 접근 제한이 전혀 없다**\n\n- **Protected : 상속클래스 및 같은 패키지에서만 사용 가능**\n\n- **Default : 같은 패키지 내에서 사용 가능**\n\n- **Private : 정의된 클래스 내부에서만 사용 가능. Getter,Setter를 이용해 정보 접근 or 수정**\n\n<br>\n\n|접근제어자|같은 클래스| 같은 패키지| 하위클래스 | 전체| \n|--|--|--|--|--|\n|public  |  o |o |o |o |\n|protected  |  o |o |o |x |\n|default  |  o |o |x |x |\n|private  |  o |x |x |x |\n\n\n<br><br><br><br>\n\n**객체지향의 4대 특징은 굉장히 중요하다. 4가지 특징의 의미를 달달 외울게 아니라 그 특징을 실제 코드에 잘 녹여내리는 것이 중요하다. 코드를 짤 때 이 4가지 특징을 잘 이해하고 적용시키면 훨씬 효율적인 코드가 될 수 있음을 명심하자.**\n","properties":"\n","discussions":{},"comments":{},"hash":-1315792411}},"syncHistory":{"main":[1042073771,-1315792411,1042073771]},"v":1,"hash":1710892093367,"tx":11228},"7LHwr5vMhDvsF6qJ/content":{"id":"7LHwr5vMhDvsF6qJ/content","type":"content","text":"---\npermalink: /2022-08-17-자바 빈(JAVA Bean)/\npublished: true\ntitle: \"[JAVA] 자바 빈(JAVA Bean)\"\ndate: 2022-08-17 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"자바 빈(JAVA Bean)\"\ncategories:\n- JAVA\ntags:\n- JAVA\n\n---\n\n<br><br><br>\n\n## 자바 빈(JAVA Bean)이란 ?\n자바의 재활용 가능한 [컴포넌트](https://hanamon.kr/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component%EB%9E%80/) 모델을 일컫는 말로 **데이터 표현**을 목적으로 하는 **자바 클래스**이다. 자바 빈즈 클래스로서 작동하기 위해서, 객체 클래스는 **정해진 관례(Java Beans Convention)** 를 따라야만 한다. Java Beans Convention은 다음과 같다.\n\n<br><br><br>\n\n-   클래스는 인자(Argument)가 없는 기본 생성자(Default constructor)를 갖는다\n-   클래스의 멤버 변수는 프로퍼티(Properties)라고 하며 private 접근 제한자를 가져야 한다.\n-   클래스의 프로퍼티들은 Getter/Setter를 통해 접근할 수 있어야 한다\n\n-   Getter의 이름은 get{프로퍼티 이름} 이며, Setter의 이름은 set{프로퍼티 이름}이다\n-   Getter/setter의 접근 제한자는 public이어야 한다.\n-   프로퍼티의 타입이 Boolean인 경우 is로 시작할 수 있다\n-   Getter의 경우 파라미터가 존재하지않아야 하며, setter의 경우 하나 이상의 파라미터가 존재한다\n-   Read Only인 경우 Setter는 없을 수 있다.\n\n-   Serializable 인터페이스를 implements 한다.\n-   자바빈 클래스는 패키징 되어야 한다. (Package)\n\n<br><br>\n\n바로 예제를 통해 알아보자.\n\n<br><br>\n\n\n**🧑 PersonBean.java**\n\n```java\npublic class PersonBean implements java.io.Serializable\n{\n    private String name;\n    private boolean coding;\n\n    // 기본 생성자 (인자가 없는).\n    public PersonBean()\n    {\n\n    }\n\n    public String getName()\n    {\n        return this.name;\n    }\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    // Different semantics for a boolean field (is vs. get)\n\n    public boolean isCoding()\n    {\n        return this.coding;\n    }\n\n    public void setCoding(boolean coding)\n    {\n        this.coding = coding;\n    }\n}\n```\n<br>\n\n**🧑 TestPersonBean.java**\n```java\npublic class TestPersonBean\n{\n    public static void main(String[] args)\n    {\n\n        PersonBean person = new PersonBean();\n        person.setName(\"Bob\");\n        person.setCoding(true);\n\n        // Output: \"Bob [coding]\"\n        System.out.print(person.getName());\n        System.out.println(person.isCoding() ? \" [coding]\" : \"\");\n    }\n}\n```\n\n\n<br><br><br><br>\n\n## 자바 빈(JAVA Bean) 사용 목적\n자바 빈은 **JSP**에서 객체를 가져오기 위한 클래스로 **DTO (Data Transfer Object)** 라고도 한다. JSP 페이지에 View 부분과 로직이 섞여있어 복잡해 보이는 구성을 피하기 위해 JSP 페이지의 로직 부분을 분리해서 자바 빈으로 구성함으로써 **코드의 재사용성을 높이고 프로그램의 효율을 높일 수 있다**.\n","properties":"\n","discussions":{},"comments":{},"hash":1908325863,"tx":11229},"O7ZdI0GnNZ8IGhYW/syncedContent":{"id":"O7ZdI0GnNZ8IGhYW/syncedContent","type":"syncedContent","historyData":{"1237047638":{"id":"O7ZdI0GnNZ8IGhYW/content","type":"content","text":"---\npermalink: /2022-08-12-인터페이스/\npublished: true\ntitle: \"[JAVA] 인터페이스\"\ndate: 2022-08-12 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n2023.06.15 내용보완\n<br><br>\n## ✅ 인터페이스란?\n\n자바 개발 뿐만아니라 자바기반 개발을 하면 인터페이스는 굉장히 중요하고 빈번하게 사용된다. 인터페이스란 뭘까?  \n\n\n **동일한  목적  하에  동일한  기능을  보장하게  하기  위함!**\n**자바의 다형성, 추상화를 이용하여 코드 수정을 줄이고 유지보수성을 높인다!**\n\n이렇게 크게 두가지 정도로 볼 수 있다. 좀더 자세하게 알아보자.\n<br><br><br>\n\n자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가질 수 있다.\n\n하지만 클래스를 이용하여 다중 상속을 할 경우  메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은  지원하지 않는다.\n\n하지만 다중 상속의 이점을 버릴 수는 없기에 자바에서는 인터페이스라는 것을  통해 다중 상속을 지원하고 있다.\n\n<br><br><br>\n\n**인터페이스(interface)란** **다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지  담당하는 일종의 추상 클래스를 의미한다.**\n\n<br><br><br>\n\n자바에서 **추상클래스**는 **추상메소드, 생성자, 변수, 심지어 일반 메소드(구현부 포함)** 도 포함 될 수 있다. \n그러나 **인터페이스**에서는 **추상메소드, 상수, 정적 메소드, 디폴트메소드** 를 포함 할 수 있다.\n\n<br><br><br><br>\n\n## ✅ 인터페이스 선언\n인터페이스는 추상클래스와 마찬가지로 자신이 직접 인스턴스를 생성 할 수 없다. **한마디로 다른 클래스에서 객체로 생성 될 수 없다는 뜻이다**. 때문에 다른 클래스에서 인터페이스를 사용하기 위해서는 다음과 같은 문법을 통해 구현한다.\n\n```java\npublic class 클래스이름 implements 인터페이스이름 {...}\n```\n\n<br><br><br><br>\n\n## ✅ 인터페이스 구현\n\n인터페이스에서 구현할 수 있는 **상수, 추상메소드, 디폴트메소드, 정적메소드** 4가지를 활용한 코드를 보자.\n<br>\n\n```java\npublic interface CalResult {\n\n\t// 계산기에서 입력될 수 있는 최대값\n\t// 상수\n\tpublic static final int MAX_INTEGER = 999999999;\n\n\t// 계산 결과 출력\n\t// 추상 메소드\n\t// public abstract는 생략가능하다\n\tpublic abstract void PrintResult(double result);\n\t\n\t// 연산 과정 출력\n\t// 추상 메소드\n\tvoid PrintProcess(StringBuffer sb);\n\t\n\n\t\n\t// 디폴트메소드 : 인터페이스에서 기본적으로 제공해주지만, \n\t// 각자 구현해서 쓸수 있다. (선택적)\n\tdefault void Display(StringBuffer sb, double result){\n\t\tPrintProcess(sb);\n\t\tPrintResult(result);\n\t\tPrintFinish();\n\t}\n\t\n\t// 정적메소드 : 인터페이스에서 제공해주는 것으로 무조건 사용 ( 절대적 )\n\tstatic void PrintFinish(){\n\t\tSystem.out.println(\"계산끝났당오예~!\");\n\t}\n}\n```\n<br>\n\n\n- **상수** : 인터페이스에서 값을 정해줄테니 함부로 바꾸지 말고 제공해주는 값만 참조하라 **(절대적)**\n\n- **추상메소드** : 가이드만 줄테니 추상메소드를 오버라이딩해서 재구현해라 **(강제적)**\n\n- **디폴트메소드** : 인터페이스에서 기본적으로 제공해주지만, 각자 구현해서 쓸수 있다. **(선택적)**\n\n- **정적메소드** : 인터페이스에서 제공해주는 있는 그대로 사용. 즉 오버라이딩 불가 **(절대적)**\n\n<br><br><br>\n\n\n### 📌 상수 \n\n인터페이스에서 선언한 상수는 항상 ```public static final``` 형태로 저장되므로 **다른 클래스에서 변경 할 수 없다**. 위에 (절대적)이라고 써놓은 이유이다. 그러나 자료를 찾아보니 인터페이스에서 상수를 선언하는 것은 **Anti-Pattern, 즉 사용을 지양해야하는 디자인 패턴** 이라는 주장이 많았다. 되도록 사용하지 않는게 좋아보인다.\n\n<br><br>\n\n### 📌추상메소드\n\n추상클래스의 추상메소드와 같다. ```접근제어자 abstract 반환 타입 클래스명 (자료형 변수명); ``` 의 형태로 선언하면 된다. 예를들면 `public abstract void Print(String str)` 이런식으로 선언할 수 있다. 이때 접근제어자와 abstract는 생략 가능하다. \n\n 추상메소드는 구현부는 따로 설정하지 않고 상속받은 클래스에서 **오버라이딩**해서 사용하도록 한다. **이때, 추상클래스든 인터페이스든 선언된 추상메소드는 반드시 오버라이딩을 통해 재구현 되어야만 한다!** 위에 (강제적) 이라고 써놓은 이유이다.\n\n<br><br>\n\n### 📌디폴트메소드\n\n원래 인터페이스에서는 추상메소드와 상수만 사용해서 제약을 많이 걸어뒀지만 JAVA8부터 디폴트메소드와 정적메소드를 추가하여 인터페이스의 범용성을 높였다. \n\n디폴트 메소드는 ```default 접근제어자 메소드명 ( 자료형 변수명 );``` 의 형태로 선언한다.  **디폴트 메소드는 상속받은 클래스에서 반드시 사용할 필요는 없다**. 필요에 따라 사용유무를 결정하면 된다. \n\n<Br>\n\n디폴트 메소드를 쓰는 경우의 예시를 들어보자. 내가 사칙연산 기능만 가지고 있는 계산기 프로그램을 만들어서 A,B,C 라는 사람에게 배포했다고 치자. 그런데 A라는 사람이 사칙연산 뿐만 아니라 공학용 계산기를 만들어달라고 한다. 공학용 계산기를 처음부터 다시 만드는건 어려우니 기존 사칙연산 계산기에 공학용 기능을 추가해서 배포하려고 한다. \n\n이때 인터페이스에 **추상메소드로 공학용 기능을 추가해서 배포하면 공학용 기능이 필요하지 않은 B,C도 공학용 메소드를 반드시 오버라이딩 해야 하는 불필요한 작업이 추가된다.** 때문에 **공학용 메소드를 디폴트 메소드로 정의하면 A만 따로 메소드를 추가해서 사용할 수 있는 이점이 생긴다.** 이런 이유로 위에 (선택적) 이라고 적어놓은 것이다.\n\n<br><br><br>\n\n### 📌정적 메소드\n\n인터페이스에서 제공한 메소드 그대로 사용해야만 한다. ```static 접근제어자 클래스명 (자료형 변수명)``` 형태로 사용한다. 반드시 써야하는 메소드는 아니고 필요에 따라 선언하면 된다.\n\t\n\n<br><br><br><br>\n\n## ✅ 인터페이스의 장점\n1. 대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화가 가능하다. \n-> **객체지향의 다형성**\n3. 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발시간을 단축할 수 있다.\n4. 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 상속구조 없이 독립적인 프로그래밍이 가능하다.\n","properties":"\n","discussions":{},"comments":{},"hash":1237047638},"-1710999460":{"id":"O7ZdI0GnNZ8IGhYW/content","type":"content","text":"---\npermalink: /2022-08-12-인터페이스/\npublished: true\ntitle: \"[JAVA] 인터페이스\"\ndate: 2022-08-12 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n\n<br><br>\n2023.06.15 내용보완\n<br><br>\n## ✅ 인터페이스란?\n\n자바 개발 뿐만아니라 자바기반 개발을 하면 인터페이스는 굉장히 중요하고 빈번하게 사용된다. 인터페이스란 뭘까?  \n\n\n **동일한  목적  하에  동일한  기능을  보장하게  하기  위함!**\n**자바의 다형성, 추상화를 이용하여 코드 수정을 줄이고 유지보수성을 높인다!**\n\n이렇게 크게 두가지 정도로 볼 수 있다. 좀더 자세하게 알아보자.\n<br><br><br>\n\n자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가질 수 있다.\n\n하지만 클래스를 이용하여 다중 상속을 할 경우  메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은  지원하지 않는다.\n\n하지만 다중 상속의 이점을 버릴 수는 없기에 자바에서는 인터페이스라는 것을  통해 다중 상속을 지원하고 있다.\n\n<br><br><br>\n\n**인터페이스(interface)란** **다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지  담당하는 일종의 추상 클래스를 의미한다.**\n\n<br><br><br>\n\n자바에서 **추상클래스**는 **추상메소드, 생성자, 변수, 심지어 일반 메소드(구현부 포함)** 도 포함 될 수 있다. \n그러나 **인터페이스**에서는 **추상메소드, 상수, 정적 메소드, 디폴트메소드** 를 포함 할 수 있다.\n\n<br><br><br><br>\n\n## ✅ 인터페이스 선언\n인터페이스는 추상클래스와 마찬가지로 자신이 직접 인스턴스를 생성 할 수 없다. **한마디로 다른 클래스에서 객체로 생성 될 수 없다는 뜻이다**. 때문에 다른 클래스에서 인터페이스를 사용하기 위해서는 다음과 같은 문법을 통해 구현한다.\n\n```java\npublic class 클래스이름 implements 인터페이스이름 {...}\n```\n\n<br><br><br><br>\n\n## ✅ 인터페이스 구현\n\n인터페이스에서 구현할 수 있는 **상수, 추상메소드, 디폴트메소드, 정적메소드** 4가지를 활용한 코드를 보자.\n<br>\n\n```java\npublic interface CalResult {\n\n\t// 계산기에서 입력될 수 있는 최대값\n\t// 상수\n\tpublic static final int MAX_INTEGER = 999999999;\n\n\t// 계산 결과 출력\n\t// 추상 메소드\n\t// public abstract는 생략가능하다\n\tpublic abstract void PrintResult(double result);\n\t\n\t// 연산 과정 출력\n\t// 추상 메소드\n\tvoid PrintProcess(StringBuffer sb);\n\t\n\n\t\n\t// 디폴트메소드 : 인터페이스에서 기본적으로 제공해주지만, \n\t// 각자 구현해서 쓸수 있다. (선택적)\n\tdefault void Display(StringBuffer sb, double result){\n\t\tPrintProcess(sb);\n\t\tPrintResult(result);\n\t\tPrintFinish();\n\t}\n\t\n\t// 정적메소드 : 인터페이스에서 제공해주는 것으로 무조건 사용 ( 절대적 )\n\tstatic void PrintFinish(){\n\t\tSystem.out.println(\"계산끝났당오예~!\");\n\t}\n}\n```\n<br>\n\n\n- **상수** : 인터페이스에서 값을 정해줄테니 함부로 바꾸지 말고 제공해주는 값만 참조하라 **(절대적)**\n\n- **추상메소드** : 가이드만 줄테니 추상메소드를 오버라이딩해서 재구현해라 **(강제적)**\n\n- **디폴트메소드** : 인터페이스에서 기본적으로 제공해주지만, 각자 구현해서 쓸수 있다. **(선택적)**\n\n- **정적메소드** : 인터페이스에서 제공해주는 있는 그대로 사용. 즉 오버라이딩 불가 **(절대적)**\n\n<br><br><br>\n\n\n### 📌 상수 \n\n인터페이스에서 선언한 상수는 항상 ```public static final``` 형태로 저장되므로 **다른 클래스에서 변경 할 수 없다**. 위에 (절대적)이라고 써놓은 이유이다. 그러나 자료를 찾아보니 인터페이스에서 상수를 선언하는 것은 **Anti-Pattern, 즉 사용을 지양해야하는 디자인 패턴** 이라는 주장이 많았다. 되도록 사용하지 않는게 좋아보인다.\n\n<br><br>\n\n### 📌추상메소드\n\n추상클래스의 추상메소드와 같다. ```접근제어자 abstract 반환 타입 클래스명 (자료형 변수명); ``` 의 형태로 선언하면 된다. 예를들면 `public abstract void Print(String str)` 이런식으로 선언할 수 있다. 이때 접근제어자와 abstract는 생략 가능하다. \n\n 추상메소드는 구현부는 따로 설정하지 않고 상속받은 클래스에서 **오버라이딩**해서 사용하도록 한다. **이때, 추상클래스든 인터페이스든 선언된 추상메소드는 반드시 오버라이딩을 통해 재구현 되어야만 한다!** 위에 (강제적) 이라고 써놓은 이유이다.\n\n<br><br>\n\n### 📌디폴트메소드\n\n원래 인터페이스에서는 추상메소드와 상수만 사용해서 제약을 많이 걸어뒀지만 JAVA8부터 디폴트메소드와 정적메소드를 추가하여 인터페이스의 범용성을 높였다. \n\n디폴트 메소드는 ```default 접근제어자 메소드명 ( 자료형 변수명 );``` 의 형태로 선언한다.  **디폴트 메소드는 상속받은 클래스에서 반드시 사용할 필요는 없다**. 필요에 따라 사용유무를 결정하면 된다. \n\n<Br>\n\n디폴트 메소드를 쓰는 경우의 예시를 들어보자. 내가 사칙연산 기능만 가지고 있는 계산기 프로그램을 만들어서 A,B,C 라는 사람에게 배포했다고 치자. 그런데 A라는 사람이 사칙연산 뿐만 아니라 공학용 계산기를 만들어달라고 한다. 공학용 계산기를 처음부터 다시 만드는건 어려우니 기존 사칙연산 계산기에 공학용 기능을 추가해서 배포하려고 한다. \n\n이때 인터페이스에 **추상메소드로 공학용 기능을 추가해서 배포하면 공학용 기능이 필요하지 않은 B,C도 공학용 메소드를 반드시 오버라이딩 해야 하는 불필요한 작업이 추가된다.** 때문에 **공학용 메소드를 디폴트 메소드로 정의하면 A만 따로 메소드를 추가해서 사용할 수 있는 이점이 생긴다.** 이런 이유로 위에 (선택적) 이라고 적어놓은 것이다.\n\n<br><br><br>\n\n### 📌정적 메소드\n\n인터페이스에서 제공한 메소드 그대로 사용해야만 한다. ```static 접근제어자 클래스명 (자료형 변수명)``` 형태로 사용한다. 반드시 써야하는 메소드는 아니고 필요에 따라 선언하면 된다.\n\t\n\n<br><br><br><br>\n\n## ✅ 인터페이스의 장점\n1. 대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화가 가능하다. \n-> **객체지향의 다형성**\n3. 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발시간을 단축할 수 있다.\n4. 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 상속구조 없이 독립적인 프로그래밍이 가능하다.\n","properties":"\n","discussions":{},"comments":{},"hash":-1710999460}},"syncHistory":{"main":[1237047638,-1710999460,1237047638]},"v":1,"hash":1710892095879,"tx":11232},"hsMOxKWCChERUD8N/content":{"id":"hsMOxKWCChERUD8N/content","type":"content","text":"---\npermalink: /2022-09-01-익명 클래스/\npublished: true\ntitle: \"[JAVA] 익명 클래스 \"\ndate: 2022-09-01 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 익명 클래스\n---\n\n<br><br>\n\n## ✅ 익명 클래스란?\n\n**익명 클래스**란 **이름을 갖지 않는 클래스**이다. **클래스 선언과 오브젝트 생성이 결합된 형태**로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용해서 정해진 형태로 만들어 사용한다. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.\n```java\nnew 인터페이스이름() { 클래스 본문 };\n```\n<br><br>\n\n이해를 위해 간단한 예시를 들어보면, 생명체라는 부모클래스를 상속받는 사람 클래스가 있다고 치자. 사람은 총 60억명 있고, 이들은 각각 직업에 따라 하는 일이 다르며, 공통적인 특징은 없다. 잠깐 프로그램에 **단발성으로 등장해서 자신이 맡은 일을 하고 사라진다**고 치자.\n\n<br><br>\n\n그러면 이런상황에서 우리가 60억명의 사람들을 클래스로 만들어 구현하는 것이 나을지, 아니면 하**나의 클래스에서 코드로 일시적으로 정의하여 쓰고 버리는것이 나을지** 선택하면 된다. 아마 60억개의 클래스를 만들 사람은 없을거다. \n\n<br><br>\n\n어차피 단발성으로 등장해서 사용하고 다시는 안 쓸 오브젝트들 인데 클래스로 만들어서 유지보수 하기에는 부담이 너무 크고 불필요하다.\n\n<br><br>\n\n이럴때 바로 우리는 **익명 클래스**를 사용하는 것이다!\n<br><br><Br><br>\n\n## ✅ 익명 클래스 구현 ( 인터페이스 )\n\n#### 📌 인터페이스\n```java\npublic interface StatementStrategy {\n\tPreparedStatement makePreparedStatement(Connection c) throws SQLException;\n}\n```\n<br>\n\n#### 📌 일반 클래스 ( 이 클래스를 익명 클래스로 전환 할꺼임 ) \n```java\npublic class AddStatement implements StatementStrategy {\n\tUser user;\n\t\n\tpublic AddStatement(User user) {\n\t\tthis.user = user;\n\t}\n\t\n\tpublic PreparedStatement makePreparedStatement(Connection c) throws SQLException {\n\n\t\tPreparedStatement ps = c.prepareStatement(\"insert into users(id,name,password) values(?,?,?)\");\n\t\tps.setString(1, user.getId());\n\t\tps.setString(2, user.getName());\n\t\tps.setString(3, user.getPassword());\n\n\t\treturn ps;\n\t}\n}\n```\n\n새로운 사용자를 DB에 추가하는 코드이다. 위 코드는 프로젝트 내에서 UserDao라는 단하나의 클래스에서만 사용되고 다른 클래스에서는 전혀 사용되지 않는다. 또한 StatementStrategy 라는 인터페이스를 상속받아 makePreparedStatement를 구현하고 있다.\n\n<br><br><br>\n\n#### 📌 익명 클래스의 구현\n\n```java\n...(생략)\n\npublic class UserDao {\n\t...\n\t// 사용자 추가 메소드\n\tpublic void add(final User user) throws SQLException {\n\n\t\t// AddStatement를 익명 내부 클래스로 전환\n\t\tthis.jdbcContext.workWithStatementStrategy(new StatementStrategy() {\n\n\t\t\tpublic PreparedStatement makePreparedStatement(Connection c) throws SQLException {\n\t\t\t\tPreparedStatement ps = c.prepareStatement(\"insert into users(id, name, password) values(?,?,?)\");\n\t\t\t\tps.setString(1, user.getId());\n\t\t\t\tps.setString(2, user.getName());\n\t\t\t\tps.setString(3, user.getPassword());\n\t\t\t\treturn ps;\n\t\t\t}\n\t\t});\n\t}\n\n\t...\n\t\n```\n\n코드를 보면  ``` this.jdbcContext.workWithStatementStrategy(new StatementStrategy() { AddStatement 클래스 본문 } ``` 이런 형태로 만들어진것을 볼 수 있다. 우리가 구현 할 클래스를 따로 이름을 정해주지 않고 다른 클래스 내부에 직접 만들어 주는 형태다.\n\n위 코드에서 익명 클래스는 ```new StatementStrategy() { ... }``` 이다. 익명클래스를 파라미터로 가진 형태이다. \n\n<br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":248958273,"tx":11232},"QO3PlLKwWnIiwVqK/syncedContent":{"id":"QO3PlLKwWnIiwVqK/syncedContent","type":"syncedContent","historyData":{"378031675":{"id":"QO3PlLKwWnIiwVqK/content","type":"content","text":"---\npermalink: /2022-08-16-인터페이스 vs 추상클래스/\npublished: true\ntitle: \"[JAVA] 인터페이스 vs 추상클래스 \"\ndate: 2022-08-16 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n<br><br>\n2023.06.15 내용추가\n<br><br>\n\n이전 포스팅에서 [인터페이스](https://idkim97.github.io/2022-08-12-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/)와 [추상클래스](https://idkim97.github.io/2022-08-12-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/)에 대해서 알아봤다. 그런데 각각의 기능이나 역할은 잘 알겠는데 둘의 차이점을 설명하라고 하면 명확하게 할 수 있을까? 본인같은 경우에도 둘의 차이점을 제대로 설명해보라고 하면 헷갈릴 만한 부분이 분명히 있기 때문에 오늘은 **인터페이스와 추상클래스의 공통점과 차이점**에 대해서 자세히 포스팅 해보려고 한다!\n\n<br><br><br><br>\n\n## ✅ 인터페이스와 추상클래스의 공통점\n\n1. **객체지향의 다형성을 활용할 수 있다.**\n\n2. **추상메소드를 사용한다.**\n\n3. **구현부가 없는 추상메소드 때문에 인스턴스화( 객체생성 )가 불가능하다.**\n\n4. **상속받는 클래스 혹은 구현하는 인터페이스 안에 있는 추상메소드를 구현하도록 강제 한다.**\n\n<br>\n \n이렇게 네가지 정도의 공통점을 들 수 있다. 여기서 몇가지 의문이 든다.\n\n**인터페이스**는 일반적으로 **상수, 추상메소드, 디폴트메소드, 정적 메소드** 로 이루어진다. **추상클래스**는 단순히 **추상메소드를 한개이상 포함한 클래스**를 말한다.\n\n**그렇다면 추상클래스에 원하는 추상메소드를 여러개 선언해서 상속받아 사용하고, 상수, 디폴트메소드, 정적메소드 역시 그냥 추상클래스에 선언해서 사용하면 추상클래스가 인터페이스의 역할을 전부다 할 수 있게 되는것 아닌가?**\n\n반은 맞고 반은 틀린 말이다.\n\n**인터페이스와 추상클래스는 존재 목적이 다르다**. **추상클래스**는 **그 추상클래스를 상속받아서 기능을 이용하고, 확장**시키는 데 있다. 반면에 **인터페이스**는 구현부가 전혀없이 메소드의 껍데기만 있는데, 그 이유는 **메소드의 구현을 강제하기 위함**이다. **구현을 강제함으로써 구현 객체의 같은 동작을 보장** 할 수 있다.\n\n<br><Br><br><br>\n\n## 인터페이스와 추상클래스의 차이점\n\n\n\n### 📕 접근제어자\n\n\n**🔔 인터페이스**\n\n> **상수 : ```public static final```**\n\n> **추상메소드 : ```public abstract```**\n\n> **디폴트 메소드 : ```default```**\n\n> **정적메소드 : ```static```** \n\n<br><br>\n\n**🔔 추상클래스**\n\n>  **static , final 이 아닌 필드 사용가능**\n\n> **public, private, protected 모두 사용 가능** \n\n<br><br><br>\n\n\n인터페이스에서 사용되는 접근제어자는 위와 같다. \n\n인터페이스에서 **상수**는 항상 **고정값**으로 적용되기 때문에 **```final``` 필드**를 가지고 **객체생성 없이 사용**할 수 있게 끔 **```static``` 필드**를 가진다. \n\n그러나 **추상클래스**는 **```static```** 이나 **```final```** 필드를 가질 수 없고 **```public, private, protected```** 모두 사용 가능하다.\n\n<Br><br><br>\n\n### 📕 사용 의도의 차이\n\n**인터페이스는 HAS - A \" ~을 포함하는 / ~을 할 수 있는\"**\n**추상클래스는 IS - A \"~이다\"**\n\n일반적으로 인터페이스와 추상클래스를 구분할 때 **HAS -A** 와 **IS-A** 로 구분하곤 한다. **다중상속 가능 여부**에 따라 이렇게 구분한 것으로 보이는데, JAVA는 한개의 클래스만 상속이 가능하기 때문에 **추상클래스의 상속을 통해 필요한 기능을 사용, 확장**하고 **인터페이스를 통해 필요한(할수있는) 기능을 강제**한다.\n\n글로만 보면 어려우니 예제를 통해 알아보자.\n\n<br><br><br><br>\n\n**🔔 CalAbstract : 추상클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport lombok.Data;\n\n@Data\npublic abstract class CalAbstract {\n\t\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\tprivate StringBuffer sb = new StringBuffer();\n\tprivate double result=0;\n\t\n\t\n\tprivate CalResult calResult;\n\t\n\t\n\t// 추상클래스 내에 클래스를 하나 만들어서 인터페이스를 implements해줌으로써 \n\t// calResult를 초기화할 수 있음.\n\t// 이게 어댑터 패턴(클래스)이네.. (아님 x)\n\tclass DefaultCalResultDisplay implements CalResult{\n\t\t\n\t\t@Override\n\t\tpublic void PrintResult() {\n\t\t\tSystem.out.println(\"결과 : \" + getResult());\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void PrintProcess() {\n\t\t\tSystem.out.println(\"연산 과정 : \" + getSb());\n\t\t}\n\t}\n\t\n\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic char judgeOp(String op) {\n\t\tif (op.equals(\"+\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"-\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"*\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"/\")) {\n\t\t\treturn op.charAt(0);\n\t\t}\n\t\treturn 'X';\n\t}\n\t\n\t// 실제 계산 수행\n\tpublic void calculate() {\n\t\tif (getOp().equals(\"+\")) {\n\t\t\tadd();\n\t\t} else if (getOp().equals(\"-\")) {\n\t\t\tsub();\n\t\t} else if (getOp().equals(\"*\")) {\n\t\t\tmul();\n\t\t} else if (getOp().equals(\"/\")) {\n\t\t\tdiv();\n\t\t}\n\t}\n\n\t// 입력받은게 숫자인지 기호인지 판단하는 객체\n\tpublic boolean judgeCal(boolean temp) {\n\t\tif (temp == true)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t// 숫자면 true, 기호면 false return\n\tpublic boolean judgeNumOrOp(String temp) {\n\t\treturn temp.matches(\"-?\\\\d+\");\n\t}\n\n\t\n\t// 추상메소드\n\tpublic abstract void cal();\n\t\n\n\t\n\tpublic void addDisplayResult(CalResult calResult) {\n\t\tthis.calResult = calResult;\n\t}\n\t\n\tpublic void display() {\n\t\tif(this.calResult == null) {\n\t\t\tDefaultCalResultDisplay defaultCalResultDisplay = new DefaultCalResultDisplay();\n\t\t\tdefaultCalResultDisplay.PrintProcess();\n\t\t\tdefaultCalResultDisplay.PrintResult();\n\t\t}\n\t\telse {\n\t\t\tcalResult.PrintProcess();\n\t\t\tcalResult.PrintResult();\n\t\t}\n\t}\n\n}\n\n```\n\n<br>\n\n사칙연산을 계산해주는 계산기를 위한 추상클래스이다. 객체지향 공부를 목적으로 짜고있는 코드이므로 좀 복잡해보일 수 있다..  일단 위 코드의 최종 목적을 간단하게 설명해보면 추상클래스와 인터페이스를 활용해서 다른기능을 가진 2개의 계산기를 만드는 것이다. \n\n하나는 일반적인 계산을 수행한다. (ex. 1+1, 2x8, 10/2)\n다른 하나는 연속적인 계산을 수행한다. ( ex 5+8-9*2/3+8 ) ( 입력순서대로 )\n최종적으로 연산과정과 연산 결과를 공통적으로 출력한다.\n\n위와 같은 기능을 가진 2개의 계산기를 구현하기 위해 인터페이스와 추상클래스를 어떻게 활용했는지를 중심으로 살펴보자.\n\n\n<br><br><br>\n\n추상클래스에 **필요한 변수**나 **일반 메소드**를 먼저 구현해줬다.\n```java\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\t// 연산과정을 저장하는 StringBuffer\n\tprivate StringBuffer sb = new StringBuffer();\n\t// 계산 결과\n\tprivate double result=0;\n```\n\n```java\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\n... 이하생략\n```\n\n<br><br><br>\n일반 클래스와 다를게 아예없다. 단지 추상클래스에는 **추상메소드**가 포함되었을 뿐이다.\n \n```java\n\t// 추상메소드\n\tpublic abstract void cal();\n```\n**이 추상메소드는 이후에 상속받을 클래스에서 각각 재정의 되어 서로 다른 두개의 계산기능(일반계산, 연속계산)으로 구현될 것이다. 추상클래스의 확장 개념이 적용된 것이다.**\n\n<br><br><Br><br>\n\n**🔔 CalResult : 인터페이스**\n```java\npackage calculate_Ver_Interface;\n\npublic interface CalResult {\n\t// 결과출력 추상메소드\n\tvoid PrintResult();\n\t\n\t// 과정출력 추상메소드\n\tvoid PrintProcess();\n}\n```\n계산기는 **반드시 결과가 출력** 되어야만 한다. 위 코드에서는 연산과정과 계산결과를 출력하는게 목적이기 때문에 두개의 메소드를 인터페이스에 선언하였다. 두개의 메소드를 인터페이스에 선언함으로써 두개의 계산기 모두 위 인터페이스를 implements 하여 **동일한 형태의 결과출력을 강제하는 효과**를 가진다.\n\n<br><br><Br><br>\n\n**🔔 ContinuousCal : 추상클래스를 상속받는 연속계산 클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class ContinuousCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\n\t// 연속 계산 수행\n\t@Override\n\tpublic void cal() {\n\t\twhile (true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\n\t\t\t// 필요한 계산코드인데 생략\n\t\t\t\t\n\t\t\t\tdisplay();\n\t\t\t\t\n\t\t\t\t\n\t\t\t// 필요한 계산코드인데 생략\n\t\t}\n\t}\n\n```\n\n위의 코드는 연속계산을 수행하는 클래스로 추상클래스를 상속받아 ``` public void cal() ``` 을 오버라이딩 하여 사용했다. 코드는 너무 길어서 생략했다. \n\n<br><br><Br>\n\n**🔔 StandardCal : 추상클래스를 상속받는 일반계산 클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class StandardCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\n\t// 단일 계산 수행\n\t@Override\n\tpublic void cal() {\n\t\twhile(true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\t\t\t// 코드 이하 생략\n\t\t\t\t\tdisplay();\n\t\t\t// 코드 이하 생략\n\t\t}\n\t}\n```\n\n마찬가지로 추상클래스를 상속받아 ``` public void cal() ``` 을 오버라이딩 한 일반 계산 클래스이다. 코드를 지금 생략해놔서 그렇지 두 클래스의 ``` public void cal() ``` 코드는 서로 기능에 따라 다르게 구성되어 있다.\n\n다시 한번 언급하고 정리해보면 추상클래스에서 선언한 추상메소드 ```public abstract void cal()``` 을 두개의 계산기 클래스에서 **서로 기능에 맞게끔 다르게 오버라이딩 하여 확장 한 것이다**.\n\n그런데 계산기에서 결과를 출력해주는 인터페이스를 implements 하지 않았다. 원래는 그냥 implements 해버리고 결과출력 메소드 오버라이딩해서 결과출력 하면 되는데 그러면 너무 쉽게 해버리는거여서 살짝 공부도 해볼겸 다르게 해봤다.\n\n<br><br><br>\n\n**🔔 CalAbstract : 추상클래스내에 클래스 선언후 implements**\n```java\nprivate CalResult calResult;\n\t\n\t\n\t// 추상클래스 내에 클래스를 하나 만들어서 인터페이스를 implements해줌으로써 \n\t// calResult를 초기화할 수 있음.\n\tclass DefaultCalResultDisplay implements CalResult{\n\t\t\n\t\t@Override\n\t\tpublic void PrintResult() {\n\t\t\tSystem.out.println(\"결과 : \" + getResult());\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void PrintProcess() {\n\t\t\tSystem.out.println(\"연산 과정 : \" + getSb());\n\t\t}\n\t}\n```\n\n```java\n\tpublic void addDisplayResult(CalResult calResult) {\n\t\tthis.calResult = calResult;\n\t}\n\t\n\tpublic void display() {\n\t\tif(this.calResult == null) {\n\t\t\tDefaultCalResultDisplay defaultCalResultDisplay = new DefaultCalResultDisplay();\n\t\t\tdefaultCalResultDisplay.PrintProcess();\n\t\t\tdefaultCalResultDisplay.PrintResult();\n\t\t}\n\t\telse {\n\t\t\tcalResult.PrintProcess();\n\t\t\tcalResult.PrintResult();\n\t\t}\n\t}\n```\n**implements를 이런 방식으로도 할 수 있구나 정도로 알아두면 좋을것 같다. 실무에서는 이런방식으로 implements를 정말 많이 사용한다.**\n\n<br><br><br><br>\n\n## 정리\n**⚡ 인터페이스와 추상클래스는 둘다 추상메소드의 구현을 강제한다.**\n\n**⚡ 인터페이스와 추상클래스는 둘다 인스턴스화가 불가능하다**\n\n**⚡ 인터페이스와 추상클래스는 접근제어자의 사용범위가 다르다.**\n\n**⚡ 인터페이스는 메소드의 동일한 동작 강제, 추상클래스는 메소드의 기능 이용, 확장이 주된 목적이다.**\n\n**⚡ 인터페이스는 HAS-A, 추상클래스는 IS-A 개념**\n","properties":"\n","discussions":{},"comments":{},"hash":378031675},"-1824550923":{"id":"QO3PlLKwWnIiwVqK/content","type":"content","text":"---\npermalink: /2022-08-16-인터페이스 vs 추상클래스/\npublished: true\ntitle: \"[JAVA] 인터페이스 vs 추상클래스 \"\ndate: 2022-08-16 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 인터페이스\n- 추상클래스\n---\n<br><br>\n2023.06.15 내용추가\n<br><br>\n\n이전 포스팅에서 [인터페이스](https://idkim97.github.io/2022-08-12-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/)와 [추상클래스](https://idkim97.github.io/2022-08-12-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/)에 대해서 알아봤다. 그런데 각각의 기능이나 역할은 잘 알겠는데 둘의 차이점을 설명하라고 하면 명확하게 할 수 있을까? 본인같은 경우에도 둘의 차이점을 제대로 설명해보라고 하면 헷갈릴 만한 부분이 분명히 있기 때문에 오늘은 **인터페이스와 추상클래스의 공통점과 차이점**에 대해서 자세히 포스팅 해보려고 한다!\n\n<br><br><br><br>\n\n## ✅ 인터페이스와 추상클래스의 공통점\n\n1. **객체지향의 다형성을 활용할 수 있다.**\n\n2. **추상메소드를 사용한다.**\n\n3. **구현부가 없는 추상메소드 때문에 인스턴스화( 객체생성 )가 불가능하다.**\n\n4. **상속받는 클래스 혹은 구현하는 인터페이스 안에 있는 추상메소드를 구현하도록 강제 한다.**\n\n<br>\n \n이렇게 네가지 정도의 공통점을 들 수 있다. 여기서 몇가지 의문이 든다.\n\n**인터페이스**는 일반적으로 **상수, 추상메소드, 디폴트메소드, 정적 메소드** 로 이루어진다. **추상클래스**는 단순히 **추상메소드를 한개이상 포함한 클래스**를 말한다.\n\n**그렇다면 추상클래스에 원하는 추상메소드를 여러개 선언해서 상속받아 사용하고, 상수, 디폴트메소드, 정적메소드 역시 그냥 추상클래스에 선언해서 사용하면 추상클래스가 인터페이스의 역할을 전부다 할 수 있게 되는것 아닌가?**\n\n반은 맞고 반은 틀린 말이다.\n\n**인터페이스와 추상클래스는 존재 목적이 다르다**. **추상클래스**는 **그 추상클래스를 상속받아서 기능을 이용하고, 확장**시키는 데 있다. 반면에 **인터페이스**는 구현부가 전혀없이 메소드의 껍데기만 있는데, 그 이유는 **메소드의 구현을 강제하기 위함**이다. **구현을 강제함으로써 구현 객체의 같은 동작을 보장** 할 수 있다.\n\n<br><Br><br><br>\n\n## 인터페이스와 추상클래스의 차이점\n\n\n\n### 📕 접근제어자\n\n\n**🔔 인터페이스**\n\n> **상수 : ```public static final```**\n\n> **추상메소드 : ```public abstract```**\n\n> **디폴트 메소드 : ```default```**\n\n> **정적메소드 : ```static```** \n\n<br><br>\n\n**🔔 추상클래스**\n\n>  **static , final 이 아닌 필드 사용가능**\n\n> **public, private, protected 모두 사용 가능** \n\n<br><br><br>\n\n\n인터페이스에서 사용되는 접근제어자는 위와 같다. \n\n인터페이스에서 **상수**는 항상 **고정값**으로 적용되기 때문에 **```final``` 필드**를 가지고 **객체생성 없이 사용**할 수 있게 끔 **```static``` 필드**를 가진다. \n\n그러나 **추상클래스**는 **```static```** 이나 **```final```** 필드를 가질 수 없고 **```public, private, protected```** 모두 사용 가능하다.\n\n<Br><br><br>\n\n### 📕 사용 의도의 차이\n\n**인터페이스는 HAS - A \" ~을 포함하는 / ~을 할 수 있는\"**\n**추상클래스는 IS - A \"~이다\"**\n\n일반적으로 인터페이스와 추상클래스를 구분할 때 **HAS -A** 와 **IS-A** 로 구분하곤 한다. **다중상속 가능 여부**에 따라 이렇게 구분한 것으로 보이는데, JAVA는 한개의 클래스만 상속이 가능하기 때문에 **추상클래스의 상속을 통해 필요한 기능을 사용, 확장**하고 **인터페이스를 통해 필요한(할수있는) 기능을 강제**한다.\n\n글로만 보면 어려우니 예제를 통해 알아보자.\n\n<br><br><br><br>\n\n**🔔 CalAbstract : 추상클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport lombok.Data;\n\n@Data\npublic abstract class CalAbstract {\n\t\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\tprivate StringBuffer sb = new StringBuffer();\n\tprivate double result=0;\n\t\n\t\n\tprivate CalResult calResult;\n\t\n\t\n\t// 추상클래스 내에 클래스를 하나 만들어서 인터페이스를 implements해줌으로써 \n\t// calResult를 초기화할 수 있음.\n\t// 이게 어댑터 패턴(클래스)이네.. (아님 x)\n\tclass DefaultCalResultDisplay implements CalResult{\n\t\t\n\t\t@Override\n\t\tpublic void PrintResult() {\n\t\t\tSystem.out.println(\"결과 : \" + getResult());\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void PrintProcess() {\n\t\t\tSystem.out.println(\"연산 과정 : \" + getSb());\n\t\t}\n\t}\n\t\n\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic char judgeOp(String op) {\n\t\tif (op.equals(\"+\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"-\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"*\")) {\n\t\t\treturn op.charAt(0);\n\t\t} else if (op.equals(\"/\")) {\n\t\t\treturn op.charAt(0);\n\t\t}\n\t\treturn 'X';\n\t}\n\t\n\t// 실제 계산 수행\n\tpublic void calculate() {\n\t\tif (getOp().equals(\"+\")) {\n\t\t\tadd();\n\t\t} else if (getOp().equals(\"-\")) {\n\t\t\tsub();\n\t\t} else if (getOp().equals(\"*\")) {\n\t\t\tmul();\n\t\t} else if (getOp().equals(\"/\")) {\n\t\t\tdiv();\n\t\t}\n\t}\n\n\t// 입력받은게 숫자인지 기호인지 판단하는 객체\n\tpublic boolean judgeCal(boolean temp) {\n\t\tif (temp == true)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t// 숫자면 true, 기호면 false return\n\tpublic boolean judgeNumOrOp(String temp) {\n\t\treturn temp.matches(\"-?\\\\d+\");\n\t}\n\n\t\n\t// 추상메소드\n\tpublic abstract void cal();\n\t\n\n\t\n\tpublic void addDisplayResult(CalResult calResult) {\n\t\tthis.calResult = calResult;\n\t}\n\t\n\tpublic void display() {\n\t\tif(this.calResult == null) {\n\t\t\tDefaultCalResultDisplay defaultCalResultDisplay = new DefaultCalResultDisplay();\n\t\t\tdefaultCalResultDisplay.PrintProcess();\n\t\t\tdefaultCalResultDisplay.PrintResult();\n\t\t}\n\t\telse {\n\t\t\tcalResult.PrintProcess();\n\t\t\tcalResult.PrintResult();\n\t\t}\n\t}\n\n}\n\n```\n\n<br>\n\n사칙연산을 계산해주는 계산기를 위한 추상클래스이다. 객체지향 공부를 목적으로 짜고있는 코드이므로 좀 복잡해보일 수 있다..  일단 위 코드의 최종 목적을 간단하게 설명해보면 추상클래스와 인터페이스를 활용해서 다른기능을 가진 2개의 계산기를 만드는 것이다. \n\n하나는 일반적인 계산을 수행한다. (ex. 1+1, 2x8, 10/2)\n다른 하나는 연속적인 계산을 수행한다. ( ex 5+8-9*2/3+8 ) ( 입력순서대로 )\n최종적으로 연산과정과 연산 결과를 공통적으로 출력한다.\n\n위와 같은 기능을 가진 2개의 계산기를 구현하기 위해 인터페이스와 추상클래스를 어떻게 활용했는지를 중심으로 살펴보자.\n\n\n<br><br><br>\n\n추상클래스에 **필요한 변수**나 **일반 메소드**를 먼저 구현해줬다.\n```java\n\tprivate int a;\n\tprivate int b;\n\tprivate String op;\n\tprivate double sum=0;\n\t\n\t// 연산과정을 저장하는 StringBuffer\n\tprivate StringBuffer sb = new StringBuffer();\n\t// 계산 결과\n\tprivate double result=0;\n```\n\n```java\n\tpublic void add() {\n\t\tsetSum(getSum()+getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void sub() {\n\t\tsetSum(getSum()-getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void mul() {\n\t\tsetSum(getSum()*getA());\n\t\tsetResult(getSum());\n\t}\n\tpublic void div() {\n\t\tsetSum(getSum()/getA());\n\t\tsetResult(getSum());\n\t}\n\n... 이하생략\n```\n\n<br><br><br>\n일반 클래스와 다를게 아예없다. 단지 추상클래스에는 **추상메소드**가 포함되었을 뿐이다.\n \n```java\n\t// 추상메소드\n\tpublic abstract void cal();\n```\n**이 추상메소드는 이후에 상속받을 클래스에서 각각 재정의 되어 서로 다른 두개의 계산기능(일반계산, 연속계산)으로 구현될 것이다. 추상클래스의 확장 개념이 적용된 것이다.**\n\n<br><br><Br><br>\n\n**🔔 CalResult : 인터페이스**\n```java\npackage calculate_Ver_Interface;\n\npublic interface CalResult {\n\t// 결과출력 추상메소드\n\tvoid PrintResult();\n\t\n\t// 과정출력 추상메소드\n\tvoid PrintProcess();\n}\n```\n계산기는 **반드시 결과가 출력** 되어야만 한다. 위 코드에서는 연산과정과 계산결과를 출력하는게 목적이기 때문에 두개의 메소드를 인터페이스에 선언하였다. 두개의 메소드를 인터페이스에 선언함으로써 두개의 계산기 모두 위 인터페이스를 implements 하여 **동일한 형태의 결과출력을 강제하는 효과**를 가진다.\n\n<br><br><Br><br>\n\n**🔔 ContinuousCal : 추상클래스를 상속받는 연속계산 클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class ContinuousCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\n\t// 연속 계산 수행\n\t@Override\n\tpublic void cal() {\n\t\twhile (true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\n\t\t\t// 필요한 계산코드인데 생략\n\t\t\t\t\n\t\t\t\tdisplay();\n\t\t\t\t\n\t\t\t\t\n\t\t\t// 필요한 계산코드인데 생략\n\t\t}\n\t}\n\n```\n\n위의 코드는 연속계산을 수행하는 클래스로 추상클래스를 상속받아 ``` public void cal() ``` 을 오버라이딩 하여 사용했다. 코드는 너무 길어서 생략했다. \n\n<br><br><Br>\n\n**🔔 StandardCal : 추상클래스를 상속받는 일반계산 클래스**\n```java\npackage calculate_Ver_Interface;\n\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport lombok.Data;\n\n@Data\npublic class StandardCal extends CalAbstract{\n\t\n\tScanner sc = new Scanner(System.in);\n\n\t// 단일 계산 수행\n\t@Override\n\tpublic void cal() {\n\t\twhile(true) {\n\t\t\tString str;\n\t\t\tstr = sc.nextLine();\n\t\t\t// 코드 이하 생략\n\t\t\t\t\tdisplay();\n\t\t\t// 코드 이하 생략\n\t\t}\n\t}\n```\n\n마찬가지로 추상클래스를 상속받아 ``` public void cal() ``` 을 오버라이딩 한 일반 계산 클래스이다. 코드를 지금 생략해놔서 그렇지 두 클래스의 ``` public void cal() ``` 코드는 서로 기능에 따라 다르게 구성되어 있다.\n\n다시 한번 언급하고 정리해보면 추상클래스에서 선언한 추상메소드 ```public abstract void cal()``` 을 두개의 계산기 클래스에서 **서로 기능에 맞게끔 다르게 오버라이딩 하여 확장 한 것이다**.\n\n그런데 계산기에서 결과를 출력해주는 인터페이스를 implements 하지 않았다. 원래는 그냥 implements 해버리고 결과출력 메소드 오버라이딩해서 결과출력 하면 되는데 그러면 너무 쉽게 해버리는거여서 살짝 공부도 해볼겸 다르게 해봤다.\n\n<br><br><br>\n\n**🔔 CalAbstract : 추상클래스내에 클래스 선언후 implements**\n```java\nprivate CalResult calResult;\n\t\n\t\n\t// 추상클래스 내에 클래스를 하나 만들어서 인터페이스를 implements해줌으로써 \n\t// calResult를 초기화할 수 있음.\n\tclass DefaultCalResultDisplay implements CalResult{\n\t\t\n\t\t@Override\n\t\tpublic void PrintResult() {\n\t\t\tSystem.out.println(\"결과 : \" + getResult());\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void PrintProcess() {\n\t\t\tSystem.out.println(\"연산 과정 : \" + getSb());\n\t\t}\n\t}\n```\n\n```java\n\tpublic void addDisplayResult(CalResult calResult) {\n\t\tthis.calResult = calResult;\n\t}\n\t\n\tpublic void display() {\n\t\tif(this.calResult == null) {\n\t\t\tDefaultCalResultDisplay defaultCalResultDisplay = new DefaultCalResultDisplay();\n\t\t\tdefaultCalResultDisplay.PrintProcess();\n\t\t\tdefaultCalResultDisplay.PrintResult();\n\t\t}\n\t\telse {\n\t\t\tcalResult.PrintProcess();\n\t\t\tcalResult.PrintResult();\n\t\t}\n\t}\n```\n**implements를 이런 방식으로도 할 수 있구나 정도로 알아두면 좋을것 같다. 실무에서는 이런방식으로 implements를 정말 많이 사용한다.**\n\n<br><br><br><br>\n\n## 정리\n**⚡ 인터페이스와 추상클래스는 둘다 추상메소드의 구현을 강제한다.**\n\n**⚡ 인터페이스와 추상클래스는 둘다 인스턴스화가 불가능하다**\n\n**⚡ 인터페이스와 추상클래스는 접근제어자의 사용범위가 다르다.**\n\n**⚡ 인터페이스는 메소드의 동일한 동작 강제, 추상클래스는 메소드의 기능 이용, 확장이 주된 목적이다.**\n\n**⚡ 인터페이스는 HAS-A, 추상클래스는 IS-A 개념**\n","properties":"\n","discussions":{},"comments":{},"hash":-1824550923}},"syncHistory":{"main":[378031675,-1824550923,378031675]},"v":1,"hash":1710892098589,"tx":11235},"omFvrSXYtukeVixH/content":{"id":"omFvrSXYtukeVixH/content","type":"content","text":"---\npermalink: /2023-06-16-7)예외처리 (try,catch, finally, throws)/\npublished: true\ntitle: \"[JAVA] 예외처리 ( try, catch, finally, throws ) \"\ndate: 2023-06-16 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ 프로그램 오류\n\n프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있는데, 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다.\n\n<br><br>\n\n### 📌 발생시점에 따른 에러 분류\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/exception2.png?raw=true\">\n</p>\n\n프로그램 오류는 발생시점에 따라 **컴파일 에러**와 **런타임 에러**로 나눌수 있다. 추가적으로 **논리적 에러**도 존재한다.\n\n**컴파일 에러는 글자 그대로 컴파일 할 때 발생하는 에러이고 소스의 오타나 잘못된 구문, 자료형 체크등 검사를 수행하면서 발생한다.**\n```java\n@Test  \nvoid compileError() {\n    STring helloStr = \"hello\";   // String이 아닌 STring으로 작성해서 오류발생\n    System.out.println(\"helloStr = \"  + helloStr);\n}\n```\n\n<br>\n\n**런타임 에러는 프로그램의 실행 시점에서 발생하는 에러로 컴파일 이후 프로그램이 실행되고 실행도중 의도치 않은 동작에 대처하지 못해 에러가 발생한다.**\n```java\n// 문자가 숫자형태가 아닌 문자 타입인 경우 \n// parseInt()메서드에서 NumberFormatException 발생\nvoid stringToInt(String str) {\n    int i = Integer.parseInt(str);\n    System.out.println(\"str : \" + i);\n```\n\n<br>\n논리적 에러는 컴파일도 잘되고 실행도 잘되지만 의도와는 다르게 동작하는 것을 말한다. 버튼을 뜨게 만들었는데 페이지가 뜬다거나, 아무 동작도 안하게 만들었는데 무언가 출력된다던가 하는 에러를 말한다.\n\n\n<br><br><br><br>\n\n## ✅ 예외 클래스의 계층 구조\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/exception1.png?raw=true\">\n</p>\n\n자바에서는 실행 시 발생할 수 있는 오류를 클래스로 정의했다. 모든 클래스의 조상은 Object 클래스이므로 Exception과 Error클래스 역시 Object클래스의 자손들이다.\n\n모든 예외의 최고 조상인 Exception 클래스는 크게 두가지로 나뉜다. **Exception 클래스와 자손들, RuntimeException클래스와 자손들** 두가지가 있다. \n\nRuntimeException클래스와 하위 예외들을 **선택적 예외(unchecked Exception)**로 개발자가 상황에 맞춰 대응해줘야 하는 예외이고 그외 나머지 예외클래스와 하위객체들을 **필수 예외(checked Exception)**라 하여 반드시 확인해줘야 하는 예외이다.\n\n**RuntimeException 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.** 배열의 범위를 벗어난 ArrayIndexOutOfBoundsException, 값이 null인 참조변수를 호출할때 발생하는 NullPointerException, 클래스간의 형변환을 잘못할때 발생하는 ClassCastException, 정수를 0으로 나눌 때 발생하는 ArithmeticException 등이 있다.\n\n**Exception 클래스들은 외부의 영향으로 발생할 수 있는 예외들로 프로그램의 사용자들의 동작에 의해 발생하는 경우가 많다.** 존재하지 않는 파일의 이름을 입력하는 FileNotFoundException, 클래스의 이름을 잘못 입력한 ClassNotFoundException, 입력 데이터 형식이 잘못된 DataFormatException 등이 있다.\n\n<br><br><br><br>\n\n## ✅ 예외 처리하기 :: try-catch\n\n프로그램의 실행 도중에 발생하는 오류는 어쩔 수 없지만, **프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생은 예외처리**를 통해 해결할 수 있다.\n\n예외처리를 위한 첫번째 방법은 **try-catch 구문**을 사용하는 것이다.\n\n```java\ntry {\n\t// 예외가 발생할 가능성이 있는 문장을 넣는다.\n} catch ( Exception1 e1 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} catch ( Exception2 e2 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} catch ( Exception3 e3 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} finally {\n\tdeleteTempFiles() // 프로그램 설치에 사용된 임시파일 삭제\n\t// try-catch구문이 종료되고 무조건 실행할 문장을 넣는다.\n}\n```\n\n하나의 try 블럭 다음에는 여러개의 catch블럭이 나올 수 있고, 발생한 예외의 종류와 일치하는 catch 블럭이 수행되고 try-catch 구문을 통째로 빠져나온다. 이때, 발생한 예외의 종류과 일치하는 catch블럭이 없는경우에는 예외가 처리되지 않는다.\n\n**`finally`** 는 예외 발생여부와 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용된다. try-catch 구문 끝에 선택적을 사용할 수 있다. 보통 임시파일 삭제나 DB연결 해제 등 불필요한 메모리를 지우거나 기존 연결을 해제하는 등 반드시 실행되어야 할 코드를 작성한다. \n\n또한 **catch문에 들어갈 예외의 순서는 작은 범위부터 차례대로 넣어줘야 한다.** 예를 들어 Exception 예외처리를 하는경우에 ,Exception 예외 클래스가 가장 최상의 부모클래스이므로 마지막 catch 구문에 작성해줘야만 한다.\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tint i = 10 ;  \n\t\tString str = \"aa\";  \n\t\ttry {  \n\t\t\tint result = 10 / i \n\t\t\treturn;  \n\t\t} catch(ArithmeticException e) {  \n\t\t\tSystem.out.println(\"ArithmeticException 발생!\");  //ArithmeticException 이 발생 했을 때만 실행  \n\t\t} catch(NullPointerException e) {  \n\t\t\tSystem.out.println(\"NullPointerException 발생!\");  //NullPointerException 이 발생 했을 때만 실행  \n\t\t} catch(Exception e){  \n\t\t\t// 그 외의 Exception 이 발생 했을 때 실행  \n\t\t} finally{  \n\t\t\tSystem.out.println(\"항상 실행\");  \n\t\t}  \n\t\t\tSystem.out.println( \"정상 종료\");  \n\t}  \n}\n```\n\n위의 코드를 보면 `ArithmeticException`, `NullPointerException`, 그리고 `Exception` 예외처리를 한것을 볼 수 있는데 `Exception` 예외처리를 가장 마지막 catch문에 작성한 것을 볼 수 있다.\n\n만일 `Exception` 예외처리를 상위 catch문에 작성한다면 `ArithmeticException`이나 `NullPointerException`이 발생한 경우에도 `Exception` 예외처리를 진행하게 된다. 그렇게 되면 각각의 예외에 맞는 catch문을 실행할 수 없어지기 때문에 올바른 예외처리를 못하게 된다. 따라서 `Exception` 예외처리는 가장 마지막 catch문에 작성해줘야만 한다.\n\n\n<br><br><br>\n### 📌 try-catch문에서의 흐름\ntry-catch문에서, 예외가 발생한 경우와 발생하지 않은 경우에 흐름은 달라진다.\n\n- **try 블럭 내에서 예외가 발생한 경우**\n\t1. 발생한 예외와 일치하는 catch문이 있는지 확인한다.\n\t2. 일치하는 catch문을 찾으면, 해당 catch블럭 내의 문장들을 수행하고, **try-catch문을 통째로 빠져나간다.**\n\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tSystem.out.println(1);\n\t\ttry {\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(3);\n\t\t} catch(Exception e) {\n\t\t\tSystem.out.println(4);\n\t\t}\n\t\tSystem.out.println(5);\n\t}  \n} // 1 2 3 5 가 출력된다\n```\n\n위 코드를 보면 어떤 오류도 발생하지 않는다. 때문에 try문은 그대로 출력되고 catch문은 실행되지 않는다. 이후 try-catch 구문을 빠져나간뒤 5를 출력한다. 결과적으로는 1, 2, 3, 5가 출력될 것이다.\n<br><br>\n\n\n- **try 블럭 내에서 예외가 발생하지 않은 경우**\n\t1. catch문을 거치지 않고 try-catch문을 통째로 빠져나간다.\n\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tSystem.out.println(1);\n\t\ttry {\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(0/0);\n\t\t\tSystem.out.println(3);\n\t\t} catch(ArithmeticException ae) {\n\t\t\tSystem.out.println(4);\n\t\t}\n\t\tSystem.out.println(5);\n\t}  \n} // 1 2 4 5 가 출력된다\n```\n\n위의 코드는 0으로 어떤수를 나눴기 때문에 `ArithmeticException`이 발생한다. 때문에 try문의 `System.out.println(0/0);` 문장 이전까지는 정상 실행되다가 `System.out.println(0/0);` 문장에서 오류가 발생하고 catch 구문으로 넘어가 실행되고 이후 try-catch 구문을 통째로 빠져나간다. 때문에 1, 2, 4, 5가 출력될 것이다.\n\n<Br><Br><Br><Br>\n\n## ✅ 예외 처리하기 :: throws\n\n예외를 처리하는 방법에는 try-catch문을 사용하는것 외에, 예외를 메서드에 선언하는 throws를 사용하는 방법이 있다. 메서드에 예외를 선언하려면, 메서드 선언부에 throws를 사용해서 발생 할 수 있는 예외를 적어주기만 하면 된다.\n\n```java\n\tvoid method() throws Exception1, Exception2, ... ExceptionN {\n\t\t// 메서드 내용\n\t}\n```\n\n예외를 선언하면, 해당 예외뿐만 아니라 **자손타입의 예외까지도 발생할 수 있다** 라고 알리는 것이다. 또한 메서드를 통한 예외처리는 실제 예외를 어떻게 처리하겠다 라는 로직을 포함하지 않기때문에 단순히 이러이러한 오류가 발생할 수 있고, **해당 오류가 발생한다면 오류에 대한 처리를 메서드를 호출한 쪽으로 넘기겠다!** 라는 의미로 사용된다. 때문에 사용자쪽은 오류에 대한 `try-catch` 구문을 반드시 사용해 처리해야만 한다.\n\n기존의 다른 언어는 메서드에 예외선언을 하지않기 때문에, 경험이 많은 프로그래머가 아니라면 어떤 상황에서 어떤 종류의 오류가 발생할 가능성이 있는지 예측하기 어려웠다. 그러나 자바에서는 메서드 내에서 발생할 가능성이 있는 예외를 선언부에 명시하여 메서드를 사용하는 쪽에 이에 대한 처리를 강요하기 때문에, 보다 견고한 코드를 작성할 수 있다.\n\n<br><br><br>\n### 📌 메서드에 예외 선언하기 흐름\n\n```java\nclass EX {\n\tpublic static void main(String[] args) throws Exception {\n\t\tmethod1();\n\t}\n\n\tstatic void method1() throws Exception {\n\t\tmethod2();\n\t}\n\n\tstatic void method2() throws Exception {\n\t\tthrow new Exception();\n\t}\n}\n```\n<br>\n\n\n위의 코드를 보면 `method2()` 에서 `throw new Exception();` 을 통해 Exception() 예외를 발생시켰다. `method2()`에서는 try-catch를 통한 예외처리를 하지 않았기 때문에 `method2()`를 호출한 `method1()`로 예외를 넘긴다(throws). `method1()` 에서도 마찬가지로 예외처리를 하지않았으므로 `method1()`을 호출한 `main` 으로 예외를 넘긴다. main에서도 마찬가지로 예외처리를 하지 않았으므로 위의 코드는 오류가 난다.\n\n<Br><br><br>\n\n\n### 📌 메서드에 예외 선언하기 예제\n```java\nclass EX {\n\tpublic static void main(String[] args) {\n\t\ttry{\n\t\t\tFile f = createFile(args[0]);\n\t\t\tSystem.out.println(f.getName()+\"파일이 성공적으로 생성되었습니다.\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.getMessage()+\"다시 입력해주세요\");\n\t\t}\n\t}\n\n\tstatic File createFile(String fileName) throws Exception {\n\t\tif(fileName==null || fileName.equals(\"\"))\n\t\t\tthrow new Exception(\"파일이름이 유효하지 않습니다\");\n\t\tFile f = new File(fileName);\n\t\t\n\t\tf.createNewFile();\n\t\treturn f;\n\t}\n}\n\t\t\n```\n\n위의 코드는 사용자로부터 파일이름을 입력받아서 파일을 생성하는 예제이다. 파일을 생성하는것은 `createFile` 메소드인데 파일이름이 유효하지 않으면 `Exception`을 발생시킨다. 이때 `createFile` 메소드에 예외가 선언되어 있으므로 `createFile` 메소드를 호출한 `main` 으로 예외처리를 넘겨준다. `main` 에서는 넘어온 예외를 try-catch 구문을 통해 해결하고 있다. \n\n그런데 이와 반대로 만약 `createFile` 메소드에서 try-catch 문을 작성해서 오류를 처리하면 어떻게 될까? **`createFile` 메소드에서 처리하게 되면 `main`에서는 오류가 발생했는지 여부도 알지 못하게 된다.**\n\n이를 잘 활용하여 예외가 발생한 메서드 내에서 자체적으로 처리해도 되는 경우 메서드 내에 try-catch문을 넣어서 처리하고, 위 예제처럼 메서드 내에서 자체적으로 해결이 안되는 경우(파일 이름을 다시 받아와야 하는 경우)에는 예외를 선언하여 호출한 메서드가 오류를 처리하도록 해야한다.\n\n \n<br><br><br><Br>\n\n## ✅ 예외 발생시키기 :: throw\n\n키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다. \n\n1. 연산자 new를 이용해 발생시키려는 예외클래스의 객체 생성\n\t`Exception e = new Exception(\"고의로 예외발생\");`\n\n2. 키워드 throw를 이용해 예외 발생\n\t`throw e;`\n\n3. `throw new Exception(\"고의로 예외발생\")` 같은 형태로도 사용가능 \n\n<br>\n\n```java\nclass EX {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tException e = new Exception(\"고의로 발생\");\n\t\t\tthrow e;\n\t\t\t// throw new Exception(\"고의로 발생\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"에러\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"정상종료\");\n\t}\n}\n```\n\n위 코드처럼 고의로 예외를 발생시켜 catch문 처리를 하도록 만들 수도 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":1456159858,"tx":11235},"7LHwr5vMhDvsF6qJ/syncedContent":{"id":"7LHwr5vMhDvsF6qJ/syncedContent","type":"syncedContent","historyData":{"1908325863":{"id":"7LHwr5vMhDvsF6qJ/content","type":"content","text":"---\npermalink: /2022-08-17-자바 빈(JAVA Bean)/\npublished: true\ntitle: \"[JAVA] 자바 빈(JAVA Bean)\"\ndate: 2022-08-17 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"자바 빈(JAVA Bean)\"\ncategories:\n- JAVA\ntags:\n- JAVA\n\n---\n\n<br><br><br>\n\n## 자바 빈(JAVA Bean)이란 ?\n자바의 재활용 가능한 [컴포넌트](https://hanamon.kr/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component%EB%9E%80/) 모델을 일컫는 말로 **데이터 표현**을 목적으로 하는 **자바 클래스**이다. 자바 빈즈 클래스로서 작동하기 위해서, 객체 클래스는 **정해진 관례(Java Beans Convention)** 를 따라야만 한다. Java Beans Convention은 다음과 같다.\n\n<br><br><br>\n\n-   클래스는 인자(Argument)가 없는 기본 생성자(Default constructor)를 갖는다\n-   클래스의 멤버 변수는 프로퍼티(Properties)라고 하며 private 접근 제한자를 가져야 한다.\n-   클래스의 프로퍼티들은 Getter/Setter를 통해 접근할 수 있어야 한다\n\n-   Getter의 이름은 get{프로퍼티 이름} 이며, Setter의 이름은 set{프로퍼티 이름}이다\n-   Getter/setter의 접근 제한자는 public이어야 한다.\n-   프로퍼티의 타입이 Boolean인 경우 is로 시작할 수 있다\n-   Getter의 경우 파라미터가 존재하지않아야 하며, setter의 경우 하나 이상의 파라미터가 존재한다\n-   Read Only인 경우 Setter는 없을 수 있다.\n\n-   Serializable 인터페이스를 implements 한다.\n-   자바빈 클래스는 패키징 되어야 한다. (Package)\n\n<br><br>\n\n바로 예제를 통해 알아보자.\n\n<br><br>\n\n\n**🧑 PersonBean.java**\n\n```java\npublic class PersonBean implements java.io.Serializable\n{\n    private String name;\n    private boolean coding;\n\n    // 기본 생성자 (인자가 없는).\n    public PersonBean()\n    {\n\n    }\n\n    public String getName()\n    {\n        return this.name;\n    }\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    // Different semantics for a boolean field (is vs. get)\n\n    public boolean isCoding()\n    {\n        return this.coding;\n    }\n\n    public void setCoding(boolean coding)\n    {\n        this.coding = coding;\n    }\n}\n```\n<br>\n\n**🧑 TestPersonBean.java**\n```java\npublic class TestPersonBean\n{\n    public static void main(String[] args)\n    {\n\n        PersonBean person = new PersonBean();\n        person.setName(\"Bob\");\n        person.setCoding(true);\n\n        // Output: \"Bob [coding]\"\n        System.out.print(person.getName());\n        System.out.println(person.isCoding() ? \" [coding]\" : \"\");\n    }\n}\n```\n\n\n<br><br><br><br>\n\n## 자바 빈(JAVA Bean) 사용 목적\n자바 빈은 **JSP**에서 객체를 가져오기 위한 클래스로 **DTO (Data Transfer Object)** 라고도 한다. JSP 페이지에 View 부분과 로직이 섞여있어 복잡해 보이는 구성을 피하기 위해 JSP 페이지의 로직 부분을 분리해서 자바 빈으로 구성함으로써 **코드의 재사용성을 높이고 프로그램의 효율을 높일 수 있다**.\n","properties":"\n","discussions":{},"comments":{},"hash":1908325863},"-426786783":{"id":"7LHwr5vMhDvsF6qJ/content","type":"content","text":"---\npermalink: /2022-08-17-자바 빈(JAVA Bean)/\npublished: true\ntitle: \"[JAVA] 자바 빈(JAVA Bean)\"\ndate: 2022-08-17 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"자바 빈(JAVA Bean)\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n\n---\n\n<br><br><br>\n\n## 자바 빈(JAVA Bean)이란 ?\n자바의 재활용 가능한 [컴포넌트](https://hanamon.kr/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component%EB%9E%80/) 모델을 일컫는 말로 **데이터 표현**을 목적으로 하는 **자바 클래스**이다. 자바 빈즈 클래스로서 작동하기 위해서, 객체 클래스는 **정해진 관례(Java Beans Convention)** 를 따라야만 한다. Java Beans Convention은 다음과 같다.\n\n<br><br><br>\n\n-   클래스는 인자(Argument)가 없는 기본 생성자(Default constructor)를 갖는다\n-   클래스의 멤버 변수는 프로퍼티(Properties)라고 하며 private 접근 제한자를 가져야 한다.\n-   클래스의 프로퍼티들은 Getter/Setter를 통해 접근할 수 있어야 한다\n\n-   Getter의 이름은 get{프로퍼티 이름} 이며, Setter의 이름은 set{프로퍼티 이름}이다\n-   Getter/setter의 접근 제한자는 public이어야 한다.\n-   프로퍼티의 타입이 Boolean인 경우 is로 시작할 수 있다\n-   Getter의 경우 파라미터가 존재하지않아야 하며, setter의 경우 하나 이상의 파라미터가 존재한다\n-   Read Only인 경우 Setter는 없을 수 있다.\n\n-   Serializable 인터페이스를 implements 한다.\n-   자바빈 클래스는 패키징 되어야 한다. (Package)\n\n<br><br>\n\n바로 예제를 통해 알아보자.\n\n<br><br>\n\n\n**🧑 PersonBean.java**\n\n```java\npublic class PersonBean implements java.io.Serializable\n{\n    private String name;\n    private boolean coding;\n\n    // 기본 생성자 (인자가 없는).\n    public PersonBean()\n    {\n\n    }\n\n    public String getName()\n    {\n        return this.name;\n    }\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    // Different semantics for a boolean field (is vs. get)\n\n    public boolean isCoding()\n    {\n        return this.coding;\n    }\n\n    public void setCoding(boolean coding)\n    {\n        this.coding = coding;\n    }\n}\n```\n<br>\n\n**🧑 TestPersonBean.java**\n```java\npublic class TestPersonBean\n{\n    public static void main(String[] args)\n    {\n\n        PersonBean person = new PersonBean();\n        person.setName(\"Bob\");\n        person.setCoding(true);\n\n        // Output: \"Bob [coding]\"\n        System.out.print(person.getName());\n        System.out.println(person.isCoding() ? \" [coding]\" : \"\");\n    }\n}\n```\n\n\n<br><br><br><br>\n\n## 자바 빈(JAVA Bean) 사용 목적\n자바 빈은 **JSP**에서 객체를 가져오기 위한 클래스로 **DTO (Data Transfer Object)** 라고도 한다. JSP 페이지에 View 부분과 로직이 섞여있어 복잡해 보이는 구성을 피하기 위해 JSP 페이지의 로직 부분을 분리해서 자바 빈으로 구성함으로써 **코드의 재사용성을 높이고 프로그램의 효율을 높일 수 있다**.\n","properties":"\n","discussions":{},"comments":{},"hash":-426786783}},"syncHistory":{"main":[1908325863,-426786783,1908325863]},"v":1,"hash":1710892101067,"tx":11237},"C8kg3so81QVoun72/content":{"id":"C8kg3so81QVoun72/content","type":"content","text":"---\npermalink: /2023-06-19-String, StringBuffer와 StringBuilder/\npublished: true\ntitle: \"[JAVA] String, StringBuffer와 StringBuilder \"\ndate: 2023-06-19 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ String VS StringBuffer/ StringBuilder\n\nJAVA에서 문자열을 처리할 때 대표적으로 많이 쓰이는게 String, StringBuffer 그리고 StringBuilder 이다. 셋다 비슷한 기능을 수행하지만 엄연히 다르고 장단점이 존재하는데 무엇인지 알아보자.\n\n<br><br><Br><br>\n## ✅ String의 불변성\n**한번 생성된 String 인스턴스는 읽어올 수는있지만, 변경할 수는 없다.** 그런데 우리는 실제로 String 클래스를 사용하면서 String이 변경되는것을 자주봤을 것이다. 다음 코드를 보자.\n\n```java\nString str = \"hello \";\nstr = str + \"world\";\n\n>>> str\n>>> hello world\n```\n이처럼 String은 불변한다고 했지만 막상 String에 새로운 문자열을 갖다 붙일 수 있다. 때문에 불변하지 않는다고 생각할 수 있지만 **실제 메모리 영역을 살펴보면 그 이유를 알 수 있다.**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/java1.png?raw=true\">\n</p>\n\n처음 String 인스턴스를 생성하고 \"hello\"라는 값을 부여하면 메모리에 할당되고 임의의 주소값을 부여받는다. 이때 **기존 String 인스턴스에 다른 문자열을 추가하면 기존에 존재하던 주소값에 이를 할당하는게 아니라 아예 새로운 메모리에 할당해서 새로운 값을 만들어내는 구조이다.** 그렇기 때문에 String인스턴스가 **'변한게'** 아니라 **'새로 생성'** 된것이다. 기존의 String 인스턴스는 전혀 변화가 없기 때문에 **String은 불변하다** 라고 보는것이다.\n\n이런식으로 '+' 연산자를 이용해서 문자열을 결합하는 것은 매 연산시마다 새로운 문자열을 가진 String 인스턴스가 생성되어 메모리 공간을 차지하기 때문에 가능한 결합 횟수를 줄이는것이 좋다. 그러나 문자열 간의 결합이 추출 등 문자열을 다루는 작업이 많이 필요한 경우에는 메모리 낭비가 심해질 수 밖에 없다. 그래서 나온게 바로 StringBuffer/StringBuilder 이다! \n\n<br><br><Br><br>\n## ✅ StringBuffer 클래스\nString은 인스턴스 생성할 때 지정된 문자열을 수정할 수 없지만, StringBuffer는 가능하다. 내부적으로 **문자열 편집을 위한 버퍼(buffer)를 가지고 있고, StringBuffer 인스턴스를 생성할 때 크기를 지정할 수도 있다.**\n\n크기를 지정하지 않은 경우 **16개의 문자**를 저장할 수 있는 크기의 버퍼를 생성하고 이를 초과하는 문자열이 들어오는 경우 **자동으로 버퍼의 길이를 늘려주는 작업이 수행되기 때문에 작업 효율이 떨어질 수 있다.** \n\n<br><br>\n\n### 📌 StringBuffer의 변경\n```java\nStringBuffer sb = new StringBuffer(\"hello\");\nsb.append(\"world\");\n```\n\nStringBuffer는 다양한 API를 사용해 변경할 수 있다. 위의 코드는 앞서 String 클래스에서 설명한 '+' 연산자와 동일한 기능을 수행하는 코드이다. StringBuffer 인스턴스를 생성하고 초기값을 \"hello\"라고 부여한 뒤 StringBuffer 인스턴스에 \"world\"를 추가한 것이다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer1.png?raw=true\">\n</p>\n\n<Br>\n그림을 보면 StringBuffer는 String과 달리 메모리를 새로 할당하지 않고 기존 메모리에 접근하여 값을 변경하는것을 볼 수 있다. 때문에 String 보다 메모리 낭비가 발생하지 않아 문자열의 추가, 수정, 삭제가 빈번하게 발생되는 경우 많이 사용한다.\n\n또 하나 기억해야할 점은 **`append()`는 반환타입이 StringBuffer이고 자기 자신의 주소를 반환한다**는 점이다. 때문에 다음과 같은 코드작성도 가능하다.\n\n```java\nStringBuffer sb = new StringBuffer(\"안녕하세요 \");\nStringBuffer sb2 = sb.append(\"반갑습니다\");\nSystem.out.println(sb);\t// 안녕하세요 반갑습니다\nSystem.out.println(sb2);\t// 안녕하세요 반갑습니다\n```\n\n```java\nStringBuffer sb = new StringBuffer(\"안녕하세요 \");\nsb.append(\"반갑습니다 \").append(\"잘부탁드려요!\");\nSystem.out.println(sb)\t// 안녕하세요 반갑습니다 잘부탁드려요!\n```\n`append()`의 반환타입이 자기자신 StringBuffer이기 때문에 위와같은 코드작성이 가능하다.\n\n<br><br><Br><br>\n## ✅ StringBuffer 메서드\n\n전부다 알면 좋겠지만 주로 많이 쓰는걸 위주로 기억해두도록 하자. 빨간 박스 친 메서드는 코딩테스트에서도 용이하게 쓰일수 있는 메서드 이기때문에 코딩테스트를 준비하는 상황이라면 기억해두도록 하자!\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer2.png?raw=true\">\n</p>\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer3.png?raw=true\">\n</p>\n\n<br><br><Br><br>\n## ✅ StringBuilder 클래스\n\nStringBuffer는 멀티쓰레드에 안전하도록 동기화되어 있다. 동기화는 StringBuffer의 성능을 떨어뜨리기 때문에 멀티쓰레드로 작성된 프로그램이 아닌경우, StringBuffer의 동기화는 불필요하게 성능만 떨어뜨린다.\n\n그래서 StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 추가되었다. StringBuffer와 기능적으로 완전히 동일해서 StringBuffer대신 StringBuilder라고 선언해주기만 하면된다. \n\n```java\nStringBuilder sb = new StringBuilder();\n```\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-1059858459,"tx":11238},"0jwjWW7L0cw2iQtV/content":{"id":"0jwjWW7L0cw2iQtV/content","type":"content","text":"---\npermalink: /2023-06-22-Thread/\npublished: true\ntitle: \"[JAVA] Thread란? \"\ndate: 2023-06-22 17:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ Thread란 ?\n프로그램을 실행하면 **OS로 부터 실행에 필요한 자원(메모리)을 할당받아 프로세스**가 된다. 프로세스는 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며 **프로세스의 자원을 이용해 실제로 작업을 수행하는 것이 바로 쓰레드**이다. 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하고, 두 개 이상의 쓰레드를 가지는 프로세스를 멀티쓰레드 프로세스(multi-thread process) 라고한다.\n\n<br><br>\n\n## ✅ Thread 구현과 실행\n자바에서 쓰레드를 구현하는 방법은 두가지가 있다.\n\n1. Runnable 인터페이스를 구현하는 방법\n2. Thread 클래스를 상속받는 방법\n\n어느쪽을 선택해도 차이는 없지만 Thread를 상속받으면 다른 클래스를 상속받을 수 없기때문에, Runnable 인터페이스를 구현하는 방법이 일반적이다. \n\n```java\n1. Thread 클래스 상속\n\nclass MyThread extends Thread {\n\tpublic void run() {\n\t\t/* 작업 내용 */\n\t}\n}\n```\n\n```java\n2. Runnable인터페이스 구현\n\nclass Mythread implements Runnable {\n\tpublic void run() {\n\t\t/* 작업 내용 */\n\t}\n}\n```\n\n위와같은 형태로 Thread를 구현할 수 있다. 어떤 방식을 사용하든 `run()` 메소드의 몸통부분을 구현함으로써 쓰레드를 만들면 된다.\n\n<br><br><br><br>\n\n### 📌 Thread 구현과 실행 예제\n```java\npublic class Ex10_ThreadEx1 {  \n\tpublic static void main(String[] args) {  \n\t\tEx1 ex1 = new Ex1();\n\t\t\n\t\tRunnable r = new Ex2();\n\t\tThread t2 = new Thread(r);\n\n\t\tex1.start();\n\t\tex2.start();  \n\t}  \n}  \n  \nclass Ex1 extends Thread{  \n\tpublic void run(){  \n\t\tfor(int i=0;i<5;i++) {\n\t\t\tSystem.out.println(getName());\n\t\t}\n\t}  \n}\n\nclass Ex2 implements Runnable {\n\tpublic void run() {\n\t\tfor(int i=0;i<5;i++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName());\n\t\t}\n\t}\n}\n```\n\nThread를 상속받은 경우에는 **Thread의 자손 클래스의 인스턴스를 생성**해주기만 하면 구현할 수 있다.\n\nRunnable 인터페이스를 구현한 경우에는 **Runnable을 구현한 클래스의 인스턴스를 생성한 다음 이 인스턴스를 Thread클래스 생성자의 매개변수로 제공**해야 한다.\n\n<br><br>\n\n### 📌 Thread의 실행 - start( )\n쓰레드를 생성했다고 해서 쓰레드가 실행되는 것은 아니다. `start()`를 호출해야만 쓰레드가 실행된다.\n```java\nThread t1 = new Thread();\nThread t2 = new Thread();\n\nt1.start();\nt2.start();\n```\n\n하지만 `start()`를 호출했다고 해서 바로 실행되는 것이 아니라, 실행대기 상태인 `waiting` status를 가지고 있다가 자신의 차례가 되면 실행된다. 이러한 쓰레드의 실행 순서는 OS의 스케쥴러에 의해 결정되는데 OS마다 스케쥴러 정책이 다르고, 쓰레드의 상태마다 또 정책이 다르기 때문에 JAVA 개발단계에서 스케쥴러에 대한 처리는 할 수 없고 OS에 맡겨야만 한다.\n\n한가지 더 알아둬야 할 것은 실행이 한번 종료된 쓰레드는 다시 `start()`를 통해서 실행 할 수 없다. 즉 하나의 쓰레드에 대해 `start()`가 한번만 호출 될 수 있다. 때문에 쓰레드의 작업을 한번더 수행하기 위해서는 인스턴스를 다시 생성하고 `start()`를 사용해야만 한다. 만일 같은 인스턴스에 대해 두번의 `start()` 를 실행하면 `IllegalThreadStateException` 이 발생한다.\n\n`IllegalThreadStateException` 이 발생하는 이유에 대해 살짝 알아보면, `start()` 메서드를 호출하게 되면 메서드의 실행 상태를 나타내는 내부 플래그가 'true'로 설정되어 해당 스레드를 다시 시작할 수 없다는것을 나타내게 된다. 그래서 같은 인스턴스에 대해 다시 `start()` 메소드를 실행하면 이미 내부 플래그가 true로 설정되어 있기 때문에 오류가 발생하게 되는 것이다. \n\n그러면 `yield()` 메서드를 실행한다음 다시 `start`메서드를 실행하면 괜찮지 않을까 해서 관련 자료를 찾아보니 `yield()` 를 호출하더라도 쓰레드의 실행상태를 초기화하는것이 아닌 쓰레드의 실행을 잠시 중단하고 다른 쓰레드에게 스케줄링 순서를 양보하는 것이기 때문에 여전히 `IllegalThreadStateException`이 발생한다고 한다.\n\n<br><br>\n\n### 📌 Thread의 실행 - run( )\n이제는 쓰레드를 실행하기 위해 `start()`메서드를 사용해야 한다는것을 알고있다. 그런데 왜 `run()` 메서드를 직접 실행하지 않고 `start()`를 통해 쓰레드를 실행하는 걸까?\n\nmain메서드에서 `run()`을 호출하는 것은 **쓰레드를 실행시키는 것이 아니라 단순히 메서드를 호출하는 것일 뿐**이다.\n\n반면에 `start()`는 새로운 쓰레드가 작업을 실행하는데 **필요한 호출스택(call stack)을 생성한 다음 `run()`을 호출해서 생성된 호출 스택에 `run()`메서드가 첫번째로 올라가게 한다.** \n\n**모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 하는데, `start()` 를 통해 작업을 수행할때마다 새로운 호출스택을 생성하고 쓰레드가 종료되면 생성된 호출스택을 소멸되게 하여 쓰레드의 실행이 가능하게끔 한다.**\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/thread1.png?raw=true\">\n</p>\n\n1. `main()` 메서드에서 쓰레드의 `start()`를 호출한다.\n2. `start()`는 쓰레드와 호출스택을 생성한다.\n3. 생성된 호출스택에 `run()` 메서드가 호출되어 작업을 수행한다.\n4. `main()` 과 `run()` 두개의 쓰레드는 OS의 스케줄링에 의해 번갈아 실행된다.\n\n**참고로 우리가 항상 사용하는 `main()` 메소드도 하나의 쓰레드이다!**\n\n<br><Br><br><br>\n\n## ✅ 싱글쓰레드와 멀티쓰레드\n싱글쓰레드는 한번에 한가지 작업만 수행할 수 있지만 쓰레드를 여러개 사용하는 멀티쓰레드는 한번에 여러가지 작업을 수행할 수 있다. 우리가 보기에 멀티쓰레드를 사용하면 동시에 여러작업을 수행하는 것처럼 보인다(실제로는 동시아님). 이러한 멀티쓰레드는 많은 장점이 존재한다.\n\n- CPU의 사용률 향상\n- 효율적인 자원의 사용\n- 사용자에 대한 응답성 향상\n- 코드 간결\n\n우리가 메신저로 채팅을 하면서 파일을 다운로드 받거나 음성대화를 나눌 수 있는 것도 대표적인 멀티쓰레드를 활용한 예이다. (그래서 멀티쓰레드를 처음배우면 꼭 채팅프로그램 만들어보는 이유이다)\n\n그러면 무조건 멀티쓰레드를 사용해서 여러작업을 동시에 수행하는게(실제로는 동시아님) 더 효율적이지 않을까 생각할 수 있지만, 뭐든 득이 있으면 실이 있는법! 항상 그렇지만은 않다. **멀티쓰레드, 즉 여러개의 쓰레드를 사용하면 같은 프로세스 내에서 자원을 공유하며 작업을 하기 때문에 동기화(Synchronized), 교착상태(Deadlock) 같은 문제들을 고려하여 프로그래밍 해야한다.** 이부분은 뒤에 좀더 자세하게 설명하겠지만 아무튼 무조건적으로 멀티쓰레드가 효율적이다 라는건 절대 아니다!\n\n<br><br>\n\n### 📌 싱글쓰레드와 멀티쓰레드 비교 ( 싱글코어 )\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/thread2.png?raw=true\">\n</p>\n\n위 그림은 **싱글코어 환경**에서 싱글 쓰레드와 멀티쓰레드의 작업을 비교한 그림이다. 첫번째 그림은 싱글쓰레드에서 두개의 작업을 처리하는 경우이다. A작업을 마친후에 B작업을 수행하는것을 볼 수 있다. 두번째 그림은 멀티쓰레드(2개)로 두개의 작업을 처리하는 경우이다. 두개의 쓰레드로 작업 하는 경우에는 짧은 시간동안 th1, th2 두개의 쓰레드가 번갈아가며 작업하고 있기때문에 두 작업이 동시에 처리되는 것처럼 느끼게 한다.\n\n그런데 위 그림을 보면 싱글쓰레드나 멀티쓰레드나 두 작업이 처리되는 시간은 거의 동일하다. 오히려 멀티쓰레드로 처리한 작업시간이 더 오래걸리게 된다. 그 이유는 **멀티쓰레드 작업시 쓰레드 간 작업 전환(Context Switching)에 걸리는 시간이 멀티쓰레드로 작업함으로써 단축되는 시간보다 더 크기 때문이다.**\n\n이러한 이유로 멀티쓰레드 작업이 항상 더 좋은것은 아님을 설명할 수 있다. 싱글코어 환경에서 단순히 CPU만을 사용하는 계산작업 이라면 오히려 멀티쓰레드보다 싱글쓰레드 환경이 더 효율적일 수 있다.\n\n<br><br>\n\n### 📌 멀티쓰레드 예제\n싱글쓰레드는 우리가 `main()`에서 맨날 실행하는 코드가 전부 싱글쓰레드 이므로 예제는 생략하고 멀티쓰레드의 예제만 살펴보도록 하겠다.\n\n```java\npublic class Ex12_MultiThread {  \n  \n\tstatic long startTime = 0;  \n  \n\tpublic static void main(String[] args) {  \n\t\tThread1 th1 = new Thread1();  \n\t\tth1.start();  \n\t\tstartTime = System.currentTimeMillis();  \n  \n\t\tfor(int i=0;i<300;i++) System.out.printf(\"%s\", new String(\"-\"));  \n  \n\t\tSystem.out.println(\"소요시간 1 : \"+(System.currentTimeMillis()-Ex12_MultiThread.startTime));  \n\t}  \n}  \n  \nclass Thread1 extends Thread {  \n\tpublic void run(){  \n\t\tfor(int i=0;i<300;i++){  \n\t\t\tSystem.out.printf(\"%s\", new String(\"|\"));  \n\t\t}  \n\t\tSystem.out.print(\"소요시간2 : \" + (System.currentTimeMillis() - Ex12_MultiThread.startTime));  \n\t}  \n}\n```\n```java\n[결과]\n-----------------------------------------------\n-----------------------------------------------\n-----------------------||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||||||||\n||||||||||||||||||||||||||---------------------\n-----------------------------------------------\n-----------------------------------------------\n---||||||||||||||||||||||||||||||||||||--------\n-------------------||||||||||||||||||||||||||소요\n시간2 : 35---------------------------------소요시\n간 1 : 36\n```\n\n위와 같은 예제에서 싱글쓰레드인 경우를 보이진 않았지만 실제로 비교를 해보면 싱글쓰레드로 실행한 작업시간이 더 짧다. 앞서 언급했다시피 **멀티쓰레드를 사용할 때 쓰레드 간의 작업전환시간 + 화면에 출력하기위한 대기시간**이 소요되기 때문에 멀티쓰레드가 더 오래걸리는 것이다. \n\n<br><Br><br><br>\n\n## ✅ 쓰레드의 우선순위\n\n**쓰레드는 우선순위(Priority)라는 속성을 가지고 있는데, 이 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다.** 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 달리하여 특정 쓰레드가 더 많은 작업시간을 갖게하는 것이다.\n\n예를들어 파일전송기능이 있는 메신저의 경우, 파일다운로드를 처리하는 쓰레드보다 메세지 전송을 처리하는 쓰레드의 우선순위를 더 높게하여 메세지를 보내면서도 파일 다운로드를 할 수 있게끔 만들어야 한다.\n\n```JAVA\nvoid setPriority(int newPriority)  // 쓰레드의 우선순위 지정\nvoid getPriority()                 // 쓰레드의 우선순위 반환\n```\n\n위와 같은 코드로 우선순위를 지정할 수 있고 1~10범위를 가지며 숫자가 높을수록 높은 우선순위를 의미한다. 또한 `main()` 메소드를 수행하는 쓰레드는 우선순위가 5로 자동 지정된다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/thread3.png?raw=true\">\n</p>\n\n위의 그림은 WINDOWS의 싱글코어 환경에서 쓰레드의 우선순위가 같은 경우와 A가 더 높은 경우 두가지 실행시간에 대한 그림이다. 우선순위가 같은 경우 A,B 두개의 쓰레드가 거의 동일한 실행시간을 가지지만, A의 우선수위가 높은 경우에는 A에 더 많은 실행시간이 먼저 부여된것을 볼 수 있다. 때문에 A가 먼저 작업이 끝나고 B가 이후에 끝나는 모습이 보인다.\n\n**그러나!** 똑같은 실험을 멀티코어 환경에서 진행해보면 실행결과는 왼쪽 그림과 똑같다. 우선순위를 다르게하여 여러번 실험을 해봐도 결과는 똑같다. **멀티코어 환경에서는 두 쓰레드의 우선순위를 달리하여도 실행시간에 대한 차이가 거의 아예 없다.** 한마디로 **\"멀티코어 환경에서는 쓰레드에 높은 우선순위를 준다 할지라도 더 많은 실행시간과 실행기회를 갖지 못할 수 있다\"** 라는 뜻이다.\n\n<br><br>\n\n### 📌 쓰레드 우선순위는 사실 실행 시간을 보장하지 않는다..!\n\n사실 대부분의 JAVA 기본책이나 블로그 글을 보면 위와 같은 내용이 대부분이고 쓰레드의 우선순위 부여가 실행시간을 보장해주진 않는다 정도로 마무리 되는데 좀 구체적인 이유가 궁금해서 찾아봤다.\n\n**자바에서 쓰레드에 우선순위를 부여하면 해당 쓰레드가 실행되는 우선순위는 높아지지만, 보장된 실행시간을 의미하지는 않는다.** 쓰레드의 우선순위는 단지 스케줄러에게 어떤 쓰레드를 우선적으로 실행시킬지 알려주는 힌트일 뿐이다.\n\n실제로 OS와 하드웨어에 따라 쓰레드 스케줄링 정책이 달라지고, 우선순위에만 의존해서 쓰레드 실행시간을 보장할 수는 없다. 예를들어 OS에서 Round Robin 스케줄링을 사용하면, 모든 쓰레드에 동등한 실행 시간을 할당하게 되어 우선순위가 높은 쓰레드가 먼저 실행되는 것을 보장할 수 없다. \n\n또한 다른 우선순위를 가진 쓰레드가 경쟁 상태(race condition)에 놓일 경우에도 우선순위가 높은 쓰레드가 우선적으로 실행되지 않을 수도 있다.\n\n이처럼 쓰레드 우선순위는 쓰레드 스케줄링에 영향을 줄 수는 있지만, 실행시간을 보장해주지는 않는다. 쓰레드 간의 상호작용과 공유 자원 접근을 관리하고, 실행시간을 조절하기 위해서는 동기화 메커니즘과 다른 쓰레드 제어 기법을 사용해야 한다.\n\n\n<br><Br><br><br>\n\n## ✅ 데몬 쓰레드(daemon thread)\n\n데몬쓰레드는 다른 일반쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다. 데몬쓰레드는 일반쓰레드의 보조 역할이기 때문에 일반쓰레드가 종료되면 자동으로 데몬쓰레드 역시 종료된다. 무한루프와 조건문을 이용해서 실행 후 대기하다가 특정 조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다.\n\n```java\nboolean isDaemon()\t// 데몬쓰레드인지 확인\nvoid setDaemon(boolean on)\t// 쓰레드를 데몬쓰레드로 변경\n```\n`setDaemon(boolean on)`은 반드시 `start()`를 호출하기 전에 실행되어야 한다. 그렇지 않으면 `IllegalThreadStateException`이 발생한다.\n","properties":"\n","discussions":{},"comments":{},"hash":693119406,"tx":11239},"hsMOxKWCChERUD8N/syncedContent":{"id":"hsMOxKWCChERUD8N/syncedContent","type":"syncedContent","historyData":{"248958273":{"id":"hsMOxKWCChERUD8N/content","type":"content","text":"---\npermalink: /2022-09-01-익명 클래스/\npublished: true\ntitle: \"[JAVA] 익명 클래스 \"\ndate: 2022-09-01 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 익명 클래스\n---\n\n<br><br>\n\n## ✅ 익명 클래스란?\n\n**익명 클래스**란 **이름을 갖지 않는 클래스**이다. **클래스 선언과 오브젝트 생성이 결합된 형태**로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용해서 정해진 형태로 만들어 사용한다. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.\n```java\nnew 인터페이스이름() { 클래스 본문 };\n```\n<br><br>\n\n이해를 위해 간단한 예시를 들어보면, 생명체라는 부모클래스를 상속받는 사람 클래스가 있다고 치자. 사람은 총 60억명 있고, 이들은 각각 직업에 따라 하는 일이 다르며, 공통적인 특징은 없다. 잠깐 프로그램에 **단발성으로 등장해서 자신이 맡은 일을 하고 사라진다**고 치자.\n\n<br><br>\n\n그러면 이런상황에서 우리가 60억명의 사람들을 클래스로 만들어 구현하는 것이 나을지, 아니면 하**나의 클래스에서 코드로 일시적으로 정의하여 쓰고 버리는것이 나을지** 선택하면 된다. 아마 60억개의 클래스를 만들 사람은 없을거다. \n\n<br><br>\n\n어차피 단발성으로 등장해서 사용하고 다시는 안 쓸 오브젝트들 인데 클래스로 만들어서 유지보수 하기에는 부담이 너무 크고 불필요하다.\n\n<br><br>\n\n이럴때 바로 우리는 **익명 클래스**를 사용하는 것이다!\n<br><br><Br><br>\n\n## ✅ 익명 클래스 구현 ( 인터페이스 )\n\n#### 📌 인터페이스\n```java\npublic interface StatementStrategy {\n\tPreparedStatement makePreparedStatement(Connection c) throws SQLException;\n}\n```\n<br>\n\n#### 📌 일반 클래스 ( 이 클래스를 익명 클래스로 전환 할꺼임 ) \n```java\npublic class AddStatement implements StatementStrategy {\n\tUser user;\n\t\n\tpublic AddStatement(User user) {\n\t\tthis.user = user;\n\t}\n\t\n\tpublic PreparedStatement makePreparedStatement(Connection c) throws SQLException {\n\n\t\tPreparedStatement ps = c.prepareStatement(\"insert into users(id,name,password) values(?,?,?)\");\n\t\tps.setString(1, user.getId());\n\t\tps.setString(2, user.getName());\n\t\tps.setString(3, user.getPassword());\n\n\t\treturn ps;\n\t}\n}\n```\n\n새로운 사용자를 DB에 추가하는 코드이다. 위 코드는 프로젝트 내에서 UserDao라는 단하나의 클래스에서만 사용되고 다른 클래스에서는 전혀 사용되지 않는다. 또한 StatementStrategy 라는 인터페이스를 상속받아 makePreparedStatement를 구현하고 있다.\n\n<br><br><br>\n\n#### 📌 익명 클래스의 구현\n\n```java\n...(생략)\n\npublic class UserDao {\n\t...\n\t// 사용자 추가 메소드\n\tpublic void add(final User user) throws SQLException {\n\n\t\t// AddStatement를 익명 내부 클래스로 전환\n\t\tthis.jdbcContext.workWithStatementStrategy(new StatementStrategy() {\n\n\t\t\tpublic PreparedStatement makePreparedStatement(Connection c) throws SQLException {\n\t\t\t\tPreparedStatement ps = c.prepareStatement(\"insert into users(id, name, password) values(?,?,?)\");\n\t\t\t\tps.setString(1, user.getId());\n\t\t\t\tps.setString(2, user.getName());\n\t\t\t\tps.setString(3, user.getPassword());\n\t\t\t\treturn ps;\n\t\t\t}\n\t\t});\n\t}\n\n\t...\n\t\n```\n\n코드를 보면  ``` this.jdbcContext.workWithStatementStrategy(new StatementStrategy() { AddStatement 클래스 본문 } ``` 이런 형태로 만들어진것을 볼 수 있다. 우리가 구현 할 클래스를 따로 이름을 정해주지 않고 다른 클래스 내부에 직접 만들어 주는 형태다.\n\n위 코드에서 익명 클래스는 ```new StatementStrategy() { ... }``` 이다. 익명클래스를 파라미터로 가진 형태이다. \n\n<br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":248958273},"2034997703":{"id":"hsMOxKWCChERUD8N/content","type":"content","text":"---\npermalink: /2022-09-01-익명 클래스/\npublished: true\ntitle: \"[JAVA] 익명 클래스 \"\ndate: 2022-09-01 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n- 익명 클래스\n---\n\n<br><br>\n\n## ✅ 익명 클래스란?\n\n**익명 클래스**란 **이름을 갖지 않는 클래스**이다. **클래스 선언과 오브젝트 생성이 결합된 형태**로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용해서 정해진 형태로 만들어 사용한다. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.\n```java\nnew 인터페이스이름() { 클래스 본문 };\n```\n<br><br>\n\n이해를 위해 간단한 예시를 들어보면, 생명체라는 부모클래스를 상속받는 사람 클래스가 있다고 치자. 사람은 총 60억명 있고, 이들은 각각 직업에 따라 하는 일이 다르며, 공통적인 특징은 없다. 잠깐 프로그램에 **단발성으로 등장해서 자신이 맡은 일을 하고 사라진다**고 치자.\n\n<br><br>\n\n그러면 이런상황에서 우리가 60억명의 사람들을 클래스로 만들어 구현하는 것이 나을지, 아니면 하**나의 클래스에서 코드로 일시적으로 정의하여 쓰고 버리는것이 나을지** 선택하면 된다. 아마 60억개의 클래스를 만들 사람은 없을거다. \n\n<br><br>\n\n어차피 단발성으로 등장해서 사용하고 다시는 안 쓸 오브젝트들 인데 클래스로 만들어서 유지보수 하기에는 부담이 너무 크고 불필요하다.\n\n<br><br>\n\n이럴때 바로 우리는 **익명 클래스**를 사용하는 것이다!\n<br><br><Br><br>\n\n## ✅ 익명 클래스 구현 ( 인터페이스 )\n\n#### 📌 인터페이스\n```java\npublic interface StatementStrategy {\n\tPreparedStatement makePreparedStatement(Connection c) throws SQLException;\n}\n```\n<br>\n\n#### 📌 일반 클래스 ( 이 클래스를 익명 클래스로 전환 할꺼임 ) \n```java\npublic class AddStatement implements StatementStrategy {\n\tUser user;\n\t\n\tpublic AddStatement(User user) {\n\t\tthis.user = user;\n\t}\n\t\n\tpublic PreparedStatement makePreparedStatement(Connection c) throws SQLException {\n\n\t\tPreparedStatement ps = c.prepareStatement(\"insert into users(id,name,password) values(?,?,?)\");\n\t\tps.setString(1, user.getId());\n\t\tps.setString(2, user.getName());\n\t\tps.setString(3, user.getPassword());\n\n\t\treturn ps;\n\t}\n}\n```\n\n새로운 사용자를 DB에 추가하는 코드이다. 위 코드는 프로젝트 내에서 UserDao라는 단하나의 클래스에서만 사용되고 다른 클래스에서는 전혀 사용되지 않는다. 또한 StatementStrategy 라는 인터페이스를 상속받아 makePreparedStatement를 구현하고 있다.\n\n<br><br><br>\n\n#### 📌 익명 클래스의 구현\n\n```java\n...(생략)\n\npublic class UserDao {\n\t...\n\t// 사용자 추가 메소드\n\tpublic void add(final User user) throws SQLException {\n\n\t\t// AddStatement를 익명 내부 클래스로 전환\n\t\tthis.jdbcContext.workWithStatementStrategy(new StatementStrategy() {\n\n\t\t\tpublic PreparedStatement makePreparedStatement(Connection c) throws SQLException {\n\t\t\t\tPreparedStatement ps = c.prepareStatement(\"insert into users(id, name, password) values(?,?,?)\");\n\t\t\t\tps.setString(1, user.getId());\n\t\t\t\tps.setString(2, user.getName());\n\t\t\t\tps.setString(3, user.getPassword());\n\t\t\t\treturn ps;\n\t\t\t}\n\t\t});\n\t}\n\n\t...\n\t\n```\n\n코드를 보면  ``` this.jdbcContext.workWithStatementStrategy(new StatementStrategy() { AddStatement 클래스 본문 } ``` 이런 형태로 만들어진것을 볼 수 있다. 우리가 구현 할 클래스를 따로 이름을 정해주지 않고 다른 클래스 내부에 직접 만들어 주는 형태다.\n\n위 코드에서 익명 클래스는 ```new StatementStrategy() { ... }``` 이다. 익명클래스를 파라미터로 가진 형태이다. \n\n<br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":2034997703}},"syncHistory":{"main":[248958273,2034997703,248958273]},"v":1,"hash":1710892103361,"tx":11239},"VQOgcLROQ4ay0oXW/content":{"id":"VQOgcLROQ4ay0oXW/content","type":"content","text":"---\npermalink: /2023-06-22-Thread/\npublished: true\ntitle: \"[JAVA] [객체지향] 좋은 객체지향 설계의 5가지 원칙\"\ndate: 2023-07-10 17:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ SOLID란 ?\n\n1. SPR(Single Responsibility Principle) : 단일 책임 원칙\n\n2. OCP(Open Closed Principle) : 개방 폐쇄 원칙\n\n3. LSP(Liskov Substitution Princlple) : 리스코프 치환 원칙\n\n4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙\n\n5. DIP(Dependency Inversion Principle) : 의존 역전 원칙\n\n\n\n\n\n\n\n\n\n좋은 객체지향 설계의 5가지 원칙\n","properties":"\n","discussions":{},"comments":{},"hash":1047674723,"tx":11242},"w6ADipsYQPt3OgNW/syncedContent":{"id":"w6ADipsYQPt3OgNW/syncedContent","type":"syncedContent","historyData":{"1036542384":{"id":"w6ADipsYQPt3OgNW/content","type":"content","text":"---\npermalink: /2023-06-16-6)Static/\npublished: true\ntitle: \"[JAVA] Static \"\ndate: 2023-06-16 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ Static - 클래스의, 공통적인\nStatic은 단어 그대로는 정적인, 고정된 이라는 의미를 가지지만 객체지향에서의 static은 **'클래스의'** 또는 **'공통적인'**의 의미를 가지고 있다. static 키워드를 사용하여 **static변수와 static 메소드**를 만들 수 있는데 다른말로 각각 **정적필드와 정적 메소드**라고하며 이 둘을 합쳐 **정적 멤버**라고 한다.\n\n인스턴스 변수는 하나의 클래스로부터 생성되었더라고 각자 다른 값을 유지하지만, **static 멤버 변수(클래스변수)는 인스턴스에 관계없이 같은 값을 가진다.** static 멤버는 인스턴스에 소속된 멤버가 아니라 **클래스에 고정된 멤버**이기 때문이다. 그래서 클래스로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할때 클래스 별로 관리된다. \n\n\n<br><br><Br><br>\n## ✅ Static 멤버 메모리 영역\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/static3.png?raw=true\">\n</p>\n\nStatic 키워드를 통해 생성된 정적멤버들은 Heap영역이 아닌 Static영역에 할당된다. **Static 영역에 할당된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점**을 가지지만 **Garbage Collector의 관리 영역 밖에 존재하기에 Static영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 존재**하게 된다. 그렇기에 Static을 너무 남발하게 되면 만들고자 하는 시스템 성능에 악영향을 줄 수 있다.\n\n<br><br><Br><br>\n## ✅ Static 메서드와 인스턴스 메서드\n일반적으로 메서드 앞에 static이 붙어있으면 클래스 메서드 (static 메서드)이고 붙어있지 않으면 인스턴스 메서드로 정의한다. 클래스 메서드는 앞서 언급한것처럼 static 메모리 영역에 저장되기 때문에 **객체를 생성하지 않고도 `클래스이름.메서드이름(매개변수)` 와 같은 형태로 호출이 가능하다.**  반면에 **인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있다.**\n\n<br>\n\n```java\nclass Calculator {\n  long a,b;\n\n  // 인스턴스 변수 a,b를 사용하기 때문에 매개변수가 필요없다\n  long add() { return a+b; }  // a,b는 인스턴스 변수\n  long sub() { return a-b; }\n  long multi() { return a*b; }\n  double div() { return a/b; }\n\n  // 인스턴스 변수와 관계없이 매개변수만으로 작업 가능하다\n  static long add(long a, long b) { return a+b; }  // a,b는 지역변수\n  static long long sub(long a, long b) { return a-b; }\n  static long multi(long a, long b) { return a*b; }\n  static double div(long a, long b) { return a/(double)b; }\n}\n\n\nclass Main {\n  public static void main(String args[]){\n    // 클래스 메서드 호출. 인스턴스 생성없이 호출 가능\n    System.out.println(Calculator.add(200L,100L);\n    System.out.println(Calculator.sub(200L,100L);\n    System.out.println(Calculator.multi(200L,100L);\n    System.out.println(Calculator.div(200L,100L);\n\n    Calculator cal = new Calculator(); // 인스턴스 생성\n    cal.a = 200L;\n    cal.b = 200L;\n\t\n\t// 인스턴스 메서드는 객체생성후에 호출 가능\n    System.out.println(mm.add());\n    System.out.println(mm.sub());\n    System.out.println(mm.multi());\n    System.out.println(mm.div());\n  }\n}\n```\n\n<br>\n\n인스턴스 메서드인 `add(), sub(), multi(), div()` 는 인스턴스 변수인 a,b로 충분히 작업이 가능하기 때문에 굳이 매개변수를 선언하지 않았다. \n\n반면에 클래스 메서드인 add(long a, long b), sub(long a, long b)등은 인스턴스 변수 없이 매개변수만으로 작업을 수행하기 때문에 static 메서드를 붙여 클래스 메서드로 선언하였다.\n\n그래서 main에서 클래스메서드는 객체호출없이 바로 사용했지만, 인스턴스 메서드는 객체호출을 한뒤 사용한걸 볼 수 있다.\n\n\n<br><br><Br><br>\n## ✅ static을 언제 붙여야 할까?\n\n1. **클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.**\n\t생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스 변수로 정의해야 한다.\n\n2. **클래스 변수(Static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.**\n\tstatic이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.\n\n3.  **클래스 메서드(Static메서드)는 인스턴스 변수를 사용할 수 없다.**\n\t인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 생성없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그래서 클래스 메서드에서 인스턴스 변수의 사용을 금지한다.\n\t반면에 인스턴스 변수나 인스턴스 메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.\n\n4. **메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.**\n\t메서드의 작업내용 중에서 인스턴스 변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스 변수를 필요로 하지 않는다면 static을 붙이자. 메서드 호출시간이 짧아지므로 성능이 향상된다. static을 안붙인 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":1036542384},"1392774314":{"id":"w6ADipsYQPt3OgNW/content","type":"content","text":"---\npermalink: /2023-06-16-6)Static/\npublished: true\ntitle: \"[JAVA] Static \"\ndate: 2023-06-16 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ Static - 클래스의, 공통적인\nStatic은 단어 그대로는 정적인, 고정된 이라는 의미를 가지지만 객체지향에서의 static은 **'클래스의'** 또는 **'공통적인'**의 의미를 가지고 있다. static 키워드를 사용하여 **static변수와 static 메소드**를 만들 수 있는데 다른말로 각각 **정적필드와 정적 메소드**라고하며 이 둘을 합쳐 **정적 멤버**라고 한다.\n\n인스턴스 변수는 하나의 클래스로부터 생성되었더라고 각자 다른 값을 유지하지만, **static 멤버 변수(클래스변수)는 인스턴스에 관계없이 같은 값을 가진다.** static 멤버는 인스턴스에 소속된 멤버가 아니라 **클래스에 고정된 멤버**이기 때문이다. 그래서 클래스로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할때 클래스 별로 관리된다. \n\n\n<br><br><Br><br>\n## ✅ Static 멤버 메모리 영역\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/static3.png?raw=true\">\n</p>\n\nStatic 키워드를 통해 생성된 정적멤버들은 Heap영역이 아닌 Static영역에 할당된다. **Static 영역에 할당된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점**을 가지지만 **Garbage Collector의 관리 영역 밖에 존재하기에 Static영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 존재**하게 된다. 그렇기에 Static을 너무 남발하게 되면 만들고자 하는 시스템 성능에 악영향을 줄 수 있다.\n\n<br><br><Br><br>\n## ✅ Static 메서드와 인스턴스 메서드\n일반적으로 메서드 앞에 static이 붙어있으면 클래스 메서드 (static 메서드)이고 붙어있지 않으면 인스턴스 메서드로 정의한다. 클래스 메서드는 앞서 언급한것처럼 static 메모리 영역에 저장되기 때문에 **객체를 생성하지 않고도 `클래스이름.메서드이름(매개변수)` 와 같은 형태로 호출이 가능하다.**  반면에 **인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있다.**\n\n<br>\n\n```java\nclass Calculator {\n  long a,b;\n\n  // 인스턴스 변수 a,b를 사용하기 때문에 매개변수가 필요없다\n  long add() { return a+b; }  // a,b는 인스턴스 변수\n  long sub() { return a-b; }\n  long multi() { return a*b; }\n  double div() { return a/b; }\n\n  // 인스턴스 변수와 관계없이 매개변수만으로 작업 가능하다\n  static long add(long a, long b) { return a+b; }  // a,b는 지역변수\n  static long long sub(long a, long b) { return a-b; }\n  static long multi(long a, long b) { return a*b; }\n  static double div(long a, long b) { return a/(double)b; }\n}\n\n\nclass Main {\n  public static void main(String args[]){\n    // 클래스 메서드 호출. 인스턴스 생성없이 호출 가능\n    System.out.println(Calculator.add(200L,100L);\n    System.out.println(Calculator.sub(200L,100L);\n    System.out.println(Calculator.multi(200L,100L);\n    System.out.println(Calculator.div(200L,100L);\n\n    Calculator cal = new Calculator(); // 인스턴스 생성\n    cal.a = 200L;\n    cal.b = 200L;\n\t\n\t// 인스턴스 메서드는 객체생성후에 호출 가능\n    System.out.println(mm.add());\n    System.out.println(mm.sub());\n    System.out.println(mm.multi());\n    System.out.println(mm.div());\n  }\n}\n```\n\n<br>\n\n인스턴스 메서드인 `add(), sub(), multi(), div()` 는 인스턴스 변수인 a,b로 충분히 작업이 가능하기 때문에 굳이 매개변수를 선언하지 않았다. \n\n반면에 클래스 메서드인 add(long a, long b), sub(long a, long b)등은 인스턴스 변수 없이 매개변수만으로 작업을 수행하기 때문에 static 메서드를 붙여 클래스 메서드로 선언하였다.\n\n그래서 main에서 클래스메서드는 객체호출없이 바로 사용했지만, 인스턴스 메서드는 객체호출을 한뒤 사용한걸 볼 수 있다.\n\n\n<br><br><Br><br>\n## ✅ static을 언제 붙여야 할까?\n\n1. **클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.**\n\t생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스 변수로 정의해야 한다.\n\n2. **클래스 변수(Static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.**\n\tstatic이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.\n\n3.  **클래스 메서드(Static메서드)는 인스턴스 변수를 사용할 수 없다.**\n\t인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 생성없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그래서 클래스 메서드에서 인스턴스 변수의 사용을 금지한다.\n\t반면에 인스턴스 변수나 인스턴스 메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.\n\n4. **메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.**\n\t메서드의 작업내용 중에서 인스턴스 변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스 변수를 필요로 하지 않는다면 static을 붙이자. 메서드 호출시간이 짧아지므로 성능이 향상된다. static을 안붙인 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":1392774314}},"syncHistory":{"main":[1392774314,1036542384,1392774314]},"v":1,"hash":1710892106190,"tx":11243},"omFvrSXYtukeVixH/syncedContent":{"id":"omFvrSXYtukeVixH/syncedContent","type":"syncedContent","historyData":{"1456159858":{"id":"omFvrSXYtukeVixH/content","type":"content","text":"---\npermalink: /2023-06-16-7)예외처리 (try,catch, finally, throws)/\npublished: true\ntitle: \"[JAVA] 예외처리 ( try, catch, finally, throws ) \"\ndate: 2023-06-16 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ 프로그램 오류\n\n프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있는데, 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다.\n\n<br><br>\n\n### 📌 발생시점에 따른 에러 분류\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/exception2.png?raw=true\">\n</p>\n\n프로그램 오류는 발생시점에 따라 **컴파일 에러**와 **런타임 에러**로 나눌수 있다. 추가적으로 **논리적 에러**도 존재한다.\n\n**컴파일 에러는 글자 그대로 컴파일 할 때 발생하는 에러이고 소스의 오타나 잘못된 구문, 자료형 체크등 검사를 수행하면서 발생한다.**\n```java\n@Test  \nvoid compileError() {\n    STring helloStr = \"hello\";   // String이 아닌 STring으로 작성해서 오류발생\n    System.out.println(\"helloStr = \"  + helloStr);\n}\n```\n\n<br>\n\n**런타임 에러는 프로그램의 실행 시점에서 발생하는 에러로 컴파일 이후 프로그램이 실행되고 실행도중 의도치 않은 동작에 대처하지 못해 에러가 발생한다.**\n```java\n// 문자가 숫자형태가 아닌 문자 타입인 경우 \n// parseInt()메서드에서 NumberFormatException 발생\nvoid stringToInt(String str) {\n    int i = Integer.parseInt(str);\n    System.out.println(\"str : \" + i);\n```\n\n<br>\n논리적 에러는 컴파일도 잘되고 실행도 잘되지만 의도와는 다르게 동작하는 것을 말한다. 버튼을 뜨게 만들었는데 페이지가 뜬다거나, 아무 동작도 안하게 만들었는데 무언가 출력된다던가 하는 에러를 말한다.\n\n\n<br><br><br><br>\n\n## ✅ 예외 클래스의 계층 구조\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/exception1.png?raw=true\">\n</p>\n\n자바에서는 실행 시 발생할 수 있는 오류를 클래스로 정의했다. 모든 클래스의 조상은 Object 클래스이므로 Exception과 Error클래스 역시 Object클래스의 자손들이다.\n\n모든 예외의 최고 조상인 Exception 클래스는 크게 두가지로 나뉜다. **Exception 클래스와 자손들, RuntimeException클래스와 자손들** 두가지가 있다. \n\nRuntimeException클래스와 하위 예외들을 **선택적 예외(unchecked Exception)**로 개발자가 상황에 맞춰 대응해줘야 하는 예외이고 그외 나머지 예외클래스와 하위객체들을 **필수 예외(checked Exception)**라 하여 반드시 확인해줘야 하는 예외이다.\n\n**RuntimeException 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.** 배열의 범위를 벗어난 ArrayIndexOutOfBoundsException, 값이 null인 참조변수를 호출할때 발생하는 NullPointerException, 클래스간의 형변환을 잘못할때 발생하는 ClassCastException, 정수를 0으로 나눌 때 발생하는 ArithmeticException 등이 있다.\n\n**Exception 클래스들은 외부의 영향으로 발생할 수 있는 예외들로 프로그램의 사용자들의 동작에 의해 발생하는 경우가 많다.** 존재하지 않는 파일의 이름을 입력하는 FileNotFoundException, 클래스의 이름을 잘못 입력한 ClassNotFoundException, 입력 데이터 형식이 잘못된 DataFormatException 등이 있다.\n\n<br><br><br><br>\n\n## ✅ 예외 처리하기 :: try-catch\n\n프로그램의 실행 도중에 발생하는 오류는 어쩔 수 없지만, **프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생은 예외처리**를 통해 해결할 수 있다.\n\n예외처리를 위한 첫번째 방법은 **try-catch 구문**을 사용하는 것이다.\n\n```java\ntry {\n\t// 예외가 발생할 가능성이 있는 문장을 넣는다.\n} catch ( Exception1 e1 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} catch ( Exception2 e2 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} catch ( Exception3 e3 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} finally {\n\tdeleteTempFiles() // 프로그램 설치에 사용된 임시파일 삭제\n\t// try-catch구문이 종료되고 무조건 실행할 문장을 넣는다.\n}\n```\n\n하나의 try 블럭 다음에는 여러개의 catch블럭이 나올 수 있고, 발생한 예외의 종류와 일치하는 catch 블럭이 수행되고 try-catch 구문을 통째로 빠져나온다. 이때, 발생한 예외의 종류과 일치하는 catch블럭이 없는경우에는 예외가 처리되지 않는다.\n\n**`finally`** 는 예외 발생여부와 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용된다. try-catch 구문 끝에 선택적을 사용할 수 있다. 보통 임시파일 삭제나 DB연결 해제 등 불필요한 메모리를 지우거나 기존 연결을 해제하는 등 반드시 실행되어야 할 코드를 작성한다. \n\n또한 **catch문에 들어갈 예외의 순서는 작은 범위부터 차례대로 넣어줘야 한다.** 예를 들어 Exception 예외처리를 하는경우에 ,Exception 예외 클래스가 가장 최상의 부모클래스이므로 마지막 catch 구문에 작성해줘야만 한다.\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tint i = 10 ;  \n\t\tString str = \"aa\";  \n\t\ttry {  \n\t\t\tint result = 10 / i \n\t\t\treturn;  \n\t\t} catch(ArithmeticException e) {  \n\t\t\tSystem.out.println(\"ArithmeticException 발생!\");  //ArithmeticException 이 발생 했을 때만 실행  \n\t\t} catch(NullPointerException e) {  \n\t\t\tSystem.out.println(\"NullPointerException 발생!\");  //NullPointerException 이 발생 했을 때만 실행  \n\t\t} catch(Exception e){  \n\t\t\t// 그 외의 Exception 이 발생 했을 때 실행  \n\t\t} finally{  \n\t\t\tSystem.out.println(\"항상 실행\");  \n\t\t}  \n\t\t\tSystem.out.println( \"정상 종료\");  \n\t}  \n}\n```\n\n위의 코드를 보면 `ArithmeticException`, `NullPointerException`, 그리고 `Exception` 예외처리를 한것을 볼 수 있는데 `Exception` 예외처리를 가장 마지막 catch문에 작성한 것을 볼 수 있다.\n\n만일 `Exception` 예외처리를 상위 catch문에 작성한다면 `ArithmeticException`이나 `NullPointerException`이 발생한 경우에도 `Exception` 예외처리를 진행하게 된다. 그렇게 되면 각각의 예외에 맞는 catch문을 실행할 수 없어지기 때문에 올바른 예외처리를 못하게 된다. 따라서 `Exception` 예외처리는 가장 마지막 catch문에 작성해줘야만 한다.\n\n\n<br><br><br>\n### 📌 try-catch문에서의 흐름\ntry-catch문에서, 예외가 발생한 경우와 발생하지 않은 경우에 흐름은 달라진다.\n\n- **try 블럭 내에서 예외가 발생한 경우**\n\t1. 발생한 예외와 일치하는 catch문이 있는지 확인한다.\n\t2. 일치하는 catch문을 찾으면, 해당 catch블럭 내의 문장들을 수행하고, **try-catch문을 통째로 빠져나간다.**\n\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tSystem.out.println(1);\n\t\ttry {\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(3);\n\t\t} catch(Exception e) {\n\t\t\tSystem.out.println(4);\n\t\t}\n\t\tSystem.out.println(5);\n\t}  \n} // 1 2 3 5 가 출력된다\n```\n\n위 코드를 보면 어떤 오류도 발생하지 않는다. 때문에 try문은 그대로 출력되고 catch문은 실행되지 않는다. 이후 try-catch 구문을 빠져나간뒤 5를 출력한다. 결과적으로는 1, 2, 3, 5가 출력될 것이다.\n<br><br>\n\n\n- **try 블럭 내에서 예외가 발생하지 않은 경우**\n\t1. catch문을 거치지 않고 try-catch문을 통째로 빠져나간다.\n\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tSystem.out.println(1);\n\t\ttry {\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(0/0);\n\t\t\tSystem.out.println(3);\n\t\t} catch(ArithmeticException ae) {\n\t\t\tSystem.out.println(4);\n\t\t}\n\t\tSystem.out.println(5);\n\t}  \n} // 1 2 4 5 가 출력된다\n```\n\n위의 코드는 0으로 어떤수를 나눴기 때문에 `ArithmeticException`이 발생한다. 때문에 try문의 `System.out.println(0/0);` 문장 이전까지는 정상 실행되다가 `System.out.println(0/0);` 문장에서 오류가 발생하고 catch 구문으로 넘어가 실행되고 이후 try-catch 구문을 통째로 빠져나간다. 때문에 1, 2, 4, 5가 출력될 것이다.\n\n<Br><Br><Br><Br>\n\n## ✅ 예외 처리하기 :: throws\n\n예외를 처리하는 방법에는 try-catch문을 사용하는것 외에, 예외를 메서드에 선언하는 throws를 사용하는 방법이 있다. 메서드에 예외를 선언하려면, 메서드 선언부에 throws를 사용해서 발생 할 수 있는 예외를 적어주기만 하면 된다.\n\n```java\n\tvoid method() throws Exception1, Exception2, ... ExceptionN {\n\t\t// 메서드 내용\n\t}\n```\n\n예외를 선언하면, 해당 예외뿐만 아니라 **자손타입의 예외까지도 발생할 수 있다** 라고 알리는 것이다. 또한 메서드를 통한 예외처리는 실제 예외를 어떻게 처리하겠다 라는 로직을 포함하지 않기때문에 단순히 이러이러한 오류가 발생할 수 있고, **해당 오류가 발생한다면 오류에 대한 처리를 메서드를 호출한 쪽으로 넘기겠다!** 라는 의미로 사용된다. 때문에 사용자쪽은 오류에 대한 `try-catch` 구문을 반드시 사용해 처리해야만 한다.\n\n기존의 다른 언어는 메서드에 예외선언을 하지않기 때문에, 경험이 많은 프로그래머가 아니라면 어떤 상황에서 어떤 종류의 오류가 발생할 가능성이 있는지 예측하기 어려웠다. 그러나 자바에서는 메서드 내에서 발생할 가능성이 있는 예외를 선언부에 명시하여 메서드를 사용하는 쪽에 이에 대한 처리를 강요하기 때문에, 보다 견고한 코드를 작성할 수 있다.\n\n<br><br><br>\n### 📌 메서드에 예외 선언하기 흐름\n\n```java\nclass EX {\n\tpublic static void main(String[] args) throws Exception {\n\t\tmethod1();\n\t}\n\n\tstatic void method1() throws Exception {\n\t\tmethod2();\n\t}\n\n\tstatic void method2() throws Exception {\n\t\tthrow new Exception();\n\t}\n}\n```\n<br>\n\n\n위의 코드를 보면 `method2()` 에서 `throw new Exception();` 을 통해 Exception() 예외를 발생시켰다. `method2()`에서는 try-catch를 통한 예외처리를 하지 않았기 때문에 `method2()`를 호출한 `method1()`로 예외를 넘긴다(throws). `method1()` 에서도 마찬가지로 예외처리를 하지않았으므로 `method1()`을 호출한 `main` 으로 예외를 넘긴다. main에서도 마찬가지로 예외처리를 하지 않았으므로 위의 코드는 오류가 난다.\n\n<Br><br><br>\n\n\n### 📌 메서드에 예외 선언하기 예제\n```java\nclass EX {\n\tpublic static void main(String[] args) {\n\t\ttry{\n\t\t\tFile f = createFile(args[0]);\n\t\t\tSystem.out.println(f.getName()+\"파일이 성공적으로 생성되었습니다.\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.getMessage()+\"다시 입력해주세요\");\n\t\t}\n\t}\n\n\tstatic File createFile(String fileName) throws Exception {\n\t\tif(fileName==null || fileName.equals(\"\"))\n\t\t\tthrow new Exception(\"파일이름이 유효하지 않습니다\");\n\t\tFile f = new File(fileName);\n\t\t\n\t\tf.createNewFile();\n\t\treturn f;\n\t}\n}\n\t\t\n```\n\n위의 코드는 사용자로부터 파일이름을 입력받아서 파일을 생성하는 예제이다. 파일을 생성하는것은 `createFile` 메소드인데 파일이름이 유효하지 않으면 `Exception`을 발생시킨다. 이때 `createFile` 메소드에 예외가 선언되어 있으므로 `createFile` 메소드를 호출한 `main` 으로 예외처리를 넘겨준다. `main` 에서는 넘어온 예외를 try-catch 구문을 통해 해결하고 있다. \n\n그런데 이와 반대로 만약 `createFile` 메소드에서 try-catch 문을 작성해서 오류를 처리하면 어떻게 될까? **`createFile` 메소드에서 처리하게 되면 `main`에서는 오류가 발생했는지 여부도 알지 못하게 된다.**\n\n이를 잘 활용하여 예외가 발생한 메서드 내에서 자체적으로 처리해도 되는 경우 메서드 내에 try-catch문을 넣어서 처리하고, 위 예제처럼 메서드 내에서 자체적으로 해결이 안되는 경우(파일 이름을 다시 받아와야 하는 경우)에는 예외를 선언하여 호출한 메서드가 오류를 처리하도록 해야한다.\n\n \n<br><br><br><Br>\n\n## ✅ 예외 발생시키기 :: throw\n\n키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다. \n\n1. 연산자 new를 이용해 발생시키려는 예외클래스의 객체 생성\n\t`Exception e = new Exception(\"고의로 예외발생\");`\n\n2. 키워드 throw를 이용해 예외 발생\n\t`throw e;`\n\n3. `throw new Exception(\"고의로 예외발생\")` 같은 형태로도 사용가능 \n\n<br>\n\n```java\nclass EX {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tException e = new Exception(\"고의로 발생\");\n\t\t\tthrow e;\n\t\t\t// throw new Exception(\"고의로 발생\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"에러\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"정상종료\");\n\t}\n}\n```\n\n위 코드처럼 고의로 예외를 발생시켜 catch문 처리를 하도록 만들 수도 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":1456159858},"2003709484":{"id":"omFvrSXYtukeVixH/content","type":"content","text":"---\npermalink: /2023-06-16-7)예외처리 (try,catch, finally, throws)/\npublished: true\ntitle: \"[JAVA] 예외처리 ( try, catch, finally, throws ) \"\ndate: 2023-06-16 03:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ 프로그램 오류\n\n프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있는데, 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다.\n\n<br><br>\n\n### 📌 발생시점에 따른 에러 분류\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/exception2.png?raw=true\">\n</p>\n\n프로그램 오류는 발생시점에 따라 **컴파일 에러**와 **런타임 에러**로 나눌수 있다. 추가적으로 **논리적 에러**도 존재한다.\n\n**컴파일 에러는 글자 그대로 컴파일 할 때 발생하는 에러이고 소스의 오타나 잘못된 구문, 자료형 체크등 검사를 수행하면서 발생한다.**\n```java\n@Test  \nvoid compileError() {\n    STring helloStr = \"hello\";   // String이 아닌 STring으로 작성해서 오류발생\n    System.out.println(\"helloStr = \"  + helloStr);\n}\n```\n\n<br>\n\n**런타임 에러는 프로그램의 실행 시점에서 발생하는 에러로 컴파일 이후 프로그램이 실행되고 실행도중 의도치 않은 동작에 대처하지 못해 에러가 발생한다.**\n```java\n// 문자가 숫자형태가 아닌 문자 타입인 경우 \n// parseInt()메서드에서 NumberFormatException 발생\nvoid stringToInt(String str) {\n    int i = Integer.parseInt(str);\n    System.out.println(\"str : \" + i);\n```\n\n<br>\n논리적 에러는 컴파일도 잘되고 실행도 잘되지만 의도와는 다르게 동작하는 것을 말한다. 버튼을 뜨게 만들었는데 페이지가 뜬다거나, 아무 동작도 안하게 만들었는데 무언가 출력된다던가 하는 에러를 말한다.\n\n\n<br><br><br><br>\n\n## ✅ 예외 클래스의 계층 구조\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/exception1.png?raw=true\">\n</p>\n\n자바에서는 실행 시 발생할 수 있는 오류를 클래스로 정의했다. 모든 클래스의 조상은 Object 클래스이므로 Exception과 Error클래스 역시 Object클래스의 자손들이다.\n\n모든 예외의 최고 조상인 Exception 클래스는 크게 두가지로 나뉜다. **Exception 클래스와 자손들, RuntimeException클래스와 자손들** 두가지가 있다. \n\nRuntimeException클래스와 하위 예외들을 **선택적 예외(unchecked Exception)**로 개발자가 상황에 맞춰 대응해줘야 하는 예외이고 그외 나머지 예외클래스와 하위객체들을 **필수 예외(checked Exception)**라 하여 반드시 확인해줘야 하는 예외이다.\n\n**RuntimeException 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.** 배열의 범위를 벗어난 ArrayIndexOutOfBoundsException, 값이 null인 참조변수를 호출할때 발생하는 NullPointerException, 클래스간의 형변환을 잘못할때 발생하는 ClassCastException, 정수를 0으로 나눌 때 발생하는 ArithmeticException 등이 있다.\n\n**Exception 클래스들은 외부의 영향으로 발생할 수 있는 예외들로 프로그램의 사용자들의 동작에 의해 발생하는 경우가 많다.** 존재하지 않는 파일의 이름을 입력하는 FileNotFoundException, 클래스의 이름을 잘못 입력한 ClassNotFoundException, 입력 데이터 형식이 잘못된 DataFormatException 등이 있다.\n\n<br><br><br><br>\n\n## ✅ 예외 처리하기 :: try-catch\n\n프로그램의 실행 도중에 발생하는 오류는 어쩔 수 없지만, **프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생은 예외처리**를 통해 해결할 수 있다.\n\n예외처리를 위한 첫번째 방법은 **try-catch 구문**을 사용하는 것이다.\n\n```java\ntry {\n\t// 예외가 발생할 가능성이 있는 문장을 넣는다.\n} catch ( Exception1 e1 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} catch ( Exception2 e2 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} catch ( Exception3 e3 ) {\n\t// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣는다.\n} finally {\n\tdeleteTempFiles() // 프로그램 설치에 사용된 임시파일 삭제\n\t// try-catch구문이 종료되고 무조건 실행할 문장을 넣는다.\n}\n```\n\n하나의 try 블럭 다음에는 여러개의 catch블럭이 나올 수 있고, 발생한 예외의 종류와 일치하는 catch 블럭이 수행되고 try-catch 구문을 통째로 빠져나온다. 이때, 발생한 예외의 종류과 일치하는 catch블럭이 없는경우에는 예외가 처리되지 않는다.\n\n**`finally`** 는 예외 발생여부와 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용된다. try-catch 구문 끝에 선택적을 사용할 수 있다. 보통 임시파일 삭제나 DB연결 해제 등 불필요한 메모리를 지우거나 기존 연결을 해제하는 등 반드시 실행되어야 할 코드를 작성한다. \n\n또한 **catch문에 들어갈 예외의 순서는 작은 범위부터 차례대로 넣어줘야 한다.** 예를 들어 Exception 예외처리를 하는경우에 ,Exception 예외 클래스가 가장 최상의 부모클래스이므로 마지막 catch 구문에 작성해줘야만 한다.\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tint i = 10 ;  \n\t\tString str = \"aa\";  \n\t\ttry {  \n\t\t\tint result = 10 / i \n\t\t\treturn;  \n\t\t} catch(ArithmeticException e) {  \n\t\t\tSystem.out.println(\"ArithmeticException 발생!\");  //ArithmeticException 이 발생 했을 때만 실행  \n\t\t} catch(NullPointerException e) {  \n\t\t\tSystem.out.println(\"NullPointerException 발생!\");  //NullPointerException 이 발생 했을 때만 실행  \n\t\t} catch(Exception e){  \n\t\t\t// 그 외의 Exception 이 발생 했을 때 실행  \n\t\t} finally{  \n\t\t\tSystem.out.println(\"항상 실행\");  \n\t\t}  \n\t\t\tSystem.out.println( \"정상 종료\");  \n\t}  \n}\n```\n\n위의 코드를 보면 `ArithmeticException`, `NullPointerException`, 그리고 `Exception` 예외처리를 한것을 볼 수 있는데 `Exception` 예외처리를 가장 마지막 catch문에 작성한 것을 볼 수 있다.\n\n만일 `Exception` 예외처리를 상위 catch문에 작성한다면 `ArithmeticException`이나 `NullPointerException`이 발생한 경우에도 `Exception` 예외처리를 진행하게 된다. 그렇게 되면 각각의 예외에 맞는 catch문을 실행할 수 없어지기 때문에 올바른 예외처리를 못하게 된다. 따라서 `Exception` 예외처리는 가장 마지막 catch문에 작성해줘야만 한다.\n\n\n<br><br><br>\n### 📌 try-catch문에서의 흐름\ntry-catch문에서, 예외가 발생한 경우와 발생하지 않은 경우에 흐름은 달라진다.\n\n- **try 블럭 내에서 예외가 발생한 경우**\n\t1. 발생한 예외와 일치하는 catch문이 있는지 확인한다.\n\t2. 일치하는 catch문을 찾으면, 해당 catch블럭 내의 문장들을 수행하고, **try-catch문을 통째로 빠져나간다.**\n\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tSystem.out.println(1);\n\t\ttry {\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(3);\n\t\t} catch(Exception e) {\n\t\t\tSystem.out.println(4);\n\t\t}\n\t\tSystem.out.println(5);\n\t}  \n} // 1 2 3 5 가 출력된다\n```\n\n위 코드를 보면 어떤 오류도 발생하지 않는다. 때문에 try문은 그대로 출력되고 catch문은 실행되지 않는다. 이후 try-catch 구문을 빠져나간뒤 5를 출력한다. 결과적으로는 1, 2, 3, 5가 출력될 것이다.\n<br><br>\n\n\n- **try 블럭 내에서 예외가 발생하지 않은 경우**\n\t1. catch문을 거치지 않고 try-catch문을 통째로 빠져나간다.\n\n```java\npublic class Ex07_Exception {  \n\tpublic static void main(String[] args) {  \n\t\tSystem.out.println(1);\n\t\ttry {\n\t\t\tSystem.out.println(2);\n\t\t\tSystem.out.println(0/0);\n\t\t\tSystem.out.println(3);\n\t\t} catch(ArithmeticException ae) {\n\t\t\tSystem.out.println(4);\n\t\t}\n\t\tSystem.out.println(5);\n\t}  \n} // 1 2 4 5 가 출력된다\n```\n\n위의 코드는 0으로 어떤수를 나눴기 때문에 `ArithmeticException`이 발생한다. 때문에 try문의 `System.out.println(0/0);` 문장 이전까지는 정상 실행되다가 `System.out.println(0/0);` 문장에서 오류가 발생하고 catch 구문으로 넘어가 실행되고 이후 try-catch 구문을 통째로 빠져나간다. 때문에 1, 2, 4, 5가 출력될 것이다.\n\n<Br><Br><Br><Br>\n\n## ✅ 예외 처리하기 :: throws\n\n예외를 처리하는 방법에는 try-catch문을 사용하는것 외에, 예외를 메서드에 선언하는 throws를 사용하는 방법이 있다. 메서드에 예외를 선언하려면, 메서드 선언부에 throws를 사용해서 발생 할 수 있는 예외를 적어주기만 하면 된다.\n\n```java\n\tvoid method() throws Exception1, Exception2, ... ExceptionN {\n\t\t// 메서드 내용\n\t}\n```\n\n예외를 선언하면, 해당 예외뿐만 아니라 **자손타입의 예외까지도 발생할 수 있다** 라고 알리는 것이다. 또한 메서드를 통한 예외처리는 실제 예외를 어떻게 처리하겠다 라는 로직을 포함하지 않기때문에 단순히 이러이러한 오류가 발생할 수 있고, **해당 오류가 발생한다면 오류에 대한 처리를 메서드를 호출한 쪽으로 넘기겠다!** 라는 의미로 사용된다. 때문에 사용자쪽은 오류에 대한 `try-catch` 구문을 반드시 사용해 처리해야만 한다.\n\n기존의 다른 언어는 메서드에 예외선언을 하지않기 때문에, 경험이 많은 프로그래머가 아니라면 어떤 상황에서 어떤 종류의 오류가 발생할 가능성이 있는지 예측하기 어려웠다. 그러나 자바에서는 메서드 내에서 발생할 가능성이 있는 예외를 선언부에 명시하여 메서드를 사용하는 쪽에 이에 대한 처리를 강요하기 때문에, 보다 견고한 코드를 작성할 수 있다.\n\n<br><br><br>\n### 📌 메서드에 예외 선언하기 흐름\n\n```java\nclass EX {\n\tpublic static void main(String[] args) throws Exception {\n\t\tmethod1();\n\t}\n\n\tstatic void method1() throws Exception {\n\t\tmethod2();\n\t}\n\n\tstatic void method2() throws Exception {\n\t\tthrow new Exception();\n\t}\n}\n```\n<br>\n\n\n위의 코드를 보면 `method2()` 에서 `throw new Exception();` 을 통해 Exception() 예외를 발생시켰다. `method2()`에서는 try-catch를 통한 예외처리를 하지 않았기 때문에 `method2()`를 호출한 `method1()`로 예외를 넘긴다(throws). `method1()` 에서도 마찬가지로 예외처리를 하지않았으므로 `method1()`을 호출한 `main` 으로 예외를 넘긴다. main에서도 마찬가지로 예외처리를 하지 않았으므로 위의 코드는 오류가 난다.\n\n<Br><br><br>\n\n\n### 📌 메서드에 예외 선언하기 예제\n```java\nclass EX {\n\tpublic static void main(String[] args) {\n\t\ttry{\n\t\t\tFile f = createFile(args[0]);\n\t\t\tSystem.out.println(f.getName()+\"파일이 성공적으로 생성되었습니다.\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.getMessage()+\"다시 입력해주세요\");\n\t\t}\n\t}\n\n\tstatic File createFile(String fileName) throws Exception {\n\t\tif(fileName==null || fileName.equals(\"\"))\n\t\t\tthrow new Exception(\"파일이름이 유효하지 않습니다\");\n\t\tFile f = new File(fileName);\n\t\t\n\t\tf.createNewFile();\n\t\treturn f;\n\t}\n}\n\t\t\n```\n\n위의 코드는 사용자로부터 파일이름을 입력받아서 파일을 생성하는 예제이다. 파일을 생성하는것은 `createFile` 메소드인데 파일이름이 유효하지 않으면 `Exception`을 발생시킨다. 이때 `createFile` 메소드에 예외가 선언되어 있으므로 `createFile` 메소드를 호출한 `main` 으로 예외처리를 넘겨준다. `main` 에서는 넘어온 예외를 try-catch 구문을 통해 해결하고 있다. \n\n그런데 이와 반대로 만약 `createFile` 메소드에서 try-catch 문을 작성해서 오류를 처리하면 어떻게 될까? **`createFile` 메소드에서 처리하게 되면 `main`에서는 오류가 발생했는지 여부도 알지 못하게 된다.**\n\n이를 잘 활용하여 예외가 발생한 메서드 내에서 자체적으로 처리해도 되는 경우 메서드 내에 try-catch문을 넣어서 처리하고, 위 예제처럼 메서드 내에서 자체적으로 해결이 안되는 경우(파일 이름을 다시 받아와야 하는 경우)에는 예외를 선언하여 호출한 메서드가 오류를 처리하도록 해야한다.\n\n \n<br><br><br><Br>\n\n## ✅ 예외 발생시키기 :: throw\n\n키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다. \n\n1. 연산자 new를 이용해 발생시키려는 예외클래스의 객체 생성\n\t`Exception e = new Exception(\"고의로 예외발생\");`\n\n2. 키워드 throw를 이용해 예외 발생\n\t`throw e;`\n\n3. `throw new Exception(\"고의로 예외발생\")` 같은 형태로도 사용가능 \n\n<br>\n\n```java\nclass EX {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tException e = new Exception(\"고의로 발생\");\n\t\t\tthrow e;\n\t\t\t// throw new Exception(\"고의로 발생\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"에러\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"정상종료\");\n\t}\n}\n```\n\n위 코드처럼 고의로 예외를 발생시켜 catch문 처리를 하도록 만들 수도 있다.\n","properties":"\n","discussions":{},"comments":{},"hash":2003709484}},"syncHistory":{"main":[1456159858,2003709484,1456159858]},"v":1,"hash":1710892108919,"tx":11246},"C8kg3so81QVoun72/syncedContent":{"id":"C8kg3so81QVoun72/syncedContent","type":"syncedContent","historyData":{"618215403":{"id":"C8kg3so81QVoun72/content","type":"content","text":"---\npermalink: /2023-06-19-String, StringBuffer와 StringBuilder/\npublished: true\ntitle: \"[JAVA] String, StringBuffer와 StringBuilder \"\ndate: 2023-06-19 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ String VS StringBuffer/ StringBuilder\n\nJAVA에서 문자열을 처리할 때 대표적으로 많이 쓰이는게 String, StringBuffer 그리고 StringBuilder 이다. 셋다 비슷한 기능을 수행하지만 엄연히 다르고 장단점이 존재하는데 무엇인지 알아보자.\n\n<br><br><Br><br>\n## ✅ String의 불변성\n**한번 생성된 String 인스턴스는 읽어올 수는있지만, 변경할 수는 없다.** 그런데 우리는 실제로 String 클래스를 사용하면서 String이 변경되는것을 자주봤을 것이다. 다음 코드를 보자.\n\n```java\nString str = \"hello \";\nstr = str + \"world\";\n\n>>> str\n>>> hello world\n```\n이처럼 String은 불변한다고 했지만 막상 String에 새로운 문자열을 갖다 붙일 수 있다. 때문에 불변하지 않는다고 생각할 수 있지만 **실제 메모리 영역을 살펴보면 그 이유를 알 수 있다.**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/java1.png?raw=true\">\n</p>\n\n처음 String 인스턴스를 생성하고 \"hello\"라는 값을 부여하면 메모리에 할당되고 임의의 주소값을 부여받는다. 이때 **기존 String 인스턴스에 다른 문자열을 추가하면 기존에 존재하던 주소값에 이를 할당하는게 아니라 아예 새로운 메모리에 할당해서 새로운 값을 만들어내는 구조이다.** 그렇기 때문에 String인스턴스가 **'변한게'** 아니라 **'새로 생성'** 된것이다. 기존의 String 인스턴스는 전혀 변화가 없기 때문에 **String은 불변하다** 라고 보는것이다.\n\n이런식으로 '+' 연산자를 이용해서 문자열을 결합하는 것은 매 연산시마다 새로운 문자열을 가진 String 인스턴스가 생성되어 메모리 공간을 차지하기 때문에 가능한 결합 횟수를 줄이는것이 좋다. 그러나 문자열 간의 결합이 추출 등 문자열을 다루는 작업이 많이 필요한 경우에는 메모리 낭비가 심해질 수 밖에 없다. 그래서 나온게 바로 StringBuffer/StringBuilder 이다! \n\n<br><br><Br><br>\n## ✅ StringBuffer 클래스\nString은 인스턴스 생성할 때 지정된 문자열을 수정할 수 없지만, StringBuffer는 가능하다. 내부적으로 **문자열 편집을 위한 버퍼(buffer)를 가지고 있고, StringBuffer 인스턴스를 생성할 때 크기를 지정할 수도 있다.**\n\n크기를 지정하지 않은 경우 **16개의 문자**를 저장할 수 있는 크기의 버퍼를 생성하고 이를 초과하는 문자열이 들어오는 경우 **자동으로 버퍼의 길이를 늘려주는 작업이 수행되기 때문에 작업 효율이 떨어질 수 있다.** \n\n<br><br>\n\n### 📌 StringBuffer의 변경\n```java\nStringBuffer sb = new StringBuffer(\"hello\");\nsb.append(\"world\");\n```\n\nStringBuffer는 다양한 API를 사용해 변경할 수 있다. 위의 코드는 앞서 String 클래스에서 설명한 '+' 연산자와 동일한 기능을 수행하는 코드이다. StringBuffer 인스턴스를 생성하고 초기값을 \"hello\"라고 부여한 뒤 StringBuffer 인스턴스에 \"world\"를 추가한 것이다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer1.png?raw=true\">\n</p>\n\n<Br>\n그림을 보면 StringBuffer는 String과 달리 메모리를 새로 할당하지 않고 기존 메모리에 접근하여 값을 변경하는것을 볼 수 있다. 때문에 String 보다 메모리 낭비가 발생하지 않아 문자열의 추가, 수정, 삭제가 빈번하게 발생되는 경우 많이 사용한다.\n\n또 하나 기억해야할 점은 **`append()`는 반환타입이 StringBuffer이고 자기 자신의 주소를 반환한다**는 점이다. 때문에 다음과 같은 코드작성도 가능하다.\n\n```java\nStringBuffer sb = new StringBuffer(\"안녕하세요 \");\nStringBuffer sb2 = sb.append(\"반갑습니다\");\nSystem.out.println(sb);\t// 안녕하세요 반갑습니다\nSystem.out.println(sb2);\t// 안녕하세요 반갑습니다\n```\n\n```java\nStringBuffer sb = new StringBuffer(\"안녕하세요 \");\nsb.append(\"반갑습니다 \").append(\"잘부탁드려요!\");\nSystem.out.println(sb)\t// 안녕하세요 반갑습니다 잘부탁드려요!\n```\n`append()`의 반환타입이 자기자신 StringBuffer이기 때문에 위와같은 코드작성이 가능하다.\n\n<br><br><Br><br>\n## ✅ StringBuffer 메서드\n\n전부다 알면 좋겠지만 주로 많이 쓰는걸 위주로 기억해두도록 하자. 빨간 박스 친 메서드는 코딩테스트에서도 용이하게 쓰일수 있는 메서드 이기때문에 코딩테스트를 준비하는 상황이라면 기억해두도록 하자!\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer2.png?raw=true\">\n</p>\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer3.png?raw=true\">\n</p>\n\n<br><br><Br><br>\n## ✅ StringBuilder 클래스\n\nStringBuffer는 멀티쓰레드에 안전하도록 동기화되어 있다. 동기화는 StringBuffer의 성능을 떨어뜨리기 때문에 멀티쓰레드로 작성된 프로그램이 아닌경우, StringBuffer의 동기화는 불필요하게 성능만 떨어뜨린다.\n\n그래서 StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 추가되었다. StringBuffer와 기능적으로 완전히 동일해서 StringBuffer대신 StringBuilder라고 선언해주기만 하면된다. \n\n```java\nStringBuilder sb = new StringBuilder();\n```\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":618215403},"-1059858459":{"id":"C8kg3so81QVoun72/content","type":"content","text":"---\npermalink: /2023-06-19-String, StringBuffer와 StringBuilder/\npublished: true\ntitle: \"[JAVA] String, StringBuffer와 StringBuilder \"\ndate: 2023-06-19 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ String VS StringBuffer/ StringBuilder\n\nJAVA에서 문자열을 처리할 때 대표적으로 많이 쓰이는게 String, StringBuffer 그리고 StringBuilder 이다. 셋다 비슷한 기능을 수행하지만 엄연히 다르고 장단점이 존재하는데 무엇인지 알아보자.\n\n<br><br><Br><br>\n## ✅ String의 불변성\n**한번 생성된 String 인스턴스는 읽어올 수는있지만, 변경할 수는 없다.** 그런데 우리는 실제로 String 클래스를 사용하면서 String이 변경되는것을 자주봤을 것이다. 다음 코드를 보자.\n\n```java\nString str = \"hello \";\nstr = str + \"world\";\n\n>>> str\n>>> hello world\n```\n이처럼 String은 불변한다고 했지만 막상 String에 새로운 문자열을 갖다 붙일 수 있다. 때문에 불변하지 않는다고 생각할 수 있지만 **실제 메모리 영역을 살펴보면 그 이유를 알 수 있다.**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/java1.png?raw=true\">\n</p>\n\n처음 String 인스턴스를 생성하고 \"hello\"라는 값을 부여하면 메모리에 할당되고 임의의 주소값을 부여받는다. 이때 **기존 String 인스턴스에 다른 문자열을 추가하면 기존에 존재하던 주소값에 이를 할당하는게 아니라 아예 새로운 메모리에 할당해서 새로운 값을 만들어내는 구조이다.** 그렇기 때문에 String인스턴스가 **'변한게'** 아니라 **'새로 생성'** 된것이다. 기존의 String 인스턴스는 전혀 변화가 없기 때문에 **String은 불변하다** 라고 보는것이다.\n\n이런식으로 '+' 연산자를 이용해서 문자열을 결합하는 것은 매 연산시마다 새로운 문자열을 가진 String 인스턴스가 생성되어 메모리 공간을 차지하기 때문에 가능한 결합 횟수를 줄이는것이 좋다. 그러나 문자열 간의 결합이 추출 등 문자열을 다루는 작업이 많이 필요한 경우에는 메모리 낭비가 심해질 수 밖에 없다. 그래서 나온게 바로 StringBuffer/StringBuilder 이다! \n\n<br><br><Br><br>\n## ✅ StringBuffer 클래스\nString은 인스턴스 생성할 때 지정된 문자열을 수정할 수 없지만, StringBuffer는 가능하다. 내부적으로 **문자열 편집을 위한 버퍼(buffer)를 가지고 있고, StringBuffer 인스턴스를 생성할 때 크기를 지정할 수도 있다.**\n\n크기를 지정하지 않은 경우 **16개의 문자**를 저장할 수 있는 크기의 버퍼를 생성하고 이를 초과하는 문자열이 들어오는 경우 **자동으로 버퍼의 길이를 늘려주는 작업이 수행되기 때문에 작업 효율이 떨어질 수 있다.** \n\n<br><br>\n\n### 📌 StringBuffer의 변경\n```java\nStringBuffer sb = new StringBuffer(\"hello\");\nsb.append(\"world\");\n```\n\nStringBuffer는 다양한 API를 사용해 변경할 수 있다. 위의 코드는 앞서 String 클래스에서 설명한 '+' 연산자와 동일한 기능을 수행하는 코드이다. StringBuffer 인스턴스를 생성하고 초기값을 \"hello\"라고 부여한 뒤 StringBuffer 인스턴스에 \"world\"를 추가한 것이다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer1.png?raw=true\">\n</p>\n\n<Br>\n그림을 보면 StringBuffer는 String과 달리 메모리를 새로 할당하지 않고 기존 메모리에 접근하여 값을 변경하는것을 볼 수 있다. 때문에 String 보다 메모리 낭비가 발생하지 않아 문자열의 추가, 수정, 삭제가 빈번하게 발생되는 경우 많이 사용한다.\n\n또 하나 기억해야할 점은 **`append()`는 반환타입이 StringBuffer이고 자기 자신의 주소를 반환한다**는 점이다. 때문에 다음과 같은 코드작성도 가능하다.\n\n```java\nStringBuffer sb = new StringBuffer(\"안녕하세요 \");\nStringBuffer sb2 = sb.append(\"반갑습니다\");\nSystem.out.println(sb);\t// 안녕하세요 반갑습니다\nSystem.out.println(sb2);\t// 안녕하세요 반갑습니다\n```\n\n```java\nStringBuffer sb = new StringBuffer(\"안녕하세요 \");\nsb.append(\"반갑습니다 \").append(\"잘부탁드려요!\");\nSystem.out.println(sb)\t// 안녕하세요 반갑습니다 잘부탁드려요!\n```\n`append()`의 반환타입이 자기자신 StringBuffer이기 때문에 위와같은 코드작성이 가능하다.\n\n<br><br><Br><br>\n## ✅ StringBuffer 메서드\n\n전부다 알면 좋겠지만 주로 많이 쓰는걸 위주로 기억해두도록 하자. 빨간 박스 친 메서드는 코딩테스트에서도 용이하게 쓰일수 있는 메서드 이기때문에 코딩테스트를 준비하는 상황이라면 기억해두도록 하자!\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer2.png?raw=true\">\n</p>\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stringbuffer3.png?raw=true\">\n</p>\n\n<br><br><Br><br>\n## ✅ StringBuilder 클래스\n\nStringBuffer는 멀티쓰레드에 안전하도록 동기화되어 있다. 동기화는 StringBuffer의 성능을 떨어뜨리기 때문에 멀티쓰레드로 작성된 프로그램이 아닌경우, StringBuffer의 동기화는 불필요하게 성능만 떨어뜨린다.\n\n그래서 StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 추가되었다. StringBuffer와 기능적으로 완전히 동일해서 StringBuffer대신 StringBuilder라고 선언해주기만 하면된다. \n\n```java\nStringBuilder sb = new StringBuilder();\n```\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-1059858459}},"syncHistory":{"main":[-1059858459,618215403,-1059858459]},"v":1,"hash":1710892111358,"tx":11248},"VQOgcLROQ4ay0oXW/syncedContent":{"id":"VQOgcLROQ4ay0oXW/syncedContent","type":"syncedContent","historyData":{"1047674723":{"id":"VQOgcLROQ4ay0oXW/content","type":"content","text":"---\npermalink: /2023-06-22-Thread/\npublished: true\ntitle: \"[JAVA] [객체지향] 좋은 객체지향 설계의 5가지 원칙\"\ndate: 2023-07-10 17:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ SOLID란 ?\n\n1. SPR(Single Responsibility Principle) : 단일 책임 원칙\n\n2. OCP(Open Closed Principle) : 개방 폐쇄 원칙\n\n3. LSP(Liskov Substitution Princlple) : 리스코프 치환 원칙\n\n4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙\n\n5. DIP(Dependency Inversion Principle) : 의존 역전 원칙\n\n\n\n\n\n\n\n\n\n좋은 객체지향 설계의 5가지 원칙\n","properties":"\n","discussions":{},"comments":{},"hash":1047674723},"-1003617559":{"id":"VQOgcLROQ4ay0oXW/content","type":"content","text":"---\npermalink: /2023-06-22-Thread/\npublished: true\ntitle: \"[JAVA] [객체지향] 좋은 객체지향 설계의 5가지 원칙\"\ndate: 2023-07-10 17:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- 객체지향\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ SOLID란 ?\n\n1. SPR(Single Responsibility Principle) : 단일 책임 원칙\n\n2. OCP(Open Closed Principle) : 개방 폐쇄 원칙\n\n3. LSP(Liskov Substitution Princlple) : 리스코프 치환 원칙\n\n4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙\n\n5. DIP(Dependency Inversion Principle) : 의존 역전 원칙\n\n\n\n\n\n\n\n\n\n좋은 객체지향 설계의 5가지 원칙\n","properties":"\n","discussions":{},"comments":{},"hash":-1003617559}},"syncHistory":{"main":[1047674723,-1003617559,1047674723]},"v":1,"hash":1710892116728,"tx":11252},"JbeDoZUm857e8fdL/syncedContent":{"id":"JbeDoZUm857e8fdL/syncedContent","type":"syncedContent","historyData":{"-1535631988":{"id":"JbeDoZUm857e8fdL/content","type":"content","text":"---\npermalink: /2022-05-31-프로그래머스_위장/\npublished : true\ntitle: \"[프로그래머스] [C/C++] [★] 위장\"\ndate: 2022-05-11 21:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"프로그래머스_위장\"\ncategories:\n- 프로그래머스\ntags:\n- 프로그래머스\n- 알고리즘\n- 문자열\n- Hash\n- Map\n---\n\n## 문제\n\n스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\n\n예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.\n\n\n| 종류 | 이름 |\n|--|--|\n| 얼굴 | 동그란 안경, 검정 선글라스 |\n|상의\t|파란색 티셔츠|\n|  하의|  청바지|\n|겉옷 |긴 코트 |\n\n\n스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.\n<br><br><br><br><br><br>\n\n## 제한사항\n-   clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.\n-   스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.\n-   같은 이름을 가진 의상은 존재하지 않습니다.\n-   clothes의 모든 원소는 문자열로 이루어져 있습니다.\n-   모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 '_' 로만 이루어져 있습니다.\n-   스파이는 하루에 최소 한 개의 의상은 입습니다.\n\n  <br><br><br><br><br><br>\n\n\n## 입출력 예 설명 \n**예제 #1**\nheadgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.\n\n```\n1. yellow_hat\n2. blue_sunglasses\n3. green_turban\n4. yellow_hat + blue_sunglasses\n5. green_turban + blue_sunglasses\n```\n\n<br><br><br>\n\n**예제 #2**  \nface에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.\n```\n1. crow_mask\n2. blue_sunglasses\n3. smoky_makeup\n```\n\n\n  \n\n\n<br><br><br><br><br><br>\n\n\n## 알고리즘 [ 접근 방법 ]\n\n**Map + 범위기반 for문**을 활용한 문제이다.\n문제를 보자마자 이번 라인 인턴 코딩테스트에서 본 문제와 거의 흡사하다는 사실을 알았다.\n이거 풀어보고 코테봤으면 바로 풀었을텐데.. 하는 아쉬움이 많이 남는다. 바로 풀어보자!\n<br><br><br>\n\n**Map은 Key-value pair를 가지고 중복을 허용하지 않으며 자동으로 오름차순 정렬이 된다.**\n\n<br><br><br>\n이를 활용해 종류별 옷의 개수를 세어준 뒤 조합의 개수를 세어주기만 하면 된다.\n예를 들어 상의가 셔츠, 맨투맨, 나시 3가지가 있는 경우 \n\n> 셔츠  \n> 맨투맨  \n> 나시  \n> 아무것도 안입는 경우  \n\n이렇게 총 4가지로 나누어 고려해주면 된다.\n\n\n\n<br><br><br><br><br><br>\n\n\n## 풀이\n```c++\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n// 종류별 의상이 몇개인지 파악\n\n// 의상 종류가 3가지다\n// 안입는 경우 + 1가지만 입는경우 + 2가지만 입는경우 + 3가지 다입는경우\n// 의상 종류가 n가지다\n// 안입는 경우 + 1가지만 입는경우 + 2가지만 입는경우 + .. + n가지 입는경우\n\nint solution(vector<vector<string>> clothes) {\n    int answer = 1;\n    \n    // map은 key-value pair를 가지고 오름차순 정렬됨, 중복 허용 x\n    map <string,int> list;\n    \n    for(int i=0;i<clothes.size();i++){\n        list[clothes[i][1]]++;\n    }\n    \n    for (auto it : list){\n        answer *= (it.second+1);\n    }\n    answer -=1;\n    \n    return answer;\n}\n```\n\n<br><br><br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1535631988}},"syncHistory":{"main":[-1535631988,-1535631988,null]},"v":1,"hash":1710892483978,"tx":11275},"JbeDoZUm857e8fdL/contentState":{"id":"JbeDoZUm857e8fdL/contentState","type":"contentState","selectionStart":2301,"selectionEnd":2301,"scrollPosition":{"sectionIdx":27,"posInSection":0.62720156555773},"hash":1710892490889,"tx":11276},"fklYIJyOheHqvfTa/contentState":{"id":"fklYIJyOheHqvfTa/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":33,"posInSection":0.8065173116089613},"hash":1710892509962,"tx":11280},"fklYIJyOheHqvfTa":{"id":"fklYIJyOheHqvfTa","type":"file","name":"2022-06-02-C++_Map","parentId":"trash","hash":1473401909,"tx":11281},"0jwjWW7L0cw2iQtV/syncedContent":{"id":"0jwjWW7L0cw2iQtV/syncedContent","type":"syncedContent","historyData":{"693119406":{"id":"0jwjWW7L0cw2iQtV/content","type":"content","text":"---\npermalink: /2023-06-22-Thread/\npublished: true\ntitle: \"[JAVA] Thread란? \"\ndate: 2023-06-22 17:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ Thread란 ?\n프로그램을 실행하면 **OS로 부터 실행에 필요한 자원(메모리)을 할당받아 프로세스**가 된다. 프로세스는 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며 **프로세스의 자원을 이용해 실제로 작업을 수행하는 것이 바로 쓰레드**이다. 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하고, 두 개 이상의 쓰레드를 가지는 프로세스를 멀티쓰레드 프로세스(multi-thread process) 라고한다.\n\n<br><br>\n\n## ✅ Thread 구현과 실행\n자바에서 쓰레드를 구현하는 방법은 두가지가 있다.\n\n1. Runnable 인터페이스를 구현하는 방법\n2. Thread 클래스를 상속받는 방법\n\n어느쪽을 선택해도 차이는 없지만 Thread를 상속받으면 다른 클래스를 상속받을 수 없기때문에, Runnable 인터페이스를 구현하는 방법이 일반적이다. \n\n```java\n1. Thread 클래스 상속\n\nclass MyThread extends Thread {\n\tpublic void run() {\n\t\t/* 작업 내용 */\n\t}\n}\n```\n\n```java\n2. Runnable인터페이스 구현\n\nclass Mythread implements Runnable {\n\tpublic void run() {\n\t\t/* 작업 내용 */\n\t}\n}\n```\n\n위와같은 형태로 Thread를 구현할 수 있다. 어떤 방식을 사용하든 `run()` 메소드의 몸통부분을 구현함으로써 쓰레드를 만들면 된다.\n\n<br><br><br><br>\n\n### 📌 Thread 구현과 실행 예제\n```java\npublic class Ex10_ThreadEx1 {  \n\tpublic static void main(String[] args) {  \n\t\tEx1 ex1 = new Ex1();\n\t\t\n\t\tRunnable r = new Ex2();\n\t\tThread t2 = new Thread(r);\n\n\t\tex1.start();\n\t\tex2.start();  \n\t}  \n}  \n  \nclass Ex1 extends Thread{  \n\tpublic void run(){  \n\t\tfor(int i=0;i<5;i++) {\n\t\t\tSystem.out.println(getName());\n\t\t}\n\t}  \n}\n\nclass Ex2 implements Runnable {\n\tpublic void run() {\n\t\tfor(int i=0;i<5;i++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName());\n\t\t}\n\t}\n}\n```\n\nThread를 상속받은 경우에는 **Thread의 자손 클래스의 인스턴스를 생성**해주기만 하면 구현할 수 있다.\n\nRunnable 인터페이스를 구현한 경우에는 **Runnable을 구현한 클래스의 인스턴스를 생성한 다음 이 인스턴스를 Thread클래스 생성자의 매개변수로 제공**해야 한다.\n\n<br><br>\n\n### 📌 Thread의 실행 - start( )\n쓰레드를 생성했다고 해서 쓰레드가 실행되는 것은 아니다. `start()`를 호출해야만 쓰레드가 실행된다.\n```java\nThread t1 = new Thread();\nThread t2 = new Thread();\n\nt1.start();\nt2.start();\n```\n\n하지만 `start()`를 호출했다고 해서 바로 실행되는 것이 아니라, 실행대기 상태인 `waiting` status를 가지고 있다가 자신의 차례가 되면 실행된다. 이러한 쓰레드의 실행 순서는 OS의 스케쥴러에 의해 결정되는데 OS마다 스케쥴러 정책이 다르고, 쓰레드의 상태마다 또 정책이 다르기 때문에 JAVA 개발단계에서 스케쥴러에 대한 처리는 할 수 없고 OS에 맡겨야만 한다.\n\n한가지 더 알아둬야 할 것은 실행이 한번 종료된 쓰레드는 다시 `start()`를 통해서 실행 할 수 없다. 즉 하나의 쓰레드에 대해 `start()`가 한번만 호출 될 수 있다. 때문에 쓰레드의 작업을 한번더 수행하기 위해서는 인스턴스를 다시 생성하고 `start()`를 사용해야만 한다. 만일 같은 인스턴스에 대해 두번의 `start()` 를 실행하면 `IllegalThreadStateException` 이 발생한다.\n\n`IllegalThreadStateException` 이 발생하는 이유에 대해 살짝 알아보면, `start()` 메서드를 호출하게 되면 메서드의 실행 상태를 나타내는 내부 플래그가 'true'로 설정되어 해당 스레드를 다시 시작할 수 없다는것을 나타내게 된다. 그래서 같은 인스턴스에 대해 다시 `start()` 메소드를 실행하면 이미 내부 플래그가 true로 설정되어 있기 때문에 오류가 발생하게 되는 것이다. \n\n그러면 `yield()` 메서드를 실행한다음 다시 `start`메서드를 실행하면 괜찮지 않을까 해서 관련 자료를 찾아보니 `yield()` 를 호출하더라도 쓰레드의 실행상태를 초기화하는것이 아닌 쓰레드의 실행을 잠시 중단하고 다른 쓰레드에게 스케줄링 순서를 양보하는 것이기 때문에 여전히 `IllegalThreadStateException`이 발생한다고 한다.\n\n<br><br>\n\n### 📌 Thread의 실행 - run( )\n이제는 쓰레드를 실행하기 위해 `start()`메서드를 사용해야 한다는것을 알고있다. 그런데 왜 `run()` 메서드를 직접 실행하지 않고 `start()`를 통해 쓰레드를 실행하는 걸까?\n\nmain메서드에서 `run()`을 호출하는 것은 **쓰레드를 실행시키는 것이 아니라 단순히 메서드를 호출하는 것일 뿐**이다.\n\n반면에 `start()`는 새로운 쓰레드가 작업을 실행하는데 **필요한 호출스택(call stack)을 생성한 다음 `run()`을 호출해서 생성된 호출 스택에 `run()`메서드가 첫번째로 올라가게 한다.** \n\n**모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 하는데, `start()` 를 통해 작업을 수행할때마다 새로운 호출스택을 생성하고 쓰레드가 종료되면 생성된 호출스택을 소멸되게 하여 쓰레드의 실행이 가능하게끔 한다.**\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/thread1.png?raw=true\">\n</p>\n\n1. `main()` 메서드에서 쓰레드의 `start()`를 호출한다.\n2. `start()`는 쓰레드와 호출스택을 생성한다.\n3. 생성된 호출스택에 `run()` 메서드가 호출되어 작업을 수행한다.\n4. `main()` 과 `run()` 두개의 쓰레드는 OS의 스케줄링에 의해 번갈아 실행된다.\n\n**참고로 우리가 항상 사용하는 `main()` 메소드도 하나의 쓰레드이다!**\n\n<br><Br><br><br>\n\n## ✅ 싱글쓰레드와 멀티쓰레드\n싱글쓰레드는 한번에 한가지 작업만 수행할 수 있지만 쓰레드를 여러개 사용하는 멀티쓰레드는 한번에 여러가지 작업을 수행할 수 있다. 우리가 보기에 멀티쓰레드를 사용하면 동시에 여러작업을 수행하는 것처럼 보인다(실제로는 동시아님). 이러한 멀티쓰레드는 많은 장점이 존재한다.\n\n- CPU의 사용률 향상\n- 효율적인 자원의 사용\n- 사용자에 대한 응답성 향상\n- 코드 간결\n\n우리가 메신저로 채팅을 하면서 파일을 다운로드 받거나 음성대화를 나눌 수 있는 것도 대표적인 멀티쓰레드를 활용한 예이다. (그래서 멀티쓰레드를 처음배우면 꼭 채팅프로그램 만들어보는 이유이다)\n\n그러면 무조건 멀티쓰레드를 사용해서 여러작업을 동시에 수행하는게(실제로는 동시아님) 더 효율적이지 않을까 생각할 수 있지만, 뭐든 득이 있으면 실이 있는법! 항상 그렇지만은 않다. **멀티쓰레드, 즉 여러개의 쓰레드를 사용하면 같은 프로세스 내에서 자원을 공유하며 작업을 하기 때문에 동기화(Synchronized), 교착상태(Deadlock) 같은 문제들을 고려하여 프로그래밍 해야한다.** 이부분은 뒤에 좀더 자세하게 설명하겠지만 아무튼 무조건적으로 멀티쓰레드가 효율적이다 라는건 절대 아니다!\n\n<br><br>\n\n### 📌 싱글쓰레드와 멀티쓰레드 비교 ( 싱글코어 )\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/thread2.png?raw=true\">\n</p>\n\n위 그림은 **싱글코어 환경**에서 싱글 쓰레드와 멀티쓰레드의 작업을 비교한 그림이다. 첫번째 그림은 싱글쓰레드에서 두개의 작업을 처리하는 경우이다. A작업을 마친후에 B작업을 수행하는것을 볼 수 있다. 두번째 그림은 멀티쓰레드(2개)로 두개의 작업을 처리하는 경우이다. 두개의 쓰레드로 작업 하는 경우에는 짧은 시간동안 th1, th2 두개의 쓰레드가 번갈아가며 작업하고 있기때문에 두 작업이 동시에 처리되는 것처럼 느끼게 한다.\n\n그런데 위 그림을 보면 싱글쓰레드나 멀티쓰레드나 두 작업이 처리되는 시간은 거의 동일하다. 오히려 멀티쓰레드로 처리한 작업시간이 더 오래걸리게 된다. 그 이유는 **멀티쓰레드 작업시 쓰레드 간 작업 전환(Context Switching)에 걸리는 시간이 멀티쓰레드로 작업함으로써 단축되는 시간보다 더 크기 때문이다.**\n\n이러한 이유로 멀티쓰레드 작업이 항상 더 좋은것은 아님을 설명할 수 있다. 싱글코어 환경에서 단순히 CPU만을 사용하는 계산작업 이라면 오히려 멀티쓰레드보다 싱글쓰레드 환경이 더 효율적일 수 있다.\n\n<br><br>\n\n### 📌 멀티쓰레드 예제\n싱글쓰레드는 우리가 `main()`에서 맨날 실행하는 코드가 전부 싱글쓰레드 이므로 예제는 생략하고 멀티쓰레드의 예제만 살펴보도록 하겠다.\n\n```java\npublic class Ex12_MultiThread {  \n  \n\tstatic long startTime = 0;  \n  \n\tpublic static void main(String[] args) {  \n\t\tThread1 th1 = new Thread1();  \n\t\tth1.start();  \n\t\tstartTime = System.currentTimeMillis();  \n  \n\t\tfor(int i=0;i<300;i++) System.out.printf(\"%s\", new String(\"-\"));  \n  \n\t\tSystem.out.println(\"소요시간 1 : \"+(System.currentTimeMillis()-Ex12_MultiThread.startTime));  \n\t}  \n}  \n  \nclass Thread1 extends Thread {  \n\tpublic void run(){  \n\t\tfor(int i=0;i<300;i++){  \n\t\t\tSystem.out.printf(\"%s\", new String(\"|\"));  \n\t\t}  \n\t\tSystem.out.print(\"소요시간2 : \" + (System.currentTimeMillis() - Ex12_MultiThread.startTime));  \n\t}  \n}\n```\n```java\n[결과]\n-----------------------------------------------\n-----------------------------------------------\n-----------------------||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||||||||\n||||||||||||||||||||||||||---------------------\n-----------------------------------------------\n-----------------------------------------------\n---||||||||||||||||||||||||||||||||||||--------\n-------------------||||||||||||||||||||||||||소요\n시간2 : 35---------------------------------소요시\n간 1 : 36\n```\n\n위와 같은 예제에서 싱글쓰레드인 경우를 보이진 않았지만 실제로 비교를 해보면 싱글쓰레드로 실행한 작업시간이 더 짧다. 앞서 언급했다시피 **멀티쓰레드를 사용할 때 쓰레드 간의 작업전환시간 + 화면에 출력하기위한 대기시간**이 소요되기 때문에 멀티쓰레드가 더 오래걸리는 것이다. \n\n<br><Br><br><br>\n\n## ✅ 쓰레드의 우선순위\n\n**쓰레드는 우선순위(Priority)라는 속성을 가지고 있는데, 이 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다.** 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 달리하여 특정 쓰레드가 더 많은 작업시간을 갖게하는 것이다.\n\n예를들어 파일전송기능이 있는 메신저의 경우, 파일다운로드를 처리하는 쓰레드보다 메세지 전송을 처리하는 쓰레드의 우선순위를 더 높게하여 메세지를 보내면서도 파일 다운로드를 할 수 있게끔 만들어야 한다.\n\n```JAVA\nvoid setPriority(int newPriority)  // 쓰레드의 우선순위 지정\nvoid getPriority()                 // 쓰레드의 우선순위 반환\n```\n\n위와 같은 코드로 우선순위를 지정할 수 있고 1~10범위를 가지며 숫자가 높을수록 높은 우선순위를 의미한다. 또한 `main()` 메소드를 수행하는 쓰레드는 우선순위가 5로 자동 지정된다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/thread3.png?raw=true\">\n</p>\n\n위의 그림은 WINDOWS의 싱글코어 환경에서 쓰레드의 우선순위가 같은 경우와 A가 더 높은 경우 두가지 실행시간에 대한 그림이다. 우선순위가 같은 경우 A,B 두개의 쓰레드가 거의 동일한 실행시간을 가지지만, A의 우선수위가 높은 경우에는 A에 더 많은 실행시간이 먼저 부여된것을 볼 수 있다. 때문에 A가 먼저 작업이 끝나고 B가 이후에 끝나는 모습이 보인다.\n\n**그러나!** 똑같은 실험을 멀티코어 환경에서 진행해보면 실행결과는 왼쪽 그림과 똑같다. 우선순위를 다르게하여 여러번 실험을 해봐도 결과는 똑같다. **멀티코어 환경에서는 두 쓰레드의 우선순위를 달리하여도 실행시간에 대한 차이가 거의 아예 없다.** 한마디로 **\"멀티코어 환경에서는 쓰레드에 높은 우선순위를 준다 할지라도 더 많은 실행시간과 실행기회를 갖지 못할 수 있다\"** 라는 뜻이다.\n\n<br><br>\n\n### 📌 쓰레드 우선순위는 사실 실행 시간을 보장하지 않는다..!\n\n사실 대부분의 JAVA 기본책이나 블로그 글을 보면 위와 같은 내용이 대부분이고 쓰레드의 우선순위 부여가 실행시간을 보장해주진 않는다 정도로 마무리 되는데 좀 구체적인 이유가 궁금해서 찾아봤다.\n\n**자바에서 쓰레드에 우선순위를 부여하면 해당 쓰레드가 실행되는 우선순위는 높아지지만, 보장된 실행시간을 의미하지는 않는다.** 쓰레드의 우선순위는 단지 스케줄러에게 어떤 쓰레드를 우선적으로 실행시킬지 알려주는 힌트일 뿐이다.\n\n실제로 OS와 하드웨어에 따라 쓰레드 스케줄링 정책이 달라지고, 우선순위에만 의존해서 쓰레드 실행시간을 보장할 수는 없다. 예를들어 OS에서 Round Robin 스케줄링을 사용하면, 모든 쓰레드에 동등한 실행 시간을 할당하게 되어 우선순위가 높은 쓰레드가 먼저 실행되는 것을 보장할 수 없다. \n\n또한 다른 우선순위를 가진 쓰레드가 경쟁 상태(race condition)에 놓일 경우에도 우선순위가 높은 쓰레드가 우선적으로 실행되지 않을 수도 있다.\n\n이처럼 쓰레드 우선순위는 쓰레드 스케줄링에 영향을 줄 수는 있지만, 실행시간을 보장해주지는 않는다. 쓰레드 간의 상호작용과 공유 자원 접근을 관리하고, 실행시간을 조절하기 위해서는 동기화 메커니즘과 다른 쓰레드 제어 기법을 사용해야 한다.\n\n\n<br><Br><br><br>\n\n## ✅ 데몬 쓰레드(daemon thread)\n\n데몬쓰레드는 다른 일반쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다. 데몬쓰레드는 일반쓰레드의 보조 역할이기 때문에 일반쓰레드가 종료되면 자동으로 데몬쓰레드 역시 종료된다. 무한루프와 조건문을 이용해서 실행 후 대기하다가 특정 조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다.\n\n```java\nboolean isDaemon()\t// 데몬쓰레드인지 확인\nvoid setDaemon(boolean on)\t// 쓰레드를 데몬쓰레드로 변경\n```\n`setDaemon(boolean on)`은 반드시 `start()`를 호출하기 전에 실행되어야 한다. 그렇지 않으면 `IllegalThreadStateException`이 발생한다.\n","properties":"\n","discussions":{},"comments":{},"hash":693119406}},"syncHistory":{"main":[693119406,693119406,null]},"v":1,"hash":1710892577485,"tx":11284},"6L2BLz0U8N7KSVN2/contentState":{"id":"6L2BLz0U8N7KSVN2/contentState","type":"contentState","selectionStart":262,"selectionEnd":262,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710893160435,"tx":11292},"6L2BLz0U8N7KSVN2/syncedContent":{"id":"6L2BLz0U8N7KSVN2/syncedContent","type":"syncedContent","historyData":{"782466471":{"id":"6L2BLz0U8N7KSVN2/content","type":"content","text":"---\npermalink: /2023-05-18-JS 내장 객체, 브라우저 객체, JS 삽입위치/\ntitle: \"[JavaScript] 문서객체모델 (Document Object Model)\"\ndate: 2023-05-18 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 내장 객체, 브라우저 객체, JS 삽입위치\"\ncategories:\n- JavaScript\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n## ✅ 문서객체모델 ( Document Object Model )\n\n우리가 자바스크립트를 사용하는 이유중 하나는 어떤 조건에 맞거나 사용자의 동작이 있을 때 웹 문서 전체 또는 일부분이 **동적으로 반응**하게 하기 위함 이다. 이를 위해서는 웹 문서의 모든 요소를 따로 제어할 수 있어야 한다.\n\n예를 들어, 웹 문서에 텍스트와 이미지가 들어있다면 웹 브라우저는 마크업 정보를 보며 텍스트 단락이 몇개고 내용은 무엇인지 살펴본다. 또한 이미지가 몇개이고 이미지 파일 경로는 어떠한지 이미지 별로 정리해서 인식한다. 그리고 이러한 텍스트와 이미지를 브라우저가 제어하려면 두 요소를 따로 구별해서 인식해야 한다.\n\n이런 모든 정보를 자바스크립트로 가져와 프로그래밍할 때 사용하는데 이때 필요한 개념이 바로 **문서 객체 모델 ( Document Object Model )** 줄여서 **DOM**\n\n\n문서 객체 모델은 DOM, 그리고 XML도 생성가능\n\n\n\n\nElement, Attribute, Value 가 뭔지 정확히 알필요 있음.\n\n\n## DOM의 event 객체\n\n`preventDefault` 중요!!\n각 태그마다 Default핸들러가 있는데 이걸 기능을 못하도록 만드는 것\n","properties":"\n","discussions":{},"comments":{},"hash":782466471}},"syncHistory":{"main":[782466471,782466471,null]},"v":1,"hash":1710893255750,"tx":11294},"mXfQrwQgdNgA8wLp/syncedContent":{"id":"mXfQrwQgdNgA8wLp/syncedContent","type":"syncedContent","historyData":{"-1861693998":{"id":"mXfQrwQgdNgA8wLp/content","type":"content","text":"---\npermalink: /2022-08-17-CRUD란/\npublished: true\ntitle: \"[개발상식] CRUD란?\"\ndate: 2022-08-17 05:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CRUD란\"\ncategories:\n- 개발상식\ntags:\n- CRUD\n- 개발상식\n- DB\n- REST API\n---\n\n<br><br><br>\n\n  \n\n## ✅ CRUD란?\n\nCRUD는 \"Create, Read, Update, Delete\"의 약어로 데이터베이스와 같은 시스템에서 기본적인 데이터 관리 기능을 의미한다.\n\nCRUD는 거의 모든 시스템에 적용되는 가장 기본이 되는 개념이라고 볼 수 있다. 프로젝트를 진행 할 때나 대규모 시스템을 살펴만 봐도 CRUD 개념이 안들어가 있는것을 보기 어렵고, 개발자끼리 회의를 할때도 많이 사용되는 단어이기 때문에 어디서 사용되고 무슨 의미인지 알아두면 좋다.\n\n필자는 크게 **데이터베이스에서의 CRUD**와 **RESTful API 설계시 사용되는 CRUD**에 대해 소개해보도록 하겠다.\n\n\n<br><br><br><br>\n\n\n## ✅ DB에서의 CRUD\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/crud1.png?raw=true\">\n</p>\n\n<br>\n\n1. **Create ( 생성 )**\n\n\t새로운 데이터를 생성한다. 이는 데이터베이스에 새로운 레코드를 추가하거나 파일 시스템에 새로운 파일을 생성하는 것과 같은 작업을 의미한다.\n\n2. **Read ( 읽기 )**\n\n\t데이터를 조회한다. 데이터베이스나 파일시스템에서 저장된 데이터를 검색하고 읽어오는 작업을 의미한다.\n\n3. **Update ( 갱신 )**\n\n\t기존 데이터를 수정한다. 데이터베이스에서 기존 레코드를 수정하거나 파일 시스템에서 파일의 내용을 갱신하는 것과 같은 작업을 의미한다.\n\n4. **Delete ( 삭제 )**\n\n\t데이터를 삭제한다. 데이터베이스에서 레코드를 삭제하거나 파일 시스템에서 파일을 삭제하는 것과 같은 작업을 의미한다. \n\n<br>\n\n\n\n\n\n\n\n\n\n<br><br><br><br>\n\n## ✅ REST API에서의 CRUD\n\n클라이언트 <-> 서버간 HTTP 프로토콜을 이용해 REST API를 설계하고 작성할 때에도 CRUD 개념이 사용된다. 클라이언트는 적절한 HTTP 메서드와 URL을 사용하여 서버에 요청을 보내어 데이터를 생성,조회,수정,삭제 할 수 있다.\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/crud2.png?raw=true\">\n</p>\n\n<br>\n\n1.  **Create (생성)**\n\n    -   HTTP 메서드: `POST`\n    -   예시: 새로운 사용자를 생성하는 경우\n        -   요청: `POST /users`\n        -   요청 본문(body): 새로운 사용자의 정보를 포함하는 JSON 또는 XML 데이터\n        -   응답: 새로운 사용자의 ID와 함께 성공 메시지 또는 적절한 상태 코드 (예: 201 Created)\n\n<br>\n\n2.  **Read (읽기)**:\n    \n    -   HTTP 메서드: `GET`\n    -   예시: 모든 사용자 목록을 가져오는 경우\n        -   요청: `GET /users`\n        -   응답: 모든 사용자의 목록을 포함하는 JSON 또는 XML 데이터 또는 적절한 상태 코드와 함께 성공 메시지 (예: 200 OK)\n        \n<br>\n\n3.  **Update (갱신)**:\n    \n    -   HTTP 메서드: `PUT` 또는 `PATCH`\n    -   예시: 특정 사용자의 정보를 업데이트하는 경우\n        -   요청: `PUT /users/{id}` 또는 `PATCH /users/{id}`\n        -   요청 본문: 업데이트할 사용자의 정보를 포함하는 JSON 또는 XML 데이터\n        -   응답: 적절한 상태 코드와 함께 성공 메시지 또는 업데이트된 사용자의 정보\n\n<br>\n\n4.  **Delete (삭제)**:\n    \n    -   HTTP 메서드: `DELETE`\n    -   예시: 특정 사용자를 삭제하는 경우\n        -   요청: `DELETE /users/{id}`\n        -   응답: 적절한 상태 코드와 함께 성공 메시지 또는 삭제된 사용자의 정보\n\n<BR><BR>\n\n한마디로,\n\n**Create는 데이터를 생성하고**\n\n**Read는 데이터를 읽으며**\n\n**Update는 새로운 데이터를 업데이트하고**\n\n**Delete는 데이터를 삭제하는 것을 의미한다!**\n\n\n\n\n\n  \n\n<br><br><br>\n\n## ✅ 간단한 CRUD 예시 \n\n필자가 프로젝트 수행하면서 CRUD를 사용했던 대화 몇개를 차용해보면 보통 이런 흐름이다.\n\n<br><br>\n\n**[ 댓글 CRUD ]**  \nA : \"테드님이 댓글 CRUD 구현해주세요\"  \nB : \"넹\"  \n... ( 뚝딱뚝딱 )  \nB : \"댓글 작성(CRUD의 C)이랑 댓글 조회(CRUD의 R)까지 구현했고, 댓글 수정(CRUD의 U)이랑 삭제(CRUD의 D)는 구현중입니다~\"  \nA : \"나머지 댓글 수정이랑 삭제도 빨리해주세요!\"  \n<Br><br>\n\n**[ 게시글 CRUD ]**  \nA : \"테드님이 게시글 CRUD 구현해주세요\"  \nB : \"넹\"  \n... ( 뚝딱뚝딱 )  \nB : \"게시글 작성, 조회, 수정, 삭제 전부다 구현 완료했습니다~\"  \n\n<br><br>\n이런 흐름으로 보통 CRUD라는 단어를 사용하곤 한다. 엄청나게 어려운 개념은 아니지만 되게 많이 사용되는 단어이기 때문에 어떤 의미인지 정확하게 알아두면 좋다.\n\n<br><br><br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-1861693998}},"syncHistory":{"main":[-1861693998,-1861693998,null]},"v":1,"hash":1710893467395,"tx":11297},"oX7d6ygndZcITdfY":{"id":"oX7d6ygndZcITdfY","type":"folder","name":"자료구조","parentId":null,"hash":2015629247,"tx":11298},"lxMWY3IFzi3Fwd8Q":{"id":"lxMWY3IFzi3Fwd8Q","type":"file","name":"2021-08-24-자료구조_Stack","parentId":"oX7d6ygndZcITdfY","hash":1402169954,"tx":11301},"AccPceb6fVYGLjbn":{"id":"AccPceb6fVYGLjbn","type":"file","name":"2021-09-03-자료구조_Queue","parentId":"oX7d6ygndZcITdfY","hash":399288587,"tx":11302},"Q630m9jJvuuKh53I/syncedContent":{"id":"Q630m9jJvuuKh53I/syncedContent","type":"syncedContent","historyData":{"962145358":{"id":"Q630m9jJvuuKh53I/content","type":"content","text":"---\npermalink: /2023-03-03-알고리즘_Arrays.sort와 Collections.sort/\ntitle: \"[알고리즘] [JAVA] Arrays.sort와 Collections.sort\"\ndate: 2023-03-03 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Arrays.sort와 Collections.sort\"\ncategories:\n- Algorithm\ntags:\n- 알고리즘\n- 정렬\n---\n<br><br>\n\n\n오늘은 코딩테스트 문제풀이중 계속 헷갈리고 어려운 정렬에 대해서 쭉 정리해보려고 한다. `Arrays.sort`, `Collections.sort` 그리고 오름차순, 내림차순, 마지막으로 `Comparator`를 사용한 `compare` 재정의 까지 알아보도록 하겠다.\n\n\n\n## ✅ Arrays.sort\n\nArrays.sort는 배열을 정렬해주는 기능을 합니다. 배열에 Integer가 있든, String이 있든 상관없이 정렬이 가능합니다.\n\n기본적으로 객체는 `Comparable`이 구현되어있습니다. `sort()`는 `Comparable`에 의해 리턴되는 값을 비교하여 오름차순 또는 내림차순으로 배열을 정렬합니다.\n\n대부분의 경우의수를 구현해보면서 사용법을 알아보도록 하겠습니다.\n\n- int 배열 오름차순, 내림차순 정렬\n- String 배열 오름차순, 내림차순 정렬\n- String 배열 문자 길이 순서대로 정렬\n- 객체 배열 정렬\n\n<br><br><br><br><br>\n\n### 📌 **int 배열 (오름차순)**\n기본적으로 Arrays.sort는 오름차순을 기본값으로 합니다.\n```java\nint[] arr = {1,20,254,13,76,22};\n\nArrays.sort(arr);\n\nSystem.out.println(Arrays.toString(arr));\n```\n\n<br>\n\n**Output :**\n```\n[1, 13, 20, 22, 76, 254]\n```\n\n<br><br><br><br><br>\n\n### 📌 **int 배열 (내림차순)**\n내림차순으로 정렬하기 위해서는 `sort()`인자에 `Collections.reverseOrder()`를 추가하면 됩니다.\n\n```java\nInteger[] arr = {1, 26, 17, 25, 99, 44, 303};\n\nArrays.sort(arr, Collections.reverseOrder());\n\nSystem.out.println(\"Sorted arr[] : \" + Arrays.toString(arr));\n```\n\n**Output :**\n```java\n[303, 99, 44, 26, 25, 17, 1]\n```\n\n<br><br>\n\n`Collections.reverseOrder()`는 Comparator 객체입니다. 일반적으로 Comparator는 직접 구현해서 사용하지만 내림차순 같은 경우는 많이 사용되므로 Collections에서 기본으로 제공해주고 있습니다.\n\n이를 직접 구현하면 아래와 같습니다.\n```\nInteger[] arr = {1, 26, 17, 25, 99, 44, 303};\n\nArrays.sort(arr, Comparator<Integer>(){\n\t@Override\n\tpublic int compare(Integer i1, Integer i2){\n\t\treturn i2-i1;\n\t}\n});\n\nSystem.out.println(Arrays.toString(arr));\n```\n<br><br><br><br><br>\n### 📌 **String 배열 (오름차순 & 내림차순)**\nString배열도 int배열과 별반 다르지 않습니다.\n```java\nString[] arr = { Apple, Banana, Pineapple, Cherry, Orange }\n\nArrays.sort(arr)\n\nSystem.out.println(Arrays.toString(arr));\n```\n\n\n**Output :** \n```java\n[ Apple, Banana, Cherry, Orange, Pineapple ]\n```\n<br>\n\n내림차순 역시 동일합니다.\n```java\nString[] arr = { Apple, Banana, Pineapple, Cherry, Orange }\n\nArrays.sort(arr,Collections.reverseOrder());\n\nSystem.out.println(Arrays.toString(arr));\n```\n**Output :** \n```java\n[ Pineapple, Orange, Cherry, Banana, Apple ]\n```\n<br><br><br><br><br>\n\n### 📌 **String 배열, 문자열 길이 순서대로 정렬**\nString배열의 문자열 길이 순서대로 정렬하고 싶다면 Comparator를 구현해야 합니다.\n```java\nString[] arr = { Apple, Banana, Pineapple, Cherry, Orange }\n\nArrays.sort(arr, new Comparator<String>(){\n\t@Override\n\tpublic int compare(String s1, String s2){\n\t\treturn s1.length()-s2.length();\n\t}\n});\n\nSystem.out.println(Arrays.toString(arr));\n```\n**Output :** \n```java\n[ Apple, Orange, Cherry, Banana, Pineapple ]\n```\n\n<br><br><br><br><br>\n\n### 📌 **객체 정렬 - Comparable 인터페이스**\n\n\n객체 정렬 방법은 여러가지가 있습니다. 그중 흔하게 쓰이는 `Comparable`을 사용한 객체 정렬부터 알아보도록 하겠습니다. \n\n먼저 사람이름과 점수를 갖고 있는 객체를 하나 생성해보고 이를 정렬해보도록 하겠습니다.\n\n\n```java\npublic class Player {\n    private String name;\n    private int score;\n\n    public Player(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n}\n```\n\n그리고 5명의 사람이 갖고 있는 점수를 생성해서 리스트에 담아보도록 하겠습니다.\n```java\nList<Player> players = new ArrayList<>();\nplayers.add(new Player(\"Alice\", 80));\nplayers.add(new Player(\"Bob\", 90));\nplayers.add(new Player(\"Chloe\", 100));\nplayers.add(new Player(\"Dale\", 70));\nplayers.add(new Player(\"Eric\", 50));\n```\n이제 다섯명의 사람을 점수별로 오름차순,내림차순 정렬해보겠습니다. `Comparable` 을 사용해서 정렬하면 다음과 같습니다.\n\n```java\npublic class Player implements Comparable<Player> {\n    private String name;\n    private int score;\n\n    public Player(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n\n\t// 오름차순 정렬\n\t@Override\n\tpublic int compareTo(Player p1){\n\t\treturn this.score - p1.score;\n\t}\n\t\n\t// 내림차순 정렬\n\t@Override\n\tpublic int compareTo(Player p1){\n\t\treturn p1.score - this.score;\n\t}\n}\n```\n\n```java\nCollections.sort(players);\n```\n\n<br><br><br><br><br>\n\n### 📌 **객체 정렬 - Comparator 인터페이스 사용**\n정렬대상 클래스의 코드를 직접 수정할 수 없는 경우, 혹은 정렬하고자 하는 객체에 이미 존재하는 정렬기준과 다른 정렬 기주으로 정렬하고 싶은 경우 `Comparator` 인터페이스를 사용해 정렬할 수 있습니다.\n\n`Comparator` 인터페이스 구현체를 `Arrays.sort()`나 `Collections.sort()` 같은 정렬 메서드의 추가 인자로 넘기면 새로운 기준으로 객체를 정렬할 수 있습니다.\n\n```java\nComparator<Player> comparator = new Comparator<Player>(){\n\n\t// 점수기준 오름차순\n\t@Override\n\tpublic int compare(Player a, Player b){\n\t\treturn a.score - b.score;\n\t}\n\n\t// 점수 기준 내림차순\n\t@Override\n\tpublic int compare(Player a, Player b){\n\t\treturn b.score - a.score;\n\t}\n```\n\n<br><br><br><br><br>\n\n### 📌 **Compare 과 CompareTo**\n","properties":"\n","discussions":{},"comments":{},"hash":962145358}},"syncHistory":{"main":[962145358,962145358,null]},"v":1,"hash":1710894428912,"tx":11513},"N72RguIezt8KuflR/contentState":{"id":"N72RguIezt8KuflR/contentState","type":"contentState","selectionStart":4050,"selectionEnd":4044,"scrollPosition":{"sectionIdx":28,"posInSection":0},"hash":1710897328548,"tx":11956},"lxMWY3IFzi3Fwd8Q/content":{"id":"lxMWY3IFzi3Fwd8Q/content","type":"content","text":"---\ntitle: \"[자료구조] 스택( Stack )이란? \"\ndate: 2021-08-24 01:00:00\ncategories:\n- 자료구조\ntags:\n- 자료구조\n---\n\n<br><br>\n\n## ✅ 스택(Stack)이란?\n선형 자료구조의 일종으로 먼저 들어간 원소가 나중에 나오는 First In Last Out ( FILO ) 구조를 가진다. 차곡차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리고 나중에 들어오는 원소는 그위에 쌓여 호출 시 가장 위에 있는 원소가 먼저 호출되는 구조이다.\n\n<br><br><br><br><br><br>\n\n\n## ✅ 스택(Stack)의 연산\n- **push(Data)** : Data 하나를 스택에 삽입한다.\n- **pop** : 스택에 있는 Data 하나를 제거한다.\n- **size** : 스택에 들어있는 정수의 개수를 출력한다.\n- **isEmpty** : 스택이 비어있으면 1(true), 아니면 0(false)을 출력한다.\n- **isFull** : 스택이 꽉차있으면 1(true), 아니면 0(false)을 출력한다.\n- **top** : 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.\n\n\n\n<br><br><br><br><br><br>\n\n## ✅ 스택(Stack)의 구조\n\n스택은 **자료의 출력 순서가 입력 순서의 역순으로 이루어질 때** 유용하게 사용된다. 우리가 스마트폰을 사용할 때 \"뒤로 가기\" 버튼을 누르면 현재 수행되는 앱이 종료되고 바로 직전에 수행되던 앱이 나타나는데, 이때 사용되는 것이 스택이다.\n\n<br>\n \n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stack1.png?raw=true\">\n</p>\n\n<br>\n\n\n- **상단(top)** : 스택에서 입출력이 이루어지는 부분\n- **하단(bottom)** : 반대쪽 바닥 부분\n- **요소(element)** : 스택에 저장되는 것\n- **공백 스택(empty stack)** : 공백 상태의 스택\n- **포화 스택(full stack)** : 포화 상태의 스택\n\n<br><br><br><br><br><br>\n\n\n## ✅ 스택(Stack) 구현\n\nStack 구현방법은 크게 두가지가 있다.\n\n1. **배열**을 이용한 구현\n\t- 장점 : 구현이 간단하며 메모리를 동적으로 할당하지 않기 때문에 속도가 빠르다.\n\t- 단점 : 배열을 사용하므로 스택의 크기가 고정된다.\n2. **리스트**를 이용한 구현\n\t- 장점 : 동적할당을 통해 가변적인 크기를 가진다.\n\t- 단점 : 삽입, 삭제시 동적할당/해제로 인해 속도가 느리다.\n\n<br><Br><Br>\n\n ### 📌 배열을 이용한 Stack 구현\n \n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stack2.png?raw=true\">\n</p>\n\n- top변수는 배열의 마지막 요소가 저장된 index를 저장한다.\n- top의 초기값은 -1을 가진다.\n- 배열의 시작은 언제나 index=0 이므로 bottom 변수를 만들 필요가 없다.\n\n- push 연산시 top = 기존 index + 1을 저장하고, 해당 index에 데이터를 저장\n- pop 연산시 top = 기존 index - 1 을 저장하고, 해당 index에 null을 저장\n\n<br><Br>\n\n```java\npublic class ArrayStack {\n\tint size;\n\tint top = -1;\n\tObject[] stack;\n\n\tpublic ArrayStack(int size){\n\t\tthis.size = size;\n\t\tstack = new Object[size];\n\t}\n\n\tpublic Object pop(){\n\t\tif(isEmpty()){\n\t\t\tthrows\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1991776809,"tx":12225},"lxMWY3IFzi3Fwd8Q/syncedContent":{"id":"lxMWY3IFzi3Fwd8Q/syncedContent","type":"syncedContent","historyData":{"1991776809":{"id":"lxMWY3IFzi3Fwd8Q/content","type":"content","text":"---\ntitle: \"[자료구조] 스택( Stack )이란? \"\ndate: 2021-08-24 01:00:00\ncategories:\n- 자료구조\ntags:\n- 자료구조\n---\n\n<br><br>\n\n## ✅ 스택(Stack)이란?\n선형 자료구조의 일종으로 먼저 들어간 원소가 나중에 나오는 First In Last Out ( FILO ) 구조를 가진다. 차곡차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리고 나중에 들어오는 원소는 그위에 쌓여 호출 시 가장 위에 있는 원소가 먼저 호출되는 구조이다.\n\n<br><br><br><br><br><br>\n\n\n## ✅ 스택(Stack)의 연산\n- **push(Data)** : Data 하나를 스택에 삽입한다.\n- **pop** : 스택에 있는 Data 하나를 제거한다.\n- **size** : 스택에 들어있는 정수의 개수를 출력한다.\n- **isEmpty** : 스택이 비어있으면 1(true), 아니면 0(false)을 출력한다.\n- **isFull** : 스택이 꽉차있으면 1(true), 아니면 0(false)을 출력한다.\n- **top** : 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.\n\n\n\n<br><br><br><br><br><br>\n\n## ✅ 스택(Stack)의 구조\n\n스택은 **자료의 출력 순서가 입력 순서의 역순으로 이루어질 때** 유용하게 사용된다. 우리가 스마트폰을 사용할 때 \"뒤로 가기\" 버튼을 누르면 현재 수행되는 앱이 종료되고 바로 직전에 수행되던 앱이 나타나는데, 이때 사용되는 것이 스택이다.\n\n<br>\n \n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stack1.png?raw=true\">\n</p>\n\n<br>\n\n\n- **상단(top)** : 스택에서 입출력이 이루어지는 부분\n- **하단(bottom)** : 반대쪽 바닥 부분\n- **요소(element)** : 스택에 저장되는 것\n- **공백 스택(empty stack)** : 공백 상태의 스택\n- **포화 스택(full stack)** : 포화 상태의 스택\n\n<br><br><br><br><br><br>\n\n\n## ✅ 스택(Stack) 구현\n\nStack 구현방법은 크게 두가지가 있다.\n\n1. **배열**을 이용한 구현\n\t- 장점 : 구현이 간단하며 메모리를 동적으로 할당하지 않기 때문에 속도가 빠르다.\n\t- 단점 : 배열을 사용하므로 스택의 크기가 고정된다.\n2. **리스트**를 이용한 구현\n\t- 장점 : 동적할당을 통해 가변적인 크기를 가진다.\n\t- 단점 : 삽입, 삭제시 동적할당/해제로 인해 속도가 느리다.\n\n<br><Br><Br>\n\n ### 📌 배열을 이용한 Stack 구현\n \n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/stack2.png?raw=true\">\n</p>\n\n- top변수는 배열의 마지막 요소가 저장된 index를 저장한다.\n- top의 초기값은 -1을 가진다.\n- 배열의 시작은 언제나 index=0 이므로 bottom 변수를 만들 필요가 없다.\n\n- push 연산시 top = 기존 index + 1을 저장하고, 해당 index에 데이터를 저장\n- pop 연산시 top = 기존 index - 1 을 저장하고, 해당 index에 null을 저장\n\n<br><Br>\n\n```java\npublic class ArrayStack {\n\tint size;\n\tint top = -1;\n\tObject[] stack;\n\n\tpublic ArrayStack(int size){\n\t\tthis.size = size;\n\t\tstack = new Object[size];\n\t}\n\n\tpublic Object pop(){\n\t\tif(isEmpty()){\n\t\t\tthrows\n}\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1991776809}},"syncHistory":{"main":[1991776809,1991776809,null]},"v":1,"hash":1710898325642,"tx":12243},"g55C7cqcezctQpDW/content":{"id":"g55C7cqcezctQpDW/content","type":"content","text":"\n\n","properties":"\n","discussions":{},"comments":{},"hash":497818810,"tx":12251},"g55C7cqcezctQpDW/contentState":{"id":"g55C7cqcezctQpDW/contentState","type":"contentState","selectionStart":1,"selectionEnd":1,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710898372409,"tx":12251},"Fr15DxYxCrywoW1c/contentState":{"id":"Fr15DxYxCrywoW1c/contentState","type":"contentState","selectionStart":1,"selectionEnd":1,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1710898374141,"tx":12252},"g55C7cqcezctQpDW":{"id":"g55C7cqcezctQpDW","type":"file","name":"쿼리 모르는 개념","parentId":"trash","hash":-2062028810,"tx":12252},"g55C7cqcezctQpDW/syncedContent":{"id":"g55C7cqcezctQpDW/syncedContent","type":"syncedContent","historyData":{"497818810":{"id":"g55C7cqcezctQpDW/content","type":"content","text":"\n\n","properties":"\n","discussions":{},"comments":{},"hash":497818810},"-740132882":{"id":"g55C7cqcezctQpDW/content","type":"content","text":"<BR>\n\n## 반올림\n\n`ROUND(반올림할 변수 OR 집계함수 , 반올림할 자릿수)`\n\n\n## 날짜 형식\n\n`TO_CHAR( DATE , 'YYYY-MM-DD' ) AS CREATED_DATE`\n","properties":"\n","discussions":{},"comments":{},"hash":-740132882}},"syncHistory":{"main":[497818810,-740132882,497818810]},"v":1,"hash":1710898394609,"tx":12269},"X3mDwXGkmeIJpTbt/syncedContent":{"id":"X3mDwXGkmeIJpTbt/syncedContent","type":"syncedContent","historyData":{"-842766002":{"id":"X3mDwXGkmeIJpTbt/content","type":"content","text":"컨테이너에서 다양한 네임스페이스를 설정가능하고 컨테이너를 생성할때 마다 관련 설정을 해줘야함 -> 불편\n\n그래서 컨테이너 런타임이 개발됨! -> Docker!!\n\n===================================================\n\n**[운영체제의 기초]** -> 얘를 알아야 컨테이너를 사용할때 발생하는 이슈 처리 가능\n\n커널스페이스?\n유저스페이스?\n\n유저스페이스에는 어플리케이션이 있고, 커널스페이스에는 OS Code가 존재. App과 OS Code가 통신하는 유일한 방법은 System call을 통한 통신밖에 없음. 대표적으로 ls 라는 명령어. \n\nbash로 ssh접속\nㄴ ls 날리면 ls app 꺼지고 화면에 결과 출력 \n\nSystem call은 **software interrupt**로 구성되어 있고, 이를 사용해서 OS Code와 통신/ (**hardware iterrupt**?) ( **IRQ**? )\n\n**Blocking IO , Non-blocking IO**\n\n**[ 컨테이너 원리 ]**\n유저스페이스의 app에서 명령을 보내면 ( system call )\n커널스페이스의 8가지 네임스페이스 fork() -> ns\n근데 너무 복잡해/ 사람눈에도 안들어오고 ns매번설정하기도 귀찮아\n-> 컨테이너 런타임 ( Docker ) 탄생이유\n\n\n**[ Docker ]**\n유저스페이스에서 동작을 하고, System Call을 사용해 커널스페이스에 명령을 내려주는 작업을 어플리케이션딴에서 자동으로 설정해주는 역할 \n\n\n====================================================\n\n컨테이너 Orchestration -> 쿠버네티스\n\n**Health Check Process API**를 따로뽑아내는 개발습관 중요 !\n\n====================================================\n**[ 면접단골질문 ]**\n공개키 비밀키 알고리즘\n대칭형 비대칭형에는 뭐가있지 ?\n\n====================================================\n\n요즘은 로그를 찍을때 두가지 방법이 있음\n1. stdout(err) -> 콘솔에 찍기\n2. txt파일에 저장하기 ( 요즘은 사용 x )\n\n최근에는 실무에서 컨테이너를 대부분 사용하는데,\n컨테이너가 여러개가 있을때, txt에 log를 기록하면 매번 확인하고 싶은 컨테이너에 접속해서, 로그가 담긴 txt파일을 일일히 확인해야하는 번거로움이 생김.\n\n근데 콘솔에 출력하면 putty같은걸 사용해서 로그를 본다고 했을때, putty꺼버리면 콘솔에 출력된 로그가 꺼져버려..\n\n그래서 docker log를 통해 이를 보완하는데\n컨테이너에서 stdout으로 로그를 찍으면 docker log를 통해 이 로그를\nfile에 기록해서 외부로 저장해버려 (모든 컨테이너의 로그)\n\n외부라고 하면 로그저장소를 의미하는데, 로그저장소에 file형태로 로그를 저장하고, kibana, splunk같은 툴을 사용해서 쿼리를 날려서 내 로그 전체를 살펴보는 방식으로 실무에서 사용한다.\n\n\n======================================================\n\n**OSI 7계층**\nL1(Physical Layer)\nL2(Data Link) : L1으로 연결된 두 노드간의 데이터 전송\nL3(Network) : Routing,Addressing을 사용해 노드간의 데이터를 어디에 전송할지 결정해주는 역할\nL4(Transport) : 포트넘버로 목적지 프로세스를 결정간으\nL5(Session) : 세션관리\nL6(Presentation) : \n","properties":"\n","discussions":{},"comments":{},"hash":-842766002}},"syncHistory":{"main":[-842766002,-842766002,null]},"v":1,"hash":1711327980624,"tx":12289},"1yvS1owczbvG7a0y/syncedContent":{"id":"1yvS1owczbvG7a0y/syncedContent","type":"syncedContent","historyData":{"-671205607":{"id":"1yvS1owczbvG7a0y/content","type":"content","text":"---\npermalink: /2023-08-10-네트워크 토폴로지의 종류와 특징/\npublished: true\ntitle: \"[네트워크] 네트워크 토폴로지의 종류와 특징\"\ndate: 2023-08-10 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"네트워크 토폴로지의 종류와 특징\"\ncategories:\n- 네트워크\ntags:\n- 네트워크\n---\n\n<br><br>\n\n# ✅ 네트워크 토폴로지\n\n네트워크 토폴로지 혹은 네트워크 구성은 네트워크 성능을 결정하는 핵심 요소라고 할 수 있다. 네트워크 토폴로지는 네트워크를 배치하는 방식으로, **링크와 노드들이 어떤 식으로 배치되어 서로 연결되는지를 물리적으로 혹은 논리적으로 설명한다.**\n\n네트워크 토폴로지는 수없이 많고, 각각의 장단점이 있으며 특정 상황에 따라 더 유용한 배치 방식이 달라진다. 이번 포스팅에서는 대표적으로 많이 사용되는 5가지의 네트워크 토폴로지의 장단점과 특징에 대해서 알아보도록 하겠다.\n\n<br><br><br><br>\n\n## ✅ 트리 토폴로지\n\n트리 토폴로지는 계층형 토폴로지라고 하며 트리형태로 배치한 네트워크 구성을 말한다. 노드들이 부모-자식 계층구조로 연결되어 있고, 연결된 두 노드는 하나의 연결만을 상호 공유한다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tree.png?raw=true\">\n</p>\n\n<br>\n\n### 📌 트리 토폴로지의 장점\n- 노드의 추가, 삭제가 쉽다.\n- 성능에 이상이 생긴 경우 네트워크 장애를 해결하기 쉽다.\n\n\n\n### 📌트리 토폴로지의 단점\n- 중앙 노드에 문제가 발생하면, 노드들 끼리의 연결이 끊어진다.\n- 계층구조가 복잡하고 선형배치 구조때문에, 노드를 추가할 수록 관리가 어렵다.\n- 비용이 많이 든다.\n\n\n<br><br><br><br>\n\n## ✅ 버스 토폴로지\n\n버스 토폴로지는 중앙 통신 회선하나에 여러개의 노드가 연결되어 공유하는 네트워크 구성이다. 보통 근거리 통신망(LAN)에 사용한다.\n\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/bus.png?raw=true\">\n</p>\n\n<br>\n\n### 📌 버스 토폴로지의 장점\n- 노드의 추가, 삭제가 쉽다.\n- 네트워크 배치가 단순하기 때문에 비용 효율적이며, 소규모 네트워크에 적합하다.\n\n\n### 📌 버스 토폴로지의 단점\n- 하나의 케이블만을 사용해 통신하기 때문에 보안에 굉장히 취약하다.\n- **스푸핑**이 발생할 수 있다.\n- 케이블에 장애가 발생하면 전체 네트워크가 멈추고, 복구하는데 많은 시간과 비용이 든다.\n- 단방향으로만 데이터 전송이 가능하다.\n\n<br>\n\n> **📄 스푸핑이란?**  \n> LAN상에서 송신부의 패킷을 송신과 관련없는 다른 호스트에 가지 않도록 하는 스위칭 기능을 마비시키거나 속여서 특정노드에 해당 패킷이 오도록 처리하는 것\n\n<br><br><br><br>\n\n## ✅ 스타 토폴로지\n\n가장 흔하게 사용되는 네트워크 토폴로지로, 네트워크 안의 모든 노드가 중앙 허브에 연결되어 있는 구조이다. 중앙 노드는 서버로서 작동하여 데이터의 흐름을 관리한다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/star.png?raw=true\">\n</p>\n\n<br>\n\n### 📌 스타 토폴로지의 장점\n- 노드의 추가, 삭제 및 장애 발견이 쉽다.\n- 패킷의 충돌 가능성이 적다.\n- 노드간 영향을 끼치는것이 적다.\n- 모든 네트워크를 연결하는데 상대적으로 적은 케이블을 사용하기 때문에 시간이 지남에 따라 네트워크 확장 및 관리가 간단하다.\n\n\n### 📌 스타 토폴로지의 단점\n- 중앙 허브에 장애가 발생하면 모든 네트워크가 멈춘다.\n- 초기 설치비용이 비싸다.\n\n\n<br><br><br><br>\n\n## ✅ 링 토폴로지\n\n각각의 노트가 양 옆의 두 노드와 연결되어 고리처럼 하나의 연속된 길을 통해 통신하는 네트워크 구성방식이다. 데이터가 한방향 또는 양방향으로 흐를수 있다.\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ring.png?raw=true\">\n</p>\n\n### 📌 링 토폴로지의 장점\n- 노드 수가 증가되어도 네트워크 상의 손실이 거의 없다.\n- 데이터의 충돌 가능성이 적다.\n- 장애를 쉽게 발견 가능하다.\n\n\n### 📌 링 토폴로지의 단점\n- 네트워크 구성 변경이 어렵다.\n- 회선에 장애가 발생하면 전체 네트워크에 큰 영향을 끼친다.\n- 노드의 추가 및 제거를 위해선 전체 네트워크를 중단해야 한다.\n\n<br><br><br><br>\n\n## ✅ 메시 토폴로지\n\n망형 토폴로지라고도 하며 그물망처럼 연결되어 있는 네트워크 구조이다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mesh.png?raw=true\">\n</p>\n\n\n### 📌 메시 토폴로지의 장점\n- 안정성과 보안성이 뛰어나다.\n- 장애가 발생해도 여러 경로가 존재하므로 네트워크를 계속 사용할 수 있다.\n- 트래픽의 분산 처리가 가능하다.\n\n\n### 📌 메시 토폴로지의 단점\n- 노드의 추가 및 삭제가 어렵다.\n- 구축비용과 운용비용이 많이 든다.\n","properties":"\n","discussions":{},"comments":{},"hash":-671205607}},"syncHistory":{"main":[-671205607,-671205607,null]},"v":1,"hash":1711328072991,"tx":12294},"i2J5V4CA691bc9Lh":{"id":"i2J5V4CA691bc9Lh","type":"folder","name":"운영체제","parentId":null,"hash":119422516,"tx":12295},"VLaa02Loo6VepSNT":{"id":"VLaa02Loo6VepSNT","type":"file","name":"2024-03-25-프로세스란","parentId":"i2J5V4CA691bc9Lh","hash":28468121,"tx":12299},"ZQ1P22aGt9pYBZQY/contentState":{"id":"ZQ1P22aGt9pYBZQY/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1711328165415,"tx":12338},"wTK8ucAfkpXnll6C/contentState":{"id":"wTK8ucAfkpXnll6C/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1711328165890,"tx":12339},"AAphmch3Ge6p9ZRi":{"id":"AAphmch3Ge6p9ZRi","type":"folder","name":"JAVA","parentId":null,"hash":1770523809,"tx":12364},"yCviR51sRbUk47WF/contentState":{"id":"yCviR51sRbUk47WF/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1711350744055,"tx":12388},"toS351vpmJre9cYC/syncedContent":{"id":"toS351vpmJre9cYC/syncedContent","type":"syncedContent","historyData":{"-757487084":{"id":"toS351vpmJre9cYC/content","type":"content","text":"---\npermalink: /2023-05-18-JS 내장 객체, 브라우저 객체, JS 삽입위치/\ntitle: \"[JavaScript] JS 내장 객체, 브라우저 객체, JS 삽입위치\"\ndate: 2023-05-18 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 내장 객체, 브라우저 객체, JS 삽입위치\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n\n## ✅ 자바스크립트 내장 객체\n\n\n### 📌 Array 객체\n자바스크립트에는 배열을 쉽게 만들고 다룰수 있는 Array 객체가 내장되어 있다. 객체를 만들기 위해서는 인스턴스가 필요하기 때문에 new 예약어와 함께 사용하면 된다.\n\n```js\n// 초기값을 지정하지 않는 경우\nvar numbers = new Array();\t\t// 배열의 크기를 지정하지 않음\nvar numbers = new Array(4);\t\t// 배열의 크기를 지정함\n\n// 초기값이 있는 경우\nvar numbers = [\"one\", \"two\", \"three\", \"four\"];\t\t// 배열선언\nvar numbers = Array(\"one\",\"two\",\"three\",\"four\");\t// Array객체 사용 배열 선언\n```\n\n<br><br>\n\n### 📌 Array 객체의 메서드\nArray 객체는 여러가지 메서드가 있다. 간단하게 표로 정리해보자.\n\n| 종류 | 설명 |\n|--|--|\n| concat | 기존 배열에 요소를 추가해 새로운 배열을 만듭니다 |\n| every | 배열의 모든 요소가 주어진 함수에 대해 참이면 true, 그렇지 않으면 false를 반환한다 |\n| filter | 배열 요소 중에서 주어진 필터링 함수에 대해 true인 요소만 골라 새로운 배열을 만든다 |\n| forEach | 배열의 모든 요소에 대해 주어진 함수를 실행한다 |\n| indexOf | 주어진 값과 일치하는 값이 있는 배열 요소의 첫 인덱스를 찾는다 |\n| join | 배열 요소를 문자열로 합친다. 이때 구분자를 지정할 수 있다 |\n| push | 배열의 맨 끝에 새로운 요소를 추가한 후 새로운 length를 반환한다 |\n| unshift | 배열의 시작 부분에 새로운 요소를 추가한다 |\n| pop | 배열의 마지막 요소를 꺼내 그 값을 결과로 반환한다 |\n| shift | 배열의 첫번째 요소를 꺼내 그 값을 결과로 반환한다 |\n| splice | 배열의 요소를 추가하거나 삭제한다 |\n| slice | 배열에서 특정한 부분만 잘라낸다 |\n| reverse | 배열의 배치 순서를 역순으로 바꾼다 |\n| sort | 배열 요소를 지정한 조건에 따라 정렬한다 |\n| toString | 배열에서 지정한 부분을 문자열로 반환한다. 이때 각 요소는 쉼표(,)로 구분한다 |\n\n<Br><br>\n\n### 📌 JS의 삽입 위치\nJS코드는 `<header>` 에 포함될 수도 있고, `<body>`에 포함될 수도 있다. 그러나 대부분의 경우 JS코드는 `<body>` 내부에 포함시켜 작성된다. `<header>` 에 위치하는 것과 `<body>`에 위치하는게 어떤 차이가 있고 왜 `<body>`에 대부분 작성하는지 알아보자.\n\n \n브라우저는 HTML의 구조와 CSS 스타일을 렌더링하는 도중 자바 스크립트를 만나게 되면 이에 대한 해석과 구현이 완료될때까지 브라우저 렌더링을 중단한다. 이후 포스팅을 이해하기 위해서는 브라우저 렌더링이 어떤 것이고, 어떤 과정을 거치는지 알 필요가 있기 때문에 [브라우저 렌더링 과정](https://idkim97.github.io/2023-05-18-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%A0%8C%EB%8D%94%EB%A7%81%20%EA%B3%BC%EC%A0%95/) 포스팅을 참고하길 바란다.\n\n한마디로, 자바스크립트의 삽입 위치가 브라우저 렌더링에 영향을 미친다는 것이다.\n\n```js\n<header>\n(..생략..)\n\t<script>\n\t\tdocument.querySelector(\"#aa\").onclick = function(){\n\t\t\talert(\"aa 선택됨\");\n\t\t}\n\t</script>\n(...생략...)\n</header>\n\n<body>\n\t(...생략...)\n</body>\n```\n\n위의 코드는 `aa`라는 아이디를 가진 요소를 클릭했을 때 \"aa 선택됨\" 이라는 경고창을 띄워주는 코드이다. 그러나 위 코드는 정상적으로 작동하지 못한다. `<script>` 코드가 `<body>` 코드보다 앞서 존재하기 때문에 아직 브라우저 렌더링이 시작되지 않았고, 이로인해 `document` 객체가 HTML요소를 가지고 있지 않기 때문에 `#aa` 라는 아이디를 가진 요소를 찾을 수가 없다. \n\n<br>\n\n이런 코드를 실행시키면 alert창이 안뜨게 된다. 왜냐하면 **document**라는 객체는 **HTML 문서의 정보**를 가지는 객체인데,  HTML요소는 body에 선언되어 있고 , header는 body보다 위쪽에 선언되어 있기때문에 document에는 아직 아무런 요소가 들어있지 않다. 즉, document가 `aa`라는 요소를 찾지 못하기때문에 발생하는 오류이다.\n\n<br>\n\n그렇다고 `<header>` 부분에 `<script>` 코드를 절대 작성하지 못하는 것은 아니다. 언제나 그렇듯 방법은 존재하기 마련이다..\n\nJS의 최상단 객체인 `window` 객체의 `onload` 메서드를 사용하면 된다. `window`객체는 브라우저 창이 열릴 때 마다 생성되는 객체이고 JS의 모든 객체의 부모노드라고 볼 수 있다. \n\n`onload` 메서드는 페이지의 모든 요소들이 로드되면 실행되는 전역 콜백 함수이다. 한 페이지에서 하나의 `window.onload()` 함수만 적용되는 특징이 있다. 때문에 자바스크립트 코드에 `window.onload` 를 붙여주면 모든 요소가 로드 된 후에 자바스크립트 코드를 실행하기 때문에 정상적으로 사용 가능하다. 아래는 예시 코드이다.\n\n\n```js\n<header>\n\t<script>\n\t\twindow.onload = function(){\n\t\t\tdocument.querySelector(\"#aa\").onclick = function(){\n\t\t\talert(\"aa 선택됨\");\n\t\t}\n\t<script>\n<header>\n```\n\n<br><br><br><br>\n\n## ✅ 브라우저 관련 객체\n\n웹 브라우저가 화면에 나타나는 순간 브라우저는 관련 객체를 만들어 낸다. 가장 먼저 window라는 최상단 객체가 만들어지고 그 밑으로 하위요소에 해당하는 객체들이 생성된다. 이는 계층구조로 나타낼 수 있고 아래 이미지 처럼 구성된다.\n<Br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/window.png?raw=true\">\n</p>\n\n<Br>\n\n관련 객체들을 간단하게 표로 정리해보겠다.\n\n|종류|설명|\n|--|--|\n| window | 브라우저 창이 열릴 때마다 하나씩 만들어진다. 브라우저 창 안의 요소 중 최상단에 위치한다 |\n| document | 웹 문서마다 하나씩 있으며 <body> 태그를 만나면 만들어진다. HTML 문서의 정보가 담겨있다 |\n| navigator | 현재 사용하는 브라우저의 정보가 들어있다 |\n| history | 현재 창에서 사용자의 방문 기록을 저장한다 |\n| location | 현재 페이지의 URL 정보가 담겨있다 |\n| screen | 현재 사용하는 화면 정보를 다룬다 |\n\n<br>\n\n이 외에도 정말 많은 객체, 프로퍼티, 메서드가 있지만 많이 사용하는 편은 아니고 굳이 다 외워둘 필요 없기때문에 작성하지 않겠다. 필요하다면 다른 블로그 게시물을 확인하면 되겠다.\n\n참고 : [자바스크립트 내장 객체 & 브라우저 객체 메서드와 프로퍼티 정리 ](https://velog.io/@kim_unknown_/JavaScript-Objects)\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-757487084}},"syncHistory":{"main":[-757487084,-757487084,null]},"v":1,"hash":1711350923373,"tx":12392},"nOITFWSLtVkWensy/content":{"id":"nOITFWSLtVkWensy/content","type":"content","text":"---\npermalink: /2023-05-17-JS 변수, 예약어, 함수 표현식, 이벤트, 이벤트핸들러/\ntitle: \"[JavaScript] JS 변수, 함수, 이벤트\"\ndate: 2023-05-17 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 변수, 함수, 이벤트\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n\n\n## ✅ 변수 선언\n\n자바스크립트에서 변수를 선언하기 위한 예약어는 `var`, `let`, \t`const`  3가지가 존재한다. 각각의 예약어는 어떤 역할을 하고 특징을 지녔는지 알아보도록 하겠다.\n\n<br><br><br><br>\n\n### 📌 예약어 var\nvar은 지역변수를 정의할때 사용한다. 별로 어려운게 없으니 예제를 통해 어떻게 사용되는지 알아보자.\n\n```js\n<script>\n\tfunction addNumber(){\n\t  var sum = 10 + 20;\n\t}\n\t\n\taddNumber();\n\tconsole.log(sum);\n</script>\n```\n`addNumber()`라는 함수를 정의하고 함수 내부에 `var sum = 10 + 20;` 이라는 지역변수를 정의했다. 이때 `sum`을 선언한 함수 외부에서 `console.log`를 실행시키고 개발자 도구를 살펴보면 오류가 나온다.\n\n<br><br>\n\n<figure align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/var1.png?raw=true\">\n<figcaption style=\"font-size:13px font-family:NanumSquare\"> 함수 밖에서 지역변수를 사용하면 나타나는 오류 메시지 </figcaption>\n</figure>\n\n<br><br>\n\n`var`는 지역변수를 선언하기 때문에 함수 내부에서 선언한 변수는 함수 내부에서만 사용가능하고 외부에서는 사용할 수 없다.\n\n그림과 같이 콘솔창에는 `Uncaught ReferenceError : sum is not defined` 라는 오류가 발생한다.\n\n\n<br><br>\n또한 var를 사용하지 않은채 예약어 없이 변수를 선언하면 전역변수로 사용할 수 있다.\n\n때문에 var은 **재선언**과 **재할당**이 가능하다. 예시를 보며 알아보자.\n```js\n<script>\n\n\tfunction  addNumber(num1, num2) {\n\t\treturn  num1 + num2;\n\t}\n\n\tvar  sum = addNumber(10, 20);\t// sum 변수 선언, 호출\n\tconsole.log(sum);\t\t\t\t// 30\n\t\n\tsum = 50;\t\t\t\t\t// sum 재할당\n\tconsole.log(sum);\t\t\t\t// 50\n\t\n\tvar  sum = 100;\t\t\t\t\t// sum 재선언\n\tconsole.log(sum);\t\t\t\t// 100\n\t\n</script>\n```\nvar로 선언한 sum 변수는 최초 선언이후에 재할당, 재선언이 가능하기 때문에 값이 계속 변하는게 보인다.\n\n\n<br><br><br><br>\n\n### 📌 예약어 let\nES6 이전의 JS 프로그램에서는 var 예약어만으로 변수를 선언했는데, 이로인해 발생하는 문제가 많았다. var 예약어를 빠트리면 전역변수로 선언되기도 하고, 프로그램의 길이가 길어지면 실수로 변수를 재선언하거나 값을 재할당하는 경우가 생기기도 한다. 그래서 ES6에서는 변수 선언을 위한 예약어로 let이나 const를 권장한다.\n\n**let** 예약어로 선언한 변수는 변수를 선언한 블록 ( { }로 묶은 부분 ) 에서만 유효하다. 예시를 통해 알아보자.\n```js\n<script>\n\tfunction  calcSum(n) {\n\t\tlet  sum = 0;\n\t\tfor(let  i = 1; i < n + 1; i++) {\n\t\t\tsum += i;\n\t\t}\t\t// i는 for문 내에서만 사용가능\n\tconsole.log(sum);\n\t}\t\t\t// sum은 calcSum함수 내에서만 사용가능\n\tcalcSum(10);\n</script>\n```\n위의 코드에서 `let sum=0`은 `calcSum()` 함수 내부에서 선언되었기 때문에 `calcSum()` 내부에서만 사용가능하다. 또한 i는 for문 내부에서 선언되었기 때문에 for문 내부에서만 사용가능 하다.\n\n<br>\nlet 예약어는 재할당은 가능하지만, 재선언은 할 수 없다. 재선언을 하면 오류가 발생하는것을 확인할 수 있다.\n\n<br><br><br><br>\n###  📌예약어 const\nconst는 이름에서 알 수 있듯이 상수 변수를 선언하는 예약어이다. 프로그램 안에서 절대 변하지 않는 변수를 선언한다는 의미이다. 특정 상수를 자주 사용하는 상황에서 유용하게 쓰인다. 또한 재선언과 재할당이 모두 불가능하다.\n\n<br><Br><br><br>\n\n## ✅ 함수 표현식\nJS에서는 같은 함수라도 다양한 방식으로 표현할 수 있다. 일반 함수, 익명 함수, 즉시 실행 함수, 화살표 함수 총 4가지 방법이 있고 그리 어려운 내용은 아니니 예제와 함께 알아보도록 하겠다.\n\n### 📌일반 함수\n```js\nfunction addNumber(num1, num2){\t\t// 함수 선언\n\tvar sum = num1 + num2;\n\treturn sum;\n}\n\nlet result = addNumber(2,3);\t\t// 함수 호출\ndocument.write(\"결과 : \"+result);\n```\n\n<br><br>\n\n### 📌익명 함수\n이름이 없는 함수를 의미한다. 일반 함수에서 함수 이름만 없어진 형태를 가진다. \n```js\nfunction (num1, num2){\n\treturn num1+num2;\n}\n```\n<BR><br>\n그렇다면 함수명이 없는데 어떻게 사용할 수 있을까? 익명함수는 함수자체가 식이기 때문에 함수를 변수에 할당할 수 있고 다른 함수의 매개변수로도 사용할 수 있다.\n\n<br><br>\n\n- 변수에 함수 할당\n\n```js\nlet result = function ( num1, num2 ) {\t\t// 익명 함수를 선언한 후 변수 result에 할당\n\treturn num1 + num2;\n}\ndocument.write(\"결과 : \" + result(10,20));\t// 익명 함수 실행\n```\n<br><br>\n\n- 다른 함수의 매개변수로 익명함수 사용\n\n```js\nfunction calculate(func){\t\t// 함수를 매개변수로 갖는 calculate함수\n\tfunc();\n}\n\ncalculate(function(num1,num2){\t// 익명함수를 인자로 가지고 calculate 함수 호출\n\treturn num1+num2;\n});\n```\n\n<br><br><br><br>\n\n### 📌즉시 실행 함수\n일반적으로 함수는 선언하고 필요할 때마다 호출해서 사용하는 방법을 많이 사용하지만, 딱 한번만 실행하는 함수라면 정의와 동시에 실행할 수 있다. 이를 즉시 실행 함수라고 하는데 기본형과 예제를 알아보자.\n\n- 기본형\n\n```js\n// 매개변수가 없는 즉시 실행 함수\n(function(){\n    // 명령\n}());\n\n// 매개변수가 있는 즉시 실행 함수\n(function(매개변수){\n    // 명령\n}());\n```\n함수를 식형태로 선언하기 때문에 마지막에 세미콜론을 붙여줘야 한다.\n\n<br><br>\n\n- 기본형 즉시실행 함수\n\n```js\n(function(){\n\tlet userName = prompt(\"이름을 입력하세요\");\n\tdocument.write(\"안녕하세요 + userName + 님!\"\n}());\n```\n\n<br><br>\n\n- 매개변수가 있는 즉시 실행 함수\n\n\n```js\n(function(num1,num2){\t\t\t// 매개 변수 num1, num2\n\tsum = num1 + num2;\n}(100,200));\t\t\t\t// 인자 100,200 설정\n\ndocument.write(\"결과 : \" + sum);\t// 결과 : 300\n```\n\n<br><br><br><br>\n\n### 📌 화살표 함수\nES6 버전부터는 `=>` 화살표 표기법을 사용해 함수 선언을 간단하게 작성할 수 있다. 이는 **익명함수** 에서만 사용가능하다!\n\n- 기본형 : ```(매개변수) => { 함수 내용 }```\n\n<br><br>\n\n- 매개변수가 없는 함수\n\n```js\nconst hi = function() { return \"안녕하세요\"}\n```\n<br><br>\n\n- 매개변수가 없는 화살표 함수\n\n```js\nconst h1 = () => { return \"안녕하세요\" };\n```\n\n<br><br>\n\n- 매개변수가 없는 화살표 함수 ( 중괄호 생략가능 )\n\n```js\nconst h1 = () => return \"안녕하세요\";\n```\n\n<br><br>\n\n- 매개변수가 1개인 함수\n\n```js\nlet hi = function(user){\n\tdocument.write(user + \"님 안녕하세요\");\n}\n```\n\n<br><br>\n\n- 매개변수가 1개인 화살표 함수\n\n```js\nlet hi = (user) => { document.write(user+\"님 안녕하세요\");\n```\n\n<br><br>\n\n- 매개변수가 2개 이상인 화살표 함수\n\n```js\nlet sum = (a,b) => a+b;\n```\n\n<br><br><br><br>\n\n## ✅ 이벤트 ( Event )\n이벤트는 웹 브라우저나 사용자가 행하는 어떤 동작을 의미한다. 마우스나 키보드, 문서 로딩, form에 데이터 입력 등의 활동을 할때 이벤트가 주로 발생한다. 이벤트의 종류는 정말 많고 일일히 외울 필요는 없어보인다. 한번 쭉 표로 정리하면서 읽어보고 필요할 때마다 찾아보면 될것 같다.\n\n<br><br>\n\n### 📌 마우스 이벤트\n\n| 종류 | 설명 |\n|--|--|\n| click | 사용자가 HTML 요소를 클릭할 때 발생하는 이벤트 |\n| dbclick | 사용자가 HTML 요소를 더블클릭 할 때 발생하는 이벤트 |\n| mousedown | 사용자가 요소 위에서 마우스 버튼을 눌렀을 때 발생하는 이벤트 |\n| mousemove | 사용자가 요소 위에서 마우스 포인터를 움직일 때 발생하는 이벤트 |\n| mouseover | 마우스 포인터가 요소 위로 옮겨질 때 발생하는 이벤트 |\n| mouseout | 마우스 포인터가 요소를 벗어날 때 발생하는 이벤트 |\n| mouseup | 사용자가 요소 위에 놓인 마우스 버튼에서 손을 뗄 때 발생하는 이벤트 |\n\n<br><br>\n\n### 📌 키보드 이벤트\n\n|종류| 설명 |\n|--|--|\n| keydown | 사용자가 키를 누르는 동안 발생하는 이벤트 |\n| keypress | 사용자가 키를 눌렀을 때 발생하는 이벤트 |\n| keyup | 사용자가 키에서 손을 땔 때 발생하는 이벤트  |\n\n<br><br>\n\n### 📌 문서 로딩 이벤트\n\n|종류|설명|\n|--|--|\n|abort| 문서가 완전히 로딩되기 전에 불러오기를 멈췄을 때 발생하는 이벤트 |\n| error | 문서가 정확히 로딩되지 않았을 때 발생하는 이벤트 |\n| load | 문서 로딩이 끝나면 발생하는 이벤트 |\n| resize | 문서 화면 크기가 바뀌었을 때 발생하는 이벤트 |\n| scroll | 문서 화면이 스크롤 되었을 때 발생하는 이벤트 |\n| unload | 문서에서 벗어날 때 발생하는 이벤트 |\n\n<br><Br>\n\n### 📌 폼 이벤트\n\n| 종류 | 설명 |\n|--|--|\n| blur | 폼 요소에 포커스를 잃었을 때 발생하는 이벤트 |\n| change | 목록이나 체크 상태 등이 변경되면 발생하는 이벤트. `<input>`, `<select>`, `<textarea>` 태그에서 사용 |\n| focus | 폼 요소에 포커스가 놓였을 때 발생하는 이벤트. `<label>`, `<select>`, `<textarea>`, `<button>` 태그에서 사용 |\n| reset | 폼이 리셋되었을 때 발생하는 이벤트 |\n| submit | submit 버튼을 클릭했을 때 발생하는 이벤트 |\n\n<br><br><br><br>\n\n\n## ✅ 이벤트처리기 (EventHandler)\n\n### 📌 HTML태그를 이용한 이벤트 처리기\n\nJavaScript에는 상당히 많은 이벤트가 존재하고 이를 처리하는 함수를 이벤트처리기 혹은 이벤트핸들러 라고 부른다. 이벤트를 처리하는 가장 기본적인 방법은 HTML 태그에 이벤트 처리기를 직접 연결하는 것이다.\n\n- 기본형 : ```<태그 on이벤트명 = \"함수명\">```\n\n간단한 예제를 통해 더 알아보자. 버튼을 클릭하면 알림창을 표시하는 예제이다.\n```js\n<body>\n\t<ul>\n\t\t<li><a href=\"#\" onclick=\"alert('버튼을 클릭했습니다.')\">Green</a></li>\n\t\t<li><a href=\"#\" onclick=\"alert('버튼을 클릭했습니다.')\">Orange</a></li>\n\t\t<li><a href=\"#\" onclick=\"alert('버튼을 클릭했습니다.')\">Purple</a></li>\n\t</ul>\n</body>\n```\n\n<br>\n버튼을 클릭하면 배경색을 바꾸는 코드이다.\n\n```js\n<body>\n\t<ul>\n\t\t<li> <a href=\"#\" onclick=\"changeBg('green')Green</a></li>\n\t\t<li> <a href=\"#\" onclick=\"changeBg('orange')Orange</a></li>\n\t\t<li> <a href=\"#\" onclick=\"changeBg('purple')Purple</a></li>\n\t</ul>\n<div id=\"result\"></div>\n\n<script>\n\tfunction changeBg(color){\n\t\tvar result = document.querySelector('#result');\n\t\tresult.style.backgroundColor = color;\n\t}\n</script>\n</body>\n```\n\n<br><br>\n\n### 📌 DOM을 이용한 이벤트 처리기\nHTML태그를 이용하면 HTML이 주인이 되어 자바스크립트의 함수를 불러와 사용하낟. 그러나 DOM을 사용하면 자바스크립트가 주인이 되어 HTML의 요소를 가져와 이벤트 처리기를 연결 할 수 있다. \n\n- 기본형 : ```웹 요소.onclick = 함수;```\n\n자바스크립트에서는 다양한 방법으로 웹 요소를 가져올 수 있는데 그 중 `quertSelector()`를 사용하는게 가장 편하다. `()`안에는 id,class명, 선택자 등을 넣을 수 있다. 예제를 통해서 어떻게 이벤트 처리를 하는지 알아보자.\n\n```js\n<body>\n\t<button id=\"change\"> 글자색 바꾸기 </button>\n\t<p> 안녕하세요. 김테드 입니다. </p>\n\t\n\t(...생략...)\n\n\t// 방법 1 : 웹 요소를 변수로 지정 & 미리 만든 함수 사용\n\tlet changebttn = document.querySelector(\"#change\");\n\tchangebttn.onclick = changeColor;\n\n\t// 방법 2 : 웹 요소를 따로 변수로 만들지 않고 사용\n\tdocument.querySelector(\"#change\").onclick = changeColor;\n\n\tfunction changeColor(){\n\t\tdocument.querySelector(\"p\").style.color = \"#f00\";\n\n\t// 방법 3 : 함수를 직접 선언\n\tdocument.querySelector(\"#change\").onclick = function(){\n\t\tdocument.querySelector(\"p\").style.color = \"#f00\";\n\t};\n\n\t(...생략...)\n\t\n```\n\n<br><br>\n\n### 🔔 Document 객체\n\nDocument 객체는 웹 페이지 그 자체를 의미한다. 웹 페이지에 존재하는 HTML 요소에 접근하고자 할 때는 반드시 Document 객체부터 시작해야만 한다. 자세한 내용은 이후 자바스크립트 객체 관련 공부를 할 때 깊게 다뤄보자.\n\n<br><br>\n\n","properties":"\n","discussions":{},"comments":{},"hash":476150886,"tx":12582},"nOITFWSLtVkWensy/syncedContent":{"id":"nOITFWSLtVkWensy/syncedContent","type":"syncedContent","historyData":{"476150886":{"id":"nOITFWSLtVkWensy/content","type":"content","text":"---\npermalink: /2023-05-17-JS 변수, 예약어, 함수 표현식, 이벤트, 이벤트핸들러/\ntitle: \"[JavaScript] JS 변수, 함수, 이벤트\"\ndate: 2023-05-17 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"JS 변수, 함수, 이벤트\"\ncategories:\n- Front-end\ntags:\n- 카카오 클라우드 스쿨\n- JavaScript\n---\n<br><br>\n\n\n\n## ✅ 변수 선언\n\n자바스크립트에서 변수를 선언하기 위한 예약어는 `var`, `let`, \t`const`  3가지가 존재한다. 각각의 예약어는 어떤 역할을 하고 특징을 지녔는지 알아보도록 하겠다.\n\n<br><br><br><br>\n\n### 📌 예약어 var\nvar은 지역변수를 정의할때 사용한다. 별로 어려운게 없으니 예제를 통해 어떻게 사용되는지 알아보자.\n\n```js\n<script>\n\tfunction addNumber(){\n\t  var sum = 10 + 20;\n\t}\n\t\n\taddNumber();\n\tconsole.log(sum);\n</script>\n```\n`addNumber()`라는 함수를 정의하고 함수 내부에 `var sum = 10 + 20;` 이라는 지역변수를 정의했다. 이때 `sum`을 선언한 함수 외부에서 `console.log`를 실행시키고 개발자 도구를 살펴보면 오류가 나온다.\n\n<br><br>\n\n<figure align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/var1.png?raw=true\">\n<figcaption style=\"font-size:13px font-family:NanumSquare\"> 함수 밖에서 지역변수를 사용하면 나타나는 오류 메시지 </figcaption>\n</figure>\n\n<br><br>\n\n`var`는 지역변수를 선언하기 때문에 함수 내부에서 선언한 변수는 함수 내부에서만 사용가능하고 외부에서는 사용할 수 없다.\n\n그림과 같이 콘솔창에는 `Uncaught ReferenceError : sum is not defined` 라는 오류가 발생한다.\n\n\n<br><br>\n또한 var를 사용하지 않은채 예약어 없이 변수를 선언하면 전역변수로 사용할 수 있다.\n\n때문에 var은 **재선언**과 **재할당**이 가능하다. 예시를 보며 알아보자.\n```js\n<script>\n\n\tfunction  addNumber(num1, num2) {\n\t\treturn  num1 + num2;\n\t}\n\n\tvar  sum = addNumber(10, 20);\t// sum 변수 선언, 호출\n\tconsole.log(sum);\t\t\t\t// 30\n\t\n\tsum = 50;\t\t\t\t\t// sum 재할당\n\tconsole.log(sum);\t\t\t\t// 50\n\t\n\tvar  sum = 100;\t\t\t\t\t// sum 재선언\n\tconsole.log(sum);\t\t\t\t// 100\n\t\n</script>\n```\nvar로 선언한 sum 변수는 최초 선언이후에 재할당, 재선언이 가능하기 때문에 값이 계속 변하는게 보인다.\n\n\n<br><br><br><br>\n\n### 📌 예약어 let\nES6 이전의 JS 프로그램에서는 var 예약어만으로 변수를 선언했는데, 이로인해 발생하는 문제가 많았다. var 예약어를 빠트리면 전역변수로 선언되기도 하고, 프로그램의 길이가 길어지면 실수로 변수를 재선언하거나 값을 재할당하는 경우가 생기기도 한다. 그래서 ES6에서는 변수 선언을 위한 예약어로 let이나 const를 권장한다.\n\n**let** 예약어로 선언한 변수는 변수를 선언한 블록 ( { }로 묶은 부분 ) 에서만 유효하다. 예시를 통해 알아보자.\n```js\n<script>\n\tfunction  calcSum(n) {\n\t\tlet  sum = 0;\n\t\tfor(let  i = 1; i < n + 1; i++) {\n\t\t\tsum += i;\n\t\t}\t\t// i는 for문 내에서만 사용가능\n\tconsole.log(sum);\n\t}\t\t\t// sum은 calcSum함수 내에서만 사용가능\n\tcalcSum(10);\n</script>\n```\n위의 코드에서 `let sum=0`은 `calcSum()` 함수 내부에서 선언되었기 때문에 `calcSum()` 내부에서만 사용가능하다. 또한 i는 for문 내부에서 선언되었기 때문에 for문 내부에서만 사용가능 하다.\n\n<br>\nlet 예약어는 재할당은 가능하지만, 재선언은 할 수 없다. 재선언을 하면 오류가 발생하는것을 확인할 수 있다.\n\n<br><br><br><br>\n###  📌예약어 const\nconst는 이름에서 알 수 있듯이 상수 변수를 선언하는 예약어이다. 프로그램 안에서 절대 변하지 않는 변수를 선언한다는 의미이다. 특정 상수를 자주 사용하는 상황에서 유용하게 쓰인다. 또한 재선언과 재할당이 모두 불가능하다.\n\n<br><Br><br><br>\n\n## ✅ 함수 표현식\nJS에서는 같은 함수라도 다양한 방식으로 표현할 수 있다. 일반 함수, 익명 함수, 즉시 실행 함수, 화살표 함수 총 4가지 방법이 있고 그리 어려운 내용은 아니니 예제와 함께 알아보도록 하겠다.\n\n### 📌일반 함수\n```js\nfunction addNumber(num1, num2){\t\t// 함수 선언\n\tvar sum = num1 + num2;\n\treturn sum;\n}\n\nlet result = addNumber(2,3);\t\t// 함수 호출\ndocument.write(\"결과 : \"+result);\n```\n\n<br><br>\n\n### 📌익명 함수\n이름이 없는 함수를 의미한다. 일반 함수에서 함수 이름만 없어진 형태를 가진다. \n```js\nfunction (num1, num2){\n\treturn num1+num2;\n}\n```\n<BR><br>\n그렇다면 함수명이 없는데 어떻게 사용할 수 있을까? 익명함수는 함수자체가 식이기 때문에 함수를 변수에 할당할 수 있고 다른 함수의 매개변수로도 사용할 수 있다.\n\n<br><br>\n\n- 변수에 함수 할당\n\n```js\nlet result = function ( num1, num2 ) {\t\t// 익명 함수를 선언한 후 변수 result에 할당\n\treturn num1 + num2;\n}\ndocument.write(\"결과 : \" + result(10,20));\t// 익명 함수 실행\n```\n<br><br>\n\n- 다른 함수의 매개변수로 익명함수 사용\n\n```js\nfunction calculate(func){\t\t// 함수를 매개변수로 갖는 calculate함수\n\tfunc();\n}\n\ncalculate(function(num1,num2){\t// 익명함수를 인자로 가지고 calculate 함수 호출\n\treturn num1+num2;\n});\n```\n\n<br><br><br><br>\n\n### 📌즉시 실행 함수\n일반적으로 함수는 선언하고 필요할 때마다 호출해서 사용하는 방법을 많이 사용하지만, 딱 한번만 실행하는 함수라면 정의와 동시에 실행할 수 있다. 이를 즉시 실행 함수라고 하는데 기본형과 예제를 알아보자.\n\n- 기본형\n\n```js\n// 매개변수가 없는 즉시 실행 함수\n(function(){\n    // 명령\n}());\n\n// 매개변수가 있는 즉시 실행 함수\n(function(매개변수){\n    // 명령\n}());\n```\n함수를 식형태로 선언하기 때문에 마지막에 세미콜론을 붙여줘야 한다.\n\n<br><br>\n\n- 기본형 즉시실행 함수\n\n```js\n(function(){\n\tlet userName = prompt(\"이름을 입력하세요\");\n\tdocument.write(\"안녕하세요 + userName + 님!\"\n}());\n```\n\n<br><br>\n\n- 매개변수가 있는 즉시 실행 함수\n\n\n```js\n(function(num1,num2){\t\t\t// 매개 변수 num1, num2\n\tsum = num1 + num2;\n}(100,200));\t\t\t\t// 인자 100,200 설정\n\ndocument.write(\"결과 : \" + sum);\t// 결과 : 300\n```\n\n<br><br><br><br>\n\n### 📌 화살표 함수\nES6 버전부터는 `=>` 화살표 표기법을 사용해 함수 선언을 간단하게 작성할 수 있다. 이는 **익명함수** 에서만 사용가능하다!\n\n- 기본형 : ```(매개변수) => { 함수 내용 }```\n\n<br><br>\n\n- 매개변수가 없는 함수\n\n```js\nconst hi = function() { return \"안녕하세요\"}\n```\n<br><br>\n\n- 매개변수가 없는 화살표 함수\n\n```js\nconst h1 = () => { return \"안녕하세요\" };\n```\n\n<br><br>\n\n- 매개변수가 없는 화살표 함수 ( 중괄호 생략가능 )\n\n```js\nconst h1 = () => return \"안녕하세요\";\n```\n\n<br><br>\n\n- 매개변수가 1개인 함수\n\n```js\nlet hi = function(user){\n\tdocument.write(user + \"님 안녕하세요\");\n}\n```\n\n<br><br>\n\n- 매개변수가 1개인 화살표 함수\n\n```js\nlet hi = (user) => { document.write(user+\"님 안녕하세요\");\n```\n\n<br><br>\n\n- 매개변수가 2개 이상인 화살표 함수\n\n```js\nlet sum = (a,b) => a+b;\n```\n\n<br><br><br><br>\n\n## ✅ 이벤트 ( Event )\n이벤트는 웹 브라우저나 사용자가 행하는 어떤 동작을 의미한다. 마우스나 키보드, 문서 로딩, form에 데이터 입력 등의 활동을 할때 이벤트가 주로 발생한다. 이벤트의 종류는 정말 많고 일일히 외울 필요는 없어보인다. 한번 쭉 표로 정리하면서 읽어보고 필요할 때마다 찾아보면 될것 같다.\n\n<br><br>\n\n### 📌 마우스 이벤트\n\n| 종류 | 설명 |\n|--|--|\n| click | 사용자가 HTML 요소를 클릭할 때 발생하는 이벤트 |\n| dbclick | 사용자가 HTML 요소를 더블클릭 할 때 발생하는 이벤트 |\n| mousedown | 사용자가 요소 위에서 마우스 버튼을 눌렀을 때 발생하는 이벤트 |\n| mousemove | 사용자가 요소 위에서 마우스 포인터를 움직일 때 발생하는 이벤트 |\n| mouseover | 마우스 포인터가 요소 위로 옮겨질 때 발생하는 이벤트 |\n| mouseout | 마우스 포인터가 요소를 벗어날 때 발생하는 이벤트 |\n| mouseup | 사용자가 요소 위에 놓인 마우스 버튼에서 손을 뗄 때 발생하는 이벤트 |\n\n<br><br>\n\n### 📌 키보드 이벤트\n\n|종류| 설명 |\n|--|--|\n| keydown | 사용자가 키를 누르는 동안 발생하는 이벤트 |\n| keypress | 사용자가 키를 눌렀을 때 발생하는 이벤트 |\n| keyup | 사용자가 키에서 손을 땔 때 발생하는 이벤트  |\n\n<br><br>\n\n### 📌 문서 로딩 이벤트\n\n|종류|설명|\n|--|--|\n|abort| 문서가 완전히 로딩되기 전에 불러오기를 멈췄을 때 발생하는 이벤트 |\n| error | 문서가 정확히 로딩되지 않았을 때 발생하는 이벤트 |\n| load | 문서 로딩이 끝나면 발생하는 이벤트 |\n| resize | 문서 화면 크기가 바뀌었을 때 발생하는 이벤트 |\n| scroll | 문서 화면이 스크롤 되었을 때 발생하는 이벤트 |\n| unload | 문서에서 벗어날 때 발생하는 이벤트 |\n\n<br><Br>\n\n### 📌 폼 이벤트\n\n| 종류 | 설명 |\n|--|--|\n| blur | 폼 요소에 포커스를 잃었을 때 발생하는 이벤트 |\n| change | 목록이나 체크 상태 등이 변경되면 발생하는 이벤트. `<input>`, `<select>`, `<textarea>` 태그에서 사용 |\n| focus | 폼 요소에 포커스가 놓였을 때 발생하는 이벤트. `<label>`, `<select>`, `<textarea>`, `<button>` 태그에서 사용 |\n| reset | 폼이 리셋되었을 때 발생하는 이벤트 |\n| submit | submit 버튼을 클릭했을 때 발생하는 이벤트 |\n\n<br><br><br><br>\n\n\n## ✅ 이벤트처리기 (EventHandler)\n\n### 📌 HTML태그를 이용한 이벤트 처리기\n\nJavaScript에는 상당히 많은 이벤트가 존재하고 이를 처리하는 함수를 이벤트처리기 혹은 이벤트핸들러 라고 부른다. 이벤트를 처리하는 가장 기본적인 방법은 HTML 태그에 이벤트 처리기를 직접 연결하는 것이다.\n\n- 기본형 : ```<태그 on이벤트명 = \"함수명\">```\n\n간단한 예제를 통해 더 알아보자. 버튼을 클릭하면 알림창을 표시하는 예제이다.\n```js\n<body>\n\t<ul>\n\t\t<li><a href=\"#\" onclick=\"alert('버튼을 클릭했습니다.')\">Green</a></li>\n\t\t<li><a href=\"#\" onclick=\"alert('버튼을 클릭했습니다.')\">Orange</a></li>\n\t\t<li><a href=\"#\" onclick=\"alert('버튼을 클릭했습니다.')\">Purple</a></li>\n\t</ul>\n</body>\n```\n\n<br>\n버튼을 클릭하면 배경색을 바꾸는 코드이다.\n\n```js\n<body>\n\t<ul>\n\t\t<li> <a href=\"#\" onclick=\"changeBg('green')Green</a></li>\n\t\t<li> <a href=\"#\" onclick=\"changeBg('orange')Orange</a></li>\n\t\t<li> <a href=\"#\" onclick=\"changeBg('purple')Purple</a></li>\n\t</ul>\n<div id=\"result\"></div>\n\n<script>\n\tfunction changeBg(color){\n\t\tvar result = document.querySelector('#result');\n\t\tresult.style.backgroundColor = color;\n\t}\n</script>\n</body>\n```\n\n<br><br>\n\n### 📌 DOM을 이용한 이벤트 처리기\nHTML태그를 이용하면 HTML이 주인이 되어 자바스크립트의 함수를 불러와 사용하낟. 그러나 DOM을 사용하면 자바스크립트가 주인이 되어 HTML의 요소를 가져와 이벤트 처리기를 연결 할 수 있다. \n\n- 기본형 : ```웹 요소.onclick = 함수;```\n\n자바스크립트에서는 다양한 방법으로 웹 요소를 가져올 수 있는데 그 중 `quertSelector()`를 사용하는게 가장 편하다. `()`안에는 id,class명, 선택자 등을 넣을 수 있다. 예제를 통해서 어떻게 이벤트 처리를 하는지 알아보자.\n\n```js\n<body>\n\t<button id=\"change\"> 글자색 바꾸기 </button>\n\t<p> 안녕하세요. 김테드 입니다. </p>\n\t\n\t(...생략...)\n\n\t// 방법 1 : 웹 요소를 변수로 지정 & 미리 만든 함수 사용\n\tlet changebttn = document.querySelector(\"#change\");\n\tchangebttn.onclick = changeColor;\n\n\t// 방법 2 : 웹 요소를 따로 변수로 만들지 않고 사용\n\tdocument.querySelector(\"#change\").onclick = changeColor;\n\n\tfunction changeColor(){\n\t\tdocument.querySelector(\"p\").style.color = \"#f00\";\n\n\t// 방법 3 : 함수를 직접 선언\n\tdocument.querySelector(\"#change\").onclick = function(){\n\t\tdocument.querySelector(\"p\").style.color = \"#f00\";\n\t};\n\n\t(...생략...)\n\t\n```\n\n<br><br>\n\n### 🔔 Document 객체\n\nDocument 객체는 웹 페이지 그 자체를 의미한다. 웹 페이지에 존재하는 HTML 요소에 접근하고자 할 때는 반드시 Document 객체부터 시작해야만 한다. 자세한 내용은 이후 자바스크립트 객체 관련 공부를 할 때 깊게 다뤄보자.\n\n<br><br>\n\n","properties":"\n","discussions":{},"comments":{},"hash":476150886}},"syncHistory":{"main":[476150886,476150886,null]},"v":1,"hash":1711352030926,"tx":12593},"eZPD4ts8Xo7mlluk/syncedContent":{"id":"eZPD4ts8Xo7mlluk/syncedContent","type":"syncedContent","historyData":{"-1951579964":{"id":"eZPD4ts8Xo7mlluk/content","type":"content","text":"## 폰트 바꾸기\n\nmain.scss 에 웹폰트 import 하고\nvariables.css 에 sans-serif태그에 글씨체 이름 추가하면 끝!\n\n\n## 개발자 도구 켜서 vscode로 검색하기\n\t\tctrl + shift + f로 클래스명 검색하기\n\n## 본문 및 사이드바 너비 설정\nvariables.scss에서\n $right-sidebar-width-narrow: 200px  !default;\n$right-sidebar-width: 300px  !default;\n$right-sidebar-width-wide: 400px  !default;\n\n얘네 수정하면됨\n\n## 로컬 접속\ncmd >> 블로그 폴더로 접근 >> bundle exec jekyll serve\n\n## 시작 페이지 수정\nindex.html 코드 추가\nrecent-posts.html 추가 -> 최근포스트 \nicon.html 추가 -> 아이콘 html\nhome.html에서 최근 포스트 기존에 있던거 삭제\n\n_sass/elements.scss 추가\n_sass/layout.scss 추가\n_sass/variavles.scss 추가\nassets/css/screen.scss 추가\nassets/css/terminal.css 추가\n\n\n\nindex.html에서 첫번째줄 layout : home 을 layout : newhome으로 변경하고 newhome.html을 _layouts 폴더에 추가함\n\n## 로고 이미지 추가\nmasthead.html 에서\n`<img  src=\"/assets/images/sitelogo.png\"  class=\"center\"> `\n코드 추가\n\n기존에 아래코드 있었음\n```\n<a  class=\"site-title\"  href=\"{{ '/' | relative_url }}\">\n\n {{ site.masthead_title | default: site.title }}\n\n{% if site.subtitle %}<span class=\"site-subtitle\">{{ site.subtitle }}</span>{% endif %}\n\n</a>\n```\n\n\n## 글씨 크기 조정\nbase.scss에서 글씨크기들 다양하게 조정가능\n","properties":"\n","discussions":{},"comments":{},"hash":-1951579964}},"syncHistory":{"main":[-1951579964,-1951579964,null]},"v":1,"hash":1711582441802,"tx":12614},"VLaa02Loo6VepSNT/content":{"id":"VLaa02Loo6VepSNT/content","type":"content","text":"---\npermalink: /2024-03-25-프로세스(Process)란?/\npublished: true\ntitle: \"[운영체제] 프로세스(Process)란?\"\ndate: 2024-03-25 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"프로세스(Process)란?\"\ncategories:\n- 운영체제\ntags:\n- 운영체제\n---\n\n<br><br>\n\n## ✅ 프로세스란?\n\n프로세스는 한마디로 **실행 중인 프로그램**이다.\n","properties":"\n","discussions":{},"comments":{},"hash":-533018811,"tx":12666},"VLaa02Loo6VepSNT/syncedContent":{"id":"VLaa02Loo6VepSNT/syncedContent","type":"syncedContent","historyData":{"-533018811":{"id":"VLaa02Loo6VepSNT/content","type":"content","text":"---\npermalink: /2024-03-25-프로세스(Process)란?/\npublished: true\ntitle: \"[운영체제] 프로세스(Process)란?\"\ndate: 2024-03-25 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"프로세스(Process)란?\"\ncategories:\n- 운영체제\ntags:\n- 운영체제\n---\n\n<br><br>\n\n## ✅ 프로세스란?\n\n프로세스는 한마디로 **실행 중인 프로그램**이다.\n","properties":"\n","discussions":{},"comments":{},"hash":-533018811}},"syncHistory":{"main":[-533018811,-533018811,null]},"v":1,"hash":1711600003441,"tx":12679},"UTqUor48bR0Yp1Bc":{"id":"UTqUor48bR0Yp1Bc","type":"folder","name":"정보처리기사","parentId":null,"hash":926160078,"tx":12680},"by4gQGx95Mp30v8Z":{"id":"by4gQGx95Mp30v8Z","type":"file","name":"2024-03-28-정보처리기사 실기 C언어편","parentId":"UTqUor48bR0Yp1Bc","hash":1860942447,"tx":12683},"fxktNjN7Qbqln352/contentState":{"id":"fxktNjN7Qbqln352/contentState","type":"contentState","selectionStart":268,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1711600088531,"tx":12687},"HImeteZ1A700ZipO/content":{"id":"HImeteZ1A700ZipO/content","type":"content","text":"<bR><BR>\n\n### 반올림\n```SQL\nSELECT ROUND(AVG(DAILY_FEE)) AS AVERAGE_FEE\nFROM CAR_RENTAL_COMPANY_CAR\nWHERE CAR_TYPE = 'SUV'\n```\n\n### COALESCE : NULL값 변환\n```SQL\nCOALESCE(A,B) -> A가 NULL이고 B가 NULL이 아닌경우 B반환\nCOALESCE(A,B) -> A가 NULL이 아니고 B가 NULL인 경우 A반환\nCOALESCE(TLNO,'NONE') -> TLNO가 NULL인 경우 NONE 반환\n\n```\n\n### DISTINCT : 중복값 제거 + NULL 제거 \n```SQL\n// 중복된 이름, NULL 제외하고 COUNT\nSELECT COUNT(DISTINCT(NAME)) FROM ANIMAL_INS\n\nSELECT DISTINCT(NAME) FROM ANIMAL_INS\n\n```\n\n### 날짜 차이 계산\n```SQL\n-- 코드를 입력하세요\nSELECT HISTORY_ID, CAR_ID, \nDATE_FORMAT(START_DATE,\"%Y-%m-%d\") AS START_DATE,\nDATE_FORMAT(END_DATE,\"%Y-%m-%d\") AS END_DATE,\nCASE\n    WHEN DATEDIFF(END_DATE,START_DATE)+1>=30 THEN \"장기 대여\"\n    ELSE \"단기 대여\" \nEND AS RENT_TYPE\nFROM CAR_RENTAL_COMPANY_RENTAL_HISTORY\nWHERE START_DATE LIKE \"2022-09-%\"\nORDER BY HISTORY_ID DESC\n```\n\n\n<BR>\n\n### 반올림\n\n`ROUND(반올림할 변수 OR 집계함수 , 반올림할 자릿수)`\n\n\n### 날짜 형식\n\n`TO_CHAR( DATE , 'YYYY-MM-DD' ) AS CREATED_DATE`\n\n\n### 대소문자 구분 없이 조회\n\n```SQL\nSELECT * \nFROM ANIMAL_INS\nWHERE UPPER(NAME) LIKE '%EL%'\n;\n```\n\n### 문자열 합치기\n```SQL\nADDRESS1 || ' ' || ADDRESS2 || ' ' ||  ADDRESS3 -> 서울특별시 강남구 사평대로344 \n```\n\n### 전화번호 사이에 - 붙이기\n```SQL\nSUBSTR(TLNO,1,3) || '-' || SUBSTR(TLNO,4,4) || '-' || SUBSTR(TLNO,7,4)\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-993301318,"tx":14284},"HImeteZ1A700ZipO/contentState":{"id":"HImeteZ1A700ZipO/contentState","type":"contentState","selectionStart":1199,"selectionEnd":1199,"scrollPosition":{"sectionIdx":3,"posInSection":0.7},"hash":1711688329757,"tx":14293},"HImeteZ1A700ZipO/syncedContent":{"id":"HImeteZ1A700ZipO/syncedContent","type":"syncedContent","historyData":{"-993301318":{"id":"HImeteZ1A700ZipO/content","type":"content","text":"<bR><BR>\n\n### 반올림\n```SQL\nSELECT ROUND(AVG(DAILY_FEE)) AS AVERAGE_FEE\nFROM CAR_RENTAL_COMPANY_CAR\nWHERE CAR_TYPE = 'SUV'\n```\n\n### COALESCE : NULL값 변환\n```SQL\nCOALESCE(A,B) -> A가 NULL이고 B가 NULL이 아닌경우 B반환\nCOALESCE(A,B) -> A가 NULL이 아니고 B가 NULL인 경우 A반환\nCOALESCE(TLNO,'NONE') -> TLNO가 NULL인 경우 NONE 반환\n\n```\n\n### DISTINCT : 중복값 제거 + NULL 제거 \n```SQL\n// 중복된 이름, NULL 제외하고 COUNT\nSELECT COUNT(DISTINCT(NAME)) FROM ANIMAL_INS\n\nSELECT DISTINCT(NAME) FROM ANIMAL_INS\n\n```\n\n### 날짜 차이 계산\n```SQL\n-- 코드를 입력하세요\nSELECT HISTORY_ID, CAR_ID, \nDATE_FORMAT(START_DATE,\"%Y-%m-%d\") AS START_DATE,\nDATE_FORMAT(END_DATE,\"%Y-%m-%d\") AS END_DATE,\nCASE\n    WHEN DATEDIFF(END_DATE,START_DATE)+1>=30 THEN \"장기 대여\"\n    ELSE \"단기 대여\" \nEND AS RENT_TYPE\nFROM CAR_RENTAL_COMPANY_RENTAL_HISTORY\nWHERE START_DATE LIKE \"2022-09-%\"\nORDER BY HISTORY_ID DESC\n```\n\n\n<BR>\n\n### 반올림\n\n`ROUND(반올림할 변수 OR 집계함수 , 반올림할 자릿수)`\n\n\n### 날짜 형식\n\n`TO_CHAR( DATE , 'YYYY-MM-DD' ) AS CREATED_DATE`\n\n\n### 대소문자 구분 없이 조회\n\n```SQL\nSELECT * \nFROM ANIMAL_INS\nWHERE UPPER(NAME) LIKE '%EL%'\n;\n```\n\n### 문자열 합치기\n```SQL\nADDRESS1 || ' ' || ADDRESS2 || ' ' ||  ADDRESS3 -> 서울특별시 강남구 사평대로344 \n```\n\n### 전화번호 사이에 - 붙이기\n```SQL\nSUBSTR(TLNO,1,3) || '-' || SUBSTR(TLNO,4,4) || '-' || SUBSTR(TLNO,7,4)\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-993301318}},"syncHistory":{"main":[-993301318,-993301318,null]},"v":1,"hash":1711688332524,"tx":14295},"jWIAbpACKd6mffUH/contentState":{"id":"jWIAbpACKd6mffUH/contentState","type":"contentState","selectionStart":235,"selectionEnd":235,"scrollPosition":{"sectionIdx":20,"posInSection":0.22171018945212492},"hash":1712130599773,"tx":14961},"rJtXtpzzHWYRjcMJ":{"id":"rJtXtpzzHWYRjcMJ","type":"file","name":"Git Conflict 처리","parentId":null,"hash":831223729,"tx":14968},"Q630m9jJvuuKh53I/contentState":{"id":"Q630m9jJvuuKh53I/contentState","type":"contentState","selectionStart":427,"selectionEnd":426,"scrollPosition":{"sectionIdx":59,"posInSection":0.20582120582120583},"hash":1712130644775,"tx":14973},"rJtXtpzzHWYRjcMJ/content":{"id":"rJtXtpzzHWYRjcMJ/content","type":"content","text":"# ✅ Git 기본 용어\n\n- 로컬 저장소 ( local repository ) : 내 PC에서 관리하는 git 저장소.\n- 원격 저장소 ( remote repository ) : 로컬 저장소를 업로드 하는 git 저장소.\n- Staging Area : 작업 폴더에서 작업한 변경 내용을 기록 하는 곳. \n\n##\n\n-  `origin` : 원격 저장소. \n- `master` : 브랜치 중 가장 중심이 되는 기본적인 브랜치\n- `HEAD` : 현재 본인이 위치한 작업 공간. 예를들어 master 브랜치에서 작업 중이라면 본인의 HEAD는 master 브랜치이고, 다른 작업을 위해 feature 브랜치를 생성하고 feature 브랜치에서 작업 중이라면 본인의 HEAD는 feature 브랜치이다.\n\n\n\n# ✅ Git Conflict 원인\n\n- 현재 newKERP는 master 브랜치에서 모든 작업을 일괄적으로 수행중.\n- 두명 이상의 인원이 같은 버전의 코드를 수정한 후 Push 하는 경우 충돌 발생\n\t- \n\t- ㄴㅇㅁㄴ\n- 최신버전의 코드를 pull받지 않고 코드를 수정한 뒤 push 하는 경우 충돌 발생\n\t- `origin/master` 의 코드와 local \n\n<br>\n\n\n\n\n\n**master 브랜치에 저장되어 있는 코드**\n\n\n\n\n\n# ✅ Git Conflict 해결방법\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1833545718,"tx":15777},"rJtXtpzzHWYRjcMJ/syncedContent":{"id":"rJtXtpzzHWYRjcMJ/syncedContent","type":"syncedContent","historyData":{"1833545718":{"id":"rJtXtpzzHWYRjcMJ/content","type":"content","text":"# ✅ Git 기본 용어\n\n- 로컬 저장소 ( local repository ) : 내 PC에서 관리하는 git 저장소.\n- 원격 저장소 ( remote repository ) : 로컬 저장소를 업로드 하는 git 저장소.\n- Staging Area : 작업 폴더에서 작업한 변경 내용을 기록 하는 곳. \n\n##\n\n-  `origin` : 원격 저장소. \n- `master` : 브랜치 중 가장 중심이 되는 기본적인 브랜치\n- `HEAD` : 현재 본인이 위치한 작업 공간. 예를들어 master 브랜치에서 작업 중이라면 본인의 HEAD는 master 브랜치이고, 다른 작업을 위해 feature 브랜치를 생성하고 feature 브랜치에서 작업 중이라면 본인의 HEAD는 feature 브랜치이다.\n\n\n\n# ✅ Git Conflict 원인\n\n- 현재 newKERP는 master 브랜치에서 모든 작업을 일괄적으로 수행중.\n- 두명 이상의 인원이 같은 버전의 코드를 수정한 후 Push 하는 경우 충돌 발생\n\t- \n\t- ㄴㅇㅁㄴ\n- 최신버전의 코드를 pull받지 않고 코드를 수정한 뒤 push 하는 경우 충돌 발생\n\t- `origin/master` 의 코드와 local \n\n<br>\n\n\n\n\n\n**master 브랜치에 저장되어 있는 코드**\n\n\n\n\n\n# ✅ Git Conflict 해결방법\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1833545718}},"syncHistory":{"main":[1833545718,1833545718,null]},"v":1,"hash":1712208835493,"tx":15801},"Fhx75tVk2bMRrChl/syncedContent":{"id":"Fhx75tVk2bMRrChl/syncedContent","type":"syncedContent","historyData":{"-1804965264":{"id":"Fhx75tVk2bMRrChl/content","type":"content","text":"---\npermalink: /2022-08-22-아파치(Apache)와 톰캣(Tomcat)/\npublished: true\ntitle: \"[Web & Server] 웹서버와 WAS (feat. 아파치 톰캣)\"\ndate: 2022-08-22 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"웹서버와 WAS (feat. 아파치 톰캣)\"\ncategories:\n- Web & Server\ntags:\n- Apache\n- Tomcat\n- WAS\n- Web 서버\n- 개발상식\n- Server\n- Web\n---\n<br><br><br>\n\n오늘은 **아파치와 톰캣**이 무엇인지, 그 차이점은 뭐가있는지, 그리고 아파치가 속해있는 **Web 서버**와 톰캣이 속해있는 **WAS(Web Application Server)** 에 대해 알아보자.\n\n<br><br><br>\n\n## ✅ 아파치 톰캣 (Apache Tomcat)\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/apache1.png?raw=true\">\n</p>\n스프링 뿐만 아니라 웹개발을 공부하는 사람이라면 **아파치 톰캣(Apache Tomcat)** 이라는 서버를 많이 들어봤을 것이다. 우리가 사용하는 많은 웹페이지는 아파치 톰캣을 서버로 사용하고, 세계에서 가장 많이 사용중인 WAS중 하나이다. \n\n**정적페이지를 처리하는 아파치(Web Server)** 와 **동적 페이지를 처리하는 톰캣 (WAS)** 이 합쳐진 구조로 각각의 기능을 일부 가져와서 제공하는 형태이기 때문에 합쳐서 부른다. **아파치, 톰캣**과 함께 **웹서버**와 **WAS**에 대해 알아보자.\n\n<br><br><br>\n\n## ✅ Web 서버\nWeb서버는 보통 **HTTP 서버**를 의미한다. HTTP 서버는 **URL(웹주소)** 및 **HTTP(프로토콜 주소)** 를 이해하는 소프트웨어 이다. HTTP 서버는 저장하는 웹 사이트의 **도메인 이름**을 통해 액세스 할 수 있으며 호스팅 된 웹 사이트의 콘텐츠를 사용자의 장치로 전달한다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet2.png?raw=true\">\n</p>\n\n브라우저에 Web 서버에서 호스팅되는 파일이 필요할 때마다 브라우저는 **HTTP**를 통해 파일을 요청한다. 요청이 올바른 Web 서버에 도달하면 HTTP서버가 요청을 수락하고 요청된 문서를 찾은 다음 HTTP를 통해 브라우저로 다시 보낸다. ( 이때, 요청된 문서를 찾지 못하면 우리가 많이 접해본 **'404 Not Found'** 를 반환한다! )\n\n<br><br>\n\n이러한 Web 서버는 **정적인 자료**를 처리하는 서버이다. **HTML, CSS, IMAGE** 등의 정적인 파일들을 **서버에 저장하고, 요청이 들어올때 마다 서버에 저장된 파일을 사용자에게 HTML파일로 뿌려주기 때문에** **서버 자원의 한계가 생기고 리소스를 많이 차지하게 되는 단점**이 있다! 이를 보완하기 위해 생긴 것이 바로 **동적으로 파일을 처리하는 WAS 서버** 이다..!\n\n<br><br>\n### 📌 Web 서버 예시\n- Apache 재단의 Apache\n- Microsoft사의 IIS, NGINX\n- Google Web Server\n- Node.js ( 자체 웹 서버 내장 )\n\n<br><br><br>\n\n## ✅ 아파치 (Apache)\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/apache2.png?raw=true\">\n</p>\n결국 **아파치 서버**는 클라이언트에서 요청한 **HTTP Request**를 처리하는 **웹서버** 이다. 아파치는 **정적 타입 (HTML, CSS, IMAGE)** 의 데이터만을 처리 한다!\n\n<br><br><br>\n\n\n\n## ✅ WAS (Web Application Server) 서버\nWAS 서버는 **동적인 자료**를 처리하는 서버이다. 기존 WEB서버는 정적 데이터만 처리가 가능하기때문에, 요청이 들어올때마다 HTML페이지, 이미지 등을 계속 응답해줘야 하고 이는 리소스의 낭비를 일으킨다. 때문에 이러한 단점을 커버하기 위해 WAS라는 서버를 만들었다. \n\n<BR>\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet3.png?raw=true\">\n</p>\n\nWAS는 **웹서버 + 서블릿 컨테이너 ( 웹 컨테이너 )** 로 구성되어 있다.  클라이언트에서 HTTP Request를 보내면 먼저 웹서버를 통해 정적데이터 처리만 필요한 요청인지 확인한다. 이후 정적 데이터 처리만 필요하다면 그대로 웹서버에서 요청에 대한 응답을 다시 클라이언트로 보내준다.\n\n그러나 동적데이터 처리가 필요한 요청이라면 이를 서블릿 컨테이너(웹컨테이너) 에 넘겨준다. 서블릿 컨테이너는 요청정보를 파악하여 실시간으로 페이지에 필요한 파일을 생성한다. 요청이 올 때마다 페이지에 필요한 정보를 그때그때 생성하므로 서버의 리소스의 부하를 줄일 수 있다는 장점이 있다.\n\n<br><br>\n### 📌 WAS 예시\n- Tomcat\n- JBoss\n- Jeus\n\n<br><br>\n\n## ✅ 톰캣(Tomcat)\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tomcat1.png?raw=true\">\n</p>\n톰캣은 **동적인 웹을 만들기 위한 웹 컨테이너** ,  **JSP와 Servlet을 구동하기 위한 서블릿 컨테이너** 역할을 수행한다. 한마디로 정적페이지를 제외한 JSP, ASP, PHP 등은 톰캣에서 처리한다. 또한 **DB연결, 데이터 조작, 다른 응용 프로그램과 상호작용**이 가능하다.\n\n<br><br><br>\n\n\n\n## ✅ 웹서버와 WAS의 구조\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/apa1.png?raw=true\">\n</p>\n<br>\n\n- 사용자 (Client)가 HTTP Request를 던졌을 때 필요한 데이터가 **정적데이터** 라면 **Web 서버(Apache)** 에서는 바로 **HTTP Response**를 통해 **정적 HTML을 반환**하고 **동적 데이터**라면 이를 **Web Container(Servlet Container)** 로 보내 동적 데이터 처리를 한 뒤 Web 서버를 통해 사용자에게 반환한다.\n\n- 기본적으로 아파치와 톰캣의 기능은 나뉘어져 있지만, 톰캣 안의 컨테이너를 통해 일부 아파치 기능을 발휘하기 때문에 아파치톰캣 이라고 합쳐서 부른다.\n\n- 아파치만 쓰면 정적 웹페이지만 처리가 가능하다\n\n- 톰캣만 쓰면 정적 웹페이지 + 동적 웹페이지 처리가 모두 가능하지만, 아파치에서 필요한 기능을 가져올 수 없고, 과부하가 걸릴 가능성이 높다.\n\n- 따라서 **아파치와 톰캣을 같이 사용하여 아파치는 정적 데이터 처리, 톰캣은 JSP, ASP, PHP 등 동적 데이터 처리를 분담한다.**\n\n- 그리고 이러한 서블릿 컨테이너는 **MVC 패턴에서 Controller**에 주로 사용된다.\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-1804965264}},"syncHistory":{"main":[-1804965264,-1804965264,null]},"v":1,"hash":1712560385718,"tx":15826},"Rkbhu5EBtxTalmMn":{"id":"Rkbhu5EBtxTalmMn","type":"file","name":"2024-03-28-정보처리기사 실기 Python 모음","parentId":"UTqUor48bR0Yp1Bc","hash":-1796259372,"tx":16284},"8IFmCnOfvma2Povc":{"id":"8IFmCnOfvma2Povc","type":"file","name":"2024-03-28-정보처리기사 실기 Java 모음","parentId":"UTqUor48bR0Yp1Bc","hash":677307406,"tx":17251},"by4gQGx95Mp30v8Z/syncedContent":{"id":"by4gQGx95Mp30v8Z/syncedContent","type":"syncedContent","historyData":{"538047454":{"id":"by4gQGx95Mp30v8Z/content","type":"content","text":"---\npermalink: /2024-03-28-정보처리기사 실기 C언어 모음/\npublished: true\ntitle: \"[정처기] 정보처리기사 실기 C언어 문제 모음\"\ndate: 2024-03-28 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"정보처리기사 실기 C언어 문제 모음\"\ncategories:\n- Spring\ntags:\n- Spring\n---\n\n<br><br>\n\n\n## ✅ 정보처리기사 C언어 문제 모음\n\n####  📌 다음은 C 언어 코드이다. 알맞는 출력 결과를 작성하시오. ( 23년 3회 ) \n<br>\n\n```c\n#include <stdio.h>\n\nint test(int n) {\n    int i, sum = 0;\n    \n    for (i = 1; i <= n / 2; i++){\n        if (n % i == 0)\n        sum += i;\n    }\n\n    if (n == sum) \n        return 1;\n   \n    return 0;\n}\n\nint main(){\n    int i, sum=0;\n    \n    for (i = 2; i <= 100; i++){ \n        if (test(i))\n        sum += i;\n    }\n\n    printf(\"%d \", sum); \n    return 0;\n\n}\n```\n<br>\n\n> 정답 : 34\n\n숫자를 일일히 넣어서 무슨 함수인지 확인해보면 **자기 자신을 제외한 약수의 합**이 **자기자신**과 같은 \"완전수\"를 찾는 문제이다. 범위는 2부터 100까지 이므로 완전수인 6, 28의 합인 34가 정답이다. `6 = 1+2+3` , `28 = 1+2+4+7+14 ` \n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 C언어에서 구조체의 멤버에 접근하기 위해 괄호안의 '기호'를 작성하시오. ( 23년 3회 )\n<br>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n \ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\n \nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    \n    d1.numPtr = &num;  \n    d2 ( ) numPtr = &num; \n \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);\n \n    free(d2); \n    return 0;\n}\n\n\n[ 출력 결과 ] \n10\n10\n```\n\n<br>\n\n> 정답 : ->\n\nC언어에서 구조체 포인터에 접근하기 위한 기호는 -> 이다.\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음 C언어 코드에 알맞는 출력값을 작성하시오. ( 23년 3회 ) \n<br>\n\n```c\n#include\n \nint f(int n) {\n    if(n<=1) return 1;\n    else return n*f(n-1);\n}\n \nint main() {\n    printf(\"%d\", f(7));\n}\n```\n\n<br>\n\n> 정답 : 5040\n\n함수를 해석해보면 1x2x3x4x5x6x7 을 의미한다.\n\n<br><br><br><br><br><br>\n\n\n####  📌다음은 C언어의 포인터 문제이다. 알맞는 출력값을 작성하시오. ( 23년 3회 )\n<br>\n\n \n```c\n#include\n \nint main() {\n    char* p = \"KOREA\";\n    printf(\"%s \", p);\n    printf(\"%s \", p+1);\n    printf(\"%c \", *p);\n    printf(\"%c \", *(p+3));\n    printf(\"%c \", *p+4);\n}\n```\n\n<br>\n\n> 정답 :\n\t> KOREA\n\t> OREA\n\t> K\n\t> E\n\t> O\n\n포인터는 주소값을 의미한다는 사실만 알고있으면 쉽게 풀 수 있다.\n그리고 `*p`가 의미하는것이 `p의 주소값을 참조한다` 즉 `p의 주소값을 통해 실제값(여기서는 문자)을 가진다` 라고 생각하면 문제를 풀기 쉽다.\n일단 p는 포인터 문자로 선언되어 있으므로 K의 주소값을 가진다.\n\n첫번째 `printf(\"%s \", p);`는 p가 나타내는 문자열 `KOREA` 를 출력한다.\n두번째 `printf(\"%s \", p+1);`은 p의 바로 다음 주소인 O부터 `KOREA`를 출력한다.\n세번째 `printf(\"%c \", *p);`는 p를 참조한다. 즉 p의 실제값인 `K`를 출력한다.\n네번째 `printf(\"%c \", *(p+3));`은 p+3의 주소값을 참조한다. 즉 `E`를 출력한다.\n마지막 `printf(\"%c \", *p+4);`는 p를 참조하고 아스키값 4를 더한다. 즉 K+4=`O`를 출력한다\n\n<br><br><br><br><br><br>\n\n####  📌다음은 C언어 코드의 문제이다. 다음의 조건에 맞도록 빈 괄호 안에 알맞은 코드를 작성하시오. ( 23년 2회 )\n\n`조건 : 입력값이 54321일 경우 출력값이 43215로 출력되어야 한다. `\n\n<br>\n\n```c\nint main(void) {\n \n    int n[5];\n    int i;\n \n    for (i = 0; i < 5; i++) {\n        printf(\"숫자를 입력해주세요 : \");\n        scanf(\"%d\", &n[i]);\n    }\n \n    for (i = 0; i < 5; i++) {\n        printf(\"%d\", (            ) );\n    }\n \n  return 0;\n \n}\n```\n<br>\n\n> 정답 : `n[(i+1)%5]`\n\n뭐 딱히 해설할게 없다. 그냥 첫번째 입력한걸 마지막에 출력되게 작성하면 된다. \n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 c언어의 코드이다. 보기의 조건에 맞추어 알맞은 출력값을 작성하시오. ( 23년 2회 )\n` 입력값은 홍길동, 김철수, 박영희 순서로 주어진다. `\n\n<br>\n\n```c\n#include<stdlio.h> \n#include<stdlib.h> \n\nchar n[30];\nchar* test() {\n    printf(입력하세요 : );\n    gets(n);\n    return n;\n}\n \nint main()\n \n{\n    char* test1;\n    char* test2;\n    char* test3;\n \n    test1 = test();\n    test2 = test();\n    test3 = test();\n \n    printf(%s\\n,test1);\n    printf(%s\\n,test2);\n    printf(%s,test3);\n}\n```\n\n<br>\n\n> 정답 :  \n>\t박영희  \n>\t박영희  \n>\t박영희   \n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 c언어의 코드이다. 알맞은 출력값을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\nint n[3] = [73, 95, 82] \nint sum = 0 \n \nfor(i=0;i<3;i++){\n    sum += n[i];\n}\n \nswitch(sum/30){\n    case 10:\n    case 9: printf(\"A\");\n    case 8: printf(\"B\");\n    case 7: \n    case 6: printf(\"C\");\n    default: printf(\"D\");\n}\n```\n\n<br>\n\n> 정답 : BCD\n\n먼저 for문을 통해 `sum = n[0]+n[1]+n[2]` 가 되므로 `sum = 250` 이 된다.\n따라서 switch(sum/30)은 switch(250/3), 즉 `switch(8)` 이 실행된다.\n근데 주의할점은 switch문의 각 case마다 **break가 걸려있지 않다는 점**이다.\n때문에 `case8` 을 수행한뒤 `case7`, `case6`,`default` 까지 실행될 것이다.\n따라서 정답은 BCD 이다.\n\n\n<br><br><br><br><br><br>\n\n####  📌다음 소스코드의 알맞은 출력을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n \n    int c = 0;\n \n    for(int i = 1; i <=2023; i++) { \n\t\tif(i%4 == 0) c++; \n    }\n    printf(\"%d\", c);\n}\n```\n\n<br>\n\n> 정답 : 505\n\nfor문의 i는 1~2023까지 돌고, i가 4의배수일때 c++ 하므로 c는 505번 1 증가한다.\n따라서 정답은 505\n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 C언어 문제이다. 알맞은 출력값을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\n#include <stdio.h>\n#define MAX_SIZE 10\n \nint isWhat[MAX_SIZE];\nint point= -1; \n \nvoid into(int num) {\n    if (point >= 10) printf(\"Full\");\n    isWhat[++point] = num;\n}\n \nint take() {\n    if (isEmpty() == 1) printf(\"Empty\");\n    return isWhat[point--];\n}\n \nint isEmpty() {\n    if (point == -1) return 1;\n    return 0;\n}\n \nint isFull() {\n    if (point == 10) return 1;\n    return 0;\n}\n \nint main(int argc, char const *argv[]){\n    int e;\n    into(5);\n    into(2);\n    while(!isEmpty()){\n        printf(\"%d\", take());\n        into(4); into(1); printf(\"%d\", take()); \n        into(3); printf(\"%d\", take()); printf(\"%d\", take()); \n        into(6); printf(\"%d\", take()); printf(\"%d\", take()); \n    }\n    return 0;\n}\n```\n\n<br>\n\n> 정답 : 213465\n\nc언어로 stack을 구현한 코드라고 보면 된다. 일반적으로 알고있는 stack의 push,pop,isEmpty, isFull을 생각하면 된다.\n\n<br><br><br><br><br><br>\n\n####  📌다음 코드는 선택정렬 구현에 관한 문제이다.  빈칸에 알맞는 연산자를 보기에서 골라 작성하시오. ( 23년 2회 )\n<br>\n\n```c\n#include\nint main() {\n    int E[] = {64, 25, 12, 22, 11};\n    int n = sizeof(E) / sizeof(E[0]);\n    int i = 0;\n    do {\n        int j = i + 1;\n        do {\n            if (E[i] (     ) E[j]) {\n                int tmp = E[i];\n                E[i] = E[j];\n                E[j] = tmp;\n            }\n            j++;\n        } while (j < n);\n        i++;\n    } while (i < n-1);\n    for(int i=0; i<=4; i++)\n        printf(\"%d \", E[i]);\n}\n```\n\n<br>\n\n> 정답 : >\n\n그냥 직관적으로도 풀수있는 문제.\n\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 C언어의 출력값을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n    char a[] = \"Art\";\n    char* p = NULL;\n    p = a;\n \n    printf(\"%s\\n\", a);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *a);\n    printf(\"%s\\n\", p);\n \n    for(int i = 0; a[i] != '\\0'; i++)\n    printf(\"%c\", a[i]);\n \n}\n\n```\n\n<br>\n\n> 정답 : \nArt\nA\nA\nArt\nArt\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 C언어의 출력값을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n \n    char* a = \"qwer\";\n    char* b = \"qwtety\";\n \n    for(int i = 0; a[i] != '\\0' ; i++){\n        for(int j = 0; b[j] != '\\0'; j++){\n            if(a[i] == b[j]) printf(\"%c\", a[i]);\n        }\n    }\n \n}\n```\n\n<br>\n\n> 정답 : qwe\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 아래 코드에서 이진수를 십진수로 변환하는 코드에 대해 괄호 (a) (b)의 적합한 답을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main() {\n \n    int input = 101110;\n    int di = 1;\n    int sum = 0;\n \n    while (1) {\n \n        if (input == 0) break\n        else {\n \n          sum = sum + (input (a)(b)) * di;\n             di = di * 2;\n             input = input / 10;\n \n        }\n    }\n \n    printf(\"%d\", sum);\n \n    return 0;\n}\n```\n<br>\n\n> 정답 : (a) %, (b) 10 or 5 or 2\n\n","properties":"\n","discussions":{},"comments":{},"hash":538047454},"-1996615672":{"id":"by4gQGx95Mp30v8Z/content","type":"content","text":"---\npermalink: /2024-03-28-정보처리기사 실기 C언어 모음/\npublished: true\ntitle: \"[정처기] 정보처리기사 실기 C언어 모음\"\ndate: 2024-03-28 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"정보처리기사 실기 C언어 모음\"\ncategories:\n- Spring\ntags:\n- Spring\n---\n\n<br><br>\n\n\n## ✅ 정보처리기사 C언어 문제 모음\n\n####  📌 다음은 C 언어 코드이다. 알맞는 출력 결과를 작성하시오. ( 23년 3회 ) \n<br>\n\n```c\n#include <stdio.h>\n\nint test(int n) {\n    int i, sum = 0;\n    \n    for (i = 1; i <= n / 2; i++){\n        if (n % i == 0)\n        sum += i;\n    }\n\n    if (n == sum) \n        return 1;\n   \n    return 0;\n}\n\nint main(){\n    int i, sum=0;\n    \n    for (i = 2; i <= 100; i++){ \n        if (test(i))\n        sum += i;\n    }\n\n    printf(\"%d \", sum); \n    return 0;\n\n}\n```\n<br>\n\n> 정답 : 34\n\n숫자를 일일히 넣어서 무슨 함수인지 확인해보면 **자기 자신을 제외한 약수의 합**이 **자기자신**과 같은 \"완전수\"를 찾는 문제이다. 범위는 2부터 100까지 이므로 완전수인 6, 28의 합인 34가 정답이다. `6 = 1+2+3` , `28 = 1+2+4+7+14 ` \n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 C언어에서 구조체의 멤버에 접근하기 위해 괄호안의 '기호'를 작성하시오. ( 23년 3회 )\n<br>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n \ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\n \nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    \n    d1.numPtr = &num;  \n    d2 ( ) numPtr = &num; \n \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);\n \n    free(d2); \n    return 0;\n}\n\n\n[ 출력 결과 ] \n10\n10\n```\n\n<br>\n\n> 정답 : ->\n\nC언어에서 구조체 포인터에 접근하기 위한 기호는 -> 이다.\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음 C언어 코드에 알맞는 출력값을 작성하시오. ( 23년 3회 ) \n<br>\n\n```c\n#include\n \nint f(int n) {\n    if(n<=1) return 1;\n    else return n*f(n-1);\n}\n \nint main() {\n    printf(\"%d\", f(7));\n}\n```\n\n<br>\n\n> 정답 : 5040\n\n함수를 해석해보면 1x2x3x4x5x6x7 을 의미한다.\n\n<br><br><br><br><br><br>\n\n\n####  📌다음은 C언어의 포인터 문제이다. 알맞는 출력값을 작성하시오. ( 23년 3회 )\n<br>\n\n \n```c\n#include\n \nint main() {\n    char* p = \"KOREA\";\n    printf(\"%s \", p);\n    printf(\"%s \", p+1);\n    printf(\"%c \", *p);\n    printf(\"%c \", *(p+3));\n    printf(\"%c \", *p+4);\n}\n```\n\n<br>\n\n> 정답 :\n\t> KOREA\n\t> OREA\n\t> K\n\t> E\n\t> O\n\n포인터는 주소값을 의미한다는 사실만 알고있으면 쉽게 풀 수 있다.\n그리고 `*p`가 의미하는것이 `p의 주소값을 참조한다` 즉 `p의 주소값을 통해 실제값(여기서는 문자)을 가진다` 라고 생각하면 문제를 풀기 쉽다.\n일단 p는 포인터 문자로 선언되어 있으므로 K의 주소값을 가진다.\n\n첫번째 `printf(\"%s \", p);`는 p가 나타내는 문자열 `KOREA` 를 출력한다.\n두번째 `printf(\"%s \", p+1);`은 p의 바로 다음 주소인 O부터 `KOREA`를 출력한다.\n세번째 `printf(\"%c \", *p);`는 p를 참조한다. 즉 p의 실제값인 `K`를 출력한다.\n네번째 `printf(\"%c \", *(p+3));`은 p+3의 주소값을 참조한다. 즉 `E`를 출력한다.\n마지막 `printf(\"%c \", *p+4);`는 p를 참조하고 아스키값 4를 더한다. 즉 K+4=`O`를 출력한다\n\n<br><br><br><br><br><br>\n\n####  📌다음은 C언어 코드의 문제이다. 다음의 조건에 맞도록 빈 괄호 안에 알맞은 코드를 작성하시오. ( 23년 2회 )\n\n`조건 : 입력값이 54321일 경우 출력값이 43215로 출력되어야 한다. `\n\n<br>\n\n```c\nint main(void) {\n \n    int n[5];\n    int i;\n \n    for (i = 0; i < 5; i++) {\n        printf(\"숫자를 입력해주세요 : \");\n        scanf(\"%d\", &n[i]);\n    }\n \n    for (i = 0; i < 5; i++) {\n        printf(\"%d\", (            ) );\n    }\n \n  return 0;\n \n}\n```\n<br>\n\n> 정답 : `n[(i+1)%5]`\n\n뭐 딱히 해설할게 없다. 그냥 첫번째 입력한걸 마지막에 출력되게 작성하면 된다. \n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 c언어의 코드이다. 보기의 조건에 맞추어 알맞은 출력값을 작성하시오. ( 23년 2회 )\n` 입력값은 홍길동, 김철수, 박영희 순서로 주어진다. `\n\n<br>\n\n```c\n#include<stdlio.h> \n#include<stdlib.h> \n\nchar n[30];\nchar* test() {\n    printf(입력하세요 : );\n    gets(n);\n    return n;\n}\n \nint main()\n \n{\n    char* test1;\n    char* test2;\n    char* test3;\n \n    test1 = test();\n    test2 = test();\n    test3 = test();\n \n    printf(%s\\n,test1);\n    printf(%s\\n,test2);\n    printf(%s,test3);\n}\n```\n\n<br>\n\n> 정답 :  \n>\t박영희  \n>\t박영희  \n>\t박영희   \n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 c언어의 코드이다. 알맞은 출력값을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\nint n[3] = [73, 95, 82] \nint sum = 0 \n \nfor(i=0;i<3;i++){\n    sum += n[i];\n}\n \nswitch(sum/30){\n    case 10:\n    case 9: printf(\"A\");\n    case 8: printf(\"B\");\n    case 7: \n    case 6: printf(\"C\");\n    default: printf(\"D\");\n}\n```\n\n<br>\n\n> 정답 : BCD\n\n먼저 for문을 통해 `sum = n[0]+n[1]+n[2]` 가 되므로 `sum = 250` 이 된다.\n따라서 switch(sum/30)은 switch(250/3), 즉 `switch(8)` 이 실행된다.\n근데 주의할점은 switch문의 각 case마다 **break가 걸려있지 않다는 점**이다.\n때문에 `case8` 을 수행한뒤 `case7`, `case6`,`default` 까지 실행될 것이다.\n따라서 정답은 BCD 이다.\n\n\n<br><br><br><br><br><br>\n\n####  📌다음 소스코드의 알맞은 출력을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n \n    int c = 0;\n \n    for(int i = 1; i <=2023; i++) { \n\t\tif(i%4 == 0) c++; \n    }\n    printf(\"%d\", c);\n}\n```\n\n<br>\n\n> 정답 : 505\n\nfor문의 i는 1~2023까지 돌고, i가 4의배수일때 c++ 하므로 c는 505번 1 증가한다.\n따라서 정답은 505\n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 C언어 문제이다. 알맞은 출력값을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\n#include <stdio.h>\n#define MAX_SIZE 10\n \nint isWhat[MAX_SIZE];\nint point= -1; \n \nvoid into(int num) {\n    if (point >= 10) printf(\"Full\");\n    isWhat[++point] = num;\n}\n \nint take() {\n    if (isEmpty() == 1) printf(\"Empty\");\n    return isWhat[point--];\n}\n \nint isEmpty() {\n    if (point == -1) return 1;\n    return 0;\n}\n \nint isFull() {\n    if (point == 10) return 1;\n    return 0;\n}\n \nint main(int argc, char const *argv[]){\n    int e;\n    into(5);\n    into(2);\n    while(!isEmpty()){\n        printf(\"%d\", take());\n        into(4); into(1); printf(\"%d\", take()); \n        into(3); printf(\"%d\", take()); printf(\"%d\", take()); \n        into(6); printf(\"%d\", take()); printf(\"%d\", take()); \n    }\n    return 0;\n}\n```\n\n<br>\n\n> 정답 : 213465\n\nc언어로 stack을 구현한 코드라고 보면 된다. 일반적으로 알고있는 stack의 push,pop,isEmpty, isFull을 생각하면 된다.\n\n<br><br><br><br><br><br>\n\n####  📌다음 코드는 선택정렬 구현에 관한 문제이다.  빈칸에 알맞는 연산자를 보기에서 골라 작성하시오. ( 23년 2회 )\n<br>\n\n```c\n#include\nint main() {\n    int E[] = {64, 25, 12, 22, 11};\n    int n = sizeof(E) / sizeof(E[0]);\n    int i = 0;\n    do {\n        int j = i + 1;\n        do {\n            if (E[i] (     ) E[j]) {\n                int tmp = E[i];\n                E[i] = E[j];\n                E[j] = tmp;\n            }\n            j++;\n        } while (j < n);\n        i++;\n    } while (i < n-1);\n    for(int i=0; i<=4; i++)\n        printf(\"%d \", E[i]);\n}\n```\n\n<br>\n\n> 정답 : >\n\n그냥 직관적으로도 풀수있는 문제.\n\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 C언어의 출력값을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n    char a[] = \"Art\";\n    char* p = NULL;\n    p = a;\n \n    printf(\"%s\\n\", a);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *a);\n    printf(\"%s\\n\", p);\n \n    for(int i = 0; a[i] != '\\0'; i++)\n    printf(\"%c\", a[i]);\n \n}\n\n```\n\n<br>\n\n> 정답 : \nArt\nA\nA\nArt\nArt\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 C언어의 출력값을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n \n    char* a = \"qwer\";\n    char* b = \"qwtety\";\n \n    for(int i = 0; a[i] != '\\0' ; i++){\n        for(int j = 0; b[j] != '\\0'; j++){\n            if(a[i] == b[j]) printf(\"%c\", a[i]);\n        }\n    }\n \n}\n```\n\n<br>\n\n> 정답 : qwe\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 아래 코드에서 이진수를 십진수로 변환하는 코드에 대해 괄호 (a) (b)의 적합한 답을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main() {\n \n    int input = 101110;\n    int di = 1;\n    int sum = 0;\n \n    while (1) {\n \n        if (input == 0) break\n        else {\n \n          sum = sum + (input (a)(b)) * di;\n             di = di * 2;\n             input = input / 10;\n \n        }\n    }\n \n    printf(\"%d\", sum);\n \n    return 0;\n}\n```\n<br>\n\n> 정답 : (a) %, (b) 10 or 5 or 2\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1996615672}},"syncHistory":{"main":[538047454,-1996615672,538047454]},"v":1,"hash":1712795901442,"tx":19502},"Rkbhu5EBtxTalmMn/syncedContent":{"id":"Rkbhu5EBtxTalmMn/syncedContent","type":"syncedContent","historyData":{"-1626526681":{"id":"Rkbhu5EBtxTalmMn/content","type":"content","text":"---\npermalink: /2024-03-28-정보처리기사 실기 Python 모음/\npublished: true\ntitle: \"[정처기] 정보처리기사 실기 Python 모음\"\ndate: 2024-03-28 10:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"정보처리기사 실기 Python 모음\"\ncategories:\n- Spring\ntags:\n- Spring\n---\n\n<br><br>\n\n\n## ✅ 정보처리기사 Python 문제 모음\n\n**📌 다음 파이썬 코드에서 알맞는 출력값을 작성하시오.( 23년 2회 )** \n\n<br>\n\n```python\na = \"engineer information processing\"\nb = a[:3]\nc = a[4:6]\nd = a[28:]\ne=b+c+d\nprint(e)\n```\n<br>\n\n> 정답 : engneing\n\n\n\n파이썬 Slice 개념을 알고있으면 쉽게 풀릴 문제다.\n```python\nitems = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nitems[2:5] # 인텍스 2에서 인덱스 5까지(인덱스 5는 제외) 슬라이싱 \n# [2, 3, 4]\n\nitems[5:] # 인덱스 5에서 끝까지 슬라이싱\n# [5, 6, 7, 8, 9, 10]\n\nitems[:3] # 처음부터 인덱스 3까지(인덱스 3은 제외) 슬라이싱 \n# [0, 1, 2]\n\nitems[:] # 처음부터 끝까지 슬라이싱(즉, 리스트 복사본 반환)\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nitems[2:9:3] # 인덱스 2에서 인텍스 9까지(인덱스 9는 제외) 3칸씩 점프 \n# [2, 5, 8]\n\nitems[:10:2] # 처음부터 인텍스 10까지(인덱스 10은 제외) 2칸씩 점프\n# [0, 2, 4, 6, 8]\n\nitems[2::2] # 인덱스 2에서 끝까지 2칸씩 점프\n# [2, 4, 6, 8, 10]\n\nitems[::3] # 전체 리스트에 대해서 3칸씩 점프\n# [0, 3, 6, 9]\n\nitems[10:0:-3] # 인텍스 10에서 0까지(인덱스 0은 제외) 역순으로 슬라이싱\n# [10, 7, 4, 1]\n\nitems[5:1:-1] # 인덱스 5에서 1까지(인텍스 1은 제외) 역순으로 슬라이싱\n# [5, 4, 3, 2]\n\nitems[1::-1] # 인덱스 1에서 끝까지 역순으로 슬라이싱\n# [1, 0]\n\nitems[1:10:-1] # 인텍스 1에서 인덱스 10까지(인덱스 10인 제외) 역순으로 슬라이싱, 하지만 슬라이싱 못하므로 빈 리스트 반환\n# []\n\nitems[:-3:-1] # 리스트 끝에서 3번째 인덱스까지(인덱스 -3은 제외) 역순으로 슬라이싱\n# [10, 9]\n\nitems[0:-3:-1] # 인텍스 0에서부터 리스트 끝에서 3번째 인덱스까지(인텍스 -3은 제외) 역순으로 슬라이싱, 하지만 슬라이싱 못하므로 빈 리스트 반환\n# []\n\nitems[::-1] # 리스트 처음부터 끝까지 역순으로 슬라이싱\n# [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\nitems[::-2] # 리스트 처음부터 끝까지 역순으로 2칸씩 슬라이싱\n# [10, 8, 6, 4, 2, 0]\n```\n\n\n<br><br><br><br><br><br>\n\n**📌 다음 파이썬 코드의 알맞는 출력값을 작성하시오. ( 23년 1회 )**\n```python\na = {'한국', '중국', '일본'}\na.add('베트남')\na.add('중국')\na.remove('일본')\na.update({'홍콩', '한국', '태국'})\nprint(a)\n```\n<br>\n\n> 정답 : {'한국', '중국', '일본', '베트남', '태국'} ( 순서는 상관없음 )\n\nset는 순서를 보장하지 않기때문에 요소를 추가할때 순서를 고려하지 않아도 된다. 또한 `update`는 없으면 추가, 있으면 유지를 하면 된다. 그러나 set는 **중괄호와 작은따옴표**를 반드시 포함해줘야 한다!!!\n\n\n\n<br><br><br><br><br><br>\n\n📌 **다음 파이썬 코드에 대한 출력값을 작성하시오.**\n\n```python\nTestList = [1,2,3,4,5]\nTestList = list(map(lambda num : num + 100, TestList))\n \nprint(TestList)\n```\n<br>\n\n> 정답 : [101, 102, 103, 104, 105]\n\n\n<br><br><br><br><br><br>\n\n**📌 다음 Python으로 구현된 프로그램과 입력값을 보고 실행 결과를 작성하시오.**\n```python\nx = input()\nx = x.capitalize()\ny = x.split()\nprint(y[0][::2], end = '*')\nprint(y[1][3:6])\n```\n\n```\n입력 : python programming\n```\n\n<br>\n\n> 정답 : Pto*gra\n\n`capitalize()`는 첫 글자를 대문자로 변경한다.\n`split()`은 공백을 기준으로 배열형태로 변경해준다.\n따라서 `y[0] = python` 이고 `y[1] = programming` 이다.\n이후는 slice해주면 된다.\n\n\n<br><br><br><br><br><br>\n\n**📌다음 python의 프로그램과 입력값을 분석하여 실행 결과에 대해 작성하시오.**\n```python\narr_str = input('input String :').split('-')\narr_len = int(input('input number : '))\narr_val = list(range(0,arr_len,2))\narr_val.remove(4)\nprint(arr_str[1].find('i') + arr_val[2])\n```\n\n```\n입력 :\ninput string : information-technology\ninput number : 12\n```\n\n<br>\n\n> 정답 : 5\n\n\n```\narr_str[0] = information\narr_str[1] = technology\narr_len = 12\narr_val = [0, 2, 4, 6, 8, 10]\narr_val.remove(4) -> [0, 2, 6, 8, 10]\narr_str[1].find('i') = -1\narr_val[2] = 6\nresult : 5\n```\nrange(start, stop) 함수는 start부터 stop-1까지의 숫자를 생성한다.\n\n\n<br><br><br><br><br><br>\n\n📌 **다음 python의 프로그램을 분석하여 실행 결과에 대해 작성하시오.**\n```python\ni = 20\nf = 123456.789E-3\nprint('%d\\n%d' % (i, i), end = '/')\nprint('%.3f' % f)\n```\n<br>\n\n> 정답 : \n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1626526681},"-917011965":{"id":"Rkbhu5EBtxTalmMn/content","type":"content","text":"---\npermalink: /2024-03-28-정보처리기사 실기 Python 모음/\npublished: true\ntitle: \"[정처기] 정보처리기사 실기 Python 문제 모음\"\ndate: 2024-03-28 10:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"정보처리기사 실기 Python 문제 모음\"\ncategories:\n- Spring\ntags:\n- Spring\n---\n\n<br><br>\n\n\n## ✅ 정보처리기사 Python 문제 모음\n\n**📌 다음 파이썬 코드에서 알맞는 출력값을 작성하시오.( 23년 2회 )** \n\n<br>\n\n```python\na = \"engineer information processing\"\nb = a[:3]\nc = a[4:6]\nd = a[28:]\ne=b+c+d\nprint(e)\n```\n<br>\n\n> 정답 : engneing\n\n\n\n파이썬 Slice 개념을 알고있으면 쉽게 풀릴 문제다.\n```python\nitems = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nitems[2:5] # 인텍스 2에서 인덱스 5까지(인덱스 5는 제외) 슬라이싱 \n# [2, 3, 4]\n\nitems[5:] # 인덱스 5에서 끝까지 슬라이싱\n# [5, 6, 7, 8, 9, 10]\n\nitems[:3] # 처음부터 인덱스 3까지(인덱스 3은 제외) 슬라이싱 \n# [0, 1, 2]\n\nitems[:] # 처음부터 끝까지 슬라이싱(즉, 리스트 복사본 반환)\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nitems[2:9:3] # 인덱스 2에서 인텍스 9까지(인덱스 9는 제외) 3칸씩 점프 \n# [2, 5, 8]\n\nitems[:10:2] # 처음부터 인텍스 10까지(인덱스 10은 제외) 2칸씩 점프\n# [0, 2, 4, 6, 8]\n\nitems[2::2] # 인덱스 2에서 끝까지 2칸씩 점프\n# [2, 4, 6, 8, 10]\n\nitems[::3] # 전체 리스트에 대해서 3칸씩 점프\n# [0, 3, 6, 9]\n\nitems[10:0:-3] # 인텍스 10에서 0까지(인덱스 0은 제외) 역순으로 슬라이싱\n# [10, 7, 4, 1]\n\nitems[5:1:-1] # 인덱스 5에서 1까지(인텍스 1은 제외) 역순으로 슬라이싱\n# [5, 4, 3, 2]\n\nitems[1::-1] # 인덱스 1에서 끝까지 역순으로 슬라이싱\n# [1, 0]\n\nitems[1:10:-1] # 인텍스 1에서 인덱스 10까지(인덱스 10인 제외) 역순으로 슬라이싱, 하지만 슬라이싱 못하므로 빈 리스트 반환\n# []\n\nitems[:-3:-1] # 리스트 끝에서 3번째 인덱스까지(인덱스 -3은 제외) 역순으로 슬라이싱\n# [10, 9]\n\nitems[0:-3:-1] # 인텍스 0에서부터 리스트 끝에서 3번째 인덱스까지(인텍스 -3은 제외) 역순으로 슬라이싱, 하지만 슬라이싱 못하므로 빈 리스트 반환\n# []\n\nitems[::-1] # 리스트 처음부터 끝까지 역순으로 슬라이싱\n# [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\nitems[::-2] # 리스트 처음부터 끝까지 역순으로 2칸씩 슬라이싱\n# [10, 8, 6, 4, 2, 0]\n```\n\n\n<br><br><br><br><br><br>\n\n**📌 다음 파이썬 코드의 알맞는 출력값을 작성하시오. ( 23년 1회 )**\n```python\na = {'한국', '중국', '일본'}\na.add('베트남')\na.add('중국')\na.remove('일본')\na.update({'홍콩', '한국', '태국'})\nprint(a)\n```\n<br>\n\n> 정답 : {'한국', '중국', '일본', '베트남', '태국'} ( 순서는 상관없음 )\n\nset는 순서를 보장하지 않기때문에 요소를 추가할때 순서를 고려하지 않아도 된다. 또한 `update`는 없으면 추가, 있으면 유지를 하면 된다. 그러나 set는 **중괄호와 작은따옴표**를 반드시 포함해줘야 한다!!!\n\n\n\n<br><br><br><br><br><br>\n\n📌 **다음 파이썬 코드에 대한 출력값을 작성하시오.**\n\n```python\nTestList = [1,2,3,4,5]\nTestList = list(map(lambda num : num + 100, TestList))\n \nprint(TestList)\n```\n<br>\n\n> 정답 : [101, 102, 103, 104, 105]\n\n\n<br><br><br><br><br><br>\n\n**📌 다음 Python으로 구현된 프로그램과 입력값을 보고 실행 결과를 작성하시오.**\n```python\nx = input()\nx = x.capitalize()\ny = x.split()\nprint(y[0][::2], end = '*')\nprint(y[1][3:6])\n```\n\n```\n입력 : python programming\n```\n\n<br>\n\n> 정답 : Pto*gra\n\n`capitalize()`는 첫 글자를 대문자로 변경한다.\n`split()`은 공백을 기준으로 배열형태로 변경해준다.\n따라서 `y[0] = python` 이고 `y[1] = programming` 이다.\n이후는 slice해주면 된다.\n\n\n<br><br><br><br><br><br>\n\n**📌다음 python의 프로그램과 입력값을 분석하여 실행 결과에 대해 작성하시오.**\n```python\narr_str = input('input String :').split('-')\narr_len = int(input('input number : '))\narr_val = list(range(0,arr_len,2))\narr_val.remove(4)\nprint(arr_str[1].find('i') + arr_val[2])\n```\n\n```\n입력 :\ninput string : information-technology\ninput number : 12\n```\n\n<br>\n\n> 정답 : 5\n\n\n```\narr_str[0] = information\narr_str[1] = technology\narr_len = 12\narr_val = [0, 2, 4, 6, 8, 10]\narr_val.remove(4) -> [0, 2, 6, 8, 10]\narr_str[1].find('i') = -1\narr_val[2] = 6\nresult : 5\n```\nrange(start, stop) 함수는 start부터 stop-1까지의 숫자를 생성한다.\n\n\n<br><br><br><br><br><br>\n\n📌 **다음 python의 프로그램을 분석하여 실행 결과에 대해 작성하시오.**\n```python\ni = 20\nf = 123456.789E-3\nprint('%d\\n%d' % (i, i), end = '/')\nprint('%.3f' % f)\n```\n<br>\n\n> 정답 : \n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-917011965}},"syncHistory":{"main":[-917011965,-1626526681,-917011965]},"v":1,"hash":1712795972469,"tx":19523},"syncData":{"id":"syncData","type":"data","data":{"1lZ2XIAxsGmeZlkc33CsaeOhjtqpHdrqHgIzNX5QJuF1NBZ4JJQ":{"id":"1lZ2XIAxsGmeZlkc33CsaeOhjtqpHdrqHgIzNX5QJuF1NBZ4JJQ","itemId":"sJA3I2YlEcsXd7KN/content","type":"content","hash":1561484369},"1Kk4FJiXUGLSeglVvWBNDL1O-w7zR41YkuJLQFM6mMFmlFXqrvw":{"id":"1Kk4FJiXUGLSeglVvWBNDL1O-w7zR41YkuJLQFM6mMFmlFXqrvw","itemId":"tUKHjSE4AzMkDcu6/content","type":"content","hash":83544872},"1Q9CDowikMO1x6eR3XjjWVIZUvzwEw75MMKBjlZ6hcxTjHvw0bQ":{"id":"1Q9CDowikMO1x6eR3XjjWVIZUvzwEw75MMKBjlZ6hcxTjHvw0bQ","itemId":"If5aQIxmIA2QnlwG/content","type":"content","hash":553285820},"1laWvmm2A7XMtJeQ4IaDOt_iM_ViLm6oJ_2TKDp0Cs8XCWaf6jw":{"id":"1laWvmm2A7XMtJeQ4IaDOt_iM_ViLm6oJ_2TKDp0Cs8XCWaf6jw","itemId":"3MlAcPk2jd146ZWA/content","type":"content","hash":1590520298},"1tvMj4k_FRC1uj2-cCftGIwpm8GQNs-EA3u4oJ7pFTuTcnRfxAw":{"id":"1tvMj4k_FRC1uj2-cCftGIwpm8GQNs-EA3u4oJ7pFTuTcnRfxAw","itemId":"YRBZD8HJuJFWJ7Aj/content","type":"content","hash":890688502},"1DZSfavJ1n3telg2DnBf9uuvwPIB01llh0vVXeGNNFRvlsOIh2A":{"id":"1DZSfavJ1n3telg2DnBf9uuvwPIB01llh0vVXeGNNFRvlsOIh2A","itemId":"p9UokYwup7mYh1M9/content","type":"content","hash":-619782640},"1sVqytusdISPezUaKTY-dYpLATvhFQQjzEt_VAyobvUQOpHiqCQ":{"id":"1sVqytusdISPezUaKTY-dYpLATvhFQQjzEt_VAyobvUQOpHiqCQ","itemId":"31JAF1na3LcScLsv/content","type":"content","hash":-2039959105},"1Zf_LuOBnOodoLYyfTwIUSKv2rU1JC7aYGcAsGqz6eunpYfXyqw":{"id":"1Zf_LuOBnOodoLYyfTwIUSKv2rU1JC7aYGcAsGqz6eunpYfXyqw","itemId":"CP6FQYPqjeJhYtSB/content","type":"content","hash":985038043},"12kKdPF-UFAZItxag0hoZLnc-NxRs5QJ6rK_591silv-_i1KuJA":{"id":"12kKdPF-UFAZItxag0hoZLnc-NxRs5QJ6rK_591silv-_i1KuJA","itemId":"tyTfzmPd7F6kUOPq/content","type":"content","hash":-640983991},"1ctxt77_E4fPyIVtlrJDPx2tZjBqJL7CYOyDBsYzIJI2nvEnKSQ":{"id":"1ctxt77_E4fPyIVtlrJDPx2tZjBqJL7CYOyDBsYzIJI2nvEnKSQ","itemId":"aae7rBzpuqHuDhqC/content","type":"content","hash":434379459},"1fa1rMY3xvB_ReyKaSaWGNN7iWZX_3N_spRMPTXc8eWAvyA4U2Q":{"id":"1fa1rMY3xvB_ReyKaSaWGNN7iWZX_3N_spRMPTXc8eWAvyA4U2Q","itemId":"7MH9EXPbwlEyua1N/content","type":"content","hash":1765659518},"1wMgvUZxJNzYOCpIJwYh9eW_Cga72VZK3kKpaDeGyLIeuHCLJlw":{"id":"1wMgvUZxJNzYOCpIJwYh9eW_Cga72VZK3kKpaDeGyLIeuHCLJlw","itemId":"zwQGgTuOeVYHa8VM/content","type":"content","hash":2108309747},"1t2zwj5DIuKdjC1SPqCvUwH540DPSBXL8yM8uEacg8q0paLjHpw":{"id":"1t2zwj5DIuKdjC1SPqCvUwH540DPSBXL8yM8uEacg8q0paLjHpw","itemId":"nfsPiciyqnl9eDk3/content","type":"content","hash":-1994882972},"1ruY_52UrWZQItowAt-wlApAV_P3LZDtr4lf_BOE_94GpnCOBwQ":{"id":"1ruY_52UrWZQItowAt-wlApAV_P3LZDtr4lf_BOE_94GpnCOBwQ","itemId":"dsPZqXB2XwSOXmhf/content","type":"content","hash":1858242666},"1X133Dxjs_lWs7umEo6NgfSD-OdLzq8_q9wo0RaDg2hCObqk18Q":{"id":"1X133Dxjs_lWs7umEo6NgfSD-OdLzq8_q9wo0RaDg2hCObqk18Q","itemId":"30ZHndsjczBXKG2t/content","type":"content","hash":486623268},"1yf6c2en18KowktcoiOzKpgH6uiPXC_7KKnv_QuwpFKRfOtxtqw":{"id":"1yf6c2en18KowktcoiOzKpgH6uiPXC_7KKnv_QuwpFKRfOtxtqw","itemId":"jWIAbpACKd6mffUH/content","type":"content","hash":-94761757},"1rnnMELDgmzqwkX5as0YzUJ5Og4QuSYp0gsZWjwMCubFTRPJelQ":{"id":"1rnnMELDgmzqwkX5as0YzUJ5Og4QuSYp0gsZWjwMCubFTRPJelQ","itemId":"mqHezxUzK3yVL3FH/content","type":"content","hash":-1611565356},"1B9Z3JegBSngqb4xdMiuPBXvcJy-vl8mtXFYUjrMdo_iXqMxtdg":{"id":"1B9Z3JegBSngqb4xdMiuPBXvcJy-vl8mtXFYUjrMdo_iXqMxtdg","itemId":"S7I9qtkAaIcuOTIm/content","type":"content","hash":-1236696749},"12Sdfp7a-mNic4q9kEZp30TIq6Kj-Zpf-y72h730omPQxTA6mjQ":{"id":"12Sdfp7a-mNic4q9kEZp30TIq6Kj-Zpf-y72h730omPQxTA6mjQ","itemId":"lxMWY3IFzi3Fwd8Q/content","type":"content","hash":1991776809},"18ysA-xNPeOqZlJxCcSkjFdVmo3DyNDNwQeH2c8hy00y1xGS8jA":{"id":"18ysA-xNPeOqZlJxCcSkjFdVmo3DyNDNwQeH2c8hy00y1xGS8jA","itemId":"IqjGfqqQQvpdMUmv/content","type":"content","hash":386497519},"1bisAK-8R--MrDdhWyKog-4vJsa6ZR8aYPWfCcS0sRLwCuurzhQ":{"id":"1bisAK-8R--MrDdhWyKog-4vJsa6ZR8aYPWfCcS0sRLwCuurzhQ","itemId":"XB8qeLyuDIPE5NtZ/content","type":"content","hash":-1534283329},"1OyRAfBjn2xzLx_k7YKSKLq0nQ7N2cMjlY_sA44IMYGGsNwnoyQ":{"id":"1OyRAfBjn2xzLx_k7YKSKLq0nQ7N2cMjlY_sA44IMYGGsNwnoyQ","itemId":"3LsY0S6l92HdtfPP/content","type":"content","hash":-776426303},"1sNKY0kF3HmhY_zFghOEHEMmAIbB0npajMHZVCrpU5mnqS_QKNw":{"id":"1sNKY0kF3HmhY_zFghOEHEMmAIbB0npajMHZVCrpU5mnqS_QKNw","itemId":"AccPceb6fVYGLjbn/content","type":"content","hash":-1466512106},"1tLtiyAZD89NvayhiRWOYjzn9XoWvVJDsh9FcvT9KhtfWfv32Ew":{"id":"1tLtiyAZD89NvayhiRWOYjzn9XoWvVJDsh9FcvT9KhtfWfv32Ew","itemId":"QjUYHBSBdQAHLPXV/content","type":"content","hash":2001068146},"1oG95bmbtKUiK6JxxIgXNBjDehfmZQEsX_oS9spwbhMdLQMIMGw":{"id":"1oG95bmbtKUiK6JxxIgXNBjDehfmZQEsX_oS9spwbhMdLQMIMGw","itemId":"fuIXk253HaqdwDFg/content","type":"content","hash":-1085769069},"1lt1QUTX3BD0swJgaUdyhyxojPrNfpA3eIdRKBp7rzanJKuCUzA":{"id":"1lt1QUTX3BD0swJgaUdyhyxojPrNfpA3eIdRKBp7rzanJKuCUzA","itemId":"f5vTQlCLsBu2JtIV/content","type":"content","hash":730747747},"10mviWeSuPxgcRsoHm7qbxgrnyCjtfgMuwq-6ytlAgulJJPpiFQ":{"id":"10mviWeSuPxgcRsoHm7qbxgrnyCjtfgMuwq-6ytlAgulJJPpiFQ","itemId":"DYReayvPEWh2qfnj/content","type":"content","hash":-1865698563},"1gnNQdfALDR2ni4i3CHoXwxNi6loh9zcO8i16ShUcnHhvbMnq4A":{"id":"1gnNQdfALDR2ni4i3CHoXwxNi6loh9zcO8i16ShUcnHhvbMnq4A","itemId":"LEhxYp8G5u90fiYq/content","type":"content","hash":-1224890333},"1Nb6Mpj6wdd88tCp030f6hCn6sjcnBlLq6x-5V1UUsUErIMUJdw":{"id":"1Nb6Mpj6wdd88tCp030f6hCn6sjcnBlLq6x-5V1UUsUErIMUJdw","itemId":"oPPKCabe4PCAuTpL/content","type":"content","hash":-1560299687},"1ouXu8R8Qg3WOhw1BSXBM4_MPOEBFjHbUJlJkMXre2yki6eX5kQ":{"id":"1ouXu8R8Qg3WOhw1BSXBM4_MPOEBFjHbUJlJkMXre2yki6eX5kQ","itemId":"EAHxuW5JgATJ3mo2/content","type":"content","hash":-1419097415},"1sMC5sajfLFjf-zDF8_xf5EBGatGOgSlUrtKkClxyNitx2kwSew":{"id":"1sMC5sajfLFjf-zDF8_xf5EBGatGOgSlUrtKkClxyNitx2kwSew","itemId":"Zd6WgSyDwAy0BrDK/content","type":"content","hash":-253091378},"1U3clg_tyX4-QVaoHIcgHYs5Yc_NHLGasXhj6WAnohnLpo6yHIw":{"id":"1U3clg_tyX4-QVaoHIcgHYs5Yc_NHLGasXhj6WAnohnLpo6yHIw","itemId":"ysh4WSkm4ITJnEGN/content","type":"content","hash":989794151},"19P6HwyognQKRT3-VdO9MuiZ91RRG4T88ifXT5Dlmfmpomuq9JQ":{"id":"19P6HwyognQKRT3-VdO9MuiZ91RRG4T88ifXT5Dlmfmpomuq9JQ","itemId":"KvfIbjNY2ObhRnU0/content","type":"content","hash":1388318610},"1YCtzTG3_S9eSyRi0q3AfljHtzvZF6-9mYd9UzjqJZd9d65RQ0A":{"id":"1YCtzTG3_S9eSyRi0q3AfljHtzvZF6-9mYd9UzjqJZd9d65RQ0A","itemId":"4VlIZeIFebGuQ7Yr/content","type":"content","hash":-1348316954},"1zhDG2aiI5FZBst0o385p0fdYOahfvDOnhK2l-q-CDR18i4eBIw":{"id":"1zhDG2aiI5FZBst0o385p0fdYOahfvDOnhK2l-q-CDR18i4eBIw","itemId":"pDeZuAQGE7zRuhXc/content","type":"content","hash":-657495354},"19xCRuGhhperrpZA5di7huViFOm59sqiynk0mSw13yHZc-lBwhw":{"id":"19xCRuGhhperrpZA5di7huViFOm59sqiynk0mSw13yHZc-lBwhw","itemId":"ybpPTUQRubuccvNK/content","type":"content","hash":-850581845},"1U0dBd3DQCa7SBiCeK-GA9YgHtk1aYkHqIm13LI4DaWWCobef6Q":{"id":"1U0dBd3DQCa7SBiCeK-GA9YgHtk1aYkHqIm13LI4DaWWCobef6Q","itemId":"I9XIrcsCCqJCsXnW/content","type":"content","hash":1428815895},"1pFj8Uqn0WMwC6LSrOru-xQYJpw6Pt8f6C2jaUMxkySA_7BD2ag":{"id":"1pFj8Uqn0WMwC6LSrOru-xQYJpw6Pt8f6C2jaUMxkySA_7BD2ag","itemId":"zaeb9S3ugI5mUe9I","type":"folder","hash":-1994256298},"1Pn7pZof29wMDBN7ymDDjmN-bPKcZKzdVYTb5AMpSqdq-Csuvwg":{"id":"1Pn7pZof29wMDBN7ymDDjmN-bPKcZKzdVYTb5AMpSqdq-Csuvwg","itemId":"fuIXk253HaqdwDFg","type":"file","hash":1525742621},"1UQLb23k3iD1DArKnkIV4Y9rvu0YZh7ysJdmz6nWKFXJvZD3ArQ":{"id":"1UQLb23k3iD1DArKnkIV4Y9rvu0YZh7ysJdmz6nWKFXJvZD3ArQ","itemId":"f5vTQlCLsBu2JtIV","type":"file","hash":1212830911},"1Z1hft71Iw1SjeyMmcvO4ntD9R-Mgj13BBQrosNA9ihRV2pYjIw":{"id":"1Z1hft71Iw1SjeyMmcvO4ntD9R-Mgj13BBQrosNA9ihRV2pYjIw","itemId":"DYReayvPEWh2qfnj","type":"file","hash":1049272719},"1IJeFtJGrcZg25oLqcAkh-4PgIC0odKKA4M0sI8swiagvDr1olw":{"id":"1IJeFtJGrcZg25oLqcAkh-4PgIC0odKKA4M0sI8swiagvDr1olw","itemId":"3czWpyCWVN518JXE","type":"folder","hash":-1052857529},"19lpgRHoVtGiROH1IeMKHbMCtFoyzotHVx5kWekNLJw9a4fbcZQ":{"id":"19lpgRHoVtGiROH1IeMKHbMCtFoyzotHVx5kWekNLJw9a4fbcZQ","itemId":"JZO7E1GRXJiiFfhC","type":"file","hash":-72873845},"1eEaNGMOvfMyeMwYQ6lZO1ExacA-8yp_0IJy-tH15BdpLEw5Vsg":{"id":"1eEaNGMOvfMyeMwYQ6lZO1ExacA-8yp_0IJy-tH15BdpLEw5Vsg","itemId":"CXkDYxCp5Qq9ere0","type":"folder","hash":1331905438},"1vMNT0taBTPYsydyG3JMWohSQDdlShs9gurytdF5zVBrt2rN8ZQ":{"id":"1vMNT0taBTPYsydyG3JMWohSQDdlShs9gurytdF5zVBrt2rN8ZQ","itemId":"jWIAbpACKd6mffUH","type":"file","hash":1801094026},"10gGIi5ezb-RnpmPphCvxJItYl9FDuBJRjhwU_JWPlfoFcbI-4g":{"id":"10gGIi5ezb-RnpmPphCvxJItYl9FDuBJRjhwU_JWPlfoFcbI-4g","itemId":"30ZHndsjczBXKG2t","type":"file","hash":-1494688936},"1EEpVQW6JonrHC8kNT1FDvcYXcvJoHaEXP_iPMRcUsJrb6YSSEQ":{"id":"1EEpVQW6JonrHC8kNT1FDvcYXcvJoHaEXP_iPMRcUsJrb6YSSEQ","itemId":"cXAfswLPLBmPzNUg","type":"file","hash":1426061647},"1QQ2OxDnso_fxmOV139DNf6X6X1WszmMnJ-5O0RZk4ACiypsrtg":{"id":"1QQ2OxDnso_fxmOV139DNf6X6X1WszmMnJ-5O0RZk4ACiypsrtg","itemId":"lxMWY3IFzi3Fwd8Q","type":"file","hash":1402169954},"1ikU-OVdn8u6dmnzC5TBPfUAiXqKwCLLTHaX4iYHKX5fCfiOkuw":{"id":"1ikU-OVdn8u6dmnzC5TBPfUAiXqKwCLLTHaX4iYHKX5fCfiOkuw","itemId":"AccPceb6fVYGLjbn","type":"file","hash":399288587},"1pqfVTOftQVRur8JEroSxLk4TNptaw3sLw3L9dMgWWcxn5lmwJw":{"id":"1pqfVTOftQVRur8JEroSxLk4TNptaw3sLw3L9dMgWWcxn5lmwJw","itemId":"fAbQ4GrjYnuIv4xU","type":"folder","hash":-1356482200},"1ZRS8XCzFvs-aMJthPiCjye5rmibmuTxW1Wb0MzxjvLf4KZQpyg":{"id":"1ZRS8XCzFvs-aMJthPiCjye5rmibmuTxW1Wb0MzxjvLf4KZQpyg","itemId":"D6AI3WmiULa0MQox","type":"file","hash":-530487961},"1DqZJR0tZpRFKbS6Ej7KclmlaA9oim-hWAvVwkdoBCxv-HKmOAA":{"id":"1DqZJR0tZpRFKbS6Ej7KclmlaA9oim-hWAvVwkdoBCxv-HKmOAA","itemId":"D6AI3WmiULa0MQox/content","type":"content","hash":175872295},"1k-5QgYOGA2cqoqGBlbdB7Hoe8AoiRTjur-4aglp0swcrtZky0g":{"id":"1k-5QgYOGA2cqoqGBlbdB7Hoe8AoiRTjur-4aglp0swcrtZky0g","itemId":"2YcBlgoRtPYITlYT","type":"file","hash":-812923146},"1wOP3EmhBepsu2FrrXLzEqqrF2mxvruAkzdB3AcRow6eGEBwtkw":{"id":"1wOP3EmhBepsu2FrrXLzEqqrF2mxvruAkzdB3AcRow6eGEBwtkw","itemId":"2YcBlgoRtPYITlYT/content","type":"content","hash":336953453},"1kwsPipGejglAyDLJlY3-TmdZBXd22VMUHM94RNZoDNH9OY48JQ":{"id":"1kwsPipGejglAyDLJlY3-TmdZBXd22VMUHM94RNZoDNH9OY48JQ","itemId":"JZO7E1GRXJiiFfhC/content","type":"content","hash":-1090010526},"1VgHG651fA4rm-jpLxIPi9bAvsDNHL3HpvpZW-bdGZ9JpVJuglg":{"id":"1VgHG651fA4rm-jpLxIPi9bAvsDNHL3HpvpZW-bdGZ9JpVJuglg","itemId":"1x2SS92trda8Dql0/content","type":"content","hash":1984698982},"1afjUg0-adBhSYxfulsleyrWPoYoAiFdAlj6V_2rySptrsDiq3g":{"id":"1afjUg0-adBhSYxfulsleyrWPoYoAiFdAlj6V_2rySptrsDiq3g","itemId":"1x2SS92trda8Dql0","type":"file","hash":-1440029720},"12HGY-mNRGlP6GWEkXnT1JpZ7wEUZhjQegYXMmdhZen3fYLWjLQ":{"id":"12HGY-mNRGlP6GWEkXnT1JpZ7wEUZhjQegYXMmdhZen3fYLWjLQ","itemId":"tLqdQCgLBZOSaYBm","type":"file","hash":265862498},"1aflbAAWzOamokW8sVBZPzCg4Jk_lA908Jxj9NEfafuY9IbP4bg":{"id":"1aflbAAWzOamokW8sVBZPzCg4Jk_lA908Jxj9NEfafuY9IbP4bg","itemId":"tLqdQCgLBZOSaYBm/content","type":"content","hash":-1401528883},"1iZqE_4mLY5S_LnDRS4x5SW4LkvbM_Gk6Yvlh1rMAuju9XKASlQ":{"id":"1iZqE_4mLY5S_LnDRS4x5SW4LkvbM_Gk6Yvlh1rMAuju9XKASlQ","itemId":"cc0DNjIMHfpFRRJW/content","type":"content","hash":81728621},"1ymuzA7Xm-ueb-yDqgf1oRn3xqa1AilXHNUyclwIb2ndDEFiLVQ":{"id":"1ymuzA7Xm-ueb-yDqgf1oRn3xqa1AilXHNUyclwIb2ndDEFiLVQ","itemId":"9BAGvpdsYjjYTrvN/content","type":"content","hash":569007155},"1d-6SBz-f31hR6Tv2HbzTTw7bjFp9OATW6qOLKSjj5Qzke-WsAQ":{"id":"1d-6SBz-f31hR6Tv2HbzTTw7bjFp9OATW6qOLKSjj5Qzke-WsAQ","itemId":"2rs7iPXVJKE420nw/content","type":"content","hash":-445259290},"1_wM-S3AuD5Z15Wamo_0Ya2xMju6Zs3QzqWyJnKvMQ0U_UGnYOg":{"id":"1_wM-S3AuD5Z15Wamo_0Ya2xMju6Zs3QzqWyJnKvMQ0U_UGnYOg","itemId":"ni3ScMP3VaGaeIOQ/content","type":"content","hash":-1956582414},"15tEGQEH4uEyC7o1-2cj-x5UEhZm6DwvIZ7mXXXF-sc7tjrj-Sg":{"id":"15tEGQEH4uEyC7o1-2cj-x5UEhZm6DwvIZ7mXXXF-sc7tjrj-Sg","itemId":"8onLCMS0jHIZdwsP/content","type":"content","hash":-1010334825},"1gh4zO7FdX4zQei0btA1WFwWrLOVTWHii6963tCuiy71sZp7Dbg":{"id":"1gh4zO7FdX4zQei0btA1WFwWrLOVTWHii6963tCuiy71sZp7Dbg","itemId":"cXAfswLPLBmPzNUg/content","type":"content","hash":363413327},"1TcRjoyHUR5DJYXH0ADJ4JiwF7CYoL7EQLDRrz0MIfiMU1PN2Cw":{"id":"1TcRjoyHUR5DJYXH0ADJ4JiwF7CYoL7EQLDRrz0MIfiMU1PN2Cw","itemId":"qu70Oe3aus3CVeFP","type":"folder","hash":-1018786741},"1E3snb8ptKJyVEMcSK5DCyDz4eWDmoQa-bcMv8l4TuTHeeb3nGw":{"id":"1E3snb8ptKJyVEMcSK5DCyDz4eWDmoQa-bcMv8l4TuTHeeb3nGw","itemId":"2rs7iPXVJKE420nw","type":"file","hash":1988787040},"1lmCicOnJ-I660sf6nz9I6GAONqtFn67nHcb_gEy4fjHx1VP4PQ":{"id":"1lmCicOnJ-I660sf6nz9I6GAONqtFn67nHcb_gEy4fjHx1VP4PQ","itemId":"8onLCMS0jHIZdwsP","type":"file","hash":-584978935},"1kQ8q3SMNube-05xgs47VeN9K8KRIFTZ_rtKqMHuZRvmRJKgIvw":{"id":"1kQ8q3SMNube-05xgs47VeN9K8KRIFTZ_rtKqMHuZRvmRJKgIvw","itemId":"9BAGvpdsYjjYTrvN","type":"file","hash":-1327373974},"1aaNabBzmYB7NBVWrPc_-HlT7n3YH-rMum5TXHy5ZLLLPdT4eWw":{"id":"1aaNabBzmYB7NBVWrPc_-HlT7n3YH-rMum5TXHy5ZLLLPdT4eWw","itemId":"cc0DNjIMHfpFRRJW","type":"file","hash":1007432267},"16sKVGoWHGgzczumNIav_N5_-1CuCgZRB08XhEJ_73Ai3hgHb9Q":{"id":"16sKVGoWHGgzczumNIav_N5_-1CuCgZRB08XhEJ_73Ai3hgHb9Q","itemId":"ni3ScMP3VaGaeIOQ","type":"file","hash":-1745413078},"1ExYRNpa6MgGWGpngi-lUKjDTZgkkW4Xku_jUAIm4Xpi0JRByDQ":{"id":"1ExYRNpa6MgGWGpngi-lUKjDTZgkkW4Xku_jUAIm4Xpi0JRByDQ","itemId":"1oEHvsghUe5VhiGy","type":"folder","hash":1568701204},"1xzMVH-l9U4Q4wgM3NmfBiUfMePBZkv2yVDEO8M8Wef9E7DLQgg":{"id":"1xzMVH-l9U4Q4wgM3NmfBiUfMePBZkv2yVDEO8M8Wef9E7DLQgg","itemId":"I9XIrcsCCqJCsXnW","type":"file","hash":918232863},"1arox4fylKITF28AAl6daq-FT2B25BAqHOmkZY0oK7o9745b8aQ":{"id":"1arox4fylKITF28AAl6daq-FT2B25BAqHOmkZY0oK7o9745b8aQ","itemId":"BUPXu7gnwQkTDAja","type":"folder","hash":1216748907},"1OFZvQF3z0ijkyxAMvs6KjxaLtbu-uvtb2V_MXBYy-EgSg4n-YA":{"id":"1OFZvQF3z0ijkyxAMvs6KjxaLtbu-uvtb2V_MXBYy-EgSg4n-YA","itemId":"oPPKCabe4PCAuTpL","type":"file","hash":-269785357},"1UkqJ0C_favjtGowH2RYLZd7c2YrAOSrUMh4ZyYQDOuI4O45iag":{"id":"1UkqJ0C_favjtGowH2RYLZd7c2YrAOSrUMh4ZyYQDOuI4O45iag","itemId":"3LsY0S6l92HdtfPP","type":"file","hash":771393512},"1AVipu3sTFxjra88jydJQAKk2eA01IiOHKkpiHyrFVPnkPVgA4Q":{"id":"1AVipu3sTFxjra88jydJQAKk2eA01IiOHKkpiHyrFVPnkPVgA4Q","itemId":"LEhxYp8G5u90fiYq","type":"file","hash":495027119},"1NxqOjuttfZIBk3BoUPN2hfNd5RxGSF1wQavmZbfh1NX_dpPJIg":{"id":"1NxqOjuttfZIBk3BoUPN2hfNd5RxGSF1wQavmZbfh1NX_dpPJIg","itemId":"5FRWO0TTd1nBmf8a","type":"folder","hash":-735307137},"1JBdyNkvabWZCZnBO1BEkz26LkviC9QS2RADIgEj36NtkyXLtUw":{"id":"1JBdyNkvabWZCZnBO1BEkz26LkviC9QS2RADIgEj36NtkyXLtUw","itemId":"IqjGfqqQQvpdMUmv","type":"file","hash":-1593413474},"14ArDbua65AKjVJEptPjjWk35LLGjJ8ig0ljiSs5oRArYAkVVjA":{"id":"14ArDbua65AKjVJEptPjjWk35LLGjJ8ig0ljiSs5oRArYAkVVjA","itemId":"QjUYHBSBdQAHLPXV","type":"file","hash":48662461},"1O-a5zP07yOfh0GuIiGHcOVL8q5JEoGiKSpxnqhDPKS_fO3Saug":{"id":"1O-a5zP07yOfh0GuIiGHcOVL8q5JEoGiKSpxnqhDPKS_fO3Saug","itemId":"U3QLvyaFPGVPjqhG","type":"folder","hash":1853572455},"16bgNrGqbHY9MCPbiGs1j8uU_SVC8h4kDlcl5G9n8Ilt8D-lRKA":{"id":"16bgNrGqbHY9MCPbiGs1j8uU_SVC8h4kDlcl5G9n8Ilt8D-lRKA","itemId":"sJA3I2YlEcsXd7KN","type":"file","hash":-780439082},"1iDNDgKHYKVUSu_yzUBPay_piaU5o2teUG5N_CZFFn6_dGPzaNA":{"id":"1iDNDgKHYKVUSu_yzUBPay_piaU5o2teUG5N_CZFFn6_dGPzaNA","itemId":"tUKHjSE4AzMkDcu6","type":"file","hash":941122060},"1Ru0kESoadvdfnACX9KF-Y5BM5e2VV1dj8e1BV49K2dFugdX6ww":{"id":"1Ru0kESoadvdfnACX9KF-Y5BM5e2VV1dj8e1BV49K2dFugdX6ww","itemId":"ybpPTUQRubuccvNK","type":"file","hash":1085763407},"1-xlZE8qCBHNYQXwpdgfsrwYDq9SzK55WnJBMDLjY3L-1GDVVAw":{"id":"1-xlZE8qCBHNYQXwpdgfsrwYDq9SzK55WnJBMDLjY3L-1GDVVAw","itemId":"If5aQIxmIA2QnlwG","type":"file","hash":-81784950},"12sPrXduyC6fRBSsiRVv4DvRqiFpuoMbpXrUgQXsnYSSqnqw_9Q":{"id":"12sPrXduyC6fRBSsiRVv4DvRqiFpuoMbpXrUgQXsnYSSqnqw_9Q","itemId":"3MlAcPk2jd146ZWA","type":"file","hash":1696475097},"1C4RNeEFCxTycW2_i3dZRe9rmUrtnrDz4Mfq9TU9QV-i5tQhJ6w":{"id":"1C4RNeEFCxTycW2_i3dZRe9rmUrtnrDz4Mfq9TU9QV-i5tQhJ6w","itemId":"p9UokYwup7mYh1M9","type":"file","hash":86713463},"19YslL8Wl9oOGeKH2pLxuLiRNBpt4YAXCvp2Q8iQ0o0udCgDzQg":{"id":"19YslL8Wl9oOGeKH2pLxuLiRNBpt4YAXCvp2Q8iQ0o0udCgDzQg","itemId":"pDeZuAQGE7zRuhXc","type":"file","hash":-1797000551},"1T8Y2bCZ5klxJF269WfOjbMXguBrmob-85DQy3dMor4ZXYQy-Ew":{"id":"1T8Y2bCZ5klxJF269WfOjbMXguBrmob-85DQy3dMor4ZXYQy-Ew","itemId":"7MH9EXPbwlEyua1N","type":"file","hash":-575734608},"1rAucVmUJJkG0enGgN_OHZgKPY7Okn59pZ3fVzL0BlwwSfGLC5A":{"id":"1rAucVmUJJkG0enGgN_OHZgKPY7Okn59pZ3fVzL0BlwwSfGLC5A","itemId":"4VlIZeIFebGuQ7Yr","type":"file","hash":-1937455437},"1wAdE-powCc-5ufhm4Zy5mzvYwNHcblIrPUutsdbXRHrecpB5wQ":{"id":"1wAdE-powCc-5ufhm4Zy5mzvYwNHcblIrPUutsdbXRHrecpB5wQ","itemId":"tyTfzmPd7F6kUOPq","type":"file","hash":1911254155},"1xS6AGByty2qBYXA6BPHzxa3rCAipqS6uvC6aARo1nVQKT0pHzA":{"id":"1xS6AGByty2qBYXA6BPHzxa3rCAipqS6uvC6aARo1nVQKT0pHzA","itemId":"KvfIbjNY2ObhRnU0","type":"file","hash":-2129224270},"1nCvyOBduE6s82uzoUBk25-KjKR2B5pLQKT51gJ1gawWQNOG9eA":{"id":"1nCvyOBduE6s82uzoUBk25-KjKR2B5pLQKT51gJ1gawWQNOG9eA","itemId":"zwQGgTuOeVYHa8VM","type":"file","hash":1637116683},"1_Qtcu5keDMmkbfTFv2ibR5AsZHABenRVbc2e8r6tUSXgOap8TA":{"id":"1_Qtcu5keDMmkbfTFv2ibR5AsZHABenRVbc2e8r6tUSXgOap8TA","itemId":"S7I9qtkAaIcuOTIm","type":"file","hash":765165223},"1yf_NGjDJfMKS1DCYBunL2pLvcARsWpbfGg1cyjgIAKfrVATR1A":{"id":"1yf_NGjDJfMKS1DCYBunL2pLvcARsWpbfGg1cyjgIAKfrVATR1A","itemId":"ysh4WSkm4ITJnEGN","type":"file","hash":-2028399411},"1eARlFoLfhalyaMS5rU0Q3yStd5p3Beo1bxQjnUxiF5An2lI3Rg":{"id":"1eARlFoLfhalyaMS5rU0Q3yStd5p3Beo1bxQjnUxiF5An2lI3Rg","itemId":"dsPZqXB2XwSOXmhf","type":"file","hash":-1570600204},"14iwff-SSyMQYzMK61r8QmlT2IGtzPaWmgvh57corT1z2mb1Ydg":{"id":"14iwff-SSyMQYzMK61r8QmlT2IGtzPaWmgvh57corT1z2mb1Ydg","itemId":"Zd6WgSyDwAy0BrDK","type":"file","hash":1477437746},"1nFwt7WXArNN1sMEGqB2l-GZIrpk_ww8TIzR6lbMU25I3H8xz_g":{"id":"1nFwt7WXArNN1sMEGqB2l-GZIrpk_ww8TIzR6lbMU25I3H8xz_g","itemId":"mqHezxUzK3yVL3FH","type":"file","hash":-560344431},"1rwRiEe_N3MHwGg19vNrZkQp-o9n_Fer-_fUJW2XJfZUCaIf6UA":{"id":"1rwRiEe_N3MHwGg19vNrZkQp-o9n_Fer-_fUJW2XJfZUCaIf6UA","itemId":"YRBZD8HJuJFWJ7Aj","type":"file","hash":1728926351},"1uMwf2YGPMz1oPE1XAfR3Hpp6GRtqavU7XviaX97hxYIz8HkX2A":{"id":"1uMwf2YGPMz1oPE1XAfR3Hpp6GRtqavU7XviaX97hxYIz8HkX2A","itemId":"31JAF1na3LcScLsv","type":"file","hash":468002193},"15Z4j-MiKZZhfuOXNnM0fA8wpN_8m-VM_LnJ7YowShSjhkf8yQQ":{"id":"15Z4j-MiKZZhfuOXNnM0fA8wpN_8m-VM_LnJ7YowShSjhkf8yQQ","itemId":"EAHxuW5JgATJ3mo2","type":"file","hash":507856723},"1l0ULPCm_xwOs2BVHNZ8IaSo4tm63vw1VnsEF-ELBBH2vMyeJVg":{"id":"1l0ULPCm_xwOs2BVHNZ8IaSo4tm63vw1VnsEF-ELBBH2vMyeJVg","itemId":"aae7rBzpuqHuDhqC","type":"file","hash":1863052556},"1f-VnQymxuvF5XfkxWO8LFW_F4_e_l91ipzE2Ym9HV2uakfdKiQ":{"id":"1f-VnQymxuvF5XfkxWO8LFW_F4_e_l91ipzE2Ym9HV2uakfdKiQ","itemId":"nfsPiciyqnl9eDk3","type":"file","hash":901223150},"1Iz2lZMJVxT6DVYoVAVTb1t1Zd5LflfpwKNsLHVNyG0RfJa61DQ":{"id":"1Iz2lZMJVxT6DVYoVAVTb1t1Zd5LflfpwKNsLHVNyG0RfJa61DQ","itemId":"CP6FQYPqjeJhYtSB","type":"file","hash":267103305},"1kQyj-beIPfhvE8xrMqe4cbLh_GLo0dMU-M6HrxtafCSeg1JpWw":{"id":"1kQyj-beIPfhvE8xrMqe4cbLh_GLo0dMU-M6HrxtafCSeg1JpWw","itemId":"XB8qeLyuDIPE5NtZ","type":"file","hash":1794047671},"1gTg3Tg_PkuYFcpnWxmPaBUaYEmR57r5oxsQkKaytUIn-7AWJXw":{"id":"1gTg3Tg_PkuYFcpnWxmPaBUaYEmR57r5oxsQkKaytUIn-7AWJXw","itemId":"mnof4lJop1YAYqO6","type":"file","hash":-1153553870},"1sqy2pDBV7YZEf4f_a4DuMkn2MVeBWdiikIfV9jxo7-Ld6FQthg":{"id":"1sqy2pDBV7YZEf4f_a4DuMkn2MVeBWdiikIfV9jxo7-Ld6FQthg","itemId":"mnof4lJop1YAYqO6/content","type":"content","hash":1875244452},"1nLLzIYT0aj-VcZwDB-RVmPwFl-9aBKhysG-B0d55yadhue9UYw":{"id":"1nLLzIYT0aj-VcZwDB-RVmPwFl-9aBKhysG-B0d55yadhue9UYw","itemId":"lrjscqeSvZS8Oz9S","type":"folder","hash":-870530307},"1D7b5-KqCQ9WFxxB0qZ2iYmqZ_cs3lljmAf8jltNfiilpS2eVPw":{"id":"1D7b5-KqCQ9WFxxB0qZ2iYmqZ_cs3lljmAf8jltNfiilpS2eVPw","itemId":"27FCLunQqiKehP51","type":"file","hash":-181130542},"1BqA1yMo_TIwaFpOV5V2I1lYXAyQ4nnhFbC8onjvvSIGNff85NA":{"id":"1BqA1yMo_TIwaFpOV5V2I1lYXAyQ4nnhFbC8onjvvSIGNff85NA","itemId":"27FCLunQqiKehP51/content","type":"content","hash":-1860652716},"1W_Qocfn1Yb2z-ToIxQhr4OwsCDp0zBMNHAmjotqp6in6V2Oyaw":{"id":"1W_Qocfn1Yb2z-ToIxQhr4OwsCDp0zBMNHAmjotqp6in6V2Oyaw","itemId":"31ixuwejQY1ahmSf","type":"file","hash":-219859688},"1mcbbJz_-VjnqyEe64-r4ppzUBcGViBygMF7YmUrDqDdFWeSw6w":{"id":"1mcbbJz_-VjnqyEe64-r4ppzUBcGViBygMF7YmUrDqDdFWeSw6w","itemId":"ijBr8Otur9vUslbg","type":"folder","hash":-859387906},"1bVpIr4Mjf2a1zzMbSMe2gDGAZlV7lCeoKyKygte8x9XGb_76qg":{"id":"1bVpIr4Mjf2a1zzMbSMe2gDGAZlV7lCeoKyKygte8x9XGb_76qg","itemId":"jFo1UfZG6pqBFoBN","type":"file","hash":-1091281159},"1xb1m_TJDoEQ0VJIisrsldgeZbbHtBVPNHuSTCSPH4TQADRBdUQ":{"id":"1xb1m_TJDoEQ0VJIisrsldgeZbbHtBVPNHuSTCSPH4TQADRBdUQ","itemId":"jFo1UfZG6pqBFoBN/content","type":"content","hash":-10034513},"166V4y0k_--wSAI0ZPwSoDpdKFhGoBC-YQGXSL92OeBVwVPizEA":{"id":"166V4y0k_--wSAI0ZPwSoDpdKFhGoBC-YQGXSL92OeBVwVPizEA","itemId":"nXXCz6aLiQ6QA2QE","type":"file","hash":-1130154517},"1lrsPm6MnvADTAJ_owNQLkfL6_DyKERma6pSFiq3qngaAYxuLpQ":{"id":"1lrsPm6MnvADTAJ_owNQLkfL6_DyKERma6pSFiq3qngaAYxuLpQ","itemId":"nXXCz6aLiQ6QA2QE/content","type":"content","hash":1670452376},"1cySt8vstAAScqPxUvwsamBz33-EazTWkiJ_a-jILT9pP-weT_g":{"id":"1cySt8vstAAScqPxUvwsamBz33-EazTWkiJ_a-jILT9pP-weT_g","itemId":"3fRCd89AZkTI6CKF","type":"folder","hash":-896079416},"1r3DtzMBpPEfH2Q4BiRSt4i-1WARVibx1E3I_GwRmsCEa0TGXgw":{"id":"1r3DtzMBpPEfH2Q4BiRSt4i-1WARVibx1E3I_GwRmsCEa0TGXgw","itemId":"VifWnBgyL1lMo6QC","type":"file","hash":-1860720091},"1v2hcxoCzSQ1t8Np4zA4EtpdJLAYugpYMKBzQL5EIC6SNEgZCAA":{"id":"1v2hcxoCzSQ1t8Np4zA4EtpdJLAYugpYMKBzQL5EIC6SNEgZCAA","itemId":"rCaBeFyH6dZGb5Ou","type":"file","hash":1610790565},"1h6w0-oJX8B6sadaSgvgq1VszP-VE9EqoR-BcieyL6O6SX8L5KQ":{"id":"1h6w0-oJX8B6sadaSgvgq1VszP-VE9EqoR-BcieyL6O6SX8L5KQ","itemId":"RhDb97gjgmCAcjXo","type":"file","hash":563350625},"1apKa3OCZii7yIvKy4kp8KZSXWvAssoPKtmokP8TnOvnnlEDG_g":{"id":"1apKa3OCZii7yIvKy4kp8KZSXWvAssoPKtmokP8TnOvnnlEDG_g","itemId":"rCaBeFyH6dZGb5Ou/content","type":"content","hash":694047141},"1VPgLoE_YRuriG93RJGWjaUyIwJ9hokughHf_t3UzO1lXRe_dUw":{"id":"1VPgLoE_YRuriG93RJGWjaUyIwJ9hokughHf_t3UzO1lXRe_dUw","itemId":"RhDb97gjgmCAcjXo/content","type":"content","hash":864004048},"1QYCGWHC0dru5a6clwJsLpt_vh65YQ5edS2CZdyBTnc_H6QKDgw":{"id":"1QYCGWHC0dru5a6clwJsLpt_vh65YQ5edS2CZdyBTnc_H6QKDgw","itemId":"uvNLKPUHyvxwNYwJ","type":"folder","hash":-1927663762},"193-9klYPxCDg9Fv4InX0ufVe01x5b1WMSKlRZ8AkiKULfThW9A":{"id":"193-9klYPxCDg9Fv4InX0ufVe01x5b1WMSKlRZ8AkiKULfThW9A","itemId":"PV7SRqnI3929RHIh","type":"file","hash":-287033078},"1WisSzWRjsYloIWRy4CcLaPG1pLDmHFu_GtYaRySNjNGOaGbkCw":{"id":"1WisSzWRjsYloIWRy4CcLaPG1pLDmHFu_GtYaRySNjNGOaGbkCw","itemId":"VifWnBgyL1lMo6QC/content","type":"content","hash":-2103000658},"1-ldOAMdpacxvCuUQe_N8w7bZ2zDIV9LPpnQQK4iP8bL34zXaqA":{"id":"1-ldOAMdpacxvCuUQe_N8w7bZ2zDIV9LPpnQQK4iP8bL34zXaqA","itemId":"jfgRCpZEYsDIHUmY","type":"file","hash":1472692907},"194titDMoH82-_uoNaJMmlzohPlj01bbY6KUGJ90waohfy_jF2A":{"id":"194titDMoH82-_uoNaJMmlzohPlj01bbY6KUGJ90waohfy_jF2A","itemId":"31ixuwejQY1ahmSf/content","type":"content","hash":-2006659413},"1P_1q04UHZwn1TCErGFKephQXSdaC0CbtVoBG423aPmSL5_L75A":{"id":"1P_1q04UHZwn1TCErGFKephQXSdaC0CbtVoBG423aPmSL5_L75A","itemId":"PV7SRqnI3929RHIh/content","type":"content","hash":618744251},"161ZQDbrHfh5ZiSZfm7tBd8O96MHB74jeUV3I3hgrRtWa_qg5cQ":{"id":"161ZQDbrHfh5ZiSZfm7tBd8O96MHB74jeUV3I3hgrRtWa_qg5cQ","itemId":"jfgRCpZEYsDIHUmY/content","type":"content","hash":-1299799938},"1DgdtVMShaCwDudB1FiRwILZp9UIfVn2S_QuqvH1zqfDdgmdVbQ":{"id":"1DgdtVMShaCwDudB1FiRwILZp9UIfVn2S_QuqvH1zqfDdgmdVbQ","itemId":"d9OhY4avzY2oqiLM","type":"file","hash":1898645642},"1vBIcNKx-je-gjMX65-7wjpjtEIMUcLiIy80o0ejEqheAP54M8Q":{"id":"1vBIcNKx-je-gjMX65-7wjpjtEIMUcLiIy80o0ejEqheAP54M8Q","itemId":"d9OhY4avzY2oqiLM/content","type":"content","hash":1313762306},"1lkTw4EuqndVviO0a-xk5WQHtStaglkVJuhyMYwGvsAOWYGhWgw":{"id":"1lkTw4EuqndVviO0a-xk5WQHtStaglkVJuhyMYwGvsAOWYGhWgw","itemId":"wmLsksMuEWVovfap","type":"file","hash":-445600894},"15AwZlpB-Q6A3ChB2B6liiKU_4vWABHLt0pQ9XiEvDACR182LCw":{"id":"15AwZlpB-Q6A3ChB2B6liiKU_4vWABHLt0pQ9XiEvDACR182LCw","itemId":"ATRuUFMbG6IBvDuO","type":"file","hash":-1962525758},"1lL5rciNrnGONCSm_RKwaaQc38QYt7ka9uX1UorjQjcAu4vxqEw":{"id":"1lL5rciNrnGONCSm_RKwaaQc38QYt7ka9uX1UorjQjcAu4vxqEw","itemId":"CVoMq6D4LAjPbCG5","type":"file","hash":-998131506},"1zLFzzU6NTTbqHhBFSyPqwqXURYsnOvv-1ctjHtzemEMKl4HHEA":{"id":"1zLFzzU6NTTbqHhBFSyPqwqXURYsnOvv-1ctjHtzemEMKl4HHEA","itemId":"wmLsksMuEWVovfap/content","type":"content","hash":-843394477},"1LLlfQBClOWo4yYAVsvTn6lsqnKX83it8bVoE0A78cMBc0iPX-g":{"id":"1LLlfQBClOWo4yYAVsvTn6lsqnKX83it8bVoE0A78cMBc0iPX-g","itemId":"ATRuUFMbG6IBvDuO/content","type":"content","hash":-806935517},"1L1-9TQloNdJizmgD0wLCcWS5xGMjKJRxbJZ-lnZBIgfibTH9_g":{"id":"1L1-9TQloNdJizmgD0wLCcWS5xGMjKJRxbJZ-lnZBIgfibTH9_g","itemId":"CVoMq6D4LAjPbCG5/content","type":"content","hash":-935658516},"1A4HIhifHCVKKrLYgVk_hDH31h5WAbeNuRKWnCLg244bw74MKLQ":{"id":"1A4HIhifHCVKKrLYgVk_hDH31h5WAbeNuRKWnCLg244bw74MKLQ","itemId":"1N5zQwL2CvCdrU9B","type":"file","hash":126434083},"1GES98oPnjZKiy_jEusEGVPAuykhTlgEQbyfAzRagjoabVyqj8w":{"id":"1GES98oPnjZKiy_jEusEGVPAuykhTlgEQbyfAzRagjoabVyqj8w","itemId":"1N5zQwL2CvCdrU9B/content","type":"content","hash":-993497552},"1XmLHdzquQRkbdizIV00WblRXILNOAdDvKskpdUKVuAiZJ7_psQ":{"id":"1XmLHdzquQRkbdizIV00WblRXILNOAdDvKskpdUKVuAiZJ7_psQ","itemId":"JbeDoZUm857e8fdL","type":"file","hash":-162888804},"1YmZsZPlZGqBXla1AVVi8pmechqNhquCnh88YHQD_V7doP74_LA":{"id":"1YmZsZPlZGqBXla1AVVi8pmechqNhquCnh88YHQD_V7doP74_LA","itemId":"JbeDoZUm857e8fdL/content","type":"content","hash":-1535631988},"1fN72s1DZQUbOFd_SY2x4chpmxfFFJpmYOklx5l_UaU4NqPQZOg":{"id":"1fN72s1DZQUbOFd_SY2x4chpmxfFFJpmYOklx5l_UaU4NqPQZOg","itemId":"fklYIJyOheHqvfTa","type":"file","hash":1473401909},"131NLLNPQY1C7EUBNhDYMTYe7JDqi6fK_3a3MCBpleoFBADgBtA":{"id":"131NLLNPQY1C7EUBNhDYMTYe7JDqi6fK_3a3MCBpleoFBADgBtA","itemId":"fklYIJyOheHqvfTa/content","type":"content","hash":-2042661254},"1bCWyK1mo4ytYycsQ7kxBxLs1a1LuBZVKIj-mY9y4BsLYhijquA":{"id":"1bCWyK1mo4ytYycsQ7kxBxLs1a1LuBZVKIj-mY9y4BsLYhijquA","itemId":"v5e2bsf3UmIOg5eS","type":"folder","hash":-1361495365},"1LZJVZuye9rFJ0CjOIHzshxxzaBB_I6FtiZBsjMbtnp6g9PzR-A":{"id":"1LZJVZuye9rFJ0CjOIHzshxxzaBB_I6FtiZBsjMbtnp6g9PzR-A","itemId":"9TTmPv43PVpNQndV","type":"file","hash":-629901003},"1b2t6pe6ki2ih4Us4Lcvy8CrdO_o-QqC1qi5GlQwb7xn8rfdVww":{"id":"1b2t6pe6ki2ih4Us4Lcvy8CrdO_o-QqC1qi5GlQwb7xn8rfdVww","itemId":"AAphmch3Ge6p9ZRi","type":"folder","hash":1770523809},"1umFdwF4wEew2ZlMhYQQAS3Whxiw19_P9ii1muhoe34qS5puJWA":{"id":"1umFdwF4wEew2ZlMhYQQAS3Whxiw19_P9ii1muhoe34qS5puJWA","itemId":"9TTmPv43PVpNQndV/content","type":"content","hash":-2025598851},"1M-E1WMONWGtzLQfy_VgMgIrpZT6Fn9K2ZvdSCsvvps0_gvr5wQ":{"id":"1M-E1WMONWGtzLQfy_VgMgIrpZT6Fn9K2ZvdSCsvvps0_gvr5wQ","itemId":"9MtDBGhyQQWuisRx","type":"file","hash":-944260305},"1TcKraM9N7BegndMlTj0kRBMMDO_Ielr3YOcpVrCrHvrxi1NI3Q":{"id":"1TcKraM9N7BegndMlTj0kRBMMDO_Ielr3YOcpVrCrHvrxi1NI3Q","itemId":"O7ZdI0GnNZ8IGhYW","type":"file","hash":1167918583},"1ha4WYgW1n7FSv5H0cZUmIBH139JV5Q2cig01BdJSyQ7MU_zO5g":{"id":"1ha4WYgW1n7FSv5H0cZUmIBH139JV5Q2cig01BdJSyQ7MU_zO5g","itemId":"nZtkP309cM7hcqO2","type":"file","hash":1926168026},"1NbtNxMQMGGAcBiZ8pSmA0ADrhgzfNnA6CExIF-s_RHNC_0lS4w":{"id":"1NbtNxMQMGGAcBiZ8pSmA0ADrhgzfNnA6CExIF-s_RHNC_0lS4w","itemId":"QBAJWTNeLD7raJPY","type":"file","hash":-1707093168},"1Al-lqVEbl6KRxgvuHaWxXttb32G_M8Y1f8h2jWFKg_IW7HAwhg":{"id":"1Al-lqVEbl6KRxgvuHaWxXttb32G_M8Y1f8h2jWFKg_IW7HAwhg","itemId":"QBAJWTNeLD7raJPY/content","type":"content","hash":-113189089},"1314hgNNWwwvLgqjuyRAGVNG6RkuAY5Lu_DYeEeTk8Cb1Xdol_w":{"id":"1314hgNNWwwvLgqjuyRAGVNG6RkuAY5Lu_DYeEeTk8Cb1Xdol_w","itemId":"QO3PlLKwWnIiwVqK","type":"file","hash":-419803291},"1kTbF5_FwXy2yoSd01uv7xZzUTUa07aXmSyuk3K5i6hG8zDiHTQ":{"id":"1kTbF5_FwXy2yoSd01uv7xZzUTUa07aXmSyuk3K5i6hG8zDiHTQ","itemId":"ifp1fePK1xXUjFE4","type":"folder","hash":490725099},"1GDh_wfianAvRmUf808hWulAPzwyTA1hl1vsRQoYdkErmJ2N2vg":{"id":"1GDh_wfianAvRmUf808hWulAPzwyTA1hl1vsRQoYdkErmJ2N2vg","itemId":"9JHueTxb1xmg5ZXP","type":"file","hash":-2042484602},"1kGpITJzOlnUhjnZ3SIiNOok4DXeuHTdDqNLHJM1Ig1ZMaIcL-Q":{"id":"1kGpITJzOlnUhjnZ3SIiNOok4DXeuHTdDqNLHJM1Ig1ZMaIcL-Q","itemId":"dmRttHYhrK5WFmOh","type":"file","hash":1221122456},"1hjpDkkANTCq9q-TQBIyUzmXyBvmiC3s5f3GIGpakUf8TXA2LeQ":{"id":"1hjpDkkANTCq9q-TQBIyUzmXyBvmiC3s5f3GIGpakUf8TXA2LeQ","itemId":"mXfQrwQgdNgA8wLp","type":"file","hash":-1853804916},"1cKzYhw9Dyo_QwQR0LKZ6Z8SqLr3skRPAFkITYS-xjHkPgRxt1A":{"id":"1cKzYhw9Dyo_QwQR0LKZ6Z8SqLr3skRPAFkITYS-xjHkPgRxt1A","itemId":"7LHwr5vMhDvsF6qJ","type":"file","hash":-728470845},"1cnqoqLd3ZwZj9W603dbS4VJE7adPzaSazlDgMYcjmUimI6LoeA":{"id":"1cnqoqLd3ZwZj9W603dbS4VJE7adPzaSazlDgMYcjmUimI6LoeA","itemId":"7LHwr5vMhDvsF6qJ/content","type":"content","hash":1908325863},"1MLyvWHNYhufxAcbm4eM0qxoRMrUk11KbOorFoafdzzhm9Bu5bg":{"id":"1MLyvWHNYhufxAcbm4eM0qxoRMrUk11KbOorFoafdzzhm9Bu5bg","itemId":"Q6xmU68w98wuNklY","type":"folder","hash":247472303},"1d-uI7pw9yK0_2N65EBD9J5-0Dkx6r8l9jaJvGRNJ89mwAkNPBQ":{"id":"1d-uI7pw9yK0_2N65EBD9J5-0Dkx6r8l9jaJvGRNJ89mwAkNPBQ","itemId":"Fhx75tVk2bMRrChl","type":"file","hash":383351009},"1jCfCG92BxOidj7ZV8VGqPt5UuiqYLXGr0wWk_fAYARYE1wa-kw":{"id":"1jCfCG92BxOidj7ZV8VGqPt5UuiqYLXGr0wWk_fAYARYE1wa-kw","itemId":"RmtXmh2lrGLVBbOm","type":"folder","hash":-770356024},"1SC2oaL8QWh50K2rztbKSRFQmtJy_UGWZFA5QAW4asdMVDaJwxg":{"id":"1SC2oaL8QWh50K2rztbKSRFQmtJy_UGWZFA5QAW4asdMVDaJwxg","itemId":"dmRttHYhrK5WFmOh/content","type":"content","hash":-2021189248},"1Hu5yvYu9qevOoOgHKrSjHHVoIyxMsL7JHL7yysstwZBdyDIIpQ":{"id":"1Hu5yvYu9qevOoOgHKrSjHHVoIyxMsL7JHL7yysstwZBdyDIIpQ","itemId":"vznoAKrCVFYxkwJ0","type":"file","hash":1530715701},"1OWWIe7OQww5cJAxOAldBTbvV75mPn1BBtodqpM4D8AGTzdUbog":{"id":"1OWWIe7OQww5cJAxOAldBTbvV75mPn1BBtodqpM4D8AGTzdUbog","itemId":"LOPgwVDwC6boRNzS","type":"file","hash":438394593},"1LgkN0Tk8U2Ewl3ob17YUVzhzjE68BIkOL7sv05jUvZYVt6PUBQ":{"id":"1LgkN0Tk8U2Ewl3ob17YUVzhzjE68BIkOL7sv05jUvZYVt6PUBQ","itemId":"RTduSDZPEbBuUVtA","type":"file","hash":134441340},"1GtH_zhi5goKf1wcGRG7F21CUJxXcP923eBAcnHimkN1ryyvKBw":{"id":"1GtH_zhi5goKf1wcGRG7F21CUJxXcP923eBAcnHimkN1ryyvKBw","itemId":"9JHueTxb1xmg5ZXP/content","type":"content","hash":-1282855084},"1AVIh3AXx85Tdhx-HGKzSQcmXu8f8pelj12THPjO-2sPwIqaUrg":{"id":"1AVIh3AXx85Tdhx-HGKzSQcmXu8f8pelj12THPjO-2sPwIqaUrg","itemId":"2OTxNzpMQajxUPNa","type":"file","hash":711571155},"1MfSIOyr1Q36vU8VqP7JCpyfrwtO9sNCYbrbAT6e26zwIF1D8Pw":{"id":"1MfSIOyr1Q36vU8VqP7JCpyfrwtO9sNCYbrbAT6e26zwIF1D8Pw","itemId":"LOPgwVDwC6boRNzS/content","type":"content","hash":-1386190483},"17jjFH009x3sG_s0gO7vGQZ8cLWQd6_oYDMBDAXoLjkt1_jE0xw":{"id":"17jjFH009x3sG_s0gO7vGQZ8cLWQd6_oYDMBDAXoLjkt1_jE0xw","itemId":"ilIvoK9bdEIgCIvn","type":"folder","hash":-987818004},"1uJXv9hFSPTwMnnt-98ANKdwUgR2I1P5tJu6VndRwK-VQoah5fw":{"id":"1uJXv9hFSPTwMnnt-98ANKdwUgR2I1P5tJu6VndRwK-VQoah5fw","itemId":"Kl8goLjOCe4Y2iU1","type":"file","hash":1124753122},"1tzlNpCwnS28FBHUn6u3tYNFogJ2WKuNRrPkamPuZuWhGYyAI3A":{"id":"1tzlNpCwnS28FBHUn6u3tYNFogJ2WKuNRrPkamPuZuWhGYyAI3A","itemId":"2OTxNzpMQajxUPNa/content","type":"content","hash":-417076915},"17Aj617OqVrX-UmwV9wUD4jbehVgjjUfMmwIxWEi0guQ9jfBhng":{"id":"17Aj617OqVrX-UmwV9wUD4jbehVgjjUfMmwIxWEi0guQ9jfBhng","itemId":"vznoAKrCVFYxkwJ0/content","type":"content","hash":-1898327262},"15t8zuhOsaUlSBEH9Jy9rdtJ8PuncnbAE-hk56zl-sxyyGI57FA":{"id":"15t8zuhOsaUlSBEH9Jy9rdtJ8PuncnbAE-hk56zl-sxyyGI57FA","itemId":"Nz2EkixXKQGcuEag","type":"file","hash":-1667773645},"1C0xnFIrqTFErdVOMf1ZGGUK8vesWZ3mihbPXZ_-uiGA4ZBWeug":{"id":"1C0xnFIrqTFErdVOMf1ZGGUK8vesWZ3mihbPXZ_-uiGA4ZBWeug","itemId":"jCnq3Wvv7Hqcz9L7","type":"file","hash":-844714989},"1pl558HPCzOeqc_S8bJX_x5G-vU5JZt0P0Cb1u1Z1l3U18kL4SQ":{"id":"1pl558HPCzOeqc_S8bJX_x5G-vU5JZt0P0Cb1u1Z1l3U18kL4SQ","itemId":"jCnq3Wvv7Hqcz9L7/content","type":"content","hash":-1559413998},"1bHTSxdwndCGUhx84wddMBoDch-eBn3TGP1Z1v5TEy0sPD346Tg":{"id":"1bHTSxdwndCGUhx84wddMBoDch-eBn3TGP1Z1v5TEy0sPD346Tg","itemId":"MTb2rEZmbJruPLxT","type":"file","hash":817991584},"1XvUOVFm8XYZMBXR0fT0ouOudxzK2VCKiQaBL93TgeP8kvx67zw":{"id":"1XvUOVFm8XYZMBXR0fT0ouOudxzK2VCKiQaBL93TgeP8kvx67zw","itemId":"hsMOxKWCChERUD8N","type":"file","hash":1830740116},"1wGJbLYSsE3yj0CBKpVBlGE2_tEEna3vH7TOrz04EgoYGnEcAOQ":{"id":"1wGJbLYSsE3yj0CBKpVBlGE2_tEEna3vH7TOrz04EgoYGnEcAOQ","itemId":"Kl8goLjOCe4Y2iU1/content","type":"content","hash":-574971919},"12XhTh7YMFEZfISVU_U6K6mZ-bzhPoeA7BkxShoXifGU0MUBtog":{"id":"12XhTh7YMFEZfISVU_U6K6mZ-bzhPoeA7BkxShoXifGU0MUBtog","itemId":"EO4J8PI1VIfZ6v35","type":"file","hash":-17710833},"17ufTvsNGuIKAeUsv1TTbEUOiEB6g0iQtMxpLOyjNW6PjeKnolw":{"id":"17ufTvsNGuIKAeUsv1TTbEUOiEB6g0iQtMxpLOyjNW6PjeKnolw","itemId":"EO4J8PI1VIfZ6v35/content","type":"content","hash":-1440377866},"1EPKWMQtR1wxedzxvOHwKeOJSo_ciC6b1sFVkD5aN_NbuqLb6Uw":{"id":"1EPKWMQtR1wxedzxvOHwKeOJSo_ciC6b1sFVkD5aN_NbuqLb6Uw","itemId":"iXzCHT0T4V83pjgR","type":"file","hash":-1427231430},"1KycmOHCmoDGWl19y_w_IT2td37m1cqyuPdpHi3NgKLDsdU2-Ig":{"id":"1KycmOHCmoDGWl19y_w_IT2td37m1cqyuPdpHi3NgKLDsdU2-Ig","itemId":"iXzCHT0T4V83pjgR/content","type":"content","hash":-579796979},"1Y5CJsDKTAx3oGvfTlD9w5cKuTXJKBgGHbF9uuVYxmYhFA57gdw":{"id":"1Y5CJsDKTAx3oGvfTlD9w5cKuTXJKBgGHbF9uuVYxmYhFA57gdw","itemId":"OiVTXhxEC6PT4wfS","type":"file","hash":-59599085},"1fN8x4BKiFjahaTWIZAHVAuzJze1aBmu2j65S_eXRK3SjnbiAbw":{"id":"1fN8x4BKiFjahaTWIZAHVAuzJze1aBmu2j65S_eXRK3SjnbiAbw","itemId":"OiVTXhxEC6PT4wfS/content","type":"content","hash":-1707962216},"17xfdmp7-W_aIgmvLZJBKZ-_cj8aV4PaplY1jbr50QxSwT65lHA":{"id":"17xfdmp7-W_aIgmvLZJBKZ-_cj8aV4PaplY1jbr50QxSwT65lHA","itemId":"MviwGZUVucL3T4n8","type":"file","hash":1958157591},"1yANB0VR2nsTa1M5SmnMIWiQ_NN0kX9H0nwzSVM-TgX-mttnPSQ":{"id":"1yANB0VR2nsTa1M5SmnMIWiQ_NN0kX9H0nwzSVM-TgX-mttnPSQ","itemId":"MviwGZUVucL3T4n8/content","type":"content","hash":1344639622},"1IXocrI6qvGezcX-v1ej_3mjGe5Tg1NWVAJQcM84sX-tRjfWzew":{"id":"1IXocrI6qvGezcX-v1ej_3mjGe5Tg1NWVAJQcM84sX-tRjfWzew","itemId":"CnmO7dcKc1ZOG1KX","type":"folder","hash":-1736582659},"1DXh42gTakLJRQs0-T51Mi7Wo8IRZKXpwvVTOnjcMMSNQcDg0eQ":{"id":"1DXh42gTakLJRQs0-T51Mi7Wo8IRZKXpwvVTOnjcMMSNQcDg0eQ","itemId":"MRasIncXHMnDEsl4","type":"file","hash":1967568513},"1qJQ0X7LJlJAtxUGZ6oPA8gUbFuJsCOg9HRxI1taUvXoVr-LDFw":{"id":"1qJQ0X7LJlJAtxUGZ6oPA8gUbFuJsCOg9HRxI1taUvXoVr-LDFw","itemId":"MRasIncXHMnDEsl4/content","type":"content","hash":190355118},"1eb7Q2a_DcVIHNTdQCdq01uLWr-aR0ABwA8aOY8RZFetuz-j8-g":{"id":"1eb7Q2a_DcVIHNTdQCdq01uLWr-aR0ABwA8aOY8RZFetuz-j8-g","itemId":"9CXoipIqNc6euydo","type":"folder","hash":982274439},"11iyefka5A4OXe9riDTn0d2JfMRdvj8X30XvdT5hDT08O5XukpQ":{"id":"11iyefka5A4OXe9riDTn0d2JfMRdvj8X30XvdT5hDT08O5XukpQ","itemId":"00TrVRATmgNqHn1N","type":"file","hash":2041825287},"1bgcKKD_NQOsa4HorLF7DWPXBHu5ZVv20XCeJxI36fgv-kHdL0w":{"id":"1bgcKKD_NQOsa4HorLF7DWPXBHu5ZVv20XCeJxI36fgv-kHdL0w","itemId":"00TrVRATmgNqHn1N/content","type":"content","hash":-1011324602},"1URZ2vQyYwRXyJbdOYUiSVIFVWppcDemVSfOO7Bhn2F9q0vZdfg":{"id":"1URZ2vQyYwRXyJbdOYUiSVIFVWppcDemVSfOO7Bhn2F9q0vZdfg","itemId":"INiNbmVlPhYbw2lt","type":"file","hash":-20108622},"1x4_Axyi8k_YbcMXbmo-BonIPCf89Ne2gG0Mr00RJScMT1-Z98A":{"id":"1x4_Axyi8k_YbcMXbmo-BonIPCf89Ne2gG0Mr00RJScMT1-Z98A","itemId":"INiNbmVlPhYbw2lt/content","type":"content","hash":-894337863},"1lGPhbEsEtKsPwa6Ed2HWb7zKYBMth96kXahyeK5AjNsXujfztg":{"id":"1lGPhbEsEtKsPwa6Ed2HWb7zKYBMth96kXahyeK5AjNsXujfztg","itemId":"5wKp8vROJwBo4Sce","type":"file","hash":1133283443},"1st3q1m5nnKY7cFRUzqzIql97o0oeUGjXEVk2Wje-ytb7Fnj5fQ":{"id":"1st3q1m5nnKY7cFRUzqzIql97o0oeUGjXEVk2Wje-ytb7Fnj5fQ","itemId":"5wKp8vROJwBo4Sce/content","type":"content","hash":-1831956372},"1jFYGbdFgcgxhPPN0ELfoV6qDr853XDR3_DBVGUrODFb9cGZ1rA":{"id":"1jFYGbdFgcgxhPPN0ELfoV6qDr853XDR3_DBVGUrODFb9cGZ1rA","itemId":"74ZWcTXgBSlLBzjE","type":"file","hash":-1387829818},"1FmFgsFzraI8Y_lKo5xH135d1YxjWB-2QtkcfK3Lpe1k4z-6oWA":{"id":"1FmFgsFzraI8Y_lKo5xH135d1YxjWB-2QtkcfK3Lpe1k4z-6oWA","itemId":"FfQclKsMdVNJJRNd","type":"file","hash":-763503198},"1nGVdR7KKRFEf8gGu0EebNz6w-hp3UoPm8LdmFypDzAoumtleTQ":{"id":"1nGVdR7KKRFEf8gGu0EebNz6w-hp3UoPm8LdmFypDzAoumtleTQ","itemId":"FfQclKsMdVNJJRNd/content","type":"content","hash":1225997900},"1jQhlAa6dxTUUj_WUUc4ogj5ZJjPo3dDzoiGopoN6S2MT2-uXBw":{"id":"1jQhlAa6dxTUUj_WUUc4ogj5ZJjPo3dDzoiGopoN6S2MT2-uXBw","itemId":"ygsX3wnSWEPl4aQH","type":"file","hash":148505139},"1OrlbUcZfr9DkZSpvdourfgARE-JcrsdsnX2C4JNBI0z2bGJFTQ":{"id":"1OrlbUcZfr9DkZSpvdourfgARE-JcrsdsnX2C4JNBI0z2bGJFTQ","itemId":"ygsX3wnSWEPl4aQH/content","type":"content","hash":-1868238632},"1dktWKhl7mhXURILkrGI9hUUTVHVB4Ll6glxNTxAv0SwF1U6arw":{"id":"1dktWKhl7mhXURILkrGI9hUUTVHVB4Ll6glxNTxAv0SwF1U6arw","itemId":"Q630m9jJvuuKh53I","type":"file","hash":-1322068014},"1nfY2lmu3HY9lGYFYA3EQqdfEd3KPaQwO14kzrCzb3I1lMZKvDw":{"id":"1nfY2lmu3HY9lGYFYA3EQqdfEd3KPaQwO14kzrCzb3I1lMZKvDw","itemId":"RPnGLdVL2Co43fn3","type":"file","hash":1400539913},"1mWya9f3MC9YYylAYs_hLd32e525-WDsWPT9vK7jvRLq1XDbqjQ":{"id":"1mWya9f3MC9YYylAYs_hLd32e525-WDsWPT9vK7jvRLq1XDbqjQ","itemId":"WD9Bzi9mPGSI4cK9","type":"file","hash":-130428059},"1CnIDZST34VBZa0XP4W8K7TaHG3Mmb8_bWnpmffHbjU1xQOJrhQ":{"id":"1CnIDZST34VBZa0XP4W8K7TaHG3Mmb8_bWnpmffHbjU1xQOJrhQ","itemId":"RPnGLdVL2Co43fn3/content","type":"content","hash":1812622952},"1qkrz_sUetKCQh3kcXHTwsOPij51isoI8BsgHrEuUpdbrqVO0dQ":{"id":"1qkrz_sUetKCQh3kcXHTwsOPij51isoI8BsgHrEuUpdbrqVO0dQ","itemId":"WD9Bzi9mPGSI4cK9/content","type":"content","hash":-1863059686},"1sJNZI0K7lT7l80wpLIdaYYACLUMI81X98jRtC6CKWfk8HsOuSQ":{"id":"1sJNZI0K7lT7l80wpLIdaYYACLUMI81X98jRtC6CKWfk8HsOuSQ","itemId":"erk03SWntmHYKgf9","type":"file","hash":3361886},"1DWBfc63wY3s1HC0ZvrpWL13kW_xFSQUzlydELwOXDiaUPF39QA":{"id":"1DWBfc63wY3s1HC0ZvrpWL13kW_xFSQUzlydELwOXDiaUPF39QA","itemId":"bHqTE0XjV1KS586A/content","type":"content","hash":1609655638},"1KClnXHvscgOoWiTQ5qAhF8NGvFgxk4g0qZAx02TIsBnAEL1W_A":{"id":"1KClnXHvscgOoWiTQ5qAhF8NGvFgxk4g0qZAx02TIsBnAEL1W_A","itemId":"yUIaIw4G8JNVFyuC","type":"folder","hash":238656380},"1K-UyQNvm0pCeMbS4FuaABpRMvTT403KMG_DQhK_w5JvYyFPHaQ":{"id":"1K-UyQNvm0pCeMbS4FuaABpRMvTT403KMG_DQhK_w5JvYyFPHaQ","itemId":"eZPD4ts8Xo7mlluk","type":"file","hash":717566588},"1c22mjfBGcRVLMm2s_CDRLX9nGU1ApklIMWsEBkbg-ko-3jFxog":{"id":"1c22mjfBGcRVLMm2s_CDRLX9nGU1ApklIMWsEBkbg-ko-3jFxog","itemId":"bHqTE0XjV1KS586A","type":"file","hash":1332832744},"1N1NfSbS7gsc2xYNMnt1SS2VKPrTVub2wwhP2KGnxmP0dhIuQBw":{"id":"1N1NfSbS7gsc2xYNMnt1SS2VKPrTVub2wwhP2KGnxmP0dhIuQBw","itemId":"5xTVal0mYmIYU6Hk","type":"file","hash":547602361},"1wp_Km2d8r2yPmeMWaLByb5g6yBvH3jP8Hxd-cM8cA05Y3ojGvg":{"id":"1wp_Km2d8r2yPmeMWaLByb5g6yBvH3jP8Hxd-cM8cA05Y3ojGvg","itemId":"1nZnksY9YPlL4cyi","type":"file","hash":719377565},"1v9lv4LsxGarAVqZ3isE9MRYyGNjEbOyWeYnIe7F_f6FSM_GBBA":{"id":"1v9lv4LsxGarAVqZ3isE9MRYyGNjEbOyWeYnIe7F_f6FSM_GBBA","itemId":"yCviR51sRbUk47WF","type":"file","hash":-787832311},"182S2_xGMpLBDBWIhSg03apKU2gtgmCXS340cRzm7gkJ8Gexn5A":{"id":"182S2_xGMpLBDBWIhSg03apKU2gtgmCXS340cRzm7gkJ8Gexn5A","itemId":"nOITFWSLtVkWensy","type":"file","hash":-1182430455},"1dhp8VTQitX-eXqwPXos05tRpRDp6rJdUDjnlPtOlHVh0SPavnw":{"id":"1dhp8VTQitX-eXqwPXos05tRpRDp6rJdUDjnlPtOlHVh0SPavnw","itemId":"5xTVal0mYmIYU6Hk/content","type":"content","hash":169604087},"1Y2gr_9IISYxM9fXFGUTMFCtP3l8_1m82hbIBNdzcXoFfwrcGZQ":{"id":"1Y2gr_9IISYxM9fXFGUTMFCtP3l8_1m82hbIBNdzcXoFfwrcGZQ","itemId":"yCviR51sRbUk47WF/content","type":"content","hash":205511356},"1jzjWJ7UcEi5edm3bm31tLBFowWrgZEYzq_74vwF4EBNA6Z5j0Q":{"id":"1jzjWJ7UcEi5edm3bm31tLBFowWrgZEYzq_74vwF4EBNA6Z5j0Q","itemId":"nOITFWSLtVkWensy/content","type":"content","hash":476150886},"1JF5rhRvz-k1LjhnWHtNrxhUG5x1zXHb8OZZiU7d6wkEdGg59xg":{"id":"1JF5rhRvz-k1LjhnWHtNrxhUG5x1zXHb8OZZiU7d6wkEdGg59xg","itemId":"B30uFDwmYERr6MWH","type":"file","hash":-1103474593},"1q_gDBUINVfRH2IyNXkIjFpz0QTAl0KgfWQbLw8MBdNuGO5Afxg":{"id":"1q_gDBUINVfRH2IyNXkIjFpz0QTAl0KgfWQbLw8MBdNuGO5Afxg","itemId":"B30uFDwmYERr6MWH/content","type":"content","hash":-2016400467},"1-Nt9p73lpkEmePurG8k4d6QXWva2EHOJAu65GXa0qUMpqSAtcg":{"id":"1-Nt9p73lpkEmePurG8k4d6QXWva2EHOJAu65GXa0qUMpqSAtcg","itemId":"toS351vpmJre9cYC","type":"file","hash":-185651982},"117IwNcDLlvWA1p7R5U7Dfv7fIv6xAU-uqGVC9CGJv_oKzVLPMw":{"id":"117IwNcDLlvWA1p7R5U7Dfv7fIv6xAU-uqGVC9CGJv_oKzVLPMw","itemId":"toS351vpmJre9cYC/content","type":"content","hash":-757487084},"1pfhwwauyUQWAXB1JboYG1_Z3RL1T16A_0G3cCq4JsDFs5krgCQ":{"id":"1pfhwwauyUQWAXB1JboYG1_Z3RL1T16A_0G3cCq4JsDFs5krgCQ","itemId":"6L2BLz0U8N7KSVN2","type":"file","hash":-1355319522},"1azm5XwCwHsb7KzTHiuyb8QaiUqhYXNn10yRc3lMcVRW6l9Gu2w":{"id":"1azm5XwCwHsb7KzTHiuyb8QaiUqhYXNn10yRc3lMcVRW6l9Gu2w","itemId":"eZPD4ts8Xo7mlluk/content","type":"content","hash":-1951579964},"1qKVsLTwKmj1sGXXrDoJKQT7-CgfclvJAz0O_hb2mzUXqDLE2OA":{"id":"1qKVsLTwKmj1sGXXrDoJKQT7-CgfclvJAz0O_hb2mzUXqDLE2OA","itemId":"1nZnksY9YPlL4cyi/content","type":"content","hash":-1312876364},"1xIfoYiZYHC_bnysQ3EZjX_JNoNrWNNtU01Xx0i9fLAviKBdFtg":{"id":"1xIfoYiZYHC_bnysQ3EZjX_JNoNrWNNtU01Xx0i9fLAviKBdFtg","itemId":"6L2BLz0U8N7KSVN2/content","type":"content","hash":782466471},"1zrsCcNTFSzEjzbk5uJuOvlrgjLoEj2v5RpwBbg5CzdgHW_07UA":{"id":"1zrsCcNTFSzEjzbk5uJuOvlrgjLoEj2v5RpwBbg5CzdgHW_07UA","itemId":"G2bkxcGIHGuRm29Z","type":"folder","hash":-493875028},"1DZ2mjM18eq4y4313mMyDZjK4NBX9lnGD_L3Cc4UKY3lSvUSwAA":{"id":"1DZ2mjM18eq4y4313mMyDZjK4NBX9lnGD_L3Cc4UKY3lSvUSwAA","itemId":"QfcCQHZlB9I2iOQ0","type":"file","hash":2138921488},"1wIVT6mTFXR2d1_eh7blbpj3ges_tuHf861c9gahAEmzr2kYH6w":{"id":"1wIVT6mTFXR2d1_eh7blbpj3ges_tuHf861c9gahAEmzr2kYH6w","itemId":"WJFVWbFTBiUUqpiQ","type":"file","hash":1996085517},"14ZdqQXUZ4YWdU4Poc8OmePxo3dcSz8UbcBbh0gACXslz7-2WfA":{"id":"14ZdqQXUZ4YWdU4Poc8OmePxo3dcSz8UbcBbh0gACXslz7-2WfA","itemId":"fazmhohPrMfu2qvK","type":"file","hash":689709418},"1GfXRIRJtJqXxR1BCe3y8UEsZKV82zY0OT2_VGYkDfU5m_nG1vA":{"id":"1GfXRIRJtJqXxR1BCe3y8UEsZKV82zY0OT2_VGYkDfU5m_nG1vA","itemId":"WJFVWbFTBiUUqpiQ/content","type":"content","hash":-508047216},"1Oq3ziZfFKGeOrTlWx0VMJxxtwxsf83Do74c1vG-WDXgLBneQsw":{"id":"1Oq3ziZfFKGeOrTlWx0VMJxxtwxsf83Do74c1vG-WDXgLBneQsw","itemId":"QfcCQHZlB9I2iOQ0/content","type":"content","hash":-1675570753},"14T5cq0DI6qB6kGCsTnt2jo0JXwY8PuKBa51teI9y70gfhjwMcg":{"id":"14T5cq0DI6qB6kGCsTnt2jo0JXwY8PuKBa51teI9y70gfhjwMcg","itemId":"ZrlBGkPkFqYFyKak","type":"file","hash":283622914},"1gBSlyObCOFLhQ5g6T-IzYza26-hVPTD6ht78YqiBcdUPJlpH0Q":{"id":"1gBSlyObCOFLhQ5g6T-IzYza26-hVPTD6ht78YqiBcdUPJlpH0Q","itemId":"ZrlBGkPkFqYFyKak/content","type":"content","hash":2113864203},"1jyWZsf-Mxa_kEzxZx8EDmWAx2W2LfQD9UfaxeDRduKsSe28aBw":{"id":"1jyWZsf-Mxa_kEzxZx8EDmWAx2W2LfQD9UfaxeDRduKsSe28aBw","itemId":"aJrzklaPe7FlmPv5/content","type":"content","hash":1436715068},"1SwOJC17VWfWf9xcqPsBWc1bINHEbYw-K6ifJRCNVtvKqE6WcSg":{"id":"1SwOJC17VWfWf9xcqPsBWc1bINHEbYw-K6ifJRCNVtvKqE6WcSg","itemId":"aJrzklaPe7FlmPv5","type":"file","hash":1703094190},"16tFNwdq1Uli8f6axAlcruk-U_cXz_nLQNqq3bjIpRnGdyn9oaA":{"id":"16tFNwdq1Uli8f6axAlcruk-U_cXz_nLQNqq3bjIpRnGdyn9oaA","itemId":"fazmhohPrMfu2qvK/content","type":"content","hash":-436172038},"1DTbyS2bM-KH9vZKH29PoIvL6XugbtsfOH81iZGlj6fEqZOSGDA":{"id":"1DTbyS2bM-KH9vZKH29PoIvL6XugbtsfOH81iZGlj6fEqZOSGDA","itemId":"J3qxgGs4hhBbD0IK","type":"file","hash":-468813674},"14IUnifZBpXRdb1wiLpnFYiZMKcaHS_Hc3ujS5wgeBa8b--B9ig":{"id":"14IUnifZBpXRdb1wiLpnFYiZMKcaHS_Hc3ujS5wgeBa8b--B9ig","itemId":"6d0K7UYUnaJHcUwH","type":"file","hash":-1880298215},"1BCE0fKJxH5TkNsCyigTpgEssNp2OJrSVxU0_2qDQjPhGrOVApg":{"id":"1BCE0fKJxH5TkNsCyigTpgEssNp2OJrSVxU0_2qDQjPhGrOVApg","itemId":"6d0K7UYUnaJHcUwH/content","type":"content","hash":-1564742317},"1X0wxqb5u1x_IGp4PWovSZa__ve0B_zmXc-ILplGV7nc3toM9lg":{"id":"1X0wxqb5u1x_IGp4PWovSZa__ve0B_zmXc-ILplGV7nc3toM9lg","itemId":"J3qxgGs4hhBbD0IK/content","type":"content","hash":-525366682},"1mcWdBl519AZjsXwRRTv2eT0dUTWo0uY5v0CPl_bT7EYSQuQDcQ":{"id":"1mcWdBl519AZjsXwRRTv2eT0dUTWo0uY5v0CPl_bT7EYSQuQDcQ","itemId":"VCnzbwtUALknf6h2","type":"file","hash":2061585656},"1DUG4zz5i1_qKxbdJRo-PSHXcZBsWJMZl3Pc1mNKPpsBAtvAsBg":{"id":"1DUG4zz5i1_qKxbdJRo-PSHXcZBsWJMZl3Pc1mNKPpsBAtvAsBg","itemId":"VCnzbwtUALknf6h2/content","type":"content","hash":1276359454},"15MJktnLB95UEY1kN_aWIKzl_uMThYoRgEGsmwGl_tKN_RsPq4w":{"id":"15MJktnLB95UEY1kN_aWIKzl_uMThYoRgEGsmwGl_tKN_RsPq4w","itemId":"vVPdin3FmpSihQxj","type":"file","hash":-536505815},"1_MOW_IO32hrjaw1fMuJqHDmYqXVhanmeEPYjr5AmH5wp6wtCPg":{"id":"1_MOW_IO32hrjaw1fMuJqHDmYqXVhanmeEPYjr5AmH5wp6wtCPg","itemId":"vVPdin3FmpSihQxj/content","type":"content","hash":-789946578},"1RdA-QDcmsXufOi0o7epPx_YavOvq-_amKnVfQqTbAI1sTQq3vw":{"id":"1RdA-QDcmsXufOi0o7epPx_YavOvq-_amKnVfQqTbAI1sTQq3vw","itemId":"Wg83VoN5zGPoNo1y","type":"file","hash":665449523},"1OTCd3dCIq1so-BFkb1UvHUz9gVUrWBmfjOwlKOZoCrnjIVPQVQ":{"id":"1OTCd3dCIq1so-BFkb1UvHUz9gVUrWBmfjOwlKOZoCrnjIVPQVQ","itemId":"Wg83VoN5zGPoNo1y/content","type":"content","hash":-1068186218},"1on3HFMxXY8VHDEhzrpd0z7dIIKC4g1LVwIbBfqaf3FZfCUYjSg":{"id":"1on3HFMxXY8VHDEhzrpd0z7dIIKC4g1LVwIbBfqaf3FZfCUYjSg","itemId":"jfStBciYCU0re8LF","type":"file","hash":-440547963},"1xO0KSHdTTwsefBGrZKKBG-Ylyu-ONF5MAoS2U2ziNhIYDsPduA":{"id":"1xO0KSHdTTwsefBGrZKKBG-Ylyu-ONF5MAoS2U2ziNhIYDsPduA","itemId":"settings","type":"data","hash":-1377341055},"1xy3XCpqypITO1oLCga4eijjXH0VB-kDEZMC_DkmcU_S79_n2bA":{"id":"1xy3XCpqypITO1oLCga4eijjXH0VB-kDEZMC_DkmcU_S79_n2bA","itemId":"badgeCreations","type":"data","hash":50628595},"1MT_hquAZ7NqRDihzhWGTmRmRlhpAQ2Q1men6o6g4xrUxnpMwNA":{"id":"1MT_hquAZ7NqRDihzhWGTmRmRlhpAQ2Q1men6o6g4xrUxnpMwNA","itemId":"jfStBciYCU0re8LF/content","type":"content","hash":1354164374},"1nuC6VwMVI9s7wzSfnZaMYREvLzVj4wSNL5M61i0jLUEWWclCRw":{"id":"1nuC6VwMVI9s7wzSfnZaMYREvLzVj4wSNL5M61i0jLUEWWclCRw","itemId":"C0Q29ajZZPzh3Jcv","type":"file","hash":433435335},"19fE2K4rxUOsiLjstwrdzZgm8yWW74BodzS2vsOcDDV4gFfMseg":{"id":"19fE2K4rxUOsiLjstwrdzZgm8yWW74BodzS2vsOcDDV4gFfMseg","itemId":"C0Q29ajZZPzh3Jcv/content","type":"content","hash":-1243151226},"1D0aDRKhTv-WKwALp7Figb7oAjjmqc9S3j-d47tip0fRloy2o1Q":{"id":"1D0aDRKhTv-WKwALp7Figb7oAjjmqc9S3j-d47tip0fRloy2o1Q","itemId":"xJpL045jRDmgWJHa","type":"file","hash":399489278},"12V54Vyo980DpatYedFkEZ6TnHa3ETXe_E1yeT28XOimF-7q9eQ":{"id":"12V54Vyo980DpatYedFkEZ6TnHa3ETXe_E1yeT28XOimF-7q9eQ","itemId":"xJpL045jRDmgWJHa/content","type":"content","hash":-1977129061},"1-aMeu6XVXGZkV2I3Q7019oZqjje25c3GFaIZquM5opI7jdrmEA":{"id":"1-aMeu6XVXGZkV2I3Q7019oZqjje25c3GFaIZquM5opI7jdrmEA","itemId":"9MtDBGhyQQWuisRx/content","type":"content","hash":1042073771},"1CvmeudEC2AZdsbTavcP7-rL_RLo-oaXWha8c6KHc8SGpFdbIYA":{"id":"1CvmeudEC2AZdsbTavcP7-rL_RLo-oaXWha8c6KHc8SGpFdbIYA","itemId":"O7ZdI0GnNZ8IGhYW/content","type":"content","hash":1237047638},"1yaXu3LDDKh4swavZmKpftRuad1YVxBVlr2vzbCOy9ICTwKOtfQ":{"id":"1yaXu3LDDKh4swavZmKpftRuad1YVxBVlr2vzbCOy9ICTwKOtfQ","itemId":"nZtkP309cM7hcqO2/content","type":"content","hash":-71673329},"1VVk-UEhIW4OHXdeFLU0Li46LKR08o90lAgdLa8xBTOtf5z4j9A":{"id":"1VVk-UEhIW4OHXdeFLU0Li46LKR08o90lAgdLa8xBTOtf5z4j9A","itemId":"QO3PlLKwWnIiwVqK/content","type":"content","hash":378031675},"1s_zrgwvsxarTLjW9SLu8ewjcvzLs_U8mHFJ46XjOtluHrWBETA":{"id":"1s_zrgwvsxarTLjW9SLu8ewjcvzLs_U8mHFJ46XjOtluHrWBETA","itemId":"hsMOxKWCChERUD8N/content","type":"content","hash":248958273},"1IB5jmdZE--pDEQqbkGYCYb7d17bYPH4DoeRJmZxT2R8SQKfq5Q":{"id":"1IB5jmdZE--pDEQqbkGYCYb7d17bYPH4DoeRJmZxT2R8SQKfq5Q","itemId":"w6ADipsYQPt3OgNW","type":"file","hash":1538004554},"1g5FKPbARTgS7YkwXTgF4S7RI_2RGKRAOaghva9XHHhsS63PpWQ":{"id":"1g5FKPbARTgS7YkwXTgF4S7RI_2RGKRAOaghva9XHHhsS63PpWQ","itemId":"w6ADipsYQPt3OgNW/content","type":"content","hash":1392774314},"1hZR1v6Lvr3HVq29RmvEXZhqBA7n5DGgnzT8VlbG8V88zmVAnFg":{"id":"1hZR1v6Lvr3HVq29RmvEXZhqBA7n5DGgnzT8VlbG8V88zmVAnFg","itemId":"omFvrSXYtukeVixH","type":"file","hash":-1270418555},"1BD_l9a5RNrVCF_WVpM6vyK7seigAPClUxVBDaDr1HqaVnPw1RQ":{"id":"1BD_l9a5RNrVCF_WVpM6vyK7seigAPClUxVBDaDr1HqaVnPw1RQ","itemId":"omFvrSXYtukeVixH/content","type":"content","hash":1456159858},"147ZleneRutfSdtzUCnI_We6VcfK35QGV152PBE_qX4FfPUcuIQ":{"id":"147ZleneRutfSdtzUCnI_We6VcfK35QGV152PBE_qX4FfPUcuIQ","itemId":"C8kg3so81QVoun72","type":"file","hash":-217934907},"16Im_KJ9CTcQvCeKNHWM21ibQceGL2S_ckFb9ngIEe6RAwH1Evw":{"id":"16Im_KJ9CTcQvCeKNHWM21ibQceGL2S_ckFb9ngIEe6RAwH1Evw","itemId":"C8kg3so81QVoun72/content","type":"content","hash":-1059858459},"1Xur_oTEplCOyAkNPwQzVf5oDEC-vivMYKmllpVDymszI8KFp7A":{"id":"1Xur_oTEplCOyAkNPwQzVf5oDEC-vivMYKmllpVDymszI8KFp7A","itemId":"0jwjWW7L0cw2iQtV","type":"file","hash":-633421909},"1bDQTEGC-XRNP0J2Po_K8YaaO4dxjr6Y7i3q9ORFMJ3O5AVZU4Q":{"id":"1bDQTEGC-XRNP0J2Po_K8YaaO4dxjr6Y7i3q9ORFMJ3O5AVZU4Q","itemId":"VhXoCDuP9kB8fjSR","type":"file","hash":-342833628},"1Kl5HHVI1CmPf-txjtwvN1ZgVMmcyyTcg43GQmEQy3JBjU9cn9g":{"id":"1Kl5HHVI1CmPf-txjtwvN1ZgVMmcyyTcg43GQmEQy3JBjU9cn9g","itemId":"Bars6CC7H5Joqa8P","type":"file","hash":-1309533867},"1OCC9v5mAcl_LDGI0F8RoohTxodAFNqTDu7rXfUATJGFilgOByg":{"id":"1OCC9v5mAcl_LDGI0F8RoohTxodAFNqTDu7rXfUATJGFilgOByg","itemId":"VhXoCDuP9kB8fjSR/content","type":"content","hash":1835859566},"1Vg1iBBODk-JhjP0Gl5ceBMEG3IetTENP4mrnNBNecrMBHsTa6g":{"id":"1Vg1iBBODk-JhjP0Gl5ceBMEG3IetTENP4mrnNBNecrMBHsTa6g","itemId":"Bars6CC7H5Joqa8P/content","type":"content","hash":1816006844},"1fCP70jWUVFaBwR8NZHAPC8OvhqDAjI4RYKKsC5iN4elsZSGbtQ":{"id":"1fCP70jWUVFaBwR8NZHAPC8OvhqDAjI4RYKKsC5iN4elsZSGbtQ","itemId":"MTb2rEZmbJruPLxT/content","type":"content","hash":1920367372},"1IbBe7SE60-ViU-zyjxvfc-ftSRkaGDlYFn3f4IFUZcPb5unCbQ":{"id":"1IbBe7SE60-ViU-zyjxvfc-ftSRkaGDlYFn3f4IFUZcPb5unCbQ","itemId":"Nz2EkixXKQGcuEag/content","type":"content","hash":-66721485},"1-RatCF-qoxUirni86til4Ht-eEM-hvFSaLDqPoNmqtO5haOmwg":{"id":"1-RatCF-qoxUirni86til4Ht-eEM-hvFSaLDqPoNmqtO5haOmwg","itemId":"yZcqkNTKpThPrnfx","type":"file","hash":-826574305},"1Vl2WikGG78tB0ny6Apyvy9i5oQyAEg5bHbI2IjZSlKgrrUV4XQ":{"id":"1Vl2WikGG78tB0ny6Apyvy9i5oQyAEg5bHbI2IjZSlKgrrUV4XQ","itemId":"N72RguIezt8KuflR","type":"file","hash":-1550474622},"1Pm2iKCn4SdVnIj5-63yfIYoxerwtiiZYDaMRDL3efJSrhM-o0g":{"id":"1Pm2iKCn4SdVnIj5-63yfIYoxerwtiiZYDaMRDL3efJSrhM-o0g","itemId":"N72RguIezt8KuflR/content","type":"content","hash":1850828839},"18TO__nUHidyz5GY8SbSyqyyzy8tKsnsIHIk0F7bs_F-x4jeGDw":{"id":"18TO__nUHidyz5GY8SbSyqyyzy8tKsnsIHIk0F7bs_F-x4jeGDw","itemId":"0jwjWW7L0cw2iQtV/content","type":"content","hash":693119406},"1HmJqP3YPGkDym6IwmRHCjWd45t08Vblumy958t6zFpfW1XBnsQ":{"id":"1HmJqP3YPGkDym6IwmRHCjWd45t08Vblumy958t6zFpfW1XBnsQ","itemId":"VQOgcLROQ4ay0oXW","type":"file","hash":-1270869832},"1z212JpkowManmFgT_HAOAs0FJSNYCoLhaCRJ9NVcuaQz3kZ36A":{"id":"1z212JpkowManmFgT_HAOAs0FJSNYCoLhaCRJ9NVcuaQz3kZ36A","itemId":"VQOgcLROQ4ay0oXW/content","type":"content","hash":1047674723},"1Knw-kWZ3oAsEPZ_PHgGybfILHiLkucu-d3T6jsNhYQgEIbu2yw":{"id":"1Knw-kWZ3oAsEPZ_PHgGybfILHiLkucu-d3T6jsNhYQgEIbu2yw","itemId":"yZcqkNTKpThPrnfx/content","type":"content","hash":57789330},"1CHCtJMlMpmhHA_dxE6cF8sOfzvg7GG5HemF85MeGPZeG53t0Cg":{"id":"1CHCtJMlMpmhHA_dxE6cF8sOfzvg7GG5HemF85MeGPZeG53t0Cg","itemId":"06MckntYpMDISZ8b","type":"file","hash":-33819402},"1mcH74u410-hRC6Oh4nuF5eMmDg4AfdWpYjaqoBly6RB8WW9ClA":{"id":"1mcH74u410-hRC6Oh4nuF5eMmDg4AfdWpYjaqoBly6RB8WW9ClA","itemId":"Fr15DxYxCrywoW1c","type":"file","hash":958220234},"1fkktu_ne053dbBwRYBBw_Cm48h1_dExVJ_ZvzdUZjh0n2y-CTQ":{"id":"1fkktu_ne053dbBwRYBBw_Cm48h1_dExVJ_ZvzdUZjh0n2y-CTQ","itemId":"HImeteZ1A700ZipO","type":"file","hash":-470289772},"1RymBkorJEqtmnKejqXM4oKV5SYxQgxKVli8OnDUH4kwv_SU9Fw":{"id":"1RymBkorJEqtmnKejqXM4oKV5SYxQgxKVli8OnDUH4kwv_SU9Fw","itemId":"HImeteZ1A700ZipO/content","type":"content","hash":-993301318},"1lioV-JrbfTlQEpv6YO7P3idvybUlDAYFY9TqBQQQ_gdGBQXKcQ":{"id":"1lioV-JrbfTlQEpv6YO7P3idvybUlDAYFY9TqBQQQ_gdGBQXKcQ","itemId":"miFoxjEkLW2xg652","type":"file","hash":-150538633},"1ZRBD6hXt4CcDX6qbKS72ot9ejJLO6J92nO6o2_sO8Ynf9m7DqA":{"id":"1ZRBD6hXt4CcDX6qbKS72ot9ejJLO6J92nO6o2_sO8Ynf9m7DqA","itemId":"1hoxohbjUViggy6d","type":"file","hash":-1144560792},"1wJ3O3Wd9FpSskPXvHwSTqxAWmaQdn1-v0n8xNyDodnFR7A2aFw":{"id":"1wJ3O3Wd9FpSskPXvHwSTqxAWmaQdn1-v0n8xNyDodnFR7A2aFw","itemId":"06MckntYpMDISZ8b/content","type":"content","hash":-1794458094},"1dw-cDnZfzjxhcjIfQPneAOQ3FU0MfhZI203sDU44AJynjVKwtg":{"id":"1dw-cDnZfzjxhcjIfQPneAOQ3FU0MfhZI203sDU44AJynjVKwtg","itemId":"miFoxjEkLW2xg652/content","type":"content","hash":-1886577830},"17WWM0L7AG82gfiTQ8mWlbg-RIHMHX0JcX1XxYQdP499Wjc7YMg":{"id":"17WWM0L7AG82gfiTQ8mWlbg-RIHMHX0JcX1XxYQdP499Wjc7YMg","itemId":"Q630m9jJvuuKh53I/content","type":"content","hash":962145358},"17coRpsP3cZOI3CPOPbAvtTmMRm-UR93ZXpse06_HHebP_3aEtw":{"id":"17coRpsP3cZOI3CPOPbAvtTmMRm-UR93ZXpse06_HHebP_3aEtw","itemId":"Fhx75tVk2bMRrChl/content","type":"content","hash":-1804965264},"16Jsh-y2cNmeps29z8UMBJ6kvTMVCCXETMa2L7fs4XzMAdOhjpQ":{"id":"16Jsh-y2cNmeps29z8UMBJ6kvTMVCCXETMa2L7fs4XzMAdOhjpQ","itemId":"vCSdbkmBz8WS1NuE","type":"file","hash":-1648545240},"1TNSIyWyEppATF8Z12ZJRL3mJvH9zTw2TVquKFymaWZOOUJwwGw":{"id":"1TNSIyWyEppATF8Z12ZJRL3mJvH9zTw2TVquKFymaWZOOUJwwGw","itemId":"vCSdbkmBz8WS1NuE/content","type":"content","hash":2018250629},"1lJxFlhIw7mCp3YzQRcPcEVsaM003IKoQFUuV_RmHnaVcF3_UEA":{"id":"1lJxFlhIw7mCp3YzQRcPcEVsaM003IKoQFUuV_RmHnaVcF3_UEA","itemId":"1hoxohbjUViggy6d/content","type":"content","hash":568030896},"1Lq9LZSdrfO9UdZ4nMDusL5Yfnm7CEnQEfh5h5CXfFHPSI2rUHw":{"id":"1Lq9LZSdrfO9UdZ4nMDusL5Yfnm7CEnQEfh5h5CXfFHPSI2rUHw","itemId":"RTduSDZPEbBuUVtA/content","type":"content","hash":-1437351472},"1c276SdwapTc5AYYbn9pxrQpgvnJwT7XCIEIjyZTVerPKuxBIdA":{"id":"1c276SdwapTc5AYYbn9pxrQpgvnJwT7XCIEIjyZTVerPKuxBIdA","itemId":"OZdRQujNaQC3tGVz","type":"folder","hash":1880686003},"12yif83BVcYweGPJDJA8ytGQuxOGSH-iHEp6rkN5gb-N8xohdMQ":{"id":"12yif83BVcYweGPJDJA8ytGQuxOGSH-iHEp6rkN5gb-N8xohdMQ","itemId":"X3mDwXGkmeIJpTbt","type":"file","hash":-1486931830},"1w4qOUUsjsN8oRVLhZcUKjts3yqkpde2DjDRnHt6V9Q9-gX14GA":{"id":"1w4qOUUsjsN8oRVLhZcUKjts3yqkpde2DjDRnHt6V9Q9-gX14GA","itemId":"X3mDwXGkmeIJpTbt/content","type":"content","hash":-842766002},"1FovmI23HMX97_GE03itD_Um0kpRrj5k8cH6LK-GRYJad-D6G2A":{"id":"1FovmI23HMX97_GE03itD_Um0kpRrj5k8cH6LK-GRYJad-D6G2A","itemId":"s15Pyg21tX1o16W5","type":"file","hash":1478414972},"17xoMY-OnwVhVcJiKMCqmlf_FJFix11aB8xrl2WkOUXcKTx6b-Q":{"id":"17xoMY-OnwVhVcJiKMCqmlf_FJFix11aB8xrl2WkOUXcKTx6b-Q","itemId":"74ZWcTXgBSlLBzjE/content","type":"content","hash":-858899268},"1WUBXO1YjT44FvSGfSJKnj4UTRIPMWuhYyskih1j_7dsnarPetw":{"id":"1WUBXO1YjT44FvSGfSJKnj4UTRIPMWuhYyskih1j_7dsnarPetw","itemId":"s15Pyg21tX1o16W5/content","type":"content","hash":1093891315},"1GjgDzp5wsCEiWJToVVJ140jyOoDMX7PnT1RMXgDb4atjxGBR4w":{"id":"1GjgDzp5wsCEiWJToVVJ140jyOoDMX7PnT1RMXgDb4atjxGBR4w","itemId":"Fr15DxYxCrywoW1c/content","type":"content","hash":-28015155},"1DAYZI4PwN89dFsVqWwGmXmBalV5BwWeAw0kiLHQg-SLbjqzKFw":{"id":"1DAYZI4PwN89dFsVqWwGmXmBalV5BwWeAw0kiLHQg-SLbjqzKFw","itemId":"ZQ1P22aGt9pYBZQY","type":"file","hash":485630579},"1G3O4pvrHt1AzJseM37np8sos7CvTnw3Yd5kH3S4MKKFkxYFQ9A":{"id":"1G3O4pvrHt1AzJseM37np8sos7CvTnw3Yd5kH3S4MKKFkxYFQ9A","itemId":"ZQ1P22aGt9pYBZQY/content","type":"content","hash":655151792},"1DwcJuT-zoinCuJ4N8HkWAMEXT_jvpfZqYpauDh9KlGO0UG_6yA":{"id":"1DwcJuT-zoinCuJ4N8HkWAMEXT_jvpfZqYpauDh9KlGO0UG_6yA","itemId":"ADbe6HrECGC5ROmU","type":"file","hash":-615749766},"1XOnJHxk957-ygeOa90Ax1IYJ74WXwgjHia9Lh2Ybo3HB7YUgDw":{"id":"1XOnJHxk957-ygeOa90Ax1IYJ74WXwgjHia9Lh2Ybo3HB7YUgDw","itemId":"ADbe6HrECGC5ROmU/content","type":"content","hash":1104898847},"1Tl74iKCmifM5MGu7NRXV6DCRRmw8SsHEex1AOnYPO-YTnWhRyw":{"id":"1Tl74iKCmifM5MGu7NRXV6DCRRmw8SsHEex1AOnYPO-YTnWhRyw","itemId":"aisCZOCBzm0r8Jcd","type":"folder","hash":-1056679373},"1u-NQqQr2mn5wfaQphnVaj9fVJTWp7D-sLDH9cuTEBk9Ba4UteA":{"id":"1u-NQqQr2mn5wfaQphnVaj9fVJTWp7D-sLDH9cuTEBk9Ba4UteA","itemId":"1yvS1owczbvG7a0y","type":"file","hash":81267180},"1zal9-HYTw_T5sdt6jkZwRrRtygsvgx00tYIBfPW6wMHXnu-ApA":{"id":"1zal9-HYTw_T5sdt6jkZwRrRtygsvgx00tYIBfPW6wMHXnu-ApA","itemId":"1yvS1owczbvG7a0y/content","type":"content","hash":-671205607},"1wvmUM4cIli2EHethJVxYJExESLoqyBA5LTNKvbZ5bAu79X_vfw":{"id":"1wvmUM4cIli2EHethJVxYJExESLoqyBA5LTNKvbZ5bAu79X_vfw","itemId":"2DVrg5MrmpVbUmh6","type":"file","hash":-1507183113},"1wHBNdW9CuJ9-Dem1Qyhr35mddhfNCqvVIxu-1IBM6bPedmc88w":{"id":"1wHBNdW9CuJ9-Dem1Qyhr35mddhfNCqvVIxu-1IBM6bPedmc88w","itemId":"erk03SWntmHYKgf9/content","type":"content","hash":991426833},"10ME6saYm27ksJHv5gPu3pZosb0kQdtJXvkNtyGW_75-UE2yoFA":{"id":"10ME6saYm27ksJHv5gPu3pZosb0kQdtJXvkNtyGW_75-UE2yoFA","itemId":"kRBjdpE8Q87pKDBk","type":"file","hash":1802560240},"1HC7-IbuT8sLvDv0bDGJV1ouymaX6Wa2kDqWJnJU75cBicVCp6Q":{"id":"1HC7-IbuT8sLvDv0bDGJV1ouymaX6Wa2kDqWJnJU75cBicVCp6Q","itemId":"2DVrg5MrmpVbUmh6/content","type":"content","hash":84187449},"1nS97gaUiDmZNGw-LLHGlgRjMJ0TCBWl7JxzM17th6Uq_HJcr-g":{"id":"1nS97gaUiDmZNGw-LLHGlgRjMJ0TCBWl7JxzM17th6Uq_HJcr-g","itemId":"kRBjdpE8Q87pKDBk/content","type":"content","hash":-2069828085},"1Z0rnidnmawWRF2VekITLIkYUkIz2UlcUlu3LRXYH51D5X8spKQ":{"id":"1Z0rnidnmawWRF2VekITLIkYUkIz2UlcUlu3LRXYH51D5X8spKQ","itemId":"mXfQrwQgdNgA8wLp/content","type":"content","hash":-1861693998},"1Bt-8sXOoFYkzOQS5P9-_HfxHi9GzvHdl0_HpVqfclf6Xot3JYg":{"id":"1Bt-8sXOoFYkzOQS5P9-_HfxHi9GzvHdl0_HpVqfclf6Xot3JYg","itemId":"wTK8ucAfkpXnll6C/content","type":"content","hash":1817930387},"1VWO3PFQxPYgALzDsFYOxuhCaUyLDW8jftRj04gtgxWjhIHbamQ":{"id":"1VWO3PFQxPYgALzDsFYOxuhCaUyLDW8jftRj04gtgxWjhIHbamQ","itemId":"wTK8ucAfkpXnll6C","type":"file","hash":-565878985},"1BylXiKYZSz6laWingWtRa2MfPvdSbUAYN4Rto3fNJHCcpiJJwQ":{"id":"1BylXiKYZSz6laWingWtRa2MfPvdSbUAYN4Rto3fNJHCcpiJJwQ","itemId":"ZRhtnSudyGKoaxuf","type":"folder","hash":-1217854062},"1rUzIRR6F4QlTU9iyFJrOcAqig8-ajapVC9J0IaF67nIkOoRVCA":{"id":"1rUzIRR6F4QlTU9iyFJrOcAqig8-ajapVC9J0IaF67nIkOoRVCA","itemId":"QCDOYp9baGlX0tfx/content","type":"content","hash":-1048238512},"1U-pJVB5n1FJsm36be29hDxeuGgpOPavuePUsazIeVzO6DQbupA":{"id":"1U-pJVB5n1FJsm36be29hDxeuGgpOPavuePUsazIeVzO6DQbupA","itemId":"QCDOYp9baGlX0tfx","type":"file","hash":227589682},"1eXsV5CENrDl8hLQD_jH_WTW1tR8Z2QuGIkofTH-XI7DY0xaJmA":{"id":"1eXsV5CENrDl8hLQD_jH_WTW1tR8Z2QuGIkofTH-XI7DY0xaJmA","itemId":"sXFUuwDsSBfhbhTA/content","type":"content","hash":242318855},"1ZZ8iPHDzs6M94LSclrTXRDWiY0WgrgnOpmbt1AgyZdAzkAtWZw":{"id":"1ZZ8iPHDzs6M94LSclrTXRDWiY0WgrgnOpmbt1AgyZdAzkAtWZw","itemId":"sXFUuwDsSBfhbhTA","type":"file","hash":2088949104},"1tk4hoG5LYAg4B1zUZsHk7gBL0OY6BbYmiiKWyoH85PfWdFd1lg":{"id":"1tk4hoG5LYAg4B1zUZsHk7gBL0OY6BbYmiiKWyoH85PfWdFd1lg","itemId":"fxktNjN7Qbqln352/content","type":"content","hash":-796006271},"1HiXzy6sPkQEfcb3JfgQHkwdOEuze8AigJgwSmWLYQDanc5XurA":{"id":"1HiXzy6sPkQEfcb3JfgQHkwdOEuze8AigJgwSmWLYQDanc5XurA","itemId":"fxktNjN7Qbqln352","type":"file","hash":1563382647},"1FPIeWw8S824VM6tSniKIGfr9BGxgpJnBwkXHlwyZ9QrcgBeqmA":{"id":"1FPIeWw8S824VM6tSniKIGfr9BGxgpJnBwkXHlwyZ9QrcgBeqmA","itemId":"GOOIxoNi3E7Gqydq","type":"folder","hash":614592570},"181BJd52e9eZ81k_RJkQRIroBjGVa0LolbHOd7F5qXOSYIHAPNg":{"id":"181BJd52e9eZ81k_RJkQRIroBjGVa0LolbHOd7F5qXOSYIHAPNg","itemId":"jeNuMwclaWKHJJjy/content","type":"content","hash":2103678661},"1yFrgw64SX9CTxTYEowemVgPDpsr_U9CtzpRyBz8OXyj60v1kow":{"id":"1yFrgw64SX9CTxTYEowemVgPDpsr_U9CtzpRyBz8OXyj60v1kow","itemId":"jeNuMwclaWKHJJjy","type":"file","hash":-486387373},"1U5ZRTjZR4uFwkTO3ucqKzAlmtXuVpem37Wh0e4M1lwmNu_dJng":{"id":"1U5ZRTjZR4uFwkTO3ucqKzAlmtXuVpem37Wh0e4M1lwmNu_dJng","itemId":"14iOQ0JTNwFklzQv/content","type":"content","hash":502730339},"1StGXWYseUy4XWaMQfa_wQMuwcvGcSnF3zhd1DPHRic2PBKzJ3Q":{"id":"1StGXWYseUy4XWaMQfa_wQMuwcvGcSnF3zhd1DPHRic2PBKzJ3Q","itemId":"14iOQ0JTNwFklzQv","type":"file","hash":-1055952409},"1v_I8HIOTLkYJKcyfMUjowT-yLgnsSJGAhWC2U5hzoabBFqknzw":{"id":"1v_I8HIOTLkYJKcyfMUjowT-yLgnsSJGAhWC2U5hzoabBFqknzw","itemId":"g55C7cqcezctQpDW/content","type":"content","hash":497818810},"1bXdgvs8LWofZ3v44rVPMSx_buPDvY7vuPAPHQGRDlyQB20omPw":{"id":"1bXdgvs8LWofZ3v44rVPMSx_buPDvY7vuPAPHQGRDlyQB20omPw","itemId":"g55C7cqcezctQpDW","type":"file","hash":-2062028810},"12ronKh0xanB1ysg95JmZ9fhh2U75nAnIRAuUrwH3m4llPNDGdQ":{"id":"12ronKh0xanB1ysg95JmZ9fhh2U75nAnIRAuUrwH3m4llPNDGdQ","itemId":"WuPlnrI0KwyoPStA","type":"folder","hash":-1147569050},"1zInf3iaoN4PS6IPXipT-Eo8HAdJp75BB1q3j3mwGFoRnhnxbaA":{"id":"1zInf3iaoN4PS6IPXipT-Eo8HAdJp75BB1q3j3mwGFoRnhnxbaA","itemId":"oX7d6ygndZcITdfY","type":"folder","hash":2015629247},"124fSVGRvNfs3TcqwBtVfTZE66RoysHVdKJULsRNp4EpewVAoEA":{"id":"124fSVGRvNfs3TcqwBtVfTZE66RoysHVdKJULsRNp4EpewVAoEA","itemId":"i2J5V4CA691bc9Lh","type":"folder","hash":119422516},"1sBWDNGzZ3_K7e2U4vTcK8HaG_qdx0Uuh5ndFDrF-g5Sm42HAQQ":{"id":"1sBWDNGzZ3_K7e2U4vTcK8HaG_qdx0Uuh5ndFDrF-g5Sm42HAQQ","itemId":"VLaa02Loo6VepSNT/content","type":"content","hash":-533018811},"1YhskkRaLfjqAR-1IJLv-8RywgY48-ty8i_yWYkaCsrnvUWNdwA":{"id":"1YhskkRaLfjqAR-1IJLv-8RywgY48-ty8i_yWYkaCsrnvUWNdwA","itemId":"VLaa02Loo6VepSNT","type":"file","hash":28468121},"1QRz56JOrCxrZ-F8DdOQmAuxy5TS4Vq7AC0YYJCyK8bEJ6gZtFg":{"id":"1QRz56JOrCxrZ-F8DdOQmAuxy5TS4Vq7AC0YYJCyK8bEJ6gZtFg","itemId":"UTqUor48bR0Yp1Bc","type":"folder","hash":926160078},"1PJrcRGTO8E08sig2b5gjcCVwjyZSYgMpoBS_L7gmqvAAD1ahMA":{"id":"1PJrcRGTO8E08sig2b5gjcCVwjyZSYgMpoBS_L7gmqvAAD1ahMA","itemId":"by4gQGx95Mp30v8Z/content","type":"content","hash":538047454},"1FGn04zyCtdd0QTdxs3dE3DN_cuDK4pduKfLubc07iVCJI__Lvg":{"id":"1FGn04zyCtdd0QTdxs3dE3DN_cuDK4pduKfLubc07iVCJI__Lvg","itemId":"by4gQGx95Mp30v8Z","type":"file","hash":1860942447},"1rMPgjYPIEv-UqGNTrjXyF34BoZejHNZUDL-Ob95QAC7j9hXjPg":{"id":"1rMPgjYPIEv-UqGNTrjXyF34BoZejHNZUDL-Ob95QAC7j9hXjPg","itemId":"rJtXtpzzHWYRjcMJ/content","type":"content","hash":1833545718},"1DwJB5Gy3YARWZ5yGUfCQQV4-ABMCOKMDXzTZm1Q_x2GHydZh3Q":{"id":"1DwJB5Gy3YARWZ5yGUfCQQV4-ABMCOKMDXzTZm1Q_x2GHydZh3Q","itemId":"rJtXtpzzHWYRjcMJ","type":"file","hash":831223729},"1GNq-UfJE1V_yD5Psul2yA_mfqb9R9rOOrVuj_ZXgzm8DmHQkew":{"id":"1GNq-UfJE1V_yD5Psul2yA_mfqb9R9rOOrVuj_ZXgzm8DmHQkew","itemId":"Rkbhu5EBtxTalmMn/content","type":"content","hash":-917011965},"1DXP68btAw74xsximvOZMsTfZn8LNu4aJeFMnFi6Gl7yIFHhKiQ":{"id":"1DXP68btAw74xsximvOZMsTfZn8LNu4aJeFMnFi6Gl7yIFHhKiQ","itemId":"Rkbhu5EBtxTalmMn","type":"file","hash":-1796259372},"1uuUY7vkiePALunVPpEgFc6xw9_WEhJabFXy03ZTjKIjS_AFGwA":{"id":"1uuUY7vkiePALunVPpEgFc6xw9_WEhJabFXy03ZTjKIjS_AFGwA","itemId":"8IFmCnOfvma2Povc/content","type":"content","hash":-1008769167},"1Lw9WuUh90u3qUwXdG1sdh8hARLWgJCLzbdREFMdnU0j5_Yb5NA":{"id":"1Lw9WuUh90u3qUwXdG1sdh8hARLWgJCLzbdREFMdnU0j5_Yb5NA","itemId":"8IFmCnOfvma2Povc","type":"file","hash":677307406}},"hash":-601537034,"tx":20199},"8IFmCnOfvma2Povc/syncedContent":{"id":"8IFmCnOfvma2Povc/syncedContent","type":"syncedContent","historyData":{"-1008769167":{"id":"8IFmCnOfvma2Povc/content","type":"content","text":"---\npermalink: /2024-03-28-정보처리기사 실기 Java 문제 모음/\npublished: true\ntitle: \"[정처기] 정보처리기사 실기 Java 문제 모음\"\ndate: 2024-03-28 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"정보처리기사 실기 Java 문제 모음\"\ncategories:\n- Spring\ntags:\n- Spring\n---\n\n<br><br>\n\n## ✅ 정보처리기사 Java 문제 모음\n\n####  📌 다음은 Java 코드이다. 올바른 출력 결과를 작성하시오. ( 23년 3회 ) \n<br>\n\n```java\nclass Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-2);\n    }\n}\n \nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-3);\n    }\n}\n \npublic class main {\n    public static void main(String args[]) {\n        Parent obj = new Child();\n        System.out.print(obj.compute(7));\n    }\n}\n```\n<br>\n\n> 정답 : 2  \n\n \n\n\n```\ncompute(6) + compute(4)\n= compute(5) + compute(3) + compute(3) + compute(1)\n= compute(4) + compute(2) + compute(2) + compute(0) + compute(2) + compute(0) + 1\n= compute(3) + compute(1) + compute(1) + compute(-1) + compute(1) + compute(-1) + compute(1) + compute(-1) + 1\n= compute(2) + 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1\n= compute(1) - 1 + 1 - 1 + 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 \n= 2\n```\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음 자바 코드를 실행할 경우 에러가 발생이 된다. 에러가 발생하는 라인명을 작성하시오. ( 23년 3회 )\n<br>\n\n```java\n1\t\tclass Person {\n2\t\t    private String name;\n3\t    \tpublic Person(String val) {\n4        \t\tname = val;\n5    \t\t}\n6    \t\tpublic static String get() {\n7    \t\t\treturn name;\n8    \t\t}\n9    \t\tpublic void print() {\n10        \t\tSystem.out.println(name);\n11    \t\t}\n12\t\t}\n13\n14\t\tpublic class main {\n15    \t\tpublic static void main(String[] args) {\n16        \t\tPerson obj = new Person(\"Kim\");\n17        \t\tobj.print();\n18    \t\t}\n19\t\t}\n```\n\n<br>\n\n> 정답 : 7\n\n```\n`name`은 인스턴스 변수이고, `get()`은 static 메서드이기 때문에 \nstatic 메서드인 `get()`에서는 name에 접근할 수 없다.\n```\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음은 JAVA 코드 문제이다. 가지고 있는 돈이 총 4620원일 경우 1000원, 500원, 100원, 10원의 지폐 및 동전을 이용하여 보기의 조건에 맞춰 최소한의 코드를 통해 괄호안을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```\n<보기>\n변수 : m\n연산자 : / , %  \n괄호 : [ , ] , ( , )   \n정수 : 1000, 500, 100, 10\n```\n\n```java\npublic class Problem {\n\n    public static void main(String[] args){\n\t\t \n\t\t m = 4620;\n \n\t\t a = (              );\n\t\t b = (              );\n\t\t c = (              );\n\t\t d = (              );\n \n\t\t System.out.println(a); //천원짜리 4장 출력\n\t\t System.out.println(b); //오백원짜리 1개 출력\n\t\t System.out.println(c); //백원짜리 1개 출력\n\t\t System.out.println(d); //십원짜리 2개 출력\n    }\n}\n```\n\n\n<br>\n\n> 정답 :  \nm / 1000  \n(m % 1000) % 500  \n(m % 500) / 100  \n(m % 100) / 10  \n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌  다음은 자바에 대한 문제이다. 알맞은 출력값을 작성하시오. ( 23년 2회 )\n<br>\n\n```java\npublic class Main{\n    public static void main(String[] args) {\n        \n        String str1 = 'Programming';\n        String str2 = 'Programming';\n        String str3 = new String('Programming');\n        \n        println(str1==str2)\n        println(str1==str3)\n        println(str1.equals(str3))\n        print(str2.equals(str3))\n    }\n}\n```\n\n<br>\n\n> 정답 :  \n> true  \n> false  \n> true  \n> true  \n\n<br><br><br><br><br><br>\n\n\n\n####  📌**아래 자바 코드에서 출력되는 값을 작성하시오. ( 23년 1회 )**\n<br>\n\n```java\nclass Static{\n    public int a = 20;\n    static int b = 0;\n}\n \npublic class Main{\n    public static void main(String[] args) {\n        \n        int a;\n        a = 10;\n        Static.b = a;\n \n        Static st = new Static();\n \n        System.out.println(Static.b++);\n        System.out.println(st.b);\n        System.out.println(a);\n        System.out.print(st.a);\n    }\n}\n```\n\n<br>\n\n> 정답 :  \n10  \n11  \n10  \n20  \n\n```\nstatic 변수는 클래스 변수이므로 클래스 내에서는 값이 공유된다.\n```\n\n<br><br><br><br><br><br>\n\n\n\n####  📌다음 코드에서 괄호안에 알맞는 값을 변수명으로 작성하시오. ( 23년 1회 )\n\n<br>\n\n\n```java\npublic class Sort {\n \n    public static void swap(int[] arr, int idx1, int idx2){\n        int temp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[( 1 )] = temp;\n    }\n \n    public static void Usort(int[] array, int length){\n        for (int i = 0; i < length; i++) {\n            for (int j = 0; j < length - i - 1; j++) {\n                if (array[j] > array[j + 1]) {\n                    swap(array, j, j + 1);\n                }\n            }\n        }\n    }\n \n    public static void main(String[] args) {\n        int[] item = new int[] { 5, 3, 8, 1, 2, 7 };\n        int nx = 6;   \n        Usort(item, ( 2 ));\n \n        for (int data : item) {\n            System.out.print(data + \" \");\n        }\n    }\n}\n```\n\n```\n출력값 : 1 2 3 5 7 8\n```\n\n<br>\n\n> 정답 :  \n> (1) temp  \n> (2) item.length\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌**다음 JAVA 코드에서 알맞는 출력 값을 작성하시오.** ( 23년 1회 )\n<br>\n\n```java\nabstact class Vehicle {\n \n    String name;\n    abstract public String getName(String val);\n \n    public String getName() {\n            return \"Vehicle name: \" + name;\n    }\n}\n \n \n \nclass Car extends Vehicle {\n \n    public Car(String val) {\n            name= super.name =val;\n    }\n \n    public String getName(String val) {\n            return \"Car name:\" + val;\n    }\n \n    public String getName(byte val[]) {\n            return \"Car name:\" + val;\n    }\n}\n \n \npublic class Main {\n \n    public static void main(String[] args) {\n \n    Vehicle obj = new Car(\"Spark\");\n    System.out.println(obj.getName());\n \n    }\n}\n```\n\n<br>\n\n> 정답 :  Vehicle name : Spark\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌**다음 자바 코드에 대한 출력 값을 작성하시오.**\n<br>\n\n```java\nclass Parent {\n    int x = 100;\n \n    Parent() {\n        this(500);\n    }\n \n    Parent(int x) {\n        this.x = x;\n    }\n \n    int getX() {\n        return x;\n    }\n}\n \nclass Child extends Parent {\n    int x = 4000;\n    \n    Child() {\n        this(5000);\n    }\n \n    Child(int x) {\n        this.x = x;\n    }\n}\n \npublic class Main {\n    public static void main(String[] args) {\n        Child obj = new Child();\n        System.out.println(obj.getX());\n    }\n}\n```\n\n<br>\n\n> 정답 : 500\n\n```\n1. Child obj = new Child() 에서 Child클래스의 obj객체를 생성\n2. Child클래스의 생성자인 Child() 호출\n3. this(5000)은 Child(5000)을 호출\n4. 때문에 Child클래스의 x=5000이 됨.\n5. obj.getX() 호출\n6. Child클래스에는 getX()메서드가 없고, 부모클래스인 Parent클래스의 getX() 실행\n7. Parent 클래스의 생성자인 Parent() 호출\n8. this(500)은 Parent(500) 호출\n9. this.x = x를 실행하므로 Parent클래스의 x=500이 됨.\n10. getX() return 500; \n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 **다음 자바 코드에 대한 출력 값을 작성하시오.** ( 22년 3회 )\n\n<br>\n\n```java\npublic class Main {\n  static int[] MakeArray(){\n \n\t  int[] tempArr = new int[4];\n  \n\t  for(int i=0; i<tempArr.length;i++){\n\t    tempArr[i] = i;\n\t  }\n  \n\t  return tempArr;\n  }\n  \n  public static void main(String[] args){\n  \n\t  int[] intArr;\n\t  intArr = MakeArray();\n  \n\t  for(int i=0; i < intArr.Length; i++)\n\t\t  System.out.print(intArr[i]);\n  }\n}\n```\n\n<br>\n\n> 정답 : 0123\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 **다음 자바 코드에 대한 출력 값을 작성하시오.** ( 22년 3회 )\n```java\npublic class Exam {\n\tpublic static void main(String[] args){\n  \n\t\tint a = 0;\n\t\tfor(int i=1; i<999; i++){\n\t\t\tif(i%3==0 && i%2!=0)\n\t\t\t\ta = i;\n\t\t}\t\t\n\t    System.out.print(a);\n    }\n}\n```\n\n<br>\n\n> 정답 : 993\n\n```\n3의 배수이면서 짝수가 아닌 수를 찾으면 된다.\n6n+3 (n>=0)을 만족하면서 값이 998보다 작은 수는 993이다.\n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌**다음 자바 코드에 대한 출력 값을 작성하시오.** ( 22년 2회 )\n<br>\n\n```java\npublic static void main(String args[]){\n  \n\tint i = 3;\n\tint k = 1;\n\t\n\tswitch(i) { \n\t    case 1: k += 1;\n\t    case 2: k++;\n\t    case 3: k = 0; \n\t    case 4: k += 3; \n\t    case 5: k -= 10; \n\t    default: k--; \n\t}\n  System.out.print(k);\n}\n```\n<br>\n\n> 정답 : -8\n\n```\n아주 비겁한 실수유도 문제.\nswitch(3)으로 시작해서 k=0; 으로 끝날듯 하지만,\nbreak;문이 case마다 선언되어 있지않기때문에\ncase3, case4, case5, default 모두 실행된다.\n따라서 k = -8\n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 **다음 자바코드에서 알맞는 출력값을 작성하시오.** ( 22년 1회 )\n\n<br>\n\n```java\nclass A {\n  int a;\n  int b;\n}\n  \n  public class Main {\n  \n\tstatic void func1(A m){\n\t\tm.a *= 10;\n\t}\n  \n\tstatic void func2(A m){\n\t\tm.a += m.b;\n\t}\n  \n  public static void main(String args[]){\n  \n  A m = new A();\n  \n  m.a = 100;\n  func1(m);\n  m.b = m.a;\n  func2(m);\n  \n  System.out.printf(\"%d\", m.a);\n  \n  }\n}\n```\n\n<br>\n\n> 정답 : 2000\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음 Java 코드 중에서 밑줄에 들어갈 알맞는 코드를 작성하시오. ( 22년 1회 )\n\n<br>\n\n```java\nclass Car implements Runnable{\n\tint a;\n  \n\tpublic void run(){\n\t\tsystem.out.println(\"message\")\n\t}\n}\n  \npublic class Main{\n\tpublic static void main(String args[]){\n\t\tThread t1 = new Thread(new ___());\n\t\tt1.start();\n\t}\n}\n```\n\n<br>\n\n> 정답 : Car\n\n```\nThread클래스의 생성자에는 Runnable 인터페이스를 구현한 객체가 필요한데,\n\nCar클래스에서 Runnable 인터페이스를 구현하고 있으므로 Car객체가 필요하다.\n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌**다음 Java 코드에 대한 알맞는 출력값을 쓰시오. ( 21년 3회 )**\n\n<br>\n\n```java\nclass Connection {\n\tprivate static Connection _inst = null;\n\tprivate int count = 0;\n\n\tstatic public Connection get() {\n\t\tif (_inst == null) {\n\t\t\t_inst = new Connection();\n\t\t\treturn _inst;\n\t\t}\n\t\treturn _inst;\n\t}\n\n\tpublic void count() {\n\t\tcount++;\n\t}\n\n\tpublic int getCount() {\n\t\treturn count;\n\t}\n}\n\npublic class testcon {\n\tpublic static void main(String[] args) {\n\t\tConnection conn1 = Connection.get();\n\t\tconn1.count();\n\t\tConnection conn2 = Connection.get();\n\t\tconn2.count();\n\t\tConnection conn3 = Connection.get();\n\t\tconn3.count();\n\n\t\tSystem.out.print(conn1.getCount());\n\t}\n}\n```\n\n<br>\n\n> 정답 : 3\n\n```\n1. 먼저 private static Connection _inst = null;은 static 메소드이므로\n   클래스 내에서는 값이 공유된다.\n2. Connection conn1 = Connection.get();을 실행하면 최초 _inst는 null\n   이므로 _inst = new Connection()이 실행되고, _inst를 return한다.\n3. conn1.count()는 count를 1로 만든다.\n4. Connection conn2 = Connection.get(); 실행시 _inst는 static 메소드\n   이므로 conn1 생성때 생성된 객체를 공유한다.\n5. 때문에 conn2.count()를 실행하면 conn1의 count과 값을 공유하여\n   count = 2가 된다.\n6. 마찬가지로 count = 3이되고, conn1.getCount()를 하면 3이 출력된다.\n```\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 **다음 Java 코드에 대한 알맞는 출력값을 쓰시오. (21년 3회 )**\n\n<br>\n\n```java\npublic class testco {\n\t public static void main(String[] args) {\n\t\t  int a = 3, b = 4, c = 3, d = 5;\n\t\t  if((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d)) {\n\t\t\t   a = b + c;\n\t\t\t    if(7 == b ^ c != a) {\n\t\t\t\t     System.out.println(a);\n\t\t\t\t    } else {\n\t\t\t\t\t    System.out.println(b);\n\t\t\t\t\t    }\n\t\t\t  } else {\n\t\t\t\t    a = c + d;\n\t\t\t\t    if(7 == c ^ d != a) {\n\t\t\t\t\t    System.out.println(a);\n\t\t\t\t\t    } else {\n\t\t\t\t\t\t    System.out.println(d);\n\t\t\t\t\t\t    }\n\t\t\t\t  }\n\t\t }\n}\n```\n\n<br>\n\n> 정답 : 7\n\n```\n[비트 연산자]\n& : 이진수 기준 같은 자리를 비교했을 때 값이 같으면 1(True) / 다르면 0(False)\n| : 이진수 기준 같은 자리를 비교했을 때 하나라도 1이면 1 / 아니면 0\n^ : 이진수 기준 같은 자리를 비교했을 때 값이 다르면 1 / 같으면 0\n\nif((a ==  2  | a == c)  &  !(c > d)  &  (1  == b ^ c != d))\n=> if( (F | T) & !F & (F ^ T)\n=> if( T & T & T ) 이므로 true\n따라서 a = b + c = 7;\n\nif(7  == b ^ c != a)\n=> if( F ^ T )\n=> if( true ) 이므로\nSystem.out.println(a); 실행 // a=7\n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음은 JAVA 관한 문제이다. 알맞는 출력값을 작성하시오. ( 21년 2회 )\n\n<br>\n\n```java\npublic class over1 {\n\tpublic static void main(String[] args){\n    \tovr a1 = new ovr1();\n        ovr a2 = new ovr2();\n        System.out.println(a1.sun(3,2) + a2.sun(3,2));\n    }\n    \n    int sun(int x, int y){\n    \treturn x + y;\n    }\n}\n\nclass ovr2 extends ovr1 {\n\n\tint sun(int x, int y){\n    \treturn x - y + super.sun(x,y);\n    }\n\n}\n```\n\n<br>\n\n> 정답 : 11\n\n```\na1.sun(3,2) = 5\na2.sun(3,2) = 3 - 2 + super.sun(3,2) = 1 + \n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1008769167}},"syncHistory":{"main":[-1008769167,-1008769167,null]},"v":1,"hash":1712799396236,"tx":20201},"CHjCxs4lbndBbawK":{"id":"CHjCxs4lbndBbawK","type":"folder","name":"ELK","parentId":null,"hash":-72223597,"tx":20204},"bZrfx6XKev82ul2h/syncedContent":{"id":"bZrfx6XKev82ul2h/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1713311416140,"tx":20208},"bZrfx6XKev82ul2h":{"id":"bZrfx6XKev82ul2h","type":"file","name":"2024-04-17-LogStash(로그스태시)란","parentId":"CHjCxs4lbndBbawK","hash":1646575685,"tx":20282},"1nZnksY9YPlL4cyi/contentState":{"id":"1nZnksY9YPlL4cyi/contentState","type":"contentState","selectionStart":63,"selectionEnd":63,"scrollPosition":{"sectionIdx":44,"posInSection":0.17777777777777778},"hash":1713333132212,"tx":20439},"RXviSkk9OEup22my":{"id":"RXviSkk9OEup22my","type":"file","name":"2024-04-18-ElasticSearch(엘라스틱서치)란","parentId":"CHjCxs4lbndBbawK","hash":-1165166581,"tx":22720},"RXviSkk9OEup22my/syncedContent":{"id":"RXviSkk9OEup22my/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1713402488051,"tx":22720},"bZrfx6XKev82ul2h/content":{"id":"bZrfx6XKev82ul2h/content","type":"content","text":"---\npermalink: /2024-04-17-LogStash(로그스태시)란/\npublished: true\ntitle: \"[ELK] LogStash(로그스태시)란? \"\ndate: 2024-04-17 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"LogStash(로그스태시)란?\"\ncategories:\n- ELK\ntags:\n- ELK\n- LogStash\n---\n<br><br><br>\n\n\n\n## ✅ LogStash(로그스태시)란?\n\nLogStash는 실시간 파이프라인 기능을 갖춘 **오픈 소스 데이터 수집 엔진**이다. LogStash는 **서로 다른 소스의 데이터**를 **동적으로 통합**하고 해당 데이터를 **원하는 대상으로 정규화**할 수 있다.\n\nLogStash는 원래 로그 수집을 위한 목적으로 사용됐지만, 현재는 로그 수집을 넘어서 훨씬 많은 기능을 위해 사용된다. 다양한 범위의 input, output, filter를 통해 많은 유형의 이벤트를 변환 할 수 있으며, 데이터 수집 프로세스를 단순화 한다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logstash1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br><br>\n\n## ✅ LogStash의 동작 방식\n\nLogStash 이벤트 처리 파이프라인은 **inputs -> filters -> outputs**의 세 단계로 구성된다. inputs은 이벤트를 생성하고, filters는 이벤트를 수정하며, outputs은 이벤트를 다른곳으로 전달한다. LogStash의 입출력은 데이터가 파이프라인에 들어오거나 나갈 때 데이터를 인코딩/디코딩 할 수 있는 코덱을 지원한다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logstash2.png?raw=true\">\n</p>\n\n<br><br><br>\n\n### 📌 Inputs ( 입력 )\n<hr>\n데이터는 여러시스템에 다양한 형태로 보관된 경우가 많은데, LogStash는 다양한 소스에서 이벤트를 동시에 가져오는 input 플러그인을 광범위하게 지원한다. 로그, 메트릭, 웹, DB저장소, AWS 등에서 데이터를 수집할 수 있다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logstash3.svg?raw=true\">\n</p>\n\n<br>\n\n- **file** : UNIX명령어인 `tail -0F` 처럼 파일시스템에서 파일을 읽어온다.\n- **syslog** : 514포트를 통해 syslog 메시지를 읽어오고 RFC3164 포맷에 따라 구분한다.\n- **redis** : redis 채널과 redis 목록을 모두 사용하여 redis 서버로부터 읽어온다. \n- **[beats](https://www.elastic.co/guide/en/logstash/7.6/plugins-inputs-beats.html)** : Beats에서 보낸 이벤트를 처리한다. \n\n\n```ruby\n# input으로 beat사용\ninput {\n  beats {\n    port => 5044\n    host => \"0.0.0.0\"\n    client_inactivity_timeout => 86400\n  }\n}\n```\n- **jdbc** : JDBC 데이터를 통해 이벤트를  생성한다.\n\n[LogStash의  Input 플러그인](https://www.elastic.co/guide/en/logstash/7.6/input-plugins.html)은 이외에도 굉장히 많고 필요에 따라 골라서 사용하면 된다.\n\n\n\n\n\n<br><br><br><br><br>\n\n### 📌 Filters ( 필터 )\n<hr>\n필터는 LogStash 파이프라인의 중간 처리 장치이다. 필터를 조건과 결합하여 특정 기준을 충족하는 경우 이벤트에 대한 작업을 수행할 수 있다. 데이터가 소스에서 저장소로 이동하는 과정에서 **각 이벤트를 구문 분석하고 명명된 필드를 식별하여 구조를 구축하며, 이를 공통 형식으로 변환 통합하여 분석한다.** 자주 쓰이는 필터는 다음과 같다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logstash4.svg?raw=true\">\n</p>\n\n<BR>\n\n- **[grok](https://www.elastic.co/guide/en/logstash/7.6/plugins-filters-grok.html)** : 임의의 텍스트를 분석하고 구조화한다. 현재 LogStash에서 구조화되지 않은 로그데이터를 구조화하고 구문 분석하는 가장 좋은 방법이다. \n\n```ruby\nfilter {\n    grok {\n        match => { \"message\" => \n        \"%{IP:client} %{WORD:method} %{URIPATHPARAM:request} \n        %{NUMBER:바이트} %{NUMBER:기간}\" \n        } \n    } \n}\n```\n<BR>\n\n- **[mutate](https://www.elastic.co/guide/en/logstash/7.6/plugins-filters-mutate.html)** : 이벤트의 필드 이름 변경, 제거, 수정 등의 변환을 수행한다.\n\n```ruby\nfilter {\n    mutate {\n        split => [\"hostname\", \".\"]\n        add_field => { \"shortHostname\" => \"%{hostname[0]}\" }\n    }\n\n    mutate {\n        rename => [\"shortHostname\", \"hostname\" ]\n    }\n}\n```\n이 구성은 원래의 `hostname` 필드를 점(`.`)으로 구분하여 분할한 후 첫 번째 부분을 `shortHostname` 필드에 추가하고, 마지막으로 `shortHostname` 필드의 이름을 다시 `hostname`으로 변경한다. 이렇게 함으로써, 예를 들어 `example.com`에서 `example`만 추출하여 `hostname` 필드에 저장하는 것과 같은 작업을 수행한다.\n\n<BR>\n\n```ruby\nfilter {\n  mutate {\n    remove_field => ['@version','es_contents','@timestamp']    \n    add_field => {\n      \"pk\" => \"%{kedcd}\"\n    }   \n  }\n}\n```\n위 코드는 `@version`,`es_contents'`,`@timestamp`라는 필드를 삭제하고, `pk`라는 필드를 추가하며 `pk`필드의 값으로는 `kedcd` 필드 값을 사용한다는 의미이다. 한마디로 kedcd필드를 pk필드에 복사하겠다는 의미와 같다.\n\n<br>\n\n\n- **drop** : 이벤트를 완전히 삭제한다.\n\n\n```ruby\nfilter {\n\tif [loglevel] == \"debug\" {\n\t    drop { }\n\t}\n}\n```\n`loglevel` 필드의 값이 debug인 경우 이벤트를 삭제하겠다는 것을 의미한다.\n\n\n- **clone** : 이벤트의 복사본을 만들고 필드를 추가하거나 제거할 수 있다.\n- **geoip** : IP주소의 지리적 위치에 대한 정보를 추가한다.\n\n<br>\n\n[LogStash의 filter 플러그인](https://www.elastic.co/guide/en/logstash/7.6/filter-plugins.html) 역시 굉장히 많으므로 필요에 따라 공식문서 등을 참고하여 활용하면 된다.\n\n\n<br><br><br><br><br>\n\n### 📌 Outputs ( 출력 ) \n<hr>\noutput은 LogStash 파이프라인의 마지막 단계이다. 간단하게 생각하면 LogStash에서 전처리한 데이터를 **어디에** 전송해줄지 결정해주는 영역이라고 볼 수 있다. 대표적으로 **ElasticSearch**를 자주 사용한다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logstash5.svg?raw=true\">\n</p>\n\n<br>\n\n- **elasticsearch** : Elasticsearch로 데이터를 전송한다. 효율적이고 쉽게 쿼리 형태로 데이터를 전송할 수 있는 방법이다.\n\n```ruby\noutput {\n\telasticsearch {\n\t    hosts => [\"http://IP주소:포트번호\"]\n\t    index => \"ElasticSearch에 저장될 인덱스명\"\n\t    user => \"사용자 이름\"\n\t    document_id => \"문서ID\"\n\t    password => \"ElasticSearch에 연결할 때 사용할 암호\"\n\t}\n}\n```\n\n\n\n\n- **file** : 디스크의 파일에 이벤트 데이터를 작성해준다.\n\n- **graphite** : 데이터를 저장하고 그래프로 표시하는 용도로 사용되는 오픈소스 graphite로 데이터를 전송한다.\n\n\n\n<br><br><br><br><br><br><br>\n\n## ✅ LogStash의 Config\n\nInput, Filter, Output에 대한 설정은 `conf` 파일에 작성해서 저장하면 된다. 이벤트 마다 다른 `conf`파일을 작성하면 되고, `example.conf` 와 같은 형태로 만들면 된다.\n\n```ruby\n# This is a comment. You should use comments to describe\n# parts of your configuration.\ninput {\n  ...\n}\n\nfilter {\n  ...\n}\n\noutput {\n  ...\n}\n``` \n\n<br><br><br>\n\n### 📌 LogStash Conf파일 예제\n<hr>\n\n```ruby\ninput {\n  # 파일에서 로그 데이터를 읽어오는 설정\n  file {\n    path => \"/var/log/nginx/access.log\"  # 읽어올 로그 파일 경로\n    start_position => \"beginning\"        # 파일을 처음부터 읽기\n    sincedb_path => \"/dev/null\"          # sincedb 파일을 사용하지 않음\n  }\n\n  # JDBC를 사용하여 데이터베이스에서 데이터를 읽어오는 설정\n  jdbc {\n    jdbc_driver_library => \"/path/to/mysql-connector-java.jar\"  # JDBC 드라이버 라이브러리 경로\n    jdbc_driver_class => \"com.mysql.jdbc.Driver\"                # 사용할 JDBC 드라이버 클래스\n    jdbc_connection_string => \"jdbc:mysql://localhost:3306/database_name\"  # 데이터베이스 연결 문자열\n    jdbc_user => \"username\"                                     # 데이터베이스 사용자 이름\n    jdbc_password => \"password\"                                 # 데이터베이스 비밀번호\n    statement => \"SELECT * FROM table_name\"                     # 실행할 쿼리문\n    jdbc_paging_enabled => true                                 # 페이징 활성화\n    jdbc_page_size => 1000                                     # 페이지 크기\n  }\n\n  # Kafka로부터 데이터를 수신하는 설정\n  kafka {\n    bootstrap_servers => \"localhost:9092\"  # Kafka 브로커의 호스트 및 포트\n    topics => [\"topic_name\"]                # 구독할 토픽 이름\n    group_id => \"logstash_consumer_group\"   # 컨슈머 그룹 ID\n    codec => json                           # 데이터 형식 (JSON 등)\n  }\n}\n\nfilter {\n  # 파일 및 JDBC input에 대한 공통 필터링 및 구문 분석\n  if [input_type] == \"file\" or [input_type] == \"jdbc\" {\n    grok {\n      match => { \"message\" => \"%{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \\\"%{WORD:method} %{URIPATHPARAM:request} HTTP/%{NUMBER:httpversion}\\\" %{NUMBER:response} %{NUMBER:bytes}\" }\n    }\n    date {\n      match => [ \"timestamp\", \"dd/MMM/yyyy:HH:mm:ss Z\" ]\n    }\n  }\n\n  # 파일 input에 대한 추가 필터\n  if [input_type] == \"file\" {\n    mutate {\n      add_field => { \"source_type\" => \"nginx_access_log\" }\n    }\n  }\n\n  # JDBC input에 대한 추가 필터\n  if [input_type] == \"jdbc\" {\n    mutate {\n      add_field => { \"source_type\" => \"database_table\" }\n    }\n  }\n\n  # Kafka input에 대한 추가 필터\n  if [input_type] == \"kafka\" {\n    mutate {\n      add_field => { \"source_type\" => \"kafka_topic\" }\n    }\n  }\n\n  # 필요에 따라 추가적인 필터링 및 필드 조작 작업을 수행할 수 있습니다.\n\n  # 예제: 특정 필드가 특정 값과 일치할 때 이벤트를 삭제하는 필터\n  if [status] == \"404\" {\n    drop {}\n  }\n}\n\noutput {\n  # Elasticsearch에 데이터를 전송하는 설정\n  elasticsearch {\n    hosts => [\"localhost:9200\"]  # Elasticsearch 호스트 및 포트\n    index => \"%{source_type}\"    # Elasticsearch에 인덱싱될 이름을 source_type 필드 값으로 동적 설정\n  }\n\n  # stdout으로 데이터를 출력하는 설정 (디버깅 용도)\n  stdout {}\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":-1270853631,"tx":22819},"by4gQGx95Mp30v8Z/content":{"id":"by4gQGx95Mp30v8Z/content","type":"content","text":"---\npermalink: /2024-03-28-정보처리기사 실기 C언어 모음/\npublished: true\ntitle: \"[정처기] 정보처리기사 실기 C언어 문제 모음\"\ndate: 2024-03-28 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"정보처리기사 실기 C언어 문제 모음\"\ncategories:\n- 정보처리기사\ntags:\n- 정보처리기사\n---\n\n<br><br>\n\n\n## ✅ 정보처리기사 C언어 문제 모음\n\n####  📌 다음은 C 언어 코드이다. 알맞는 출력 결과를 작성하시오. ( 23년 3회 ) \n<br>\n\n```c\n#include <stdio.h>\n\nint test(int n) {\n    int i, sum = 0;\n    \n    for (i = 1; i <= n / 2; i++){\n        if (n % i == 0)\n        sum += i;\n    }\n\n    if (n == sum) \n        return 1;\n   \n    return 0;\n}\n\nint main(){\n    int i, sum=0;\n    \n    for (i = 2; i <= 100; i++){ \n        if (test(i))\n        sum += i;\n    }\n\n    printf(\"%d \", sum); \n    return 0;\n\n}\n```\n<br>\n\n> 정답 : 34\n\n숫자를 일일히 넣어서 무슨 함수인지 확인해보면 **자기 자신을 제외한 약수의 합**이 **자기자신**과 같은 \"완전수\"를 찾는 문제이다. 범위는 2부터 100까지 이므로 완전수인 6, 28의 합인 34가 정답이다. `6 = 1+2+3` , `28 = 1+2+4+7+14 ` \n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 C언어에서 구조체의 멤버에 접근하기 위해 괄호안의 '기호'를 작성하시오. ( 23년 3회 )\n<br>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n \ntypedef struct Data{\n    char c;\n    int *numPtr; \n} Data;\n \nint main(){\n    int num = 10;\n    Data d1;    \n    Data *d2 = malloc(sizeof(struct Data));\n    \n    d1.numPtr = &num;  \n    d2 ( ) numPtr = &num; \n \n    printf(\"%d\\n\", *d1.numPtr); \n    printf(\"%d\\n\", *d2 ( ) numPtr);\n \n    free(d2); \n    return 0;\n}\n\n\n[ 출력 결과 ] \n10\n10\n```\n\n<br>\n\n> 정답 : ->\n\nC언어에서 구조체 포인터에 접근하기 위한 기호는 -> 이다.\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음 C언어 코드에 알맞는 출력값을 작성하시오. ( 23년 3회 ) \n<br>\n\n```c\n#include\n \nint f(int n) {\n    if(n<=1) return 1;\n    else return n*f(n-1);\n}\n \nint main() {\n    printf(\"%d\", f(7));\n}\n```\n\n<br>\n\n> 정답 : 5040\n\n함수를 해석해보면 1x2x3x4x5x6x7 을 의미한다.\n\n<br><br><br><br><br><br>\n\n\n####  📌다음은 C언어의 포인터 문제이다. 알맞는 출력값을 작성하시오. ( 23년 3회 )\n<br>\n\n \n```c\n#include\n \nint main() {\n    char* p = \"KOREA\";\n    printf(\"%s \", p);\n    printf(\"%s \", p+1);\n    printf(\"%c \", *p);\n    printf(\"%c \", *(p+3));\n    printf(\"%c \", *p+4);\n}\n```\n\n<br>\n\n> 정답 :\n\t> KOREA\n\t> OREA\n\t> K\n\t> E\n\t> O\n\n포인터는 주소값을 의미한다는 사실만 알고있으면 쉽게 풀 수 있다.\n그리고 `*p`가 의미하는것이 `p의 주소값을 참조한다` 즉 `p의 주소값을 통해 실제값(여기서는 문자)을 가진다` 라고 생각하면 문제를 풀기 쉽다.\n일단 p는 포인터 문자로 선언되어 있으므로 K의 주소값을 가진다.\n\n첫번째 `printf(\"%s \", p);`는 p가 나타내는 문자열 `KOREA` 를 출력한다.\n두번째 `printf(\"%s \", p+1);`은 p의 바로 다음 주소인 O부터 `KOREA`를 출력한다.\n세번째 `printf(\"%c \", *p);`는 p를 참조한다. 즉 p의 실제값인 `K`를 출력한다.\n네번째 `printf(\"%c \", *(p+3));`은 p+3의 주소값을 참조한다. 즉 `E`를 출력한다.\n마지막 `printf(\"%c \", *p+4);`는 p를 참조하고 아스키값 4를 더한다. 즉 K+4=`O`를 출력한다\n\n<br><br><br><br><br><br>\n\n####  📌다음은 C언어 코드의 문제이다. 다음의 조건에 맞도록 빈 괄호 안에 알맞은 코드를 작성하시오. ( 23년 2회 )\n\n`조건 : 입력값이 54321일 경우 출력값이 43215로 출력되어야 한다. `\n\n<br>\n\n```c\nint main(void) {\n \n    int n[5];\n    int i;\n \n    for (i = 0; i < 5; i++) {\n        printf(\"숫자를 입력해주세요 : \");\n        scanf(\"%d\", &n[i]);\n    }\n \n    for (i = 0; i < 5; i++) {\n        printf(\"%d\", (            ) );\n    }\n \n  return 0;\n \n}\n```\n<br>\n\n> 정답 : `n[(i+1)%5]`\n\n뭐 딱히 해설할게 없다. 그냥 첫번째 입력한걸 마지막에 출력되게 작성하면 된다. \n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 c언어의 코드이다. 보기의 조건에 맞추어 알맞은 출력값을 작성하시오. ( 23년 2회 )\n` 입력값은 홍길동, 김철수, 박영희 순서로 주어진다. `\n\n<br>\n\n```c\n#include<stdlio.h> \n#include<stdlib.h> \n\nchar n[30];\nchar* test() {\n    printf(입력하세요 : );\n    gets(n);\n    return n;\n}\n \nint main()\n \n{\n    char* test1;\n    char* test2;\n    char* test3;\n \n    test1 = test();\n    test2 = test();\n    test3 = test();\n \n    printf(%s\\n,test1);\n    printf(%s\\n,test2);\n    printf(%s,test3);\n}\n```\n\n<br>\n\n> 정답 :  \n>\t박영희  \n>\t박영희  \n>\t박영희   \n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 c언어의 코드이다. 알맞은 출력값을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\nint n[3] = [73, 95, 82] \nint sum = 0 \n \nfor(i=0;i<3;i++){\n    sum += n[i];\n}\n \nswitch(sum/30){\n    case 10:\n    case 9: printf(\"A\");\n    case 8: printf(\"B\");\n    case 7: \n    case 6: printf(\"C\");\n    default: printf(\"D\");\n}\n```\n\n<br>\n\n> 정답 : BCD\n\n먼저 for문을 통해 `sum = n[0]+n[1]+n[2]` 가 되므로 `sum = 250` 이 된다.\n따라서 switch(sum/30)은 switch(250/3), 즉 `switch(8)` 이 실행된다.\n근데 주의할점은 switch문의 각 case마다 **break가 걸려있지 않다는 점**이다.\n때문에 `case8` 을 수행한뒤 `case7`, `case6`,`default` 까지 실행될 것이다.\n따라서 정답은 BCD 이다.\n\n\n<br><br><br><br><br><br>\n\n####  📌다음 소스코드의 알맞은 출력을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n \n    int c = 0;\n \n    for(int i = 1; i <=2023; i++) { \n\t\tif(i%4 == 0) c++; \n    }\n    printf(\"%d\", c);\n}\n```\n\n<br>\n\n> 정답 : 505\n\nfor문의 i는 1~2023까지 돌고, i가 4의배수일때 c++ 하므로 c는 505번 1 증가한다.\n따라서 정답은 505\n\n\n<br><br><br><br><br><br>\n\n####  📌다음은 C언어 문제이다. 알맞은 출력값을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```c\n#include <stdio.h>\n#define MAX_SIZE 10\n \nint isWhat[MAX_SIZE];\nint point= -1; \n \nvoid into(int num) {\n    if (point >= 10) printf(\"Full\");\n    isWhat[++point] = num;\n}\n \nint take() {\n    if (isEmpty() == 1) printf(\"Empty\");\n    return isWhat[point--];\n}\n \nint isEmpty() {\n    if (point == -1) return 1;\n    return 0;\n}\n \nint isFull() {\n    if (point == 10) return 1;\n    return 0;\n}\n \nint main(int argc, char const *argv[]){\n    int e;\n    into(5);\n    into(2);\n    while(!isEmpty()){\n        printf(\"%d\", take());\n        into(4); into(1); printf(\"%d\", take()); \n        into(3); printf(\"%d\", take()); printf(\"%d\", take()); \n        into(6); printf(\"%d\", take()); printf(\"%d\", take()); \n    }\n    return 0;\n}\n```\n\n<br>\n\n> 정답 : 213465\n\nc언어로 stack을 구현한 코드라고 보면 된다. 일반적으로 알고있는 stack의 push,pop,isEmpty, isFull을 생각하면 된다.\n\n<br><br><br><br><br><br>\n\n####  📌다음 코드는 선택정렬 구현에 관한 문제이다.  빈칸에 알맞는 연산자를 보기에서 골라 작성하시오. ( 23년 2회 )\n<br>\n\n```c\n#include\nint main() {\n    int E[] = {64, 25, 12, 22, 11};\n    int n = sizeof(E) / sizeof(E[0]);\n    int i = 0;\n    do {\n        int j = i + 1;\n        do {\n            if (E[i] (     ) E[j]) {\n                int tmp = E[i];\n                E[i] = E[j];\n                E[j] = tmp;\n            }\n            j++;\n        } while (j < n);\n        i++;\n    } while (i < n-1);\n    for(int i=0; i<=4; i++)\n        printf(\"%d \", E[i]);\n}\n```\n\n<br>\n\n> 정답 : >\n\n그냥 직관적으로도 풀수있는 문제.\n\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 C언어의 출력값을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n    char a[] = \"Art\";\n    char* p = NULL;\n    p = a;\n \n    printf(\"%s\\n\", a);\n    printf(\"%c\\n\", *p);\n    printf(\"%c\\n\", *a);\n    printf(\"%s\\n\", p);\n \n    for(int i = 0; a[i] != '\\0'; i++)\n    printf(\"%c\", a[i]);\n \n}\n\n```\n\n<br>\n\n> 정답 : \nArt\nA\nA\nArt\nArt\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 C언어의 출력값을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main(){\n \n    char* a = \"qwer\";\n    char* b = \"qwtety\";\n \n    for(int i = 0; a[i] != '\\0' ; i++){\n        for(int j = 0; b[j] != '\\0'; j++){\n            if(a[i] == b[j]) printf(\"%c\", a[i]);\n        }\n    }\n \n}\n```\n\n<br>\n\n> 정답 : qwe\n\n\n<br><br><br><br><br><br>\n\n####  📌**다음 아래 코드에서 이진수를 십진수로 변환하는 코드에 대해 괄호 (a) (b)의 적합한 답을 작성하시오.** ( 23년 1회 )\n<br>\n\n```c\n#include <stdio.h>\n \nint main() {\n \n    int input = 101110;\n    int di = 1;\n    int sum = 0;\n \n    while (1) {\n \n        if (input == 0) break\n        else {\n \n          sum = sum + (input (a)(b)) * di;\n             di = di * 2;\n             input = input / 10;\n \n        }\n    }\n \n    printf(\"%d\", sum);\n \n    return 0;\n}\n```\n<br>\n\n> 정답 : (a) %, (b) 10 or 5 or 2\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1756814306,"tx":23190},"8IFmCnOfvma2Povc/content":{"id":"8IFmCnOfvma2Povc/content","type":"content","text":"---\npermalink: /2024-03-28-정보처리기사 실기 Java 문제 모음/\npublished: true\ntitle: \"[정처기] 정보처리기사 실기 Java 문제 모음\"\ndate: 2024-03-28 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"정보처리기사 실기 Java 문제 모음\"\ncategories:\n- 정보처리기사\ntags:\n- 정보처리기사\n---\n\n<br><br>\n\n## ✅ 정보처리기사 Java 문제 모음\n\n####  📌 다음은 Java 코드이다. 올바른 출력 결과를 작성하시오. ( 23년 3회 ) \n<br>\n\n```java\nclass Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-2);\n    }\n}\n \nclass Child extends Parent {\n    int compute(int num) {\n        if(num <= 1)\n            return num;\n        return compute(num-1) + compute(num-3);\n    }\n}\n \npublic class main {\n    public static void main(String args[]) {\n        Parent obj = new Child();\n        System.out.print(obj.compute(7));\n    }\n}\n```\n<br>\n\n> 정답 : 2  \n\n \n\n\n```\ncompute(6) + compute(4)\n= compute(5) + compute(3) + compute(3) + compute(1)\n= compute(4) + compute(2) + compute(2) + compute(0) + compute(2) + compute(0) + 1\n= compute(3) + compute(1) + compute(1) + compute(-1) + compute(1) + compute(-1) + compute(1) + compute(-1) + 1\n= compute(2) + 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1\n= compute(1) - 1 + 1 - 1 + 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 \n= 2\n```\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음 자바 코드를 실행할 경우 에러가 발생이 된다. 에러가 발생하는 라인명을 작성하시오. ( 23년 3회 )\n<br>\n\n```java\n1\t\tclass Person {\n2\t\t    private String name;\n3\t    \tpublic Person(String val) {\n4        \t\tname = val;\n5    \t\t}\n6    \t\tpublic static String get() {\n7    \t\t\treturn name;\n8    \t\t}\n9    \t\tpublic void print() {\n10        \t\tSystem.out.println(name);\n11    \t\t}\n12\t\t}\n13\n14\t\tpublic class main {\n15    \t\tpublic static void main(String[] args) {\n16        \t\tPerson obj = new Person(\"Kim\");\n17        \t\tobj.print();\n18    \t\t}\n19\t\t}\n```\n\n<br>\n\n> 정답 : 7\n\n```\n`name`은 인스턴스 변수이고, `get()`은 static 메서드이기 때문에 \nstatic 메서드인 `get()`에서는 name에 접근할 수 없다.\n```\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음은 JAVA 코드 문제이다. 가지고 있는 돈이 총 4620원일 경우 1000원, 500원, 100원, 10원의 지폐 및 동전을 이용하여 보기의 조건에 맞춰 최소한의 코드를 통해 괄호안을 작성하시오. ( 23년 2회 )\n\n<br>\n\n```\n<보기>\n변수 : m\n연산자 : / , %  \n괄호 : [ , ] , ( , )   \n정수 : 1000, 500, 100, 10\n```\n\n```java\npublic class Problem {\n\n    public static void main(String[] args){\n\t\t \n\t\t m = 4620;\n \n\t\t a = (              );\n\t\t b = (              );\n\t\t c = (              );\n\t\t d = (              );\n \n\t\t System.out.println(a); //천원짜리 4장 출력\n\t\t System.out.println(b); //오백원짜리 1개 출력\n\t\t System.out.println(c); //백원짜리 1개 출력\n\t\t System.out.println(d); //십원짜리 2개 출력\n    }\n}\n```\n\n\n<br>\n\n> 정답 :  \nm / 1000  \n(m % 1000) % 500  \n(m % 500) / 100  \n(m % 100) / 10  \n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌  다음은 자바에 대한 문제이다. 알맞은 출력값을 작성하시오. ( 23년 2회 )\n<br>\n\n```java\npublic class Main{\n    public static void main(String[] args) {\n        \n        String str1 = 'Programming';\n        String str2 = 'Programming';\n        String str3 = new String('Programming');\n        \n        println(str1==str2)\n        println(str1==str3)\n        println(str1.equals(str3))\n        print(str2.equals(str3))\n    }\n}\n```\n\n<br>\n\n> 정답 :  \n> true  \n> false  \n> true  \n> true  \n\n<br><br><br><br><br><br>\n\n\n\n####  📌**아래 자바 코드에서 출력되는 값을 작성하시오. ( 23년 1회 )**\n<br>\n\n```java\nclass Static{\n    public int a = 20;\n    static int b = 0;\n}\n \npublic class Main{\n    public static void main(String[] args) {\n        \n        int a;\n        a = 10;\n        Static.b = a;\n \n        Static st = new Static();\n \n        System.out.println(Static.b++);\n        System.out.println(st.b);\n        System.out.println(a);\n        System.out.print(st.a);\n    }\n}\n```\n\n<br>\n\n> 정답 :  \n10  \n11  \n10  \n20  \n\n```\nstatic 변수는 클래스 변수이므로 클래스 내에서는 값이 공유된다.\n```\n\n<br><br><br><br><br><br>\n\n\n\n####  📌다음 코드에서 괄호안에 알맞는 값을 변수명으로 작성하시오. ( 23년 1회 )\n\n<br>\n\n\n```java\npublic class Sort {\n \n    public static void swap(int[] arr, int idx1, int idx2){\n        int temp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[( 1 )] = temp;\n    }\n \n    public static void Usort(int[] array, int length){\n        for (int i = 0; i < length; i++) {\n            for (int j = 0; j < length - i - 1; j++) {\n                if (array[j] > array[j + 1]) {\n                    swap(array, j, j + 1);\n                }\n            }\n        }\n    }\n \n    public static void main(String[] args) {\n        int[] item = new int[] { 5, 3, 8, 1, 2, 7 };\n        int nx = 6;   \n        Usort(item, ( 2 ));\n \n        for (int data : item) {\n            System.out.print(data + \" \");\n        }\n    }\n}\n```\n\n```\n출력값 : 1 2 3 5 7 8\n```\n\n<br>\n\n> 정답 :  \n> (1) temp  \n> (2) item.length\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌**다음 JAVA 코드에서 알맞는 출력 값을 작성하시오.** ( 23년 1회 )\n<br>\n\n```java\nabstact class Vehicle {\n \n    String name;\n    abstract public String getName(String val);\n \n    public String getName() {\n            return \"Vehicle name: \" + name;\n    }\n}\n \n \n \nclass Car extends Vehicle {\n \n    public Car(String val) {\n            name= super.name =val;\n    }\n \n    public String getName(String val) {\n            return \"Car name:\" + val;\n    }\n \n    public String getName(byte val[]) {\n            return \"Car name:\" + val;\n    }\n}\n \n \npublic class Main {\n \n    public static void main(String[] args) {\n \n    Vehicle obj = new Car(\"Spark\");\n    System.out.println(obj.getName());\n \n    }\n}\n```\n\n<br>\n\n> 정답 :  Vehicle name : Spark\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌**다음 자바 코드에 대한 출력 값을 작성하시오.**\n<br>\n\n```java\nclass Parent {\n    int x = 100;\n \n    Parent() {\n        this(500);\n    }\n \n    Parent(int x) {\n        this.x = x;\n    }\n \n    int getX() {\n        return x;\n    }\n}\n \nclass Child extends Parent {\n    int x = 4000;\n    \n    Child() {\n        this(5000);\n    }\n \n    Child(int x) {\n        this.x = x;\n    }\n}\n \npublic class Main {\n    public static void main(String[] args) {\n        Child obj = new Child();\n        System.out.println(obj.getX());\n    }\n}\n```\n\n<br>\n\n> 정답 : 500\n\n```\n1. Child obj = new Child() 에서 Child클래스의 obj객체를 생성\n2. Child클래스의 생성자인 Child() 호출\n3. this(5000)은 Child(5000)을 호출\n4. 때문에 Child클래스의 x=5000이 됨.\n5. obj.getX() 호출\n6. Child클래스에는 getX()메서드가 없고, 부모클래스인 Parent클래스의 getX() 실행\n7. Parent 클래스의 생성자인 Parent() 호출\n8. this(500)은 Parent(500) 호출\n9. this.x = x를 실행하므로 Parent클래스의 x=500이 됨.\n10. getX() return 500; \n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 **다음 자바 코드에 대한 출력 값을 작성하시오.** ( 22년 3회 )\n\n<br>\n\n```java\npublic class Main {\n  static int[] MakeArray(){\n \n\t  int[] tempArr = new int[4];\n  \n\t  for(int i=0; i<tempArr.length;i++){\n\t    tempArr[i] = i;\n\t  }\n  \n\t  return tempArr;\n  }\n  \n  public static void main(String[] args){\n  \n\t  int[] intArr;\n\t  intArr = MakeArray();\n  \n\t  for(int i=0; i < intArr.Length; i++)\n\t\t  System.out.print(intArr[i]);\n  }\n}\n```\n\n<br>\n\n> 정답 : 0123\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 **다음 자바 코드에 대한 출력 값을 작성하시오.** ( 22년 3회 )\n```java\npublic class Exam {\n\tpublic static void main(String[] args){\n  \n\t\tint a = 0;\n\t\tfor(int i=1; i<999; i++){\n\t\t\tif(i%3==0 && i%2!=0)\n\t\t\t\ta = i;\n\t\t}\t\t\n\t    System.out.print(a);\n    }\n}\n```\n\n<br>\n\n> 정답 : 993\n\n```\n3의 배수이면서 짝수가 아닌 수를 찾으면 된다.\n6n+3 (n>=0)을 만족하면서 값이 998보다 작은 수는 993이다.\n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌**다음 자바 코드에 대한 출력 값을 작성하시오.** ( 22년 2회 )\n<br>\n\n```java\npublic static void main(String args[]){\n  \n\tint i = 3;\n\tint k = 1;\n\t\n\tswitch(i) { \n\t    case 1: k += 1;\n\t    case 2: k++;\n\t    case 3: k = 0; \n\t    case 4: k += 3; \n\t    case 5: k -= 10; \n\t    default: k--; \n\t}\n  System.out.print(k);\n}\n```\n<br>\n\n> 정답 : -8\n\n```\n아주 비겁한 실수유도 문제.\nswitch(3)으로 시작해서 k=0; 으로 끝날듯 하지만,\nbreak;문이 case마다 선언되어 있지않기때문에\ncase3, case4, case5, default 모두 실행된다.\n따라서 k = -8\n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 **다음 자바코드에서 알맞는 출력값을 작성하시오.** ( 22년 1회 )\n\n<br>\n\n```java\nclass A {\n  int a;\n  int b;\n}\n  \n  public class Main {\n  \n\tstatic void func1(A m){\n\t\tm.a *= 10;\n\t}\n  \n\tstatic void func2(A m){\n\t\tm.a += m.b;\n\t}\n  \n  public static void main(String args[]){\n  \n  A m = new A();\n  \n  m.a = 100;\n  func1(m);\n  m.b = m.a;\n  func2(m);\n  \n  System.out.printf(\"%d\", m.a);\n  \n  }\n}\n```\n\n<br>\n\n> 정답 : 2000\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음 Java 코드 중에서 밑줄에 들어갈 알맞는 코드를 작성하시오. ( 22년 1회 )\n\n<br>\n\n```java\nclass Car implements Runnable{\n\tint a;\n  \n\tpublic void run(){\n\t\tsystem.out.println(\"message\")\n\t}\n}\n  \npublic class Main{\n\tpublic static void main(String args[]){\n\t\tThread t1 = new Thread(new ___());\n\t\tt1.start();\n\t}\n}\n```\n\n<br>\n\n> 정답 : Car\n\n```\nThread클래스의 생성자에는 Runnable 인터페이스를 구현한 객체가 필요한데,\n\nCar클래스에서 Runnable 인터페이스를 구현하고 있으므로 Car객체가 필요하다.\n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌**다음 Java 코드에 대한 알맞는 출력값을 쓰시오. ( 21년 3회 )**\n\n<br>\n\n```java\nclass Connection {\n\tprivate static Connection _inst = null;\n\tprivate int count = 0;\n\n\tstatic public Connection get() {\n\t\tif (_inst == null) {\n\t\t\t_inst = new Connection();\n\t\t\treturn _inst;\n\t\t}\n\t\treturn _inst;\n\t}\n\n\tpublic void count() {\n\t\tcount++;\n\t}\n\n\tpublic int getCount() {\n\t\treturn count;\n\t}\n}\n\npublic class testcon {\n\tpublic static void main(String[] args) {\n\t\tConnection conn1 = Connection.get();\n\t\tconn1.count();\n\t\tConnection conn2 = Connection.get();\n\t\tconn2.count();\n\t\tConnection conn3 = Connection.get();\n\t\tconn3.count();\n\n\t\tSystem.out.print(conn1.getCount());\n\t}\n}\n```\n\n<br>\n\n> 정답 : 3\n\n```\n1. 먼저 private static Connection _inst = null;은 static 메소드이므로\n   클래스 내에서는 값이 공유된다.\n2. Connection conn1 = Connection.get();을 실행하면 최초 _inst는 null\n   이므로 _inst = new Connection()이 실행되고, _inst를 return한다.\n3. conn1.count()는 count를 1로 만든다.\n4. Connection conn2 = Connection.get(); 실행시 _inst는 static 메소드\n   이므로 conn1 생성때 생성된 객체를 공유한다.\n5. 때문에 conn2.count()를 실행하면 conn1의 count과 값을 공유하여\n   count = 2가 된다.\n6. 마찬가지로 count = 3이되고, conn1.getCount()를 하면 3이 출력된다.\n```\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 **다음 Java 코드에 대한 알맞는 출력값을 쓰시오. (21년 3회 )**\n\n<br>\n\n```java\npublic class testco {\n\t public static void main(String[] args) {\n\t\t  int a = 3, b = 4, c = 3, d = 5;\n\t\t  if((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d)) {\n\t\t\t   a = b + c;\n\t\t\t    if(7 == b ^ c != a) {\n\t\t\t\t     System.out.println(a);\n\t\t\t\t    } else {\n\t\t\t\t\t    System.out.println(b);\n\t\t\t\t\t    }\n\t\t\t  } else {\n\t\t\t\t    a = c + d;\n\t\t\t\t    if(7 == c ^ d != a) {\n\t\t\t\t\t    System.out.println(a);\n\t\t\t\t\t    } else {\n\t\t\t\t\t\t    System.out.println(d);\n\t\t\t\t\t\t    }\n\t\t\t\t  }\n\t\t }\n}\n```\n\n<br>\n\n> 정답 : 7\n\n```\n[비트 연산자]\n& : 이진수 기준 같은 자리를 비교했을 때 값이 같으면 1(True) / 다르면 0(False)\n| : 이진수 기준 같은 자리를 비교했을 때 하나라도 1이면 1 / 아니면 0\n^ : 이진수 기준 같은 자리를 비교했을 때 값이 다르면 1 / 같으면 0\n\nif((a ==  2  | a == c)  &  !(c > d)  &  (1  == b ^ c != d))\n=> if( (F | T) & !F & (F ^ T)\n=> if( T & T & T ) 이므로 true\n따라서 a = b + c = 7;\n\nif(7  == b ^ c != a)\n=> if( F ^ T )\n=> if( true ) 이므로\nSystem.out.println(a); 실행 // a=7\n```\n\n\n<br><br><br><br><br><br>\n\n\n\n####  📌 다음은 JAVA 관한 문제이다. 알맞는 출력값을 작성하시오. ( 21년 2회 )\n\n<br>\n\n```java\npublic class over1 {\n\tpublic static void main(String[] args){\n    \tovr a1 = new ovr1();\n        ovr a2 = new ovr2();\n        System.out.println(a1.sun(3,2) + a2.sun(3,2));\n    }\n    \n    int sun(int x, int y){\n    \treturn x + y;\n    }\n}\n\nclass ovr2 extends ovr1 {\n\n\tint sun(int x, int y){\n    \treturn x - y + super.sun(x,y);\n    }\n\n}\n```\n\n<br>\n\n> 정답 : 11\n\n```\na1.sun(3,2) = 5\na2.sun(3,2) = 3 - 2 + super.sun(3,2) = 1 + \n```\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1408329807,"tx":23197},"8IFmCnOfvma2Povc/contentState":{"id":"8IFmCnOfvma2Povc/contentState","type":"contentState","selectionStart":223,"selectionEnd":223,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1713413809131,"tx":23198},"Rkbhu5EBtxTalmMn/content":{"id":"Rkbhu5EBtxTalmMn/content","type":"content","text":"---\npermalink: /2024-03-28-정보처리기사 실기 Python 모음/\npublished: true\ntitle: \"[정처기] 정보처리기사 실기 Python 문제 모음\"\ndate: 2024-03-28 10:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"정보처리기사 실기 Python 문제 모음\"\ncategories:\n- 정보처리기사\ntags:\n- 정보처리기사\n---\n\n<br><br>\n\n\n## ✅ 정보처리기사 Python 문제 모음\n\n**📌 다음 파이썬 코드에서 알맞는 출력값을 작성하시오.( 23년 2회 )** \n\n<br>\n\n```python\na = \"engineer information processing\"\nb = a[:3]\nc = a[4:6]\nd = a[28:]\ne=b+c+d\nprint(e)\n```\n<br>\n\n> 정답 : engneing\n\n\n\n파이썬 Slice 개념을 알고있으면 쉽게 풀릴 문제다.\n```python\nitems = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nitems[2:5] # 인텍스 2에서 인덱스 5까지(인덱스 5는 제외) 슬라이싱 \n# [2, 3, 4]\n\nitems[5:] # 인덱스 5에서 끝까지 슬라이싱\n# [5, 6, 7, 8, 9, 10]\n\nitems[:3] # 처음부터 인덱스 3까지(인덱스 3은 제외) 슬라이싱 \n# [0, 1, 2]\n\nitems[:] # 처음부터 끝까지 슬라이싱(즉, 리스트 복사본 반환)\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nitems[2:9:3] # 인덱스 2에서 인텍스 9까지(인덱스 9는 제외) 3칸씩 점프 \n# [2, 5, 8]\n\nitems[:10:2] # 처음부터 인텍스 10까지(인덱스 10은 제외) 2칸씩 점프\n# [0, 2, 4, 6, 8]\n\nitems[2::2] # 인덱스 2에서 끝까지 2칸씩 점프\n# [2, 4, 6, 8, 10]\n\nitems[::3] # 전체 리스트에 대해서 3칸씩 점프\n# [0, 3, 6, 9]\n\nitems[10:0:-3] # 인텍스 10에서 0까지(인덱스 0은 제외) 역순으로 슬라이싱\n# [10, 7, 4, 1]\n\nitems[5:1:-1] # 인덱스 5에서 1까지(인텍스 1은 제외) 역순으로 슬라이싱\n# [5, 4, 3, 2]\n\nitems[1::-1] # 인덱스 1에서 끝까지 역순으로 슬라이싱\n# [1, 0]\n\nitems[1:10:-1] # 인텍스 1에서 인덱스 10까지(인덱스 10인 제외) 역순으로 슬라이싱, 하지만 슬라이싱 못하므로 빈 리스트 반환\n# []\n\nitems[:-3:-1] # 리스트 끝에서 3번째 인덱스까지(인덱스 -3은 제외) 역순으로 슬라이싱\n# [10, 9]\n\nitems[0:-3:-1] # 인텍스 0에서부터 리스트 끝에서 3번째 인덱스까지(인텍스 -3은 제외) 역순으로 슬라이싱, 하지만 슬라이싱 못하므로 빈 리스트 반환\n# []\n\nitems[::-1] # 리스트 처음부터 끝까지 역순으로 슬라이싱\n# [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\nitems[::-2] # 리스트 처음부터 끝까지 역순으로 2칸씩 슬라이싱\n# [10, 8, 6, 4, 2, 0]\n```\n\n\n<br><br><br><br><br><br>\n\n**📌 다음 파이썬 코드의 알맞는 출력값을 작성하시오. ( 23년 1회 )**\n```python\na = {'한국', '중국', '일본'}\na.add('베트남')\na.add('중국')\na.remove('일본')\na.update({'홍콩', '한국', '태국'})\nprint(a)\n```\n<br>\n\n> 정답 : {'한국', '중국', '일본', '베트남', '태국'} ( 순서는 상관없음 )\n\nset는 순서를 보장하지 않기때문에 요소를 추가할때 순서를 고려하지 않아도 된다. 또한 `update`는 없으면 추가, 있으면 유지를 하면 된다. 그러나 set는 **중괄호와 작은따옴표**를 반드시 포함해줘야 한다!!!\n\n\n\n<br><br><br><br><br><br>\n\n📌 **다음 파이썬 코드에 대한 출력값을 작성하시오.**\n\n```python\nTestList = [1,2,3,4,5]\nTestList = list(map(lambda num : num + 100, TestList))\n \nprint(TestList)\n```\n<br>\n\n> 정답 : [101, 102, 103, 104, 105]\n\n\n<br><br><br><br><br><br>\n\n**📌 다음 Python으로 구현된 프로그램과 입력값을 보고 실행 결과를 작성하시오.**\n```python\nx = input()\nx = x.capitalize()\ny = x.split()\nprint(y[0][::2], end = '*')\nprint(y[1][3:6])\n```\n\n```\n입력 : python programming\n```\n\n<br>\n\n> 정답 : Pto*gra\n\n`capitalize()`는 첫 글자를 대문자로 변경한다.\n`split()`은 공백을 기준으로 배열형태로 변경해준다.\n따라서 `y[0] = python` 이고 `y[1] = programming` 이다.\n이후는 slice해주면 된다.\n\n\n<br><br><br><br><br><br>\n\n**📌다음 python의 프로그램과 입력값을 분석하여 실행 결과에 대해 작성하시오.**\n```python\narr_str = input('input String :').split('-')\narr_len = int(input('input number : '))\narr_val = list(range(0,arr_len,2))\narr_val.remove(4)\nprint(arr_str[1].find('i') + arr_val[2])\n```\n\n```\n입력 :\ninput string : information-technology\ninput number : 12\n```\n\n<br>\n\n> 정답 : 5\n\n\n```\narr_str[0] = information\narr_str[1] = technology\narr_len = 12\narr_val = [0, 2, 4, 6, 8, 10]\narr_val.remove(4) -> [0, 2, 6, 8, 10]\narr_str[1].find('i') = -1\narr_val[2] = 6\nresult : 5\n```\nrange(start, stop) 함수는 start부터 stop-1까지의 숫자를 생성한다.\n\n\n<br><br><br><br><br><br>\n\n📌 **다음 python의 프로그램을 분석하여 실행 결과에 대해 작성하시오.**\n```python\ni = 20\nf = 123456.789E-3\nprint('%d\\n%d' % (i, i), end = '/')\nprint('%.3f' % f)\n```\n<br>\n\n> 정답 : \n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1063228989,"tx":23200},"MRasIncXHMnDEsl4/contentState":{"id":"MRasIncXHMnDEsl4/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":15,"posInSection":0.6},"hash":1713482652057,"tx":24262},"Bars6CC7H5Joqa8P/contentState":{"id":"Bars6CC7H5Joqa8P/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":14,"posInSection":0.2},"hash":1713482652433,"tx":24263},"eZPD4ts8Xo7mlluk/content":{"id":"eZPD4ts8Xo7mlluk/content","type":"content","text":"## 폰트 바꾸기\n\nmain.scss 에 웹폰트 import 하고\nvariables.css 에 sans-serif태그에 글씨체 이름 추가하면 끝!\n\n\n## 개발자 도구 켜서 vscode로 검색하기\n\t\tctrl + shift + f로 클래스명 검색하기\n\n## 본문 및 사이드바 너비 설정\nvariables.scss에서\n $right-sidebar-width-narrow: 200px  !default;\n$right-sidebar-width: 300px  !default;\n$right-sidebar-width-wide: 400px  !default;\n\n얘네 수정하면됨\n\n## 로컬 접속\ncmd >> 블로그 폴더로 접근 >> bundle exec jekyll serve\n\n## 시작 페이지 수정\nindex.html 코드 추가\nrecent-posts.html 추가 -> 최근포스트 \nicon.html 추가 -> 아이콘 html\nhome.html에서 최근 포스트 기존에 있던거 삭제\n\n_sass/elements.scss 추가\n_sass/layout.scss 추가\n_sass/variavles.scss 추가\nassets/css/screen.scss 추가\nassets/css/terminal.css 추가\n\n\n\nindex.html에서 첫번째줄 layout : home 을 layout : newhome으로 변경하고 newhome.html을 _layouts 폴더에 추가함\n\n## 로고 이미지 추가\nmasthead.html 에서\n`<img  src=\"/assets/images/sitelogo.png\"  class=\"center\"> `\n코드 추가\n\n기존에 아래코드 있었음\n```\n<a  class=\"site-title\"  href=\"{{ '/' | relative_url }}\">\n\n {{ site.masthead_title | default: site.title }}\n\n{% if site.subtitle %}<span class=\"site-subtitle\">{{ site.subtitle }}</span>{% endif %}\n\n</a>\n```\n\n\n## 글씨 크기 조정\nbase.scss에서 글씨크기들 다양하게 조정가능\n\n\n## 문자 박스\n\n<p class=\"notice\">\nDefault 박스\n</p>\n\n<p class=\"notice--primary\">\nPrimary 박스\n</p>\n\n<p class=\"notice--info\">\nInfo 박스\n</p>\n\n<p class=\"notice--warning\">\nwarning 박스\n</p>\n\n<p class=\"notice--success\">\nSuccess 박스\n</p>\n\n<p class=\"notice--danger\">\nDanger 박스\n</p>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1378346888,"tx":24590},"PV7SRqnI3929RHIh/contentState":{"id":"PV7SRqnI3929RHIh/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":35,"posInSection":0.6666666666666666},"hash":1713491394904,"tx":25948},"RXviSkk9OEup22my/content":{"id":"RXviSkk9OEup22my/content","type":"content","text":"---\npermalink: /2024-04-18-ElasticSearch(엘라스틱서치)란/\npublished: true\ntitle: \"[ELK] ElasticSearch (엘라스틱서치)란? \"\ndate: 2024-04-17 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"ElasticSearch (엘라스틱서치)란?\"\ncategories:\n- ELK\ntags:\n- ELK\n- ElasticSearch\n---\n\n<br><br><br>\n\n\n\n## ✅ Elasticsearch\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic1.png?raw=true\">\n</p>\n\n**Elasticsearch는 모든 데이터를 색인하여 저장하고 검색, 집계 등을 수행하며 결과를 클라이언트 또는 다른프로그램으로 전달하여 동작하는 검색엔진이다. 아파치 루씬(Apache Lucene)** 기반 루씬 개발자들을 중심으로 개발이 시작되었으며,  뛰어난 검색 능력과 대규모 분산 시스템을 구축할 수 있는 다양한 기능을 제공하며 설치 과정도 비교적 간편하다.\n\n기존 관계데이터베이스 시스템에서는 다루기 어려운 전문검색(Full Text Search) 기능과 점수 기반의 다양한 정확도 알고리즘, 실시간 분석 등의 구현이 가능하다.\n\n또한 다양한 플러그인을 통해 AWS, MS Azure와 같은 클라우드 서비스 그리고 Hadoop 플랫폼들과의 연동도 가능하다.\n\n<br><br><br>\n<br><br><br>\n<br>\n\n## ✅ Elasticsearch의 특징\nElasticSearch는 단독 검색엔진으로 쓰이기도 하지만, ELK 스택이라는 집합으로 **ElasticSearch + LogStash + Kibana** 와 함께 쓰이기도 한다. ELK는 접근성과 용이성이 좋기때문에 최근 많은 기업과 프로젝트에서 사용되고 있는데 이는 ElasticSearch의 다음과 같은 특징 덕분이다.\n\n<br><br>\n\n### 📌 오픈소스 기반\n<hr>\nElasticsearch의 모든 제품은 Github([https://github.com/elastic](https://github.com/elastic))에 공개되어 있다. 누구나 자유롭게 사용 가능하고 개발할 수 있기 때문에 기술적으로 빠르게 성장해왔다. 또한 루씬이 자바로 만들어졌기 때문에 ElasticSearch 역시 자바로 코딩이 되어있다.\n\n<br><br>\n\n### 📌 실시간 분석 (real-time)\n<hr>\nElasticsearch의 가장 큰 특징 중 하나는 실시간 분석 시스템이다. Elasticsearch 클러스터가 실행되고 있는 동안에는 계속해서 데이터가 입력(인덱싱)되고, 이와 동시에 실시간에 가까운 속도로 색인된 데이터의 검색 및 집계가 가능하다.\n\n<br><br>\n\n### 📌 전문(full text) 검색 엔진\n<hr>\n루씬은 기본적으로 역파일 색인(inverted file index)이라는 구조로 데이터를 저장한다. 때문에 루씬을 사용하는 **ElasticSearch도 역파일 색인 구조로 데이터를 저장하여 검색하는데 이를 전문 검색** 이라고 한다.\n\n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic2.png?raw=true\">\n</p>\n\nJSON 문서 기반 Elasticsearch는 내부적으로는 역파일 색인 구조로 데이터를 저장하고 있으나, 사용자의 관점에서는 JSON 형식으로 데이터를 전달한다. JSON형식은 간결하고 개발자들이 다루기 편한 구조로 되어 있어 색인 할 대상 문서를 가공 하거나 다른 클라이언트 프로그램과 연동하기에 용이하다.\n\n또한 key-value 형식이 아닌 문서 기반으로 되어 있기에 복합적인 정보를 포함하는 형식의 문서를 있는 그대로 저장이 가능하며 사용자가 직관적으로 이해하고 사용할 수 있다. Elasticsearch에서 질의에 사용되는 쿼리문이나 쿼리에 대한 결과도 모두 JSON 형식으로 전달되고 리턴된다.\n\n다만 JSON이 Elasticsearch가 지원하는 유일한 형식이기 사전에 입력할 데이터를 JSON 형식으로 가공하는 것이 필요한데, 대부분의 형식들은 LogStash에서 변환을 지원하고 있다.\n\n\n<br><br>\n\n### 📌 RESTful API\n<hr>\n\n현재 대규모 시스템들은 대부분 MSA를 기본으로 설계된다. MSA구조는 거의 대부분 REST API를 사용해 데이터를 주고받는데, ElasticSearch 역시 REST API를 기본으로 지원하여 REST API로 CRUD를 처리한다.\n\n\n<br><br>\n\n### 📌 멀티테넌시 (multitenancy)\n<hr>\nElasticsearch의 데이터들은 인덱스(Index) 라는 논리적인 집합 단위로 구성되며 서로 다른 저장소에 분산되어 저장된다. 서로 다른 인덱스들을 별도의 커넥션 없이 하나의 질의로 묶어서 검색하고, 검색 결과들을 하나의 출력으로 도출할 수 있는데, Elasticsearch의 이러한 특징을 멀티테넌시 라고 한다.\n\n\n<br><br><br>\n<br><br><br>\n<br>\n\n## ✅ Elasticsearch의 클러스터링\n\nElasticsearch는 **대용량 데이터의 증가에 따른 스케일 아웃과 데이터 무결성을 유지하기 위한 클러스터링을 지원**한다. 항상 클러스터를 기본으로 동작하고 1개의 노드만 있어도 클러스터로 구성된다.\n\n<br><br>\n\n### 📌 여러 서버에 하나의 클러스터로 실행\n<hr>\n\nElasticsearch의 노드들은 클라이언트와의 통신을 위한 HTTP 포트 (9200 ~ 9299), 노드 간의 데이터 교환을 위한 TCP 포트 ( 9300 ~ 9399 ) 총 2개의 네트워크 통신을 열어두고 있다. 일반적으로 1개의 물리 서버마다 하나의 노드를 실행하는 것을 권장한다. 3개의 다른 물리 서버에서 각각 1개씩의 노드를 실행한 클러스터는 다음 그림과 같다.\n\n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic1.avif?raw=true\">\n</p>\n\n<br><br><br>\n\n하나의 물리적인 서버 안에서 여러개의 노드를 실행하는 것도 가능하다. 이런 경우 각 노드들은 차례대로 9200,9201... 순으로 포트를 사용하게 된다. 클라이언트는 9200, 9201 등의 포트를 통해 원하는 노드와 통신을 할 수 있다. 만약 서버1에서 두개의 노드를 실행하고, 또 다른 서버에서 한개의 노드를 실행하면 클러스터는 다음과 같이 구성된다.\n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic3.png?raw=true\">\n</p>\n\n\n<br><br><br>\n\n**물리적인 구성과 상관 없이 여러 노드가 하나의 클러스터로 묶이기 위해서는 클러스터명 `cluster.name` 설정이 묶여질 노드들 모두 동일해야 한다. 같은 서버나 네트워크망 내부에 있다 하더라도 `cluster.name`이 동일하지 않으면 논리적으로 서로 다른 클러스터로 실행이 되고, 각각 별개의 시스템으로 인식된다.**\n\n\n<br><br>\n\n### 📌 하나의 서버에서 여러 클러스터 실행\n<hr>\n\n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic4.png?raw=true\">\n</p>\n\n하나의 물리 서버에 3개의 노드를 실행시키는 상황이다. node-1과 node-2는 es-cluster-1이라는 이름의 클러스터에서 실행되고, node-3은 es-cluster-2라는 이름의 클러스터에서 실행된다. 설정은 `config/elasticsearch.yml` 파일에서 아래와 같이 입력한다.\n\n```yml\ncluster.name: es-cluster-1\nnode.name: \"node-1\"\n\ncluster.name: es-cluster-1\nnode.name: \"node-2\"\n\ncluster.name: es-cluster-2\nnode.name: \"node-3\"\n```\n\nnode-1과 node-2는 es-cluster-1이라는 클러스터에 묶여있기 때문에 데이터 교환이 일어난다. node-1로 입력된 데이터는 node-2에서도 읽을 수 있고 반대도 가능하다. 그러나 node-3은 클러스터가 다르기 때문에 node-1,2에 입력된 데이터를 node-3에서는 읽을 수 없다. \n\n<br><br><br>\n<br><br><br>\n<br>\n\n\n\n## ✅ 인덱스와 샤드 - Index & Shards\nElasticsearch 에서 단일 데이터 단위는 **도큐먼트(document)** 라고 한다. 그리고 이 도큐먼트를 모아놓은 집합을 **인덱스(Index)** 라고 한다. 인덱스는 **샤드(Shard)** 라는 단위로 분리되고 각 노드에 분산되어 저장된다. 다음 그림은 하나의 인덱스가 5개의 샤드로 저장되도록 설정한 예시이다.\n\n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic5.png?raw=true\">\n</p>\n\n<p class=\"notice--info\">\n⚠️ 샤드란 데이터를 분리하기 용이한 기준을 잡고 데이터를 분산저장 하는것\n</p>\n\n<br><br>\n\n### 📌 프라이머리 샤드(Primary Shard)와 복제본(Replica)\n<hr>\n\nElasticsearch는 샤드를 사용해 데이터를 저장하는 방식을 채택했기 때문에 샤드의 문제점이 그대로 발생한다. 샤드는 데이터를 분산 저장하기 때문에 **분산저장된 데이터중 일부가 유실되거나 사라질수 있어 복제본(Replica)을 생성해서 보관한다.** 때문에 Elasticsearch에서도 샤드에 대한 Replica를 항상 생성하여 데이터가 완전히 유실될 위험을 줄이고 있다.\n\nElasticsearch는 별도의 설정을 하지 않으면 **7.0버전부터는 Default로 1개의 샤드로 인덱스를 구성**하고, **6.x이하 버전에서는 Default로 5개의 샤드로 인덱스를 구성**한다. 클러스터에 노드를 추가하면 샤드들이 각 노드들로 분산되고 **Default로 1개의 Replica를 생성**한다. 이때 처음 생성된 샤드들을 **프라이머리 샤드(Primary Shard)** 라고 한다.\n\n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic6.avif?raw=true\">\n</p>\n\n<p class=\"notice--danger\">\n⚠️ 노드가 1개만 있는 경우 프라이머리 샤드만 존재하고 레플리카는 생성되지 않기 때문에 Elasticsearch에서는 데이터 가용성과 무결성을 위해 최소 3개의 노드로 구성할 것을 권장한다!\n</p>\n\n같은 쌍의 샤드와 레플리카는 동일한 데이터를 담고있고, **당연하겠지만 반드시 서로 다른 노드에 저장된다.** 데이터 무결성을 위해 레플리카를 생성한 것이기 때문에 당연히 서로 다른 노드에 저장함으로써 데이터를 항상 유지할 수 있어야 한다.\n\n만약 예를들어 위 그림에서 시스템 다운이나 네트워크 단절로 인해 Node-3이 유실되면 이 클러스터는 Node-3의 0,4번 샤드를 잃어버린다. 그러나 여전히 Node-1의 0번 샤드, Node-2의 4번 샤드가 존재하기 때문에 데이터 유실 없이 클러스터의 사용이 가능하다. \n\n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic7.webp?raw=true\">\n</p>\n\n**노드가 죽어 샤드를 잃으면 클러스터는 처음에 유실된 노드가 복구되기를 기다린다. 그러나 타임아웃이 지나 노드가 복구되지 않을거라 판단되면 유실된 샤드를 복제한다. 프라이머리 샤드가 유실되었다면 레플리카를 복제후 기존 레플리카로 취급당하던 샤드가 프라이머리 샤드가 되고, 레플리카가 유실된 경우 프라이머리 샤드를 복제해 레플리카를 다시 만들어낸다.** \n\n이렇게 Elasticsearch는 프라이머리 샤드와 레플리카를 통해 노드가 유실되어도 데이터의 가용성과 무결성을 보장한다.\n\n\n<br><br><br>\n<br><br><br>\n<br>\n\n\n\n## ✅ 마스터 노드와 데이터 노드 \n\nElasticsearch 클러스터는 하나이상의 노드들로 구성된다. 그 중 하나의 노드는 **인덱스의 메타 데이터, 샤드의 위치와 같은 클러스터 상태 정보를 관리하는 마스터 노드의 역할을 수행한다.** 클러스터 마다 마스터 노드가 존재하고, 마스터 노드가 없다면 클러스터는 작동이 정지된다.\n\n또 일부 노드는 **실제로 색인된 데이터를 저장하고 있는 데이터 노드** 역할을 수행한다.\n\n<br><br>\n\n### 📌 마스터 노드 (Master Node)\n<hr>\n\n\n기본적으로 `elasticsearch.yml`에 Default 설정은 `node.master:true`로 되어 있다. 마스터 노드가 없으면 클러스터의 작동이 정지되기 때문에 **기본적으로 모든 노드는 마스터 노드로 선출될 수 있는 마스터 후보 노드**이다. 만약 현재 마스터 노드가 다운되면 마스터 후보 노드들중 하나가 마스터 노드로 선출되어 마스터 노드의 역할을 수행하게 된다. 이러한 마스터 후보 노드들은 마스터 노드의 정보를 공유하고 있기 때문에 마스터 역할 수행이 바로 가능하다.\n\n그러나 클러스터가 커져, 노드와 샤드의 개수가 많아지게 되면 모든 노드들이 마스터 노드의 정보를 계속 공유하는 것은 부담이 될수 있다. 때문에 마스터 노드 후보 노드를 따로 설정해서 유지하는 것이 전체 클러스터 성능에는 도움이 될 수 있다. 이를 위해 마스터 노드로 사용하지 않을 노드들은 `node.master:false`로 설정하여 마스터 노드의 역할을 하지 않도록 설정하는 것이 좋다.\n\n\n<br><br>\n\n### 📌 데이터 노드 (Data Node)\n<hr>\n\n데이터 노드는 실제로 색인된 데이터를 저장하고 있는 노드이다. 마스터 노드와 데이터 노드를 구분지어 설정하기 위해 마스터 후보 노드들은 `node.data:false` 로 설정하여 마스터 노드 역할만 하고 데이터는 저장되지 않게 설정할 수 있다. 이를 통해 마스터 노드는 클러스터 관리만 수행하고, 데이터 노드는 데이터 저장 역할만 수행하여 효율적으로 클러스터를 운영할 수 있다.\n\n다음 코드는 node-1은 마스터 역할만 수행하는 노드, node-2,3,4는 데이터 노드 역할만 수행하는 노드로 설정한 예제이다. \n```yml\n## config/elasticsearch.yml\n\n# node-1\nnode.master: true\nnode.data: false\n\n# node-2\nnode.master: false\nnode.data: true\n\n# node-3\nnode.master: false\nnode.data: true\n\n# node-4\nnode.master: false\nnode.data: true\n```\n\n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elastic9.png?raw=true\">\n</p>\n\n<p class=\"notice--danger\">\n⚠️ 실제 운영 환경에서는 마스터 후보 노드를 1개만 설정하면 안되고 최소 3개이상의 홀수개로 설정해야 한다. 그렇지 않으면 Split Brain 문제가 발생할 수 있다.\n</p>\n\n\n\n\n<br><br><br><br><br><br><br>\n> ✅ 참고 : https://esbook.kimjmin.net\n\n\n\n\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-852571357,"tx":25964},"sXFUuwDsSBfhbhTA/content":{"id":"sXFUuwDsSBfhbhTA/content","type":"content","text":"---\npermalink: /2024-03-19-SFA(Sales Force Automation)란/\npublished: true\ntitle: \"[ERP] SFA(Sales Force Automation)란?\"\ndate: 2024-03-19 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"SFA(Sales Force Automation)란?\"\ncategories:\n- ERP\ntags:\n- ERP\n- SFA\n---\n\n<br><br>\n\n\n## ✅ SFA(Sales Force Automation)란?\n\nSFA는 Sales Force Automation의 약어로 사용되며, 기업이 영업 활동을 관리하고 자동화하기 위해 사용되는 시스템을 의미한다. SFA 시스템의 주요 목적은 영업직원의 동선 및 고객 상담의 진행 상황과 같은 정보를 수집하고 이를 관리하여 실질적인 매출로 이어지도록 돕는 것이며, 영업 프로세스를 효율적으로 실행하여 영업팀의 생산성을 높이고 매출을 증대하는 것이다.\n\n\n<br><br><br><Br>\n\n## ✅ SFA 사용 이유\n1. **영업 조직 효율화**\n\t\n조직 내 영업활동으로 취득한 고객 정보를 일원화해 관리하고, 실시간으로 업데이트 한다면 영업 조직은 물론 업체 타 부서 직원들까지 항상 최신 정보를 바탕으로 고객을 응대할 수 있게 된다. 특히 업무 미팅 이전에 고객업체는 물론이고 관련 업계 현황까지 미리 확인하여 고객의 요구사항을 파악해 선제적으로 상품과 서비스를 제안하는것이 가능해진다.\n\n또한 전체 영업현황을 꿰뚫는 인사이트를 유지할 수 있고 영업조직 내부적으로도 개별 직원 각각의 업무 진척 상황을 빠르게 파악하는 것이 가능해진다. \n\n\n2. **영업 업무 구조화**\n\n전통적으로 영업 업무는 개별직원의 역량과 경험에 의지하는 경우가 많다. 높은 실적을 올려온 소수의 직원과 나머지 평균 수준의 직원을 비교하면 업무 처리 효율은 물론, 실적에서도 큰 격차를 드러내기 마련이다. \n\n이러한 뛰어난 영업직원의 영업 노하우를 메뉴얼화, 구조화해 다른 동료와 협업하도록 한다면 기존 조직의 한정적인 시간과 비용, 인력으로 최상의 결과를 얻어낼 수 있다.\n\n또한 실시간으로 업데이트 된 영업 프로세스 현황은 비단 영업부서를 넘어 재고 관리, 인사, 자금 조달 등 기업 내 모든 타 부서에서 활용돼 보다 효과적인 전략을 세울 수 있게 된다. \n\n<br><br><br><br>\n\n## ✅ SFA의 주요 기능\n\n1. **안건관리 기능**\n\n영업 담당자가 담당하고 있는 안건이 어떤 상황에 있는지, 상담상 정체나 장애가 없는지, 계약이 확정될 확률이 어느정도인지, 이러한 각각의 안건과 관련된 정보를 관리한다.\n\n영업 업무는 잠재고객 발굴부터 계약 성사에 이르기 까지 몇 가지 단계를 거친다. 그리고, 각각의 단계에서 어느정도 상담이 진행되었는지를 관리하고 개별 안건에 맞는 액션을 위하는 것이 확실한 매출을 확보하는 수단이 된다.\n\n\n2. **활동관리 기능**\n\n영업사원에게 있어 한정된 시간을 유효하게 사용하여 고객과의 커뮤니케이션을 하는 것은 필수이다. 그러나 안건에 따라 방문 빈도에 차이가 나거나 방문할 수 없어 방치를 하게 되면 안건의 타이밍이 어긋나기 때문에 유망한 잠재 고객을 경쟁사에게 빼앗기는 일이 발생하기도 한다.\n\n이를 보완해주는 기능이 활동관리 기능이다. 영업 담당자가 얼마나 계약에 공헌하고 있는지, 매출에 공헌하고 있는지 보다 정확하게 평가하는 것이 가능하여 낭비없이 영업 활동을 전개할 수 있다.\n\n3. **고객관리 기능**\n\n일반적으로 기업 전체 매출의 상당 부분은 소수 핵심고객에게서 발생한다. \"전체 20%의 고객이 전체 매출의 80%를 차지한다\"는 파레토 법칙이 그대로 적용된다는 것이다. 따라서 SFA를 통해 핵심고객을 기업 규모와 업종, 형태 등으로 분석하고 실시간 업데이트 된 데이터를 기반으로 새로운 상품과 서비스를 선제적으로 제안해 고객업체를 만족시키고 매출 역시 향상시킬 수 있다.\n\n4. **보고서 및 대시보드**\n\nSFA 시스템은 영업팀의 실적 및 성과를 모니터링 할 수 있는 다양한 보고서 및 대시보드를 제공한다. 판매 동향, 목표 달성 여부, 판매 리드 등의 정보를 시각적으로 표시하여 판매활동을 평가하고 의사 결정을 내리는 데 도움을 준다. 이를 통해 영업 조직은 성과를 분석하고 개선할 수 있는 영역을 식별 할 수 있다.\n\n<br><br><br><br>\n\n## ✅ SFA의 장점\n\n1. **고객 관리 및 관계 강화**\n\nSFA 시스템은 고객 정보를 중앙 집중식으로 관리하고 추적하여 영업팀이 고객과의 관계를 효과적으로 관리할 수 있다. 이를 통해 고객에 대한 개별화된 서비스를 제공하고 고객과의 관계를 강화할 수 있다.\n\t\n2. **영업 활동 효율성 증대**\n\nSFA 시스템은 영업 프로세스를 자동화하여 영업 팀이 시간을 절약하고 생산성을 높일 수 있도록 돕는다. 주문 처리, 견적 작성, 계약 관리 등의 반복적인 작업을 자동화함으로써 영업 팀은 더 많은 시간을 고객과의 상호 작용에 집중할 수 있다.\n\n\n3. **실시간 데이터 및 분석 제공**\n\nSFA 시스템은 실시간으로 영업 데이터를 수집하고 분석하여 영업 팀이 실시간으로 성과를 모니터링하고 의사 결정을 내릴 수 있도록 돕는다. 이를 통해 영업 전략을 신속하게 수정하고 조정할 수 있으며, 시장 동향을 파악하여 적절한 대응을 할 수 있다.\n\n\n4. **고객 서비스 향상**\n\nSFA 시스템은 고객 서비스를 개선하는 데 도움을 준다. 고객의 요청이나 문의사항을 신속하게 처리하고 추적함으로써 고객 만족도를 향상시킬 수 있다.\n\n\n5. **정확한 예측과 분석**\n\nSFA 시스템은 데이터를 기반으로 판매 예측 및 성과 분석을 제공하여 영업 팀이 향후 수익을 예측하고 영업 전략을 개선할 수 있도록 돕는다.\n\t\n","properties":"\n","discussions":{},"comments":{},"hash":1645710421,"tx":26006},"QCDOYp9baGlX0tfx/content":{"id":"QCDOYp9baGlX0tfx/content","type":"content","text":"---\npermalink: /2024-03-11-ERP(Enterprise Resource Planning)란\npublished: true\ntitle: \"[ERP] ERP(Enterprise Resource Planning)란?\"\ndate: 2024-03-11 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"ERP(Enterprise Resource Planning)란?\"\ncategories:\n- ERP\ntags:\n- ERP\n---\n\n<br><br>\n\n\n## ✅ ERP(Enterprise Resource Planning) 란?\n\nERP는 Enterprise Resource Planning의 약자로, **기업 내 모든 부문에 걸쳐 자원을 효과적으로 관리하기 위한 통합 솔루션이다.** EPR 시스템은 주문 처리, 재고 관리, 생산 계획, 구매, 판매, 회계, 인사 등 조직 내의 다양한 업무 영역을 포함하며 조직의 다양한 기능을 통합하여 효율성과 생산성을 향상시키고 의사 결정을 지원하기 위해 실시간 데이터를 제공한다.\n\n일반적으로 ERP 시스템은 다양한 모듈을 제공하며, 비즈니스를 효율적으로 운영하는 데 필수적인 자동화와 통합 등을 제공한다. 예를 들어 판매 모듈에서는 판매계획, 주문관리, 실적관리 등의 판매 관련 서비스를 제공하고, 인사 모듈에서는 인사관리, 근태관리, 평가관리 등의 서비스를 제공한다.\n\nERP시스템은 DB와 함께 작동하여 모든 부서와 사용자가 하나의 통합된 시스템에서 작업할 수 있도록 해주며 이러한 통합은 데이터의 일관성과 신뢰성을 보장하여 중복된 작업을 피하고 정보를 쉽게 공유할 수 있도록 도와준다.\n\n\n<br><br><br><br>\n\n## ✅ ERP 시스템 필수 요소\n현대 ERP 시스템에는 관련 산업과 제공하는 모듈에 따라 다양한 기능을 포함하고 있지만, 아래 10가지 기본 기능은 ERP 시스템의 필수 요소이다.\n\n1. **공통 데이터 베이스**\n\n정보 및 단일 데이터 버전을 중앙화해 일관성 있는 데이터를 제공하고 회사의 각 기능을 종합적으로 사용할 수 있다.\n\n2. **내장형 분석**\n\n보고 및 규제 준수, 셀프 BI, 분석 툴이 내장되어 비즈니스의 모든 영역에 대해 인사이트를 제공할 수 있다.\n\n3. **데이터 시각화**\n\n대시보드, KPI(핵심성과지표) 등의 분석을 통해 주요 정보를 시각적으로 표시함으로써 빠른 의사결정을 가능하게 한다.\n\n4. **자동화**\n\nAI, 머신러닝을 통해 반복업무를 자동화하고 고급 RPA를 제공한다.\n\n5. **일관성 있는 UI/UX**\n\n여러 모듈들이 동일한 모양과 느낌을 이루고, 프로세스, 사용자, 사업부, 사업장, 제품 라인에 손쉽게 사용 가능한 구성과 툴을 제공한다.\n\t\n6. **통합**\n\n비즈니스 프로세스와 워크플로우를  완벽 통합하고 다른 SW 솔루션 및 데이터와 쉽게 통합된다.\n\t\n7. **새로운 기술 지원**\n\nAI 및 머신러닝, IoT, RPA, 보안 및 개인정보 보호 기능, 모바일을 지원한다.\n\t\n8. **안정적이고 검증된 기술 플랫폼**\n\n빠르고 안정적이며 입증된 기술스택을 지원한다.\n\t\n9. **다국어 지원**\n\n다양한 언어를 지원한다. \n\t\n10. **다양한 배포 옵션** \n\n클라우드, 온프레미스 또는 하이브리드 중에서 선택할 수 있다.\n\n\n<br><br><br><br>\n\n\n\n## ✅ ERP의 장점\n\n1. **생산성 제고**\n\t\n핵심 비즈니스 프로세스를 합리화, 자동화해 조직의 모든 인력이 더 적은 리소스로 더 많은 작업을 수행 할 수 있다.\n\n2. **시간 단축**\n\t\n업무 보고 속도를 향상시키고 결과를 손쉽게 공유 할 수 있어 불필요한 업무 시간을 단축 할 수 있다.\n\n3. **쉬운 정보 접근**\n\t\n통합 데이터베이스 관리 시스템을 통해 지속적이고 정확한 데이터를 제공하고 중복 데이터 생성을 방지한다. 이를 통해 모든 부서의 사용자들이 실시간으로 업무와 관련된 정보에 쉽게 접근 할 수 있다.\n\n4. **높은 확장성**\n\nERP는 기업의 성장과 함께 시스템 변경 및 적용이 용이하며, Add-On 모듈을 통해 기능을 쉽게 확장 할 수 있다. 이는 변화하는 비즈니스 요구에 유연하게 대응할 수 있도록 해준다.\n\n5. **비용 절감**\n\nERP는 시간 단축과 업무 향상을 통해 비용 절감 효과를 얻을 수 있다. 일관된 데이터와 프로세스 통합으로 인해 인력 및 자원의 효율성이 향상되고, 재고 관리, 생산 계획, 구매 등 비즈니스 프로세스의 최적화가 가능해진다.\n\n<br><br><br><br>\n\n\n## ✅ ERP의 단점\n\n1. **구축 시간**\n\nERP 시스템을 구축하기 위해서는 정확한 업무 파악과 적합한 ERP 시스템의 선택이 필요하다. 업무 프로세스를 분석하고 시스템을 설계하고 구현하는 과정은 많은 시간과 노력이 필요하다.\n\n2. **구축 비용**\n\nERP 시스템을 구축하는 비용은 기업의 사업 규모와 필요에 따라 다양하다. ERP 시스템을 구축하거나 ASP(애플리케이션 서비스 공급자) 형태의 ERP 시스템을 적용하는 경우에는 상당한 비용이 소요될 수 있다.\n\n3. **복잡한 기능**\n\nERP 시스템은 다양한 기능을 가지고 있기 때문에 이러한 기능에 익숙해지고 효과적으로 사용할 수 있도록 지속적인 교육과 지원이 필요하다.\n\n4. **제품 옵션 관리**\n\n다양한 모듈에서 사용하는 제품군의 옵션이 많거나 특별히 자주 변경되는 경우, 이를 관리하기 어려울 수 있다. ERP 시스템은 이러한 다양한 제품 옵션을 효과적으로 관리하기 위한 유연성이 필요하다.\n\n\n\n<br><br><br><br>\n\n## ✅ ERP의 미래\n\n본인은 클라우드 ERP를 통해 더 효율적인 차세대 ERP 시스템을 구축할 수 있을것으로 생각한다. 관련자료를 다양하게 찾아봤는데 클라우드 ERP의 이점에 대해 자세히 설명해주는 삼성SDS의 인사이트 리포트가 있어 링크를 첨부한다.\n\n[참고 자료 : 왜 클라우드 ERP인가? ](https://www.samsungsds.com/kr/insights/cloud_erp.html)\n\n\n<br><br>\n\n또한 클라우드 ERP에 생성형 AI를 도입하여 고객 운영, 영업 마케팅, 소프트웨어 엔지니어링, 연구개발(R&D) 등에 혁신적인 생산성 증대에 일조하는 관련 인사이트도 첨부하도록 하겠다.\n\n[참고 자료 : 생성 AI, 진정한 지능형 클라우드 ERP의 완성](https://news.sap.com/korea/2023/10/%EC%83%9D%EC%84%B1-ai-%EC%A7%84%EC%A0%95%ED%95%9C-%EC%A7%80%EB%8A%A5%ED%98%95-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-erp%EC%9D%98-%EC%99%84%EC%84%B1/)\n","properties":"\n","discussions":{},"comments":{},"hash":-380270936,"tx":26034},"w2rF7i814I5K61Gi":{"id":"w2rF7i814I5K61Gi","type":"file","name":"2024-04-19-Kibana(키바나)란","parentId":"CHjCxs4lbndBbawK","hash":-951004062,"tx":26081},"w2rF7i814I5K61Gi/syncedContent":{"id":"w2rF7i814I5K61Gi/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1713509848585,"tx":26081},"QCDOYp9baGlX0tfx/contentState":{"id":"QCDOYp9baGlX0tfx/contentState","type":"contentState","selectionStart":3288,"selectionEnd":3288,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1713511355876,"tx":26367},"sXFUuwDsSBfhbhTA/contentState":{"id":"sXFUuwDsSBfhbhTA/contentState","type":"contentState","selectionStart":417,"selectionEnd":417,"scrollPosition":{"sectionIdx":1,"posInSection":0.20416666666666666},"hash":1713511356683,"tx":26368},"4VlIZeIFebGuQ7Yr/contentState":{"id":"4VlIZeIFebGuQ7Yr/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1713513534627,"tx":26451},"kRBjdpE8Q87pKDBk/contentState":{"id":"kRBjdpE8Q87pKDBk/contentState","type":"contentState","selectionStart":194,"selectionEnd":194,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1713740901594,"tx":26478},"cbpX0FKBzhieTySP":{"id":"cbpX0FKBzhieTySP","type":"file","name":"2024-04-22-ELK(Elasticsearch+LogStash+Kibana) 스택이란","parentId":"CHjCxs4lbndBbawK","hash":112666469,"tx":26502},"cbpX0FKBzhieTySP/syncedContent":{"id":"cbpX0FKBzhieTySP/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1713744898227,"tx":26502},"ptoLJUzGpYr1U2Hq":{"id":"ptoLJUzGpYr1U2Hq","type":"file","name":"2024-04-20-Beats(비츠)란?","parentId":"CHjCxs4lbndBbawK","hash":750800656,"tx":27524},"ptoLJUzGpYr1U2Hq/syncedContent":{"id":"ptoLJUzGpYr1U2Hq/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1713750277374,"tx":27524},"ptoLJUzGpYr1U2Hq/content":{"id":"ptoLJUzGpYr1U2Hq/content","type":"content","text":"\n","properties":"\n","discussions":{},"comments":{},"hash":-2088746612,"tx":28464},"w2rF7i814I5K61Gi/content":{"id":"w2rF7i814I5K61Gi/content","type":"content","text":"---\npermalink: /2024-04-19-Kibana(키바나)란/\npublished: true\ntitle: \"[ELK] Kibana(키바나)란?\"\ndate: 2024-04-19 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Kibana(키바나)란?\"\ncategories:\n- ELK\ntags:\n- ELK\n- Kibana\n---\n\n<br><br><br>\n\n빅데이터 아키텍처에서 시각화는 굉장히 중요하다. 예를 들어, 내 웹사이트를 방문한 사람들의 방문 시간대를 알고싶다면 엘라스틱서치를 활용해 어렵지 않게 요일과 시간대별로 사용자수를 알아낼 수 있을 것이다. 그러나 이렇게 얻은 결과를 단순 테이블 형태로 파악한다면 눈에 잘 들어오지 않을 것이다. 이 때문에 우리는 많은 양의 비정형적인 데이터를 보고서나 대시보드 형태로 시각화 하는 과정이 필요하다.\n\n우리는 비츠와 로그스태시를 이용해 수집하고 가공한 데이터를 엘라스틱 서치에 저장하고 이를 Kibana를 통해서 시각화 할 것이다. \n\n<br><br><br><br><br><br>\n\n\n## ✅ Kibana란?\n\n**Kibana**는 Elastic Stack의 중요한 구성 요소 중 하나로, **데이터 시각화 및 분석 도구**이다. Elasticsearch에서 저장된 데이터를 쉽게 시각화 하고 탐색할 수 있는 웹 인터페이스를 제공한다. **Kibana는 사용자가 Elasticsearch에 쿼리를 실행하고, 결과를 다양한 형태로 시각화 하여 분석할 수 있도록 도와준다.** Kibana의 기능은 크게 세가지 정도로 분류될 수 있다.\n\n\n1. **데이터 분석과 시각화 툴**\n오픈소스 기반의 데이터 탐색 및 시각화 도구 제공\n\n2. **엘라스틱 관리**\n보안, 스냅샷, 인덱스 관리, 개발자 도구 등 제공\n\n3. **엘라스틱 중앙 허브**\n모니터링을 비롯해 엘라스틱 솔루션을 탐색하기 위한 포털\n\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/kibana1.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br><br>\n\n## ✅ Kibana 사용 이유\n\n그렇다면 Kibana를 언제, 왜 사용해야 할까? 만약 Elasticsearch를 검색엔진으로 사용하면서 Kibana를 사용하지 않는다면 통계 페이지나 데이터 처리를 위해 WAS를 직접 구성하고, amCharts, c3 등의 차트 라이브러리를 이용하여 UI 코드를 작성해야 할 것이다. 번거로운 작업이지만 하려면 할 수 있다. \n\n그러나 Kibana를 사용하면 쉽고 간단하고 빠르게 데이터 시각화를 완성할 수 있다. 또한 Kibana는 오픈소스이기 때문에 접근성도 좋다. 때문에 Elasticsearch의 실시간 데이터 시각화를 위해서는 Kibana는 거의 필수라고 볼 수 있다.\n\n\n<br><br><br><br><br><br><br>\n\n## ✅ Kibana의 시각화 주요 기능\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/kibana2.png?raw=true\">\n</p>\n\nKibana 시각화에는 여러 주요 기능이 있다. **Discover, Visualize, Dashboard, Canvas, Maps** 등이 있는데 각각에 대해 알아보도록 하자.\n\n\n<br><br>\n\n### 📌 Discover\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/kibana3.png?raw=true\">\n</p>\n\n**Discover는 데이터를 확인하고 탐색하기 위한 용도로 사용된다.** 문서/이벤트/도큐먼트/로그의 시간에 따른 발생량을 히스토그램으로 보여주기도 하고 데이터 구조나 필드 타입 등을 간단히 확인할 수도 있다.\n\n\n<br><br>\n\n### 📌 Visualize\n<hr>\n\n**Visualize 메뉴는 엘라스틱 서치에 저장된 데이터를 그래프나 표, 지도 등 다양한 타입으로 보여주는 역할을 한다.** 라인, 바, 파이 차트부터 맵, 시계열 비주얼 빌더, 태그 클라우드 등 다양한 시각화 타입을 지원한다. 가장 효과적으로 데이터를 보여줄 수 있는 타입을 선택하면 된다. 이때 시각화는 **엘라스틱 서치의 집계를 통해 그래프를 그린다.**\n\n<p class=\"notice--info\">\n⚠️ 메트릭 집계 : 평균/최소/최대 같은 수량을 계산한다.  <br>\n⚠️ 버킷 집계 : 특정 기준에 맞춰 데이터를 분리한다. 서브 버킷을 생성할 수 있다.  <br>\n⚠️ 파이프라인 집계 : 집계 결과를 입력으로 받아 다시 집계를 한다. 부모/형제 집계 유형이 있다.  \n</p>\n\n<br><br>\n\n### 📌 Dashboard\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/kibana4.png?raw=true\">\n</p>\n\n\n**대시보드는 시각화 타입들을 한 페이지에 모아 볼 수 있는 기능으로, 한 화면에서 다양한 관점으로 데이터를 보면서 분석할 수 있다.** 또한 자동 새로고침 기능을 이용해 대시보드를 통해 시스템을 실시간으로 모니터링 할 수 있다. 따로 기술적으로 학습해야 하거나 어려운 내용은 없다. \n\n<br><br>\n\n### 📌 Canvas\n<hr>\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/kibana5.png?raw=true\">\n</p>\n\n**캔버스는 인포그래픽 형태로 데이터를 프레젠테이션할 수 있게 해주는 툴이다.** 일종의 파워포인트 처럼 화면을 편집하고 보여줄수 있다고 생각하면 된다. Kibana의 Dashboard가 아주 좋은 시각화 모듈을 제공하지만, 뭔가 정형화된 느낌이 들어 본인만의 방식으로 시각화 자료를 만들고 싶다면 Canvas를 사용하면 된다. \n\n\n <br><br>\n\n### 📌 Maps\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/kibana6.png?raw=true\">\n</p>\n\n**Maps는 위치정보가 포함된 데이터를 지도에 올려 시각화 할 수 있고, 멀티 레이어 가능을 통해 다양한 형태의 지도를 레이어한 화면에서 볼 수 있다.**\n","properties":"\n","discussions":{},"comments":{},"hash":2007778019,"tx":28500},"cbpX0FKBzhieTySP/content":{"id":"cbpX0FKBzhieTySP/content","type":"content","text":"---\npermalink: /2024-04-22-ELK(Elasticsearch+LogStash+Kibana) 스택이란/\npublished: true\ntitle: \"[ELK] ELK(Elasticsearch+LogStash+Kibana) 스택이란? \"\ndate: 2024-04-23 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"ELK(Elasticsearch+LogStash+Kibana) 스택이란\"\ncategories:\n- ELK\ntags:\n- ELK\n- ElasticSearch\n- LogStash\n- Kibana\n- Solr\n---\n\n<br><br><br>\n\n## ✅ ELK 스택이란 ?\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elk1.jpg?raw=true\">\n</p>\n\n\nELK 스택은 **Elasticsearch, LogStash, Kibana**의 로그 수집 및 시각화를 위한 세가지 오픈소스 프로젝트를 의미하는 약어이다. ELK 스택은 원래 독립적으로 개발되던 오픈소스 프로젝트였지만 각각의 구성 요소가 개별적으로 갖는 강점을 결합하여 효과적인 데이터 분석 및 모니터링 솔루션으로 거듭날 수 있었기에 함께 사용하게 됐다.\n\n\n보통 메인은 **Elasticsearch**이다. **Elasticsearch**를 사용하고자 할 때, 다양한 소스에서 데이터를 편하게 수집하기 위해 **LogStash**를 함께 사용하고, 저장된 데이터를 편하게 시각화하고 분석하기 위해 **Kibana**를 함께 사용하는 순서를 띄긴한다. 굳이 이 3가지 프로젝트를 항상 함께 사용할 필요는 없다. 그러나 ELK 스택은 **Elastic**이라는 회사에서 함께 개발하고 세가지 프로젝트를 같이 사용하기에 편리하게끔 최적화 시켜놨기 때문에 다른 특별한 이유가 없다면 함께 사용하는게 좋다.\n\n<br><br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elk2.jpg?raw=true\">\n</p>\n\nELK 스택은 독립된 모듈로 사용할 수도 있고, 다른 오픈소스 프로젝트와 연동해도 무방하다. **Beats**라는 경량화된 데이터 수집 모듈과 함께 사용할 수도 있다. 또한 데이터를 안정적으로 버퍼링하고 전달하는 **Redis, Kafka, RabbitMQ** 등과 같이 사용할 수도 있다.\n\n각각의 요소에 대한 포스팅은 따로 작성해뒀으니 여기서는 간략하게만 설명하고 넘어가도록 하겠다. 자세한 포스팅은 [ELK 카테고리](https://idkim97.github.io/categories/#elk)에 작성되어 있으니 참고하면 좋겠다.\n\n<br>\n\n### [📌 E : Elasticsearch](https://idkim97.github.io/2024-04-18-ElasticSearch%28%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%29%EB%9E%80/)\n<hr>\n\n**Elasticsearch는 실시간 분산형 검색엔진이다.** 주로 데이터 검색 및 분석을 위해 사용되고 데규모 데이터를 저장하고 실시간으로 검색할 수 있도록 설계되었다. Java 기반으로 제작되었고, 스키마가 없는 NoSQL 데이터베이스 계열에 속한다.\n\n\n<br>\n\n### [📌 L : LogStash](https://idkim97.github.io/2024-04-17-LogStash%28%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C%29%EB%9E%80/)\n<hr>\n\n**LogStash는 다양한 소스에서 데이터를 수집하고, 변환하며, ElasticSearch 또는 다른 저장소에 전달하는 데이터 처리 파이프 라인 도구이다.** 로그파일, 이벤트로그, 메트릭 등 다양한 소스에서 데이터를 수집할 수 있고, 데이터를 필터링 및 정규화하여 Elasticsearch에 인덱싱 할 수 있다.\n\n\n<br>\n\n### [📌 K : Kibana](https://idkim97.github.io/2024-04-19-Kibana%28%ED%82%A4%EB%B0%94%EB%82%98%29%EB%9E%80/)\n<hr>\n\n**Kibana는 Elasticsearch에서 저장된 데이터를 시각화하고 분석하는 데 사용된다.** 사용자는 대시보드, 차트, 그래프 및 지도를 생성하여 데이터를 탐색하고 시각적으로 표현할 수 있다. Elasticsearch와 연동하여 거의 실시간으로 데이터를 시각화 할 수 있다는 큰 장점이 있다.\n\n<br>\n\n### 📌 Beats\n<hr>\nELK스택이 더욱 널리 사용될 수 있었던 큰 요인중 하나가 Beats의 연동이다. 기존 LogStash는 데이터 수집과 데이터 입출력 및 필터 그리고 변환까지 담당하고 있었기에 오버헤드가 굉장히 크다. 그러나 데이터 수집만을 담당하는 Beats를 도입함으로써 애플리케이션의 성능에 영향을 미치지 않고 필요한 이벤트를 수집할 수 있다.\n\n엘라스틱서치에서는 공식적으로 파일비트, 메트릭비트, 패킷비트, 윈로그비트, 오딧비트, 하트비트, 펑션비트, 카프카비트 등 상당히 많은 비트를 지원한다. 또한 온프레미스와 가상 머신뿐만 아니라 컨테이너와 쿠버네티스 환경에서도 사용이 가능하다.\n\n<br>\n\n\n\n<br><br><br><br><Br><br>\n\n## ✅ ELK 스택을 왜 사용할까?\n\nELK스택은 Elasticsearch + Logstash + Kibana를 함께 사용하는 기술로 로그 수집 + 검색엔진 + 대시보드의 기능을 수행한다는 것을 알았다. 그럼 우리는 왜 굳이 ELK스택을 활용하는지 알아야 사용해야 할 필요성을 느끼고 당위성을 체감할 수 있다. 왜 많은 사람들이 ELK스택을 사용하는 것일까?\n\n**왜 ELK스택을 사용할까**를 파악하는 가장 쉬운 방법은 ELK를 대체할 다른 기술은 어떠한지를 살펴보면 된다. ELK보다 더 좋고 편한 기술이 있다면 그걸 사용하지 ELK를 사용하진 않을 것이기 때문이다.\n\n일단 ELK스택에서 가장 핵심기술은 **Elasticsearch**이다. 검색엔진으로 Elasticsearch를 선정한 뒤, 이에 대한 데이터를 편하게 수집하고, 대시보드를 보여줄 수 있는 편리한 툴을 찾은 결과 ELK스택이 탄생하게 된 것이다.\n\n\n그렇다면 Elasticsearch를 대체할 수 있는 검색엔진을 살펴보면 된다. 현재 Elasticsearch와 견줄만한 검색엔진은 **Solr**과 **Splunk**가 있다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/elk3.jpg?raw=true\">\n</p>\n\nSplunk는 유료로 제공되는 검색엔진이므로 제외하고 Solr와 Elasticsearch에 대한 비교를 해보도록 하겠다. \n\n<br><br><br>\n\n### 📌 Elasticsearch VS Solr\n<hr>\n\n **Elasticsearch 장점**\n \n 1. 사용 편의성 : RESTful API를 제공하여 쉽게 데이터를 쿼리하고 관리할 수 있다. 진입 장벽이 낮다.\n 2. 확장성 : Elasticsearch는 scale-out이 가능하다. 클러스터에 노드를 추가함으로써 트래픽이 증가해도 성능을 유지할 수 있다.\n 3. 생태계 : 오픈소스이기 때문에 활발한 커뮤니티와 다양한 플러그인, 도구가 제공된다.\n\n\n**Elasticsearch 단점**\n1. 메모리 사용 : Elasticsearch는 많은 메모리를 사용하므로, 메모리 제약이 있는 환경에서 조심해야 한다.\n2. 복잡성 : 초기설정이 복잡하다. 클러스터링, 보안 설정등을 구성하는데 어려울 수 있다.\n\n\n\n**Solr 장점**\n1. 성능 : 일부 케이스에서 Elasticsearch보다 빠른속도를 보이는 경우가 있음\n2. 기능 완성도 : 텍스트 분석, 튜닝 옵션 등 검색과 관련된 다양한 기능 지원\n\n**Solr 단점**\n1. 복잡성 : 초기 설정이 어렵고 러닝 커브가 높을 수 있다.\n2. 생태계 : Elasticsearch보다 커뮤니티가 작고 플러그인 및 도구가 적다.\n\n\n<br><br><br>\n\n장단점을 보면 Elastiscsearch가 성능이 항상 더 좋아보이지는 않는다. 본인이 안정적인 환경속에서 빠른 검색 속도를 원한다면 오히려 Solr를 사용하는게 더 좋아보인다. 그럼에도 불구하고 Elasticsearch가 더 많은 사람들이 사용하는 검색엔진인 가장 큰 이유는 **생태계의 차이**라고 생각한다.\n\nElasticsearch는 이미 사용하기 너무 편리하게 생태계가 잘 갖춰져 있다. \n\n로그를 수집하고 가공하는 **[logstash](https://idkim97.github.io/2024-04-17-LogStash%28%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C%29%EB%9E%80/)**  \nlogstash가 무겁다면 로그 수집만을 목적으로 설계된 **Beats**  \n데이터 처리 이벤트에 대한 버퍼를 처리하는 **Kafka**  \n검색엔진의 결과를 다양한 UI로 제공하는 **[Kibana](https://idkim97.github.io/2024-04-19-Kibana%28%ED%82%A4%EB%B0%94%EB%82%98%29%EB%9E%80/)**  \n그리고 이 모두와 연동해서 사용할 수 있는 **[Elasticsearch](https://idkim97.github.io/2024-04-18-ElasticSearch%28%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%29%EB%9E%80/)**  \n\n이렇게 안정적인 생태계가 구축된 것이 Elasticsearch를 많은 사람들이 이용하는 가장 큰 이유가 아닐까 싶다.\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1523169470,"tx":29942},"X3mDwXGkmeIJpTbt/content":{"id":"X3mDwXGkmeIJpTbt/content","type":"content","text":"컨테이너에서 다양한 네임스페이스를 설정가능하고 컨테이너를 생성할때 마다 관련 설정을 해줘야함 -> 불편\n\n그래서 컨테이너 런타임이 개발됨! -> Docker!!\n\n===================================================\n\n**[운영체제의 기초]** -> 얘를 알아야 컨테이너를 사용할때 발생하는 이슈 처리 가능\n\n커널스페이스?\n유저스페이스?\n                \n유저스페이스에는 어플리케이션이 있고, 커널스페이스에는 OS Code가 존재. App과 OS Code가 통신하는 유일한 방법은 System call을 통한 통신밖에 없음. 대표적으로 ls 라는 명령어. \n\nbash로 ssh접속\nㄴ ls 날리면 ls app 꺼지고 화면에 결과 출력 \n\nSystem call은 **software interrupt**로 구성되어 있고, 이를 사용해서 OS Code와 통신/ (**hardware iterrupt**?) ( **IRQ**? )\n\n**Blocking IO , Non-blocking IO**\n\n**[ 컨테이너 원리 ]**\n유저스페이스의 app에서 명령을 보내면 ( system call )\n커널스페이스의 8가지 네임스페이스 fork() -> ns\n근데 너무 복잡해/ 사람눈에도 안들어오고 ns매번설정하기도 귀찮아\n-> 컨테이너 런타임 ( Docker ) 탄생이유\n\n\n**[ Docker ]**\n유저스페이스에서 동작을 하고, System Call을 사용해 커널스페이스에 명령을 내려주는 작업을 어플리케이션딴에서 자동으로 설정해주는 역할 \n\n\n====================================================\n\n컨테이너 Orchestration -> 쿠버네티스\n\n**Health Check Process API**를 따로뽑아내는 개발습관 중요 !\n\n====================================================\n**[ 면접단골질문 ]**\n공개키 비밀키 알고리즘\n대칭형 비대칭형에는 뭐가있지 ?\n\n====================================================\n\n요즘은 로그를 찍을때 두가지 방법이 있음\n1. stdout(err) -> 콘솔에 찍기\n2. txt파일에 저장하기 ( 요즘은 사용 x )\n\n최근에는 실무에서 컨테이너를 대부분 사용하는데,\n컨테이너가 여러개가 있을때, txt에 log를 기록하면 매번 확인하고 싶은 컨테이너에 접속해서, 로그가 담긴 txt파일을 일일히 확인해야하는 번거로움이 생김.\n\n근데 콘솔에 출력하면 putty같은걸 사용해서 로그를 본다고 했을때, putty꺼버리면 콘솔에 출력된 로그가 꺼져버려..\n\n그래서 docker log를 통해 이를 보완하는데\n컨테이너에서 stdout으로 로그를 찍으면 docker log를 통해 이 로그를\nfile에 기록해서 외부로 저장해버려 (모든 컨테이너의 로그)\n\n외부라고 하면 로그저장소를 의미하는데, 로그저장소에 file형태로 로그를 저장하고, kibana, splunk같은 툴을 사용해서 쿼리를 날려서 내 로그 전체를 살펴보는 방식으로 실무에서 사용한다.\n\n\n======================================================\n\n**OSI 7계층**\nL1(Physical Layer)\nL2(Data Link) : L1으로 연결된 두 노드간의 데이터 전송\nL3(Network) : Routing,Addressing을 사용해 노드간의 데이터를 어디에 전송할지 결정해주는 역할\nL4(Transport) : 포트넘버로 목적지 프로세스를 결정간으\nL5(Session) : 세션관리\nL6(Presentation) : \n","properties":"\n","discussions":{},"comments":{},"hash":-405961906,"tx":30219},"MviwGZUVucL3T4n8/contentState":{"id":"MviwGZUVucL3T4n8/contentState","type":"contentState","selectionStart":321,"selectionEnd":321,"scrollPosition":{"sectionIdx":23,"posInSection":0.6666666666666666},"hash":1714107544232,"tx":30222},"nOITFWSLtVkWensy/contentState":{"id":"nOITFWSLtVkWensy/contentState","type":"contentState","selectionStart":7708,"selectionEnd":7708,"scrollPosition":{"sectionIdx":110,"posInSection":0.27621483375959077},"hash":1714107544981,"tx":30223},"toS351vpmJre9cYC/contentState":{"id":"toS351vpmJre9cYC/contentState","type":"contentState","selectionStart":329,"selectionEnd":329,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1714107545987,"tx":30224},"jfStBciYCU0re8LF/contentState":{"id":"jfStBciYCU0re8LF/contentState","type":"contentState","selectionStart":6589,"selectionEnd":6587,"scrollPosition":{"sectionIdx":79,"posInSection":0.18169209431345354},"hash":1715218283466,"tx":30230},"YDJJdqjhA30zySZh":{"id":"YDJJdqjhA30zySZh","type":"file","name":"2024-05-09-HashMap","parentId":"oX7d6ygndZcITdfY","hash":1516630968,"tx":30256},"YDJJdqjhA30zySZh/syncedContent":{"id":"YDJJdqjhA30zySZh/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1715219393357,"tx":30256},"ptoLJUzGpYr1U2Hq/contentState":{"id":"ptoLJUzGpYr1U2Hq/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1715220917221,"tx":30524},"cbpX0FKBzhieTySP/contentState":{"id":"cbpX0FKBzhieTySP/contentState","type":"contentState","selectionStart":3502,"selectionEnd":3469,"scrollPosition":{"sectionIdx":7,"posInSection":0.5592417061611374},"hash":1715221542156,"tx":30859},"YDJJdqjhA30zySZh/content":{"id":"YDJJdqjhA30zySZh/content","type":"content","text":"---\npermalink: /2024-05-09-Java HashMap 사용법 및 총정리 /\npublished: true\ntitle: \"[자료구조] Java HashMap 사용법 및 총정리\"\ndate: 2024-05-09 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Java HashMap 사용법 및 총정리\"\ncategories:\n- 자료구조\ntags:\n- 자료구조\n- HashMap\n---\n<br><br><br>\n\n## ✅ HashMap이란 ?\n\nHashMap은 Map 인터페이스를 구현한 대표적인 Map 컬렉션이다. Map 인터페이스를 상속하고 있기 때문에 Map의 성질을 그대로 사용할 수 있다. 키(Key)와 값(Value)로 구성된 객체를 저장하는 구조를 가지는데, **값은 중복 저장될 수 있지만, 키는 중복 저장될 수 없다.** 또한 HashMap은 이름 그대로 Hashing을 사용하기 때문에 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/hashmap1.png?raw=true\">\n</p>\n\n위 그림처럼 HashMap은 내부에 '키'와 '값'을 저장하는 구조를 띄는데, 해시 함수를 통해 키와 값이 저장되는 위치를 결정하기 때문에, 사용자는 저장된 위치를 알 수 없고 삽입되는 순서 또한 저장 위치와 관계가 없다.\n\n<br><br><br><br><br><br>\n\n\n## ✅ HashMap 사용법\n\n### 📌 HashMap 선언\n```java\nHashMap<String,String> map1 = new HashMap<String,String>();\t// HashMap 생성\nHashMap<String,String> map2 = new HashMap<>();\t\t\t// 타입 파라미터 생략 가능\nHashMap<String,String> map3 = new HashMap<>(map1);\t\t// map1의 모든 값을 가진 HashMap 생성\nHashMap<String,String> map4 = new HashMap<>(10);\t\t// 초기화 크기 지정\n```\n\nHashMap은 키,값을 파라미터로 설정하고 기본생성자를 호출하면 생성할 수 있다. 타입 파라미터는 생략 가능하다. 동적으로 메모리를 할당 하기 때문에 사이즈를 정해줄 필요가 없지만 초기 크기를 설정하는 것도 가능하다.  \n\n<br><br>\n\n### 📌 HashMap 값 추가\n<hr>\n\n```java\nHashMap<Integer,String> map = new HashMap<>();\nmap.put(1,\"엄마\");\nmap.put(2,\"아빠\");\nmap.put(3,\"동생\");\n```\nHashMap에 값을 추가할 때는 ```put(key,value)``` 메소드를 사용할 수 있다. 이때 HashMap은 중복키값을 허용하지 않기 때문에 기존에 존재하는 키값을 또 추가한다면 기존 value는 새로운 value로 갱신된다.\n\n\n<br><br>\n\n### 📌 HashMap 값 삭제\n<hr>\n\n```java\nHashMap<Integer,String> map = new HashMap<>();\nmap.put(1,\"엄마\");\nmap.put(2,\"아빠\");\nmap.put(3,\"동생\");\n\nmap.remove(1);\t\t// key값 1 제거\nmap.clear();\t\t// 모든 값 제거\n```\n\nHashMap의 값을 제거하려면 ```remove(key)``` 메소드를 사용하면 된다. 오직 키 값을 가지고 요소를 삭제할 수 있다. ```clear()``` 메소드는 HashMap의 모든 값을 제거하고 메모리 누수를 최소화 하기 위해 HashMap 사용 완료후 반드시 추가해주는 습관을 들이는 것이 좋다.\n\n\n<br><br>\n\n### 📌 HashMap 값 출력\n<hr>\n\n```java\nHashMap<Integer,String> map = new HashMap<>();\nmap.put(1,\"엄마\");\nmap.put(2,\"아빠\");\nmap.put(3,\"동생\");\n\n\nSystem.out.println(map);\t\t// {1=엄마, 2=아빠, 3=동생}\nSystem.out.println(map.get(1));\t\t// 엄마\n\n\n// entrySet() 활용\nfor(Entry<Integer,String> entry : map.entrySet()) {\t\t\t\t\t\n\tSystem.out.println(entry.getKey() + \" \" + entry.getValue();\n}\n\n//  keySet() 활용\nfor(Integer i : map.keySet()) {\n\tSystem.out.println(i + \" \" + map.get(i));\n}\n```\n\nHashMap은 일반적인 List나 Array를 출력하는 방법과는 다른 방식으로 출력할 수 있다. List나 Array는 입력한 순서에 따라 배열에 차례대로 값을 저장할 수 있지만, HashMap은 해시함수를 통해 값을 저장하기 때문에 사용자가 값이 저장되는 위치를 알 수 없다. 때문에 일반적인 방법으로 출력할 수 없고 ```entrySet()``` 이나 ```keySet()``` 메소드를 사용하여 출력해야 한다.\n\n```enteySet()```은 forEach문과 함께 사용하면 편리하다.  Entry객체를 하나 만들고 Entry객체에 map을 넣어준다음 ```getKey()```, ```getValue()``` 로 값을 가져오면 된다.\n\n```java\nfor(Entry<Integer,String> entry : map.entrySet()) {\t\t\t\t\t\n\tSystem.out.println(entry.getKey() + \" \" + entry.getValue();\n}\n```\n\n```keySet()```은 ```HashMap```의 key값만 저장하는 메소드인데 key값만 알고있다면 value는 자동으로 알 수 있기 때문에 코드가 간편한 ```keySet()``` 을 활용하는 경우가 많다. 그러나 성능만 놓고 보면 ```EntrySet()```이 훨씬 좋기 때문에 대용량데이터를 처리해야 한다면 ```EntrySet()```을 권장한다. \n\n```java\nfor(Integer i : map.keySet()) {\n\tSystem.out.println(i + \" \" + map.get(i));\n}\n```\n\n<br><br>\n\n### 📌 HashMap 값 출력 - Iterator\n<hr>\n\n```java\nHashMap<Integer,String> map = new HashMap<>();\nmap.put(1,\"엄마\");\nmap.put(2,\"아빠\");\nmap.put(3,\"동생\");\n\nIterator<Entry<Integer,String>> entries = map.entrySet().iterator();\nwhile(entries.hasNext()){\n\tMap.Entry<Integer,String> entry = entries.next();\n\tSystem.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n\nIterator<Integer> keys = map.keySet().iterator();\nwhile(keys.hasNext()){\n\tint key = key.next();\n\tSystem.out.println(key + \" \" + map.get(key));\n}\n```\n\nHashMap에 대한 전체요소를 출력하고자 할때는 Iterator를 사용해 출력할 수 도 있다.\n\n<br><br>\n\n### 📌 HashMap 값 수정\n<hr>\n\n```java\nHashMap<Integer,String> map = new HashMap<>();\nmap.put(1,\"엄마\");\nmap.put(2,\"아빠\");\nmap.put(3,\"동생\");\n\nmap.replace(1,\"새엄마\");\nmap.replace(2,\"새아빠\");\n```\n\n```replace(key,value)``` :  key에 해당하는 value를 변경할 수 있다.\n\n<br><br>\n\n### 📌 HashMap 값 확인\n<hr>\n\n```java\nHashMap<Integer,String> map = new HashMap<>();\nmap.put(1,\"엄마\");\nmap.put(2,\"아빠\");\nmap.put(3,\"동생\");\n\nmap.containsKey(1);\t\t\t// true\nmap.containsValue(\"엄마\");\t\t// true\nmap.isEmpty();\t\t\t\t// false\nmap.size();\t\t\t\t// 3\n```\n\n- ```containsKey(key)``` : key와 일치하는 데이터가 있는지 확인 ( 있으면 true)\n- ```containsValue(value)``` : value와 일치하는 데이터가 있는지 확인 ( 있으면 true)\n- ```isEmpty()``` : HashMap이 비어있는지 확인 ( 비었으면 true )\n- ```size() ``` : HashMap의 key-value 쌍 개수 반환\n\n\n<br><br>\n\n### 📌 HashMap 값 반환\n<hr>\n\n- ```get(key)``` : key와 맵핑된 value 반환\n- ```getOrDefault(key, DefaultValue)``` : key와 맵핑된 value값을 반환하고 value값이 없으면 defaultValue값을 반환한다.\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-81561201,"tx":32516},"EuU8pmiZWx04CkEn":{"id":"EuU8pmiZWx04CkEn","type":"file","name":"2024-05-10-HashSet","parentId":"oX7d6ygndZcITdfY","hash":-1577974828,"tx":32525},"EuU8pmiZWx04CkEn/syncedContent":{"id":"EuU8pmiZWx04CkEn/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1715301203744,"tx":32525},"EuU8pmiZWx04CkEn/content":{"id":"EuU8pmiZWx04CkEn/content","type":"content","text":"---\npermalink: /2024-05-10-Java HashSet 사용법 및 총정리 /\npublished: true\ntitle: \"[자료구조] Java HashSet 사용법 및 총정리\"\ndate: 2024-05-10 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Java HashMap 사용법 및 총정리\"\ncategories:\n- 자료구조\ntags:\n- 자료구조\n- HashSet\n---\n<br><br><br>\n\n## ✅ HashSet이란 ?\n\nHashSet은 Set 인터페이스를 구현한 대표적인 Set 컬렉션이다. Set 인터페이스를 상속하고 있기 때문에 Set의 성질을 그대로 사용할 수 있다. `java.util.HashSet` 클래스를 통해 제공된다. HashSet은 내부적으로 HashMap을 사용하여 요소들을 저장하기 때문에 **같은 요소의 중복 저장을 허용하지 않는다.** 또한 해시함수를 사용해 값을 저장하므로 **저장순서를 유지하지 않는다.**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/hashset1.png?raw=true\">\n</p>\n\n\n<br><br><br><br><br><br>\n\n## ✅ HashSet 사용법\n\n### 📌 HashSet 선언\n<hr>\n\n```java\nHashSet<Integer> set1 = new HashSet<Integer>();\t// HashSet 생성\nHashSet<Integer> set2 = new HaseSet<>();\t// 타입 파라미터 생략 가능\nHashSet<Integer> set3 = new HashSet<Integer>(set1);\t// set1의 모든 값을 가진 HashsSet 생성\nHashSet<Integer> set4 = new HashSet<Integer>(10);\t// 초기 용량 지정\n```\n\nHashSet은 기본적으로 initial capacity(16), load factor(0.75)의 값을 가진 객체를 생성한다. HashSet은 저장공간보다 값이 추가로 들어오는 경우, List처럼 저장공간을 늘리는데 저장 공간을 약 두배정도로 늘려버린다. 여기서 과부하가 많이 발생하기 때문에, 초기 저장할 데이터 갯수를 알고 있다면 Set의 초기 용량을 설정해주는 것이 좋다.\n\n<br><br>\n\n### 📌 HashSet 값 추가\n<hr>\n\n```java\nHashSet<Integer> set = new HashSet<Integer>();\nset.add(1);\nset.add(2);\nset.add(3);\n```\n\nHashSet에 값을 추가할 때는 ```add(value)``` 메소드를 사용할 수 있다. 이때 HashSet은 중복값을 허용하지 않기 때문에 기존에 존재하는 값을 또 추가한다 해도 하나의 값만 유지된다.\n\n<br><br>\n\n### 📌 HashSet 값 삭제\n<hr>\n\n```java\nHashSet<Integer> set = new HashSet<Integer>();\nset.add(1);\nset.add(2);\nset.add(3);\n\nset.remove(1);\t// 값 1 제거\nset.clear();\t// 모든 값 제거\n```\n\nHashSet의 값을 제거하려면 ```remove(value)``` 메소드를 사용하면 된다. ```clear()``` 메소드는 HashSet의 모든 값을 제거하고 메모리 누수를 최소화 하기 위해 HashSet 사용 완료후 반드시 추가해주는 습관을 들이는 것이 좋다.\n\n<br><br>\n\n### 📌 HashSet 값 출력\n<hr>\n\n```java\nHashSet<Integer> set = new HashSet<>();\nset.add(1);\nset.add(2);\nset.add(3);\n\nSystem.out.println(set);\t// [1,2,3]\n\nIterator iter = set.iterator();\nwhile(iter.hasNext()) {\n\tSystem.out.println(iter.next());\n}\n```\n\nHashSet을 그냥 출력하면 대괄호에 묶여 출력된다. HashSet의 각 요소를 출력하기 위해서는 다른방식을 써야하는데, HashSet에는 `get()` 메서드가 없다. 그래서 반복자(Iterator)를 이용해 각 요소를 출력한다.\n\n\n<br><br>\n\n### 📌 HashSet 값 검색\n<hr>\n\n```java\nHashSet<Integer> set = new HashSet<>();\nset.put(1);\nset.put(2);\nset.put(3);\n\nSystem.out.println(set.contains(1));\t// true\nSystem.out.println(set.contains(5));\t// false\n```\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":904891507,"tx":33421},"VQOgcLROQ4ay0oXW/contentState":{"id":"VQOgcLROQ4ay0oXW/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1715814088928,"tx":33449},"VQOgcLROQ4ay0oXW":{"id":"VQOgcLROQ4ay0oXW","type":"file","name":"2023-07-10-좋은 객체지향 설계의 5가지 원칙","parentId":"trash","hash":2042022119,"tx":33450},"QO3PlLKwWnIiwVqK/contentState":{"id":"QO3PlLKwWnIiwVqK/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1715814100560,"tx":33456},"08K40WXSblJ4yn74/syncedContent":{"id":"08K40WXSblJ4yn74/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1715814118930,"tx":33457},"Rkbhu5EBtxTalmMn/contentState":{"id":"Rkbhu5EBtxTalmMn/contentState","type":"contentState","selectionStart":226,"selectionEnd":226,"scrollPosition":{"sectionIdx":12,"posInSection":0.20332936979785968},"hash":1715827361927,"tx":34270},"3pPfZNfURBxowOxC/syncedContent":{"id":"3pPfZNfURBxowOxC/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1716426415393,"tx":40167},"jCnq3Wvv7Hqcz9L7/contentState":{"id":"jCnq3Wvv7Hqcz9L7/contentState","type":"contentState","selectionStart":54,"selectionEnd":54,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716426841586,"tx":40223},"jCnq3Wvv7Hqcz9L7":{"id":"jCnq3Wvv7Hqcz9L7","type":"file","name":"2022-09-02-5주차인턴일기","parentId":"trash","hash":-631053273,"tx":40224},"QBAJWTNeLD7raJPY/contentState":{"id":"QBAJWTNeLD7raJPY/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":16,"posInSection":0.36666666666666664},"hash":1716426850906,"tx":40229},"QaEMZoJUSOrF5AKA":{"id":"QaEMZoJUSOrF5AKA","type":"folder","name":"후기","parentId":null,"hash":-1471076885,"tx":40236},"dmRttHYhrK5WFmOh/contentState":{"id":"dmRttHYhrK5WFmOh/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":1,"posInSection":0.6666666666666666},"hash":1716438411558,"tx":42297},"vznoAKrCVFYxkwJ0/contentState":{"id":"vznoAKrCVFYxkwJ0/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716438411100,"tx":42297},"9TTmPv43PVpNQndV/contentState":{"id":"9TTmPv43PVpNQndV/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716438411989,"tx":42298},"eZPD4ts8Xo7mlluk/contentState":{"id":"eZPD4ts8Xo7mlluk/contentState","type":"contentState","selectionStart":1197,"selectionEnd":1160,"scrollPosition":{"sectionIdx":0,"posInSection":0.8026315789473685},"hash":1716439104107,"tx":42303},"2OTxNzpMQajxUPNa/contentState":{"id":"2OTxNzpMQajxUPNa/contentState","type":"contentState","selectionStart":433,"selectionEnd":433,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716439106597,"tx":42305},"Kl8goLjOCe4Y2iU1/contentState":{"id":"Kl8goLjOCe4Y2iU1/contentState","type":"contentState","selectionStart":1004,"selectionEnd":1002,"scrollPosition":{"sectionIdx":10,"posInSection":0.8235294117647058},"hash":1716439106953,"tx":42305},"1mdCDouqVJGvLxrK/syncedContent":{"id":"1mdCDouqVJGvLxrK/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1716443343180,"tx":42807},"1mdCDouqVJGvLxrK/content":{"id":"1mdCDouqVJGvLxrK/content","type":"content","text":"\n\n","properties":"\n","discussions":{},"comments":{},"hash":497818810,"tx":42834},"1mdCDouqVJGvLxrK/contentState":{"id":"1mdCDouqVJGvLxrK/contentState","type":"contentState","selectionStart":1,"selectionEnd":1,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716443589967,"tx":42834},"1mdCDouqVJGvLxrK":{"id":"1mdCDouqVJGvLxrK","type":"file","name":"category-codingTest","parentId":"trash","hash":-334937913,"tx":42835},"rJtXtpzzHWYRjcMJ/contentState":{"id":"rJtXtpzzHWYRjcMJ/contentState","type":"contentState","selectionStart":1,"selectionEnd":1,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716443592193,"tx":42835},"KvfIbjNY2ObhRnU0/contentState":{"id":"KvfIbjNY2ObhRnU0/contentState","type":"contentState","selectionStart":93,"selectionEnd":93,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716449851442,"tx":42839},"31ixuwejQY1ahmSf/contentState":{"id":"31ixuwejQY1ahmSf/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716449857062,"tx":42840},"cc0DNjIMHfpFRRJW/contentState":{"id":"cc0DNjIMHfpFRRJW/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716449859903,"tx":42841},"I9XIrcsCCqJCsXnW/contentState":{"id":"I9XIrcsCCqJCsXnW/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716449861349,"tx":42842},"EAHxuW5JgATJ3mo2/contentState":{"id":"EAHxuW5JgATJ3mo2/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716449863003,"tx":42843},"3LsY0S6l92HdtfPP/contentState":{"id":"3LsY0S6l92HdtfPP/contentState","type":"contentState","selectionStart":229,"selectionEnd":229,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716449865903,"tx":42845},"LOPgwVDwC6boRNzS/contentState":{"id":"LOPgwVDwC6boRNzS/contentState","type":"contentState","selectionStart":622,"selectionEnd":504,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716450524919,"tx":42856},"1yvS1owczbvG7a0y/contentState":{"id":"1yvS1owczbvG7a0y/contentState","type":"contentState","selectionStart":197,"selectionEnd":197,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716450626741,"tx":42860},"00TrVRATmgNqHn1N/contentState":{"id":"00TrVRATmgNqHn1N/contentState","type":"contentState","selectionStart":232,"selectionEnd":220,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716450854812,"tx":42865},"WD9Bzi9mPGSI4cK9/contentState":{"id":"WD9Bzi9mPGSI4cK9/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716450857087,"tx":42866},"ygsX3wnSWEPl4aQH/contentState":{"id":"ygsX3wnSWEPl4aQH/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716450856213,"tx":42866},"FfQclKsMdVNJJRNd/contentState":{"id":"FfQclKsMdVNJJRNd/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716511767513,"tx":42868},"by4gQGx95Mp30v8Z/contentState":{"id":"by4gQGx95Mp30v8Z/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716768158047,"tx":42883},"jeNuMwclaWKHJJjy/contentState":{"id":"jeNuMwclaWKHJJjy/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716768167774,"tx":42884},"08K40WXSblJ4yn74":{"id":"08K40WXSblJ4yn74","type":"file","name":"2024-05-16-Java메모리최적화","parentId":"AAphmch3Ge6p9ZRi","hash":-1032853101,"tx":42999},"08K40WXSblJ4yn74/content":{"id":"08K40WXSblJ4yn74/content","type":"content","text":"---\npermalink: /2024-05-16-JAVA-heap-memory-optimization/\npublished: true\ntitle: \"[JAVA] Heap 메모리 최적화와 오류 수정 과정\"\ndate: 2024-05-16 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Heap 메모리 최적화와 오류 수정 과정\"\ncategories:\n- JAVA\ntags:\n- JAVA\n---\n\n<br><br><br>\n\n## ✅ JVM Memory 최적화 문제\n\n사내 시스템 중 특이한 서버가 하나 있다. 셀레니움 기반 데이터 수집 서버와 문서 병합을 수행하는 DCS 서버가 주를 이루고, 일부 배치작업들이 가동되고 있는 윈도우 원격 서버이다. 가장 많이 동작하는 서버는 DCS 서버이다. CS팀에서 실무를 하실 때 여러개의 문서를 병합하거나 회사 도장을 찍어서 외부에 반출하는 경우가 상당히 많은데 이런 작업을 지속적으로 수행하는 서버이기 때문에 상당히 많이 사용된다.\n\n이 서버가 제작되고 가동된지는 꽤 오래됐다고 들었다. 얼마나 오래됐는지는 모르겠지만 적어도 5년은 넘게 코드 수정이 거의 없이 유지되고 있는 서버 정도로 알고있다.\n\n**그런데 한가지 특이한 점은 서버에 문제가 지속적으로 발생해 매일 아침 서버를 재시작 하고 있다는 사실.. 그것도 몇년 동안이나..! 매일 재시작 하고계신 사수님도 \"메모리 누수 때문에 생긴 문제로 인수인계 받았다\" 정도로 인지하고 계셨고 정확한 문제 원인은 모르는 상황이었다. ( 사실은 메모리 누수가 아닌 메모리 최적화 문제였다 )**\n\n다른 업무가 굉장히 많은 상황속에서 단순 재시작만으로 메모리 누수를 해결할 수 있다는 사실은 꽤나 효율적(?)이라고 볼 수 있지만 아직 입사 3개월차인 나는 담당하고 있는 업무가 많지 않기에 이번 기회에 문제 원인을 파악하고 해결해보면 좋을 것 같다는 생각이 들었다. 본인이 이런거 방치해두는 걸 못보는 편이기도 하고 .. 무엇보다 재밌어 보여서 바로 시작했다.\n\n그 과정을 시간순으로 쭉 기록해 보기 위한 글이다.\n\n\n<br><br><br><Br><Br><br>\n\n## ✅ 문제 원인을 먼저 파악해보자\n\n메모리 누수 문제라고 전달 받았지만 진짜 메모리 누수 때문에 오류가 발생하는 건지, 다른 이유인지 분명히 확인할 필요가 있어보였다. 근데 나는 메모리 분석을 해본적이 없었다.. 어떻게 하는지 전혀 몰랐기 때문에 관련 방법을 많이 찾아보며 삽질을 시작했다.\n\n<br><br>\n\n### 📌 Window의 리소스 모니터\n<hr>\n\n먼저 DCS 서버가 얼마나 많은 메모리를 사용하고 있는지 확인하고 싶었다. 가장 단순한 방법으로는 리소스 모니터에서 메모리 탭을 통해 확인할 수 있었다. DCS서버는 JAVA 프로젝트로 가동 중 이였기 때문에 javaw.exe 라는 이름을 가진 프로세스의 메모리 사용량을 확인했고 약 **1GBytes** 정도를 차지하고 있었다.\n\n원격서버의 전체 메모리가 8GBytes 인데 자바 프로그램 하나가 1GB를 차지하고 있다는 점은 좀 이상했다. 지나치게 큰 메모리를 차지하고 있는것으로 보였다. 그렇지만 이것만으로는 메모리 누수를 일으키고 있다 라고 볼 수 없었다. 메모리 누수가 생기고 있다면 메모리 사용량이 점점 증가되고 있음을 확인해야만 하는데 이 데이터로는 확인이 불가능했다.\n\n\n<br><br>\n\n### 📌 Window의 성능 모니터\n<hr>\n\n메모리 증감 추이를 확인하기 위해서는 실시간 모니터링이 필요하다고 생각했다. VisualVM이나 Eclipse Memory Analyzer 같은 모니터링 툴을 찾아봤는데 러닝커브도 꽤 있어보이고 원격서버에 새로운 프로그램을 설치해서 모니터링 하는 작업은 안그래도 버벅거리는 서버에 더 큰 부하를 줄 수 있을거 같아 일단 차치해두었다. ( 결국 위의 툴을 쓰긴함 )\n\n가장 간단한 방법은 윈도우에서 제공하는 성능 모니터 였다. 원하는 프로세스의 데이터를 선택해서 실시간으로 사용량을 추출해주는 아주 간단한 방식이였기에 시도해봤다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak1.png?raw=true\">\n</p>\n\n아무런 작업을 하지않고 사용중인 DCS 서버의 메모리 사용량 추이의 일부이다. 리소스 모니터의 값과 동일하게 거의 1GB정도의 메모리를 사용하고 있었고 시간이 지남에 따라 메모리 사용량이 조금씩 증가함을 알 수 있었는데 이정도로는 메모리 누수가 발생한다고 확신하기 힘들었다. 오히려 시간이 많이 지나면서 GC가 동작하고 메모리 사용량은 700MB까지 줄어들기도 했다.\n\n\n<br><br>\n\n### 📌 Eclipse Memory Analyzer ( MAT )\n<hr>\n\n결국 메모리 분석 툴을 사용하는편이 가장 확실하게 누수를 확인할 수 있겠다고 생각했다. JAVA 메모리 분석툴은 보통 Eclipse Memory Analyzer(MAT)나 VisualVM을 사용한다는 관련글들을 보고 MAT를 설치해서 사용해보고자 했다.\n\n일반적으로 JAVA 프로세스에서 메모리 누수가 의심된다면 **Heapdump 파일**을 생성하고 분석도구를 통해 누수 원인을 찾을 수 있다. 근데 Heapdump파일을 생성하는 것부터 애를 먹었다.. 해봤어야 알지..\n\n먼저 실행중인 자바 프로세스 ( DCS 서버 )의 PID를 확인해야 한다. cmd 명령어를 통해 확인할 수 있다.\n```cmd\njps -lvm\n```\n위의 명령어를 통해 실행중인 자바 프로세스를 전부 확인할 수 있었고, dcs서버의 PID를 알아냈다.\n\n이후 heapdump파일을 생성하는 명령어를 입력해줬다.\n\n```cmd\njmap -dump:format=b,file=/dump파일을 저장할 경로/dump파일명.hprof\n```\n\nheapdump파일을 이렇게 생성하면 생성하는 순간의 heap 메모리 영역에 대한 데이터를 뽑아주는 hprof 파일이 만들어진다. \n \n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak10.png?raw=true\">\n</p>\n\nMAT는 이렇게 원형차트로 메모리 누수로 의심되는 요소를 보여주고 얼마나 heap 메모리 영역을 차지하고 있는지, 어떤 클래스를 참조하고 있는지 등 다양한 정보를 보여준다. \n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak11.png?raw=true\">\n</p>\n\n위 그림처럼 MAT에서 누수가 발생한 세부 클래스를 확인할 수도 있다. HashMap 객체들에서 누수가 가장 많이 발생하고 있음을 확인할 수 있었는데, **HashMap은 일반적으로는 메모리 누수를 일으키지 않도록 설계되어 있긴하다. 그러나 HashMap을 사용한 후, 필요없는 엔트리를 제거하지 않으면 강한참조가 걸려 메모리가 GC를 통해 자동으로 해제되지 않을 수 있다. 아마 많은 HashMap에서 더이상 객체를 사용하지 않지만 강한 참조가 걸려있어 메모리 누수를 일으키는 것으로 보인다.**\n\n그런데 hprof 파일을 분석한 결과가 조금 이상하다.  DCS서버가 차지하고 있는 Heap 메모리 영역은 25.7MB에 불과하고 그중에서 누수로 인해 차지하고 있는 영역은 15.3MB정도 밖에 안된다.\n\n분명 리소스 모니터와 성능 모니터를 통해 확인한 메모리 사용량은 1GB에 육박하는데 MAT에서 분석한 메모리 누수는 굉장히 미미하다고 나왔다.\n\n내가 제대로 분석한건지 확신이 안들었다. 다른 프로세스의 heap dump를 분석했나? MAT를 제대로 못보고 있나? 감을 잡기 어려웠다.. **아니면 혹시 메모리 누수가 아니라 메모리를 비효율적으로 사용하고 있는 것은 아닐까? 하는 의문이 강하게 들었다.**\n\n<br><br>\n\n### 📌 VisualVM\n<hr>\n\n메모리 누수가 원인이 아닐거라는 생각이 들긴 했지만 다른 분석툴로 한번더 확인해보고자 했다. JDK를 설치하면 함께 설치되는 VisualVM은 Heap 메모리 사용 현황을 대시보드 형태로 실시간으로 보여주는 장점이 있어 한눈에 메모리 사용량을 확인하기 좋아보였다.\n\n근데 VisualVM으로 확인해도 크게 다르진 않았다. ( 코드 리팩토링 전 VisualVM 이미지를 저장하진 못했다 .. ) **메모리 누수 문제가 아니였다.** 메모리 누수가 없다고 볼 순 없지만, 메모리 누수량은 현저히 적어 서버의 성능에 영향을 줄 정도가 아니였다. \n\n문제는 **메모리 누수가 아니라, 메모리가 최적화되지 않은것** 으로 확실시 됐다.\n\n\n<br><br><br><Br><Br><Br>\n\n\n## ✅ 메모리 낭비가 왜 발생할까\n\n이제 메모리를 최적화 하는 작업이 필요했다. 그러기 위해선 어디서 왜 메모리 낭비가 발생하는지를 알아봐야 했다. 먼저 메모리 낭비를 일으키는 일반적인 원인을 찾아봤다.\n\n첫째, 불필요한 객체 생성이 잦아질 때\n둘째, 대용량 데이터 처리를 위해 부적절한 자료 구조 사용 시\n셋째, JVM의 GC 옵션이 적절하지 못할 시\n\n보통 위의 세가지 이유정도로 메모리가 낭비되곤 한다. 이때 첫번째, 두번째 이유는 코드를 어떻게 작성하느냐에 따라 메모리 낭비를 최소화 할 수 있지만, 세번째 이유는 코드나 로직과는 별개로 GC의 동작 주기나 Heap 메모리 용량을 조절함으로써 해결할 수 있기 때문에 근본적인 해결방법이 되지 못한다. \n\n예를들어 컴퓨터에서 사용 가능한 메모리가 8GB 뿐인데, Heap 메모리 최대 사용 용량을 6GB정도로 설정 해버린다면 해당 프로그램은 잘 돌아갈 수 있지만, 이를 제외한 나머지 프로그램들은 2GB의 메모리밖에 사용할 수 없기 때문에 조삼모사일 뿐이다. **따라서 먼저 코드 리팩토링을 통해 서버 자체적으로 메모리 최적화를 진행하는 방식이 필요해보였다.**\n\n\n<br><br><br><Br><Br><br>\n\n## ✅ 어디부터 리팩토링 해야 할까\n\n이제 코드의 어느 부분이 잘못 설계되었는지 확인해볼 필요가 있었다. 그런데 너무 막연했다. 내가 만든 프로젝트도 아니고, 클래스도 한두개가 아닌데 어디부터 보고 고쳐야 할까..\n\n먼저 인과적으로 문제를 바라보고자 했다. 기존에 발생하고 있는 문제와 이를 어떻게 해결해왔는지를 보면 갈피가 잡힐 것 같았다. 크게 문제가 발생하는 원인은 두가지 정도로 볼 수 있다.\n\n1. DCS 서버 자체의 메모리 문제\n2. DCS 서버가 가동중인 가상 서버 자체의 문제\n\nDCS서버가 제대로 동작하지 않아 사내시스템에 문제가 생길 때마다 DCS서버만 재시작 해주면 정상적으로 기능이 수행됐기에 DCS서버 자체의 메모리 문제임을 확신할 수 있었다.\n\n그럼 다음으로 DCS 서버에서 어느 클래스 혹은 패키지가 문제의 주범일까?\n\nDCS서버 로그를 보니 주로 수행하는 기능은 다음과 같았다.\n\n1. 문서 병합 \n2. 문서 변환\n3. 문서에 도장 이미지 추가\n\n위의 3가지 작업이 전체작업의 90%이상을 차지하고 있었고, 이 작업들을 수행하는 과정에서 메모리 낭비가 발생하고 있음을 직관적으로 알 수 있었다. 그래서 먼저 위 3개 기능들의 관련 패키지를 리팩토링 하고자 했다.\n\n\n\n<br><br><br><Br><Br><br>\n\n## ✅ 리소스 해제가 안돼있네\n\n<br><br>\n\n### 📌 try-catch finally\n<hr>\n\n\n주로 수행하는 작업이 문서 병합, 변환 등의 문서관련 작업이기 때문에 문서 처리를 위한 객체를 어떻게 생성하고 처리했나 살펴봤다. 그런데 예외처리가 제대로 되어있지 않았다. **작업이 정상적으로 완료되면 객체를 clear()하지만 예외가 발생하면 객체가 그대로 남아있는 구조였다.** 문서 처리 작업을 한번 수행할 때마다 객체를 하나씩 생성하기 때문에 예외가 발생하는대로 메모리 낭비가 발생하는 구조였다.\n\n그래서 `PDFDoc` 객체를 try-catch 구문 바깥으로 뺀 후 초기값을 null로 설정하고, 예외처리를 통해 `PDFDoc` 객체를 해제하는 코드를 추가해줬다. 원래 try-with-resource 구문을 사용해서 `close()` 없이 리소스를 해제하려고 했지만 프로젝트가 JDK 1.6버전을 사용하고 있어서 해당 구문을 지원하지 않아 `try-catch`에 `finally` 구문을 추가했다.\n\n```java\nPDFDoc doc = null;\n\t\t\ntry {\n\t\tPDFNet.initialize(\"라이센스\");\n\n\t\t...\n\t\t\t\n\t\tdoc = new PDFDoc((new StringBuilder(String.valueOf(input_path))).append(inputFileName).toString());\n\t\tdoc.initSecurityHandler();\n\t\t\t\n\t\t...\n\t\t\t\n\t\ttry{\n\t\t\tdoc.save((new StringBuilder(String.valueOf(output_path))).append(outputFileName).toString(), 16L, null);\n\t\t} catch(PDFNetException e){\n\t\t\tSystem.out.println(\"Failed to save document: \" + e.getMessage());\n\t\t}\n\t\t\n\t\tresult = \"Success\";\n\t\t\t\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t} finally {\n\t\tcloseDocument(doc);\n\t\tPDFNet.terminate();\n\t}\n```\n\n위와 비슷한 방식으로 PDF객체에 대한 생성주기 코드를 전부 리팩토링 했다. 예외상황에 발생하는 메모리 낭비와 미처 삭제되지 않은 PDF객체로 인해 발생하는 메모리 낭비에 대한 최적화를 기대했다.\n\n<br><br>\n\n### 📌 HashMap 객체 해제\n<hr>\n\n코드를 쭉 살펴보니 상당히 많은 HashMap을 사용하고 있었다. 그런데 HashMap을 사용 후 참조를 해제하는 `clear()` 메소드는 전혀 작성돼있지 않았다. DCS서버가 문서 관련 작업을 수행할 때 수많은 HashMap이 생성되지만 전부 `map.put(\"key\",\"value\")` 처럼 강한 참조를 가지고 있고, GC에 의해서 해제되지 않고 있는 상황이다.\n\n이 부분이 상당한 메모리 낭비를 일으키고 있을 것으로 예상했다. 서버에서 주로 수행하는 작업이 문서 병합, 문서 변환, 직인 도장 이미지 첨부 3가지 작업이기 때문에 이를 수행하는 클래스들 위주로 리소스를 해제해주면 해결 될 것으로 예상하고 작업을 수행했다.\n\n```java\nHashMap<String, Object> rtnMap = docMergeService.docMerge(inputList, output_path, merge_file_name);\nList<HashMap<String, Object>> inputList = new ArrayList<HashMap<String, Object>>();\nList<JobDtlVo> jobDtlInsertList = new ArrayList<JobDtlVo>();\n\n...\n\nrtnMap.clear();\ninputList.clear();\njobDtlInsertList.clear();\n```\n\n방식은 간단했다. HashMap을 선언하고 사용한 뒤 코드 마지막 부분에 `clear()` 처리 해줬다. 주의할 점은 HashMap에 들어있는 객체를 이후에도 사용해야 하거나, return을 해줘야할 때 `clear()`를 해버리면 값이 전부 사라지기 때문에 반드시 전부 사용한 뒤, 혹은 더이상 필요하지 않은 HashMap만 해제해야 한다. 이렇게 꽤 많은 코드에 대한 리팩토링을 수행했다.\n\n\n<br><br>\n\n### 📌 String을 StringBuilder로\n<hr>\n코드를 또 살펴보니 작업을 수행할 때마다 그 결과를 String객체로 출력하고 있었다. log도 아니고 `println` 으로 매번 결과를 출력하는게 어떤 의도인지는 모르겠지만 일단 작성되어 있었으니 기조는 유지하기로 했다.\n\n다만 String 객체에 대한 + 연산이 빈번하게 있었기 때문에 String 객체가 계속 추가되는 낭비가 있을것 같아 `String`을 `StringBuilder`로 변경했다. 사실 JDK 1.5 이후 버전부터는 String 객체가 StringBuilder 객체로 컴파일 되도록 변경되어 큰 문제가 없을 수 있지만 혹시모를 메모리 낭비까지도 방지해보기 위해 변경했다.\n\n그리고 여러 API를 쏴서 동시에 작업을 수행하는 멀티쓰레드 환경의 서버였지만, 동기화를 지원하는 StringBuffer를 사용하지 않은 이유는 단순 결과 출력을 위한 String 객체에 대한 수정 작업 이였고, 출력문을 굳이 자세히 확인하지 않는다는점, 그리고 출력문에 대한 동기화가 필수요소가 아니라는 점을 고려하여 성능이 더 좋은 StringBuilder를 사용했다. \n\n\n\n<br><br><br><Br><Br><br>\n\n## ✅ 결과를 확인해보자..!\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak7.png?raw=true\">\n</p>\n이 자료가 VisualVM을 통해 확인한 최초의 DCS서버 HeapDump 파일이다.  Instances 수치는 인스턴스의 개수를 의미하고 Size는 차지하고 있는 메모리 용량을 의미한다. 단위는 Byte이다. Char, Int, Byte, String, HashMap 순으로 메모리를 차지하고 있다. 이들의 메모리 사용량의 합은 대략 23MB 정도이다. 이제 리팩토링 전후를 비교하기 위해 최근 DCS 서버의 HeapDump 파일을 보자.\n\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak6.png?raw=true\">\n</p>\n\n리팩토링 후 15일정도 운영한 DCS 서버의 Heap 메모리 사용량이다. Char, Byte, String, Int, HashMap 순으로 메모리를 많이 차지하고 있고 약 17~18MB정도를 사용중이다. 이전 상태와 비교하면 약 5MB정도의 Heap 메모리 사용량이 줄어든 것을 확인할 수 있다. 좀 더 확실한 비교를 위해 VisualVM의 기능을 활용해 두 덤프파일을 직접 비교해봤다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak8.png?raw=true\">\n</p>\n\n두 덤프파일을 비교하여 Size가 가장 많이 줄어든 순서대로 클래스를 나열한 이미지이다. int[] 클래스가 가장 크게 메모리 사용량이 감소했고 char[], String, HashMap이 그 뒤를 이루고 있다. int[] 클래스가 가장 크게 감소한 이유는 HashMap 리소스를 해제하면서 HashMap 내부에서 사용되던 int배열이 함께 해제되었기 때문이라고 생각한다. 전체적으로 보면 메모리 사용량은 감소된 것을 볼 수 있다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak9.png?raw=true\">\n</p>\n다음은 Size가 증가한 순서대로 클래스를 나열한 이미지이다. WeakReference 클래스가 크게 증가했음을 볼 수 있는데 이는 리팩토링이 성공적으로 이루어 졌음을 의미한다.\n\n`WeakReference`는 가비지 컬렉터가 객체를 더 쉽게 회수할 수 있도록 돕는 참조 유형이다. 코드 리팩토링 과정에서 강한 참조를 약한 참조로 변경했다면, 가비지 컬렉션이 더 효율적으로 작동하여 메모리 누수를 줄일 수 있다.\n\n**본인은 `try-catch-finally` 구문을 통해 불필요 객체를 해제했기 때문에 `weakReference` 객체가 증가했고 GC가 더 효율적으로 작동함으로써 Heap 메모리 사용량이 줄어든 것으로 보인다.**\n\n\n<br><br>\n\n### 📌 역시 Heap 메모리 문제가 아니야\n<hr>\n\n위의 결과를 보면 리팩토링을 통해 Heap 메모리 사용량을 줄이긴 했지만 ( 물론 비율로 따지면 상당히 큰 감소 ) Java 서버 자체가 사용하고 있는 전체 메모리 양에 비하면 작은 수치이기 때문에 아직 문제가 해결됐다고 판단할 수는 없다. 적어도 Heap 메모리 수치만 확인해서는 안되고, 서버 자체의 메모리 사용량을 확인할 필요가 있어보인다.\n\n그렇지만 기존 서버에 문제가 굉장히 잦아 매일 서버를 재시작 해주던 것과는 달리 15일정도 유지됐다는 것은 리팩토링으로 인한 메모리 최적화 작업이 효과가 있었다는 것은 분명해 보인다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak2.png?raw=true\">\n</p>\n\n리팩토링 이후 DCS서버의 메모리 사용량이다. 기존 900MB~1GB까지 사용하던게 약200MB까지 확 줄어든 것을 볼 수 있다. 메모리 최적화 작업이 효과가 있었다..!\n\n서버가 이전에 계속 터진이유는 아무래도 Heap 메모리 문제가 아니라 DCS 서버 자체가 차지하고 있는 메모리 용량이 지나치게 컸기 때문에 생긴게 아닐까 예상해본다.\n\n\n\n<br><br><br><Br><Br><br>\n\n## ✅ 또 서버가 터졌다..\n\n회의를 하던 도중 서버가 터졌다. 당장 서버를 복구해야 하기에 다른 분이 서버를 복구해주시긴 했지만 에러 로그에 대한 설정이 전혀 없었기에 서버가 어떤 이유로 터진건지 전혀 알 수 없었다. 확인할 수 있는건 켜놨던 visualVM 하나.. Heap 메모리 영역에 문제가 있었는지 정도는 확인 가능했다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak12.png?raw=true\">\n</p>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak13.png?raw=true\">\n</p>\n\n메모리가 급등급락하고 있긴하지만 Max 영역을 벗어난다던가 OOM이 발생한 흔적은 보이지 않는다. 아무래도 OOM이 발생하면 에러로그를 남기는 작업이 필요해 보인다. 바로 톰캣서버에 환경변수들을 추가해줬다.\n\n<br><br>\n\n### 📌 OOM 로그 기록\n<hr>\n\n```\nOOM 발생시 로그 기록 argument 추가\n\n...\n-XX:+HeapDumpOnOutOfMemoryError \n-XX:HeapDumpPath=C:\\Users\\Administrator\\Desktop\\heapdump\\OOMHeapDump \n-XX:ErrorFile=C:\\Users\\Administrator\\Desktop\\heapdump\\OOMErrorLog\\hs_err_pid%p.log \n-Xloggc:C:\\Users\\Administrator\\Desktop\\heapdump\\OOMGCLog\\gc.log \n-XX:+PrintGC \n-XX:+PrintGCDetails \n-XX:+PrintGCTimeStamps\n```\n\n위와같은 환경변수들을 추가해줬다. 하나씩 설명해보면\n\n- `-XX:+HeapDumpOnOutOfMemoryError ` : OOM 발생시 힙 덤프 생성\n- `-XX:HeapDumpPath=<경로>` : 힙 덤프 파일 저장 경로 \n-    `-XX:+PrintGC`: GC 이벤트를 출력\n-   `-XX:+PrintGCDetails`: GC 이벤트의 상세 정보를 출력\n-   `-XX:+PrintGCTimeStamps`: GC 이벤트의 타임스탬프를 출력\n-   `-Xloggc:<path>`: GC 로그 파일이 저장될 경로 지정\n-   `-XX:ErrorFile=<path>`: JVM 오류가 발생했을 때 오류 로그 파일이 저장될 경로 지정\n\n\n이제 무슨 문제가 발생해도 로그가 다 남도록 설정해뒀으니 서버가 터지면 원인을 파악하기 쉬울 것이다. 서버가 안터지는게 제일 좋지만 일단 차분히 기다려봤다.\n\n\n\n<br><br><br><Br><Br><br>\n\n## ✅ 임시파일 생성 실패\n\n이번에는 서버를 새로 킨 뒤 얼마 지나지 않아 오류가 발생했다. 한 4~5일정도 운영했는데 오류가 터졌다. 그렇지만 이번에는 에러 로그 설정을 해 둔 덕에 모든 오류 로그를 확인할 수 있었다..! 근데 OOM에러가 발생할거라는 예상과는 달리 전혀 다른 문제가 발생했다.\n\n<br> \n\n```\nException: \n\t Message: Could not open a temporary file. Make sure to close unused documents.\n\t Conditional expression: m_stream != NULL\n\t Filename   : TempFile.cpp\n\t Function   : trn::SDF::TempFile::OpenTempFile\n\t Linenumber : 147\n\t Error code : 0\n\n\tat pdftron.PDF.Stamper.StampImage(Native Method)\n\tat pdftron.PDF.Stamper.stampImage(Stamper.java:110)\n\tat kccworld.info.dcs.rest.api.stamp.service.StampSealServiceImpl.stampSeal(StampSealServiceImpl.java:59)\n\tat kccworld.info.dcs.rest.api.stamp.ApiStampSealController.stampSeal(ApiStampSealController.java:96)\n\n\t... (생략)\n```\n\n<br>\n\n```\nException: \n\t Message: An error occurred during page import: Could not open a temporary file. Make sure to close unused documents.\n\t Conditional expression: false\n\t Filename   : PDFDoc.cpp\n\t Function   : trn::PDF::IMPL_TRN_PDFDocImportPages\n\t Linenumber : 1291\n\t Error code : 0\n\n\tat pdftron.PDF.PDFDoc.ImportPages(Native Method)\n\tat pdftron.PDF.PDFDoc.importPages(PDFDoc.java:829)\n\tat pdftron.PDF.PDFDoc.importPages(PDFDoc.java:809)\n\tat kccworld.info.dcs.rest.api.merge.service.DocMergeServiceImpl.mergepdf(DocMergeServiceImpl.java:147)\n\tat kccworld.info.dcs.rest.api.merge.service.DocMergeServiceImpl.docMerge(DocMergeServiceImpl.java:93)\n\tat kccworld.info.dcs.rest.api.merge.ApiDocMergeController.docConvert(ApiDocMergeController.java:80)\n```\n\n에러 로그를 보니 stamp 이미지를 적용하는 과정에서 임시파일을 찾을 수 없다는 에러가 보인다. 일단 임시파일을 생성한다는 사실 조차 몰랐기에 임시파일이 어느작업을 할 때 생성되고 임시파일이 왜 생성되지 않는지 확인할 필요가 있었다.\n\n일단 임시파일이 어느 작업을 수행할 때 생성되는지 확인하기 위해 PDFtron의 jar파일을 뜯어 class파일을 확인해봤다. 그러나 class 파일이 너무 불친절해서 어느시점에서 임시파일을 생성하는지는 알기 힘들었다. 그래서 임시파일은 일단 어딘가에 생성된다고 가정하고 더이상 임시파일이 생성되지 않는 이유를 찾아봤다.\n\n여러가지 이유 중 가장 합리적으로 판단한 경우는 **\"운영체제 내에서 하나의 프로세스가 연결할 수 있는 핸들러의 수가 제한되어있다.\"** 라는 것이었다. **PDFtron의 어떤 객체를 생성할 때 임시파일이 생성되고 이 임시파일이 DCS 프로세스와 연결된 채 해제되지 않아 문서 변환,병합 등의 작업을 수행하면 수행할 수록 DCS에 연결된 핸들러의 수가 점점 증가하여 나중에는 가용할 수 있는 양을 넘어서기에 더이상 임시파일을 생성하지 못한다고 생각했다.**\n\n바로 리소스 모니터를 통해 DCS 프로세스에 연결된 핸들러를 확인해봤더니 굉장히 많은 임시파일이 연결되어 있었다. 분명 리팩토링을 하면서 PDFtron객체를 전부 사용 후 해제했다고 생각했는데 아직 해제되지 않은 무언가가 존재하는듯 했다. 일단 어느작업을 수행할 때 임시파일이 생성되는지 실시간으로 확인하기 위해 리소스 모니터를 켜둔채 문서 병합, 변환, 도장 작업을 한번씩 해봤다. **그런데 오직 도장찍는 작업을 수행할 때만 DCS에 임시파일 핸들러가 연결됐다.** 드디어 찾았다! \n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/leak16.png?raw=true\">\n</p>\n\n위와 같은 임시파일들이 작업 수행 후 삭제가 안되고 DCS서버 프로세스의 핸들러로 계속 연결되어 있었다. 이제 stamp 작업을 수행할 때 왜 임시파일이 해제가 안되고 계속 연결상태를 유지하는지 원인만 찾으면 같은 오류가 반복되지 않을것 같다..!\n\n그래서 문서 병합, 변환, 도장 작업을 수행하면서 동시에 연결된 핸들러가 어떻게 구성되는지 확인해봤는데 병합, 변환, 도장 작업 수행시에 연결되는 핸들러와는 별개로 임시파일도 함께 연결되어 있었다. **내 예상으로는 PDFTron 객체가 리소스 해제가 되지 않아 임시파일이 연결되어 있을거란 것과는 달리 객체에 대한 리소스 해제는 리팩토링 한대로 원활히 수행되고 있었고 알 수 없는 임시파일이 지속적으로 연결되어 있는 상태였다.**\n\n이 말은 내 코드의 문제가 아니라 PDFTron 라이브러리에서 제공하는 API를 사용할 때 라이브러리 내부적으로 임시파일을 생성하는 로직이 있는데 이를 자동으로 해제하지 못하고 있음을 의미했다. DCS 서버가 앞서 말했다시피 엄청 오래된 서버이고, 이 때 사용된 PDFTron 라이브러리 역시 굉장히 구버전이기 때문에 충분히 오류가 있을 수 있겠다 생각했다. **어쩔수 없이 PDFTron의 공식문서를 죄다 확인하는 수밖에 없다..** \n\n<br><br><br><Br><Br><br>\n\n## ✅ 드디어 해결방법 발견..!\n\n드디어 해결방법을 찾았다! PDFTron 객체를 사용할 때 다음과 같은 코드를 추가하면 된다. \n\n```java\nPDFNet.initialize(\"라이센스 키\");\nPDFNet.setDefaultDiskCachingEnabled(false);\n```\n기본적으로 PDFNet(PDFTron)은 디스크캐싱을 true로 유지하는데, 이를 false로 변경하면 더이상 임시파일을 생성하지 않고, 작업 수행에 필요한 파일을 디스크에 저장한다고 한다. 디스크에 직접 저장한다는게 좀 꺼림칙 하긴 했지만 일단 해당 코드를 추가해준뒤 다시 서버를 돌려보니 더이상 임시파일이 물려있지는 않았다. 해당 코드가 추가되면서 어떤 문제를 또 일으킬지는 시간이 지나면서 확인해봐야겠지만 일단 내가 발견한 모든 오류는 해결된 셈이다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":262146406,"tx":44435},"X3mDwXGkmeIJpTbt/contentState":{"id":"X3mDwXGkmeIJpTbt/contentState","type":"contentState","selectionStart":250,"selectionEnd":250,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716872394888,"tx":44443},"lxMWY3IFzi3Fwd8Q/contentState":{"id":"lxMWY3IFzi3Fwd8Q/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716872403598,"tx":44446},"AccPceb6fVYGLjbn/contentState":{"id":"AccPceb6fVYGLjbn/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716872404500,"tx":44447},"YDJJdqjhA30zySZh/contentState":{"id":"YDJJdqjhA30zySZh/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716872404875,"tx":44448},"EuU8pmiZWx04CkEn/contentState":{"id":"EuU8pmiZWx04CkEn/contentState","type":"contentState","selectionStart":1222,"selectionEnd":1188,"scrollPosition":{"sectionIdx":12,"posInSection":0.8583333333333333},"hash":1716872405373,"tx":44449},"VLaa02Loo6VepSNT/contentState":{"id":"VLaa02Loo6VepSNT/contentState","type":"contentState","selectionStart":232,"selectionEnd":232,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716872413078,"tx":44451},"0jwjWW7L0cw2iQtV/contentState":{"id":"0jwjWW7L0cw2iQtV/contentState","type":"contentState","selectionStart":215,"selectionEnd":215,"scrollPosition":{"sectionIdx":53,"posInSection":0.667063020214031},"hash":1716877541903,"tx":44982},"RXviSkk9OEup22my/contentState":{"id":"RXviSkk9OEup22my/contentState","type":"contentState","selectionStart":4701,"selectionEnd":4707,"scrollPosition":{"sectionIdx":56,"posInSection":0.7166666666666667},"hash":1716877653777,"tx":45017},"bZrfx6XKev82ul2h/contentState":{"id":"bZrfx6XKev82ul2h/contentState","type":"contentState","selectionStart":262,"selectionEnd":240,"scrollPosition":{"sectionIdx":13,"posInSection":0.36666666666666664},"hash":1716877657049,"tx":45018},"JZO7E1GRXJiiFfhC":{"id":"JZO7E1GRXJiiFfhC","type":"file","name":"2021-09-09-CA_Instructions","parentId":"3czWpyCWVN518JXE","hash":-145045401,"tx":46711},"ADbe6HrECGC5ROmU/content":{"id":"ADbe6HrECGC5ROmU/content","type":"content","text":"---\npermalink: /2023-11-10-생산자_소비자(Producer_Consumer) 패턴/\npublished: true\ntitle: \"[Design Pattern] 생산자&소비자(Producer&Consumer) 패턴 \"\ndate: 2023-11-10 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"생산자&소비자(Producer&Consumer) 패턴\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n- 생산자&소비자(Producer&Consumer) 패턴\n---\n<br><br><br>\n\n## ✅ 생산자 소비자 패턴이란?\n\n생산자-소비자 패턴은 **멀티스레드 환경에서 여러 스레드가 공유 자원에 접근할 때 발생하는 동기화 문제를 해결하기 위한** 디자인 패턴이다.\n\n생산자-소비자 패턴은 멀티스레드 환경에서 **생산자(Producer) 스레드가 데이터를 생성하고, 소비자(Consumer) 스레드가 해당 데이터를 소비**하도록 구성되고, 효율적으로 자원을 관리할 수 있도록 한다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/producerconsumer.png?raw=true\">\n</p>\n\n<br>\n\n위 그림처럼 작업을 생성하는 **생산자 스레드**와 Queue로 설계된 **공유자원**, 그리고 작업을 수행하는 **소비자 스레드**로 구성되어 있는것이 일반적인 생산자-소비자 패턴의 구조이다.\n\n<br><br><br><br>\n\n## ✅ 생산자 소비자 패턴의 구성 요소\n\n1. **생산자(Producer)**\n\n\t데이터를 생성하고 공유자원에 저장하는 역할을 수행한다. 생산자는 새로운 데이터를 생성하여 공유자원에 추가하거나 기존의 데이터를 갱신한다.\n\n\n2. **소비자(Consumer)**\n\n\t공유 자원에서 데이터를 가져와서 처리하는 역할을 수행한다.\n\n\n3. **공유 자원(Buffer 또는 Queue)**\n\n\t생산자와 소비자 간의 데이터 교환을 위한 공유 자원이다. 일반적으로 버퍼(Buffer)나 큐(Queue)로 구현된다.\n\n4. **동기화 메커니즘**\n\n\t생산자와 소비자 간의 동기화를 이루기 위한 메커니즘이 존재한다. 생산자측은 공유자원이 가득 차있는지 확인하고 데이터를 추가하기 위해 대기해야 하고, 소비자측은 공유자원이 비어 있는지 확인하고 데이터를 가져오기 위해 대기하는 등의 동작을 수행한다. 일반적으로 **뮤텍스(Mutex), 세마포어(Semaphore), 조건 변수(Condition Variable)** 등이 있다.\n\n<br>\n\n> **뮤텍스 : 상호 배제를 통해 한번에 한 스레드만 공유자원에 접근 가능하도록 함**  \n> **세마포어 : 공유 자원에 접근할 수 있는 스레드의 수를 제어**  \n> **조건변수 : 특정 조건을 만족할 때 까지 스레드를 대기시킴** \n\n<br><br><br><br>\n\n\n## ✅ 생산자 소비자 패턴을 사용하는 이유\n\n1. **자원관리**\n\n\t여러 스레드가 공유자원에 동시에 접근하는 상황에서 자원을 효율적으로 관리할 수 있다. 한마디로 자원의 공유 및 동시 접근 문제를 효과적으로 해결할 수 있다.\n\n2. **동기화**\n\n\t멀티 스레드 환경에서 생성자와 소비자 간의 데이터 접근을 동기화하여 데이터의 **일관성**과 **안정성**을 보장할 수 있다. 동기화 메커니즘을 통해 생산자 작업을 생성 할 때 소비자가 이를 가져오고, 소비자가 작업을 처리할 때 다른 소비자가 동일한 데이터를 중복으로 처리하지 않도록 보장한다.\n\n3. **효율성**\n\n\t생산자-소비자 간의 작업을 비동기적으로 처리하여 시스템의 성능을 향상시킬 수 있다. 생산자는 데이터를 생성하고 버퍼에 추가하는 동안 다른 작업을 수행할 수 있고, 소비자 역시 데이터를 처리하는 동안 다른 작업을 수행할 수 있다.\n\n4. **작업 속도 조절 가능**\n\n\t버퍼, 큐의 크기나 생산자의 생산속도를 조절하여 시스템의 작업 속도를 조절할 수 있다. 이를 통해 안정성과 효율성을 최적화 할 수 있다.\n\t\n\n<br><br><br><br>\n\n\n## ✅ 생산자 소비자 패턴 적용 상황\n\n1. **스레드 풀 ( Thread Pool )**\n\n\t생산자는 작업을 생성하고 버퍼,큐에 추가하며, 소비자는 버퍼에서 작업을 가져와 처리한다. 이를 통해 작업을 비동기적으로 처리하여 시스템의 처리량을 향상시킬 수 있다.\n\n```java\nimport java.util.concurrent.*;\n\nclass Producer implements Runnable {\n    private BlockingQueue<Integer> buffer;\n    private int data = 0;\n\n    public Producer(BlockingQueue<Integer> buffer) {\n        this.buffer = buffer;\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                produce(data++);\n                Thread.sleep(1000); // 생산 간격을 조절하기 위해 잠시 멈춤\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private void produce(int i) throws InterruptedException {\n        System.out.println(\"Producing: \" + i);\n        buffer.put(i); // 데이터를 생산하여 버퍼에 추가\n    }\n}\n\nclass Consumer implements Runnable {\n    private BlockingQueue<Integer> buffer;\n\n    public Consumer(BlockingQueue<Integer> buffer) {\n        this.buffer = buffer;\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                int data = consume();\n                Thread.sleep(2000); // 소비 간격을 조절하기 위해 잠시 멈춤\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private int consume() throws InterruptedException {\n        int data = buffer.take(); // 버퍼에서 데이터를 가져옴\n        System.out.println(\"Consuming: \" + data);\n        return data;\n    }\n}\n\npublic class ThreadPoolProducerConsumer {\n    public static void main(String[] args) {\n        // 버퍼로 사용할 BlockingQueue 생성\n        BlockingQueue<Integer> buffer = new ArrayBlockingQueue<>(10);\n\n        // 스레드 풀 생성\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        // 생산자 및 소비자 스레드 생성 및 스레드 풀에 제출\n        executor.submit(new Producer(buffer));\n        executor.submit(new Consumer(buffer));\n\n        // 스레드 풀 종료\n        executor.shutdown();\n    }\n}\n```\n\n위의 예제에서는 BlockingQueue를 사용하여 공유 버퍼를 구현했다. 그리고 Producer 클래스와 Consumer 클래스는 각각 Runnable을 구현하여 생산자 스레드와 소비자 스레드를 정의한다.\n\n생산자는 데이터를 생성하여 BlockingQueue에 추가하고, 소비자는 BlockingQueue에서 데이터를 가져와서 처리한다. 이 두가지 작업은 스레드 풀을 사용하여 병렬적으로 실행된다.\n\n마지막으로 main 메서드에서는 스레드 풀을 생성하고, 생산자 및 소비자 스레드를 스레드 풀에 제출한다. 모든 작업이 완료된 후에는 스레드 풀을 종료한다.\n<br><br>\n\n\n\n2. **이벤트 기반 시스템 ( Event-Driven Systems )**\n\n\t이벤트 발생 시 생산자는 해당 이벤트를 생성하고 큐에 추가하는 역할을 수행하며, 소비자는 큐에서 이벤트를 가져와 처리한다.\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n// 생산자 이벤트 클래스\nclass ProduceEvent {\n    private int data;\n\n    public ProduceEvent(int data) {\n        this.data = data;\n    }\n\n    public int getData() {\n        return data;\n    }\n}\n\n// 소비자 이벤트 클래스\nclass ConsumeEvent {\n    private int data;\n\n    public ConsumeEvent(int data) {\n        this.data = data;\n    }\n\n    public int getData() {\n        return data;\n    }\n}\n\n// 생산자 클래스\nclass Producer implements Runnable {\n    private BlockingQueue<ProduceEvent> produceQueue;\n    private int data = 0;\n\n    public Producer(BlockingQueue<ProduceEvent> produceQueue) {\n        this.produceQueue = produceQueue;\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                ProduceEvent event = new ProduceEvent(data++);\n                produceQueue.put(event);\n                System.out.println(\"Producing: \" + event.getData());\n                Thread.sleep(1000); // 생산 간격을 조절하기 위해 잠시 멈춤\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\n// 소비자 클래스\nclass Consumer implements Runnable {\n    private BlockingQueue<ProduceEvent> produceQueue;\n    private BlockingQueue<ConsumeEvent> consumeQueue;\n\n    public Consumer(BlockingQueue<ProduceEvent> produceQueue, BlockingQueue<ConsumeEvent> consumeQueue) {\n        this.produceQueue = produceQueue;\n        this.consumeQueue = consumeQueue;\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                ProduceEvent event = produceQueue.take();\n                ConsumeEvent consumeEvent = new ConsumeEvent(event.getData());\n                consumeQueue.put(consumeEvent);\n                System.out.println(\"Consuming: \" + consumeEvent.getData());\n                Thread.sleep(2000); // 소비 간격을 조절하기 위해 잠시 멈춤\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\npublic class EventDrivenProducerConsumer {\n    public static void main(String[] args) {\n        BlockingQueue<ProduceEvent> produceQueue = new LinkedBlockingQueue<>();\n        BlockingQueue<ConsumeEvent> consumeQueue = new LinkedBlockingQueue<>();\n\n        // 생산자와 소비자 객체 생성\n        Producer producer = new Producer(produceQueue);\n        Consumer consumer = new Consumer(produceQueue, consumeQueue);\n\n        // 생산자와 소비자를 각각 스레드로 실행\n        Thread producerThread = new Thread(producer);\n        Thread consumerThread = new Thread(consumer);\n        producerThread.start();\n        consumerThread.start();\n    }\n}\n```\n\n생산자가 생산한 데이터를 이벤트 객체로 담아서 큐에 넣고, 소비자는 이벤트를 큐에서 가져와서 처리한다. \n\n<br><br>\n\n\n3. **생산자-소비자 문제 해결**\n\n\t공유자원에 접근하는 여러 스레드간의 동기화 문제를 해결하기 위해 사용된다. 생산자는 버퍼에 데이터를 추가하고, 소비자는 버퍼에서 데이터를 가져와 처리함으로써 동기화된 데이터 접근을 보장한다.\n\n\n<br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-351354945,"tx":46751},"ADbe6HrECGC5ROmU/contentState":{"id":"ADbe6HrECGC5ROmU/contentState","type":"contentState","selectionStart":183,"selectionEnd":183,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1716968142527,"tx":46753},"14iOQ0JTNwFklzQv/content":{"id":"14iOQ0JTNwFklzQv/content","type":"content","text":"---\npermalink: /2024-03-18-퍼사드(Facade) 패턴/\npublished: true\ntitle: \"[Design Pattern] 퍼사드(Facade) 패턴 \"\ndate: 2024-03-18 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"퍼사드(Facade) 패턴\"\ncategories:\n- 디자인 패턴\ntags:\n- 디자인 패턴\n- Design Pattern\n- 퍼사드(Facade) 패턴\n---\n<br><br><br>\n\n## ✅ 퍼사드 패턴이란?\n\n퍼사드(Facade) 패턴은 **복잡한 시스템이나 서브시스템을 간략한 인터페이스를 통해 제공하여 시스템의 복잡성을 감소시키고 사용하기 편리하게 만들어주는 패턴이다.** 복잡한 시스템을 감싸고 있는 외부 인터페이스를 제공하여 시스템 간의 의존성을 낮추고, 클라이언트가 시스템의 내부 구조에 대해 알 필요 없이 사용할 수 있게 해준다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/facade.png?raw=true\">\n</p>\n\n<br>\n\n퍼사드 패턴의 핵심 요소는 \"퍼사드\" 클래스이다. 퍼사드 클래스를 통해 시스템의 복잡한 부분을 캡슐화하고, 간단한 인터페이스를 제공한다. 클라이언트는 이 퍼사드 클래스를 사용하여 서브시스템과 상호작용 한다.\n\n<br><br><br><br>\n\n\n\n## ✅ 퍼사드 패턴의 구성 요소\n\n1. **Facade**\n\n\t클라이언트와 내부 시스템 간의 중간 계층으로 작용하는 인터페이스를 제공한다. 복잡한 서브 시스템에 대한 단순한 메소드들로 구성된다.\n\n2. **Subsystem Classes**\n\n\t퍼사드 클래스에 의해 감싸지는 복잡한 서브시스템의 클래스들을 의미한다. 이 클래스들이 시스템의 핵심 로직을 구현한다.\n\n3. **Client**\n\n\tFacade를 사용하여 복잡한 시스템을 간편하게 사용하는 클라이언트이다.\n\n<br><Br><br><Br>\n\n## ✅ 퍼사드 패턴의 구조\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/facade2.png?raw=true\">\n</p>\n\n<br>\n\n1. 퍼사드 패턴을 사용하면 하위 시스템 기능들의 특정 부분에 편리하게 접근할 수 있다.\n2. 추가적인 퍼사드 클래스는 관련없는 기능들이 포함되어 복잡한 구조로 퍼사드 클래스가 변질되는 것을 방지할 수 있다.\n3. 복잡한 하위 시스템은 수십 개의 다양한 객체들로 구성된다. 모든 객체가 의미있는 작업을 수행하도록 하려면, 하위 시스템의 세부적인 구현 정보를 깊이 있게 알아야 한다. 이때 하위 시스템 클래스들은 퍼사드 클래스의 존재를 인식하지 못한다.\n4. 클라이언트는 하위 시스템 객체를 직접 호출하는 것 대신 퍼사드 클래스를 통해 하위 시스템 객체를 사용한다.\n\n<br>\n### 📌 퍼사드 패턴 의사코드\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/facade3.png?raw=true\">\n</p>\n\n<br>\n\n```java\n// 복잡한 비디오 변환 프레임워크 클래스의 일부이다. \n// 해당 프레임워크 코드는 우리가 제어할 수 없기 때문에 단순화할 수 없다.\n\nclass VideoFile\n// …\n\nclass OggCompressionCodec\n// …\n\nclass MPEG4CompressionCodec\n// …\n\nclass CodecFactory\n// …\n\nclass BitrateReader\n// …\n\nclass AudioMixer\n// …\n\n// 퍼사드 클래스를 만들어 프레임워크의 복잡성을 간단한 인터페이스 뒤에 숨길 수\n// 있다. 기능성과 단순함을 상호보완한다.\nclass VideoConverter is\n    method convert(filename, format):File is\n        file = new VideoFile(filename)\n        sourceCodec = (new CodecFactory).extract(file)\n        if (format == \"mp4\")\n            destinationCodec = new MPEG4CompressionCodec()\n        else\n            destinationCodec = new OggCompressionCodec()\n        buffer = BitrateReader.read(filename, sourceCodec)\n        result = BitrateReader.convert(buffer, destinationCodec)\n        result = (new AudioMixer()).fix(result)\n        return new File(result)\n\n// 애플리케이션 클래스들은 복잡한 프레임워크에서 제공하는 수많은 클래스에 의존하지\n// 않는다. 또한 프레임워크의 전환을 결정한 경우에는 퍼사드 클래스만 다시 작성하면 된다.\nclass Application is\n    method main() is\n        convertor = new VideoConverter()\n        mp4 = convertor.convert(\"funny-cats-video.ogg\", \"mp4\")\n        mp4.save()\n```\n\n<br><br><br><br>\n\n\n## ✅ 퍼사드 패턴을 사용하는 이유\n\n1. **단순한 인터페이스 제공**\n\n\t복잡한 시스템에 대해 단순한 인터페이스를 제공하여 클라이언트가 시스템의 내부 동작을 이해할 필요 없이 사용할 수 있다.\n\n2. **시스템 간의 의존성 낮춤**\n\n\tFacade 패턴은 시스템의 내부 구조를 숨기기 때문에, 시스템 간의 의존성을 줄여서 시스템을 변경하거나 유지보수 하기 쉽게 만든다.\n\n3. **구조적 복잡성 감소**\n\n\t복잡한 시스템을 여러 개의 간단한 서브시스템으로 분할하고, 이를 Facade를 통해 조합함으로써 구조적 복잡성을 줄일 수 있다.\n\n<br><br><br><br>\n\n\n## ✅ 퍼사드 패턴 적용 상황\n\n1. **라이브러리의 사용**\n\n\t자주 사용하는 기능을 라이브러리로 제공할 때, 라이브러리 내부의 복잡한 기능을 Facade를 통해 단순화하여 사용자가 쉽게 사용할 수 있게 한다.\n\n<br>\n\n```java\n// 서브시스템 1: 가계부 데이터 관리\nclass AccountBook {\n    public void addExpense(String category, double amount) {\n        // 가계부에 지출 내역 추가\n        System.out.println(\"Added expense of $\" + amount + \" to category: \" + category);\n    }\n\n    public void addIncome(String source, double amount) {\n        // 가계부에 수입 내역 추가\n        System.out.println(\"Added income of $\" + amount + \" from source: \" + source);\n    }\n}\n\n// 서브시스템 2: 가계부 보고서 생성\nclass ReportGenerator {\n    public void generateMonthlyReport() {\n        // 월간 보고서 생성\n        System.out.println(\"Generated monthly report\");\n    }\n\n    public void generateYearlyReport() {\n        // 연간 보고서 생성\n        System.out.println(\"Generated yearly report\");\n    }\n}\n\n// 퍼사드 클래스: 클라이언트에게 단순한 인터페이스를 제공\nclass AccountFacade {\n    private AccountBook accountBook;\n    private ReportGenerator reportGenerator;\n\n    public AccountFacade() {\n        this.accountBook = new AccountBook();\n        this.reportGenerator = new ReportGenerator();\n    }\n\n    // 가계부에 지출 추가 메서드\n    public void addExpense(String category, double amount) {\n        accountBook.addExpense(category, amount);\n    }\n\n    // 가계부에 수입 추가 메서드\n    public void addIncome(String source, double amount) {\n        accountBook.addIncome(source, amount);\n    }\n\n    // 월간 보고서 생성 메서드\n    public void generateMonthlyReport() {\n        reportGenerator.generateMonthlyReport();\n    }\n\n    // 연간 보고서 생성 메서드\n    public void generateYearlyReport() {\n        reportGenerator.generateYearlyReport();\n    }\n}\n\n// 클라이언트\npublic class Client {\n    public static void main(String[] args) {\n        // 퍼사드를 통해 간단한 인터페이스로 서브시스템을 사용\n        AccountFacade accountFacade = new AccountFacade();\n\n        // 가계부 작업\n        accountFacade.addExpense(\"Groceries\", 50.00);\n        accountFacade.addIncome(\"Salary\", 2000.00);\n\n        // 보고서 생성\n        accountFacade.generateMonthlyReport();\n        accountFacade.generateYearlyReport();\n    }\n}\n\n```\n","properties":"\n","discussions":{},"comments":{},"hash":1203005227,"tx":46852},"14iOQ0JTNwFklzQv/contentState":{"id":"14iOQ0JTNwFklzQv/contentState","type":"contentState","selectionStart":1515,"selectionEnd":1515,"scrollPosition":{"sectionIdx":19,"posInSection":0.540785498489426},"hash":1716968288697,"tx":46854},"RTduSDZPEbBuUVtA/content":{"id":"RTduSDZPEbBuUVtA/content","type":"content","text":"---\npermalink: /2022-08-23-what-is-servlet/\npublished: true\ntitle: \"[Web & Server] 서블릿(Servlet)이란? \"\ndate: 2022-08-23 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"서블릿(Servlet)이란\"\ncategories:\n- Web & Server\ntags:\n- WAS\n- Web 서버\n- 개발상식\n\n---\n<br><br><br>\n\n## ✅ 서블릿(Servlet)이란?\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet1.png?raw=true\">\n</p>\n\n**서블릿이란 Dynamic Web Page, 즉 동적 페이지를 만들 때 사용되는 JAVA기반 웹 애플리케이션 프로그래밍 기술이다.** 웹을 만들 때는 다양한 요청 (Request)과 응답(Response)이 있고, 이 요청과 응답에는 규칙이 존재하는데, 이러한 요청 응답을 간단한 메서드 호출로 체계적으로 다룰 수 있게 해주는 기술이라고 보면 된다.\n\n좁은 의미로 서블릿을 보면 위와 같은 기능을 하는 **자바 클래스**이고,\n넓은 의미로 서블릿을 보면 위와 같은 기능을 하는 **자바 패키지**이다.\n\n<br><br><br>\n\n## ✅ 서블릿의 등장 배경\n과거에 서버는 정적페이지(HTML,CSS,Image) 만을 처리했다. 클라이언트가 자료를 요청하면 서버는 미리 만들어둔 데이터를 저장하고 있다가 HTML로 반환했다. 그런데 점점 사용자가 많아지자 저장공간도 부족해지고, 사용자들은 정적페이지가 아닌 각자 필요에 맞는 동적 페이지를 받고 싶어했다. 그래서 이러한 **동적 페이지를 만들기 위해 생겨난 것**이 **서블릿(Servlet)**이다!\n\n\n<br><br><br>\n\n## ✅ 서블릿과 서버\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet3.png?raw=true\">\n</p>\n앞선 포스팅에서 Web서버와 WAS에 대해서 알아봤는데 서블릿과도 관계가 아주 깊다. Web서버는 정적페이지를 처리하고, WAS는 동적페이지를 처리하는데 **WAS에서 연산을 담당하는 것이 바로 서블릿이다.** 이러한 서블릿은 **WAS내의 서블릿 컨테이너(웹 컨테이너)에서 관리된다.**\n\n<br><br><br>\n\n## ✅ 서블릿 컨테이너 (웹 컨테이너)\n서블릿 컨테이너는 말그대로 서블릿을 담고 관리해주는 컨테이너 이다. 일반적으로 홈페이지에 들어가면 굉장히 많은 기능을 제공하는데 예를 들어 쇼핑몰 페이지만 봐도 구매, 장바구니 등록, 게시판, 회원가입 등 기능이 굉장히 많다. 이런 기능들은 데이터를 주고받으며 사용자에 따라 각기 다른 정보를 제공해야 하므로 동적 데이터, 즉 서블릿을 통해 작동되는데 하나의 서버 안에 수많은 서블릿이 존재하면, 이를 전부 컨트롤하기는 어려운 일이다. 따라서 서블릿 컨테이너가 모든 서블릿을 제어함으로써 효율적인 서버 관리가 가능하다.\n\n<br><br>\n\n앞서 서블릿은 일종의 **자바 클래스 혹은 패키지**라고 얘기 한 바 있다. 서블릿을 실제로 작성해보면 자바 언어로 쓰이고 자바 클래스 형태를 띄고 있는걸 알 수 있다. 그리고 이러한 서블릿은 ```javax.servlet.http``` 라는 패키지 안에 포함되어 있다. javax.servlet은 서블릿 구현을 위한 다양한 인터페이스와 클래스가 포함된 꾸러미이다. 우리가 쓰는 서블릿 클래스는 이 패키지 안에서 하나를 빌려와서 구현한 것이다.\n\n<br><br>\n\n우리가 servlet 클래스의 규칙에 맞게 구현을 하고 클라이언트가 요청을 하면 컨테이너는 **HttpServletRequest, HttpServletResponse** 두 객체를 생성하고 **POST,GET** 여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.\n<BR>\n\n- **HttpServletRequest**   \nhttp프로토콜의 request정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URI, URL 등의 정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있습니다.\n\n- **HttpServletResponse**   \nWAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여 서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송합니다.\n\n<br><br><br><br>\n\n## ✅ 서블릿 컨테이너의 실행 순서\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet4.png?raw=true\">\n</p>\n\n1️⃣ **클라이언트의 요청**\n\nHTTP프로토콜을 통해 Request 받은 요청이 정적 페이지라면 WEB서버를 통해 바로 처리해주고, 동적 페이지라면 서블릿 컨테이너로 넘긴다.\n\n<br>\n\t\n2️⃣ **HttpServletRequest, HttpServletResponse 객체 생성**\n\n요청이 들어오면 서블릿 컨테이너에서는 HttpServletRequest, HttpServletResponse 객체를 생성한다. HttpServletRequest는 요청에 대한 데이터 처리과정을 담당하고, HttpServletResponse는 요청에 대한 결과물 반환을 담당한다.\n\n<br>\n\n3️⃣ **Web.xml 파싱**\n\nWeb.xml은 서블릿의 위치(주소)는 어디인지, 어떤 이름으로 mapping 할 것인지 찾을 수 있도록 도와주는 문서이다. Web.xml을 참조해서 Servlet으로 접근한다고 보면 된다.\n서블릿 컨테이너는 Web.xml 문서에 따라 그에 맞는 서블릿 주소를 찾고 서블릿에 접근한다.\n\n<br>\n\t\n4️⃣ **서블릿 초기화**\nWeb.xml 문서에 따라 실행할 서블릿을 찾았다면 해당 서블릿 클래스를 로드한다. 그리고 서블릿에서 사용할 객체를 만든다. 그리고 이 객체를 이용해 init()메서드를 호출해서 서블릿을 사용할 수 있도록 초기화한다.\n\n<br>\n\n5️⃣ **Service 실행**\n서블릿 초기화 이후에는 요청을 처리하는 service() 메서드가 실행 된다. 그리고 service()는 요청이 get방식인지, post방식인지에 따라 맞는 메서드를 실행한다.\n\n요청이 get이라면 `doGet()`을,\n요청을 post라면 `doPost()`를 실행한다.\n\n<br>\n\n6️⃣ **destroy() 실행**\n더이상 사용되지 않는다고 판단하거나 서버가 종료될 때 컨테이너는 `destroy()` 메서드를 실행하여 서블릿을 제거한다.\n\n<br><br><br>\n\n \n\n","properties":"\n","discussions":{},"comments":{},"hash":-583634468,"tx":47195},"oT3RS2G9LsJ6xJ1f/syncedContent":{"id":"oT3RS2G9LsJ6xJ1f/syncedContent","type":"syncedContent","historyData":{},"syncHistory":{},"v":0,"hash":1717028581365,"tx":47313},"oT3RS2G9LsJ6xJ1f":{"id":"oT3RS2G9LsJ6xJ1f","type":"file","name":"2021-09-12-CA_Instruction Set Architecture","parentId":"3czWpyCWVN518JXE","hash":-538611651,"tx":48294},"1x2SS92trda8Dql0":{"id":"1x2SS92trda8Dql0","type":"file","name":"2021-09-13-CA_LEGv8-ISA","parentId":"3czWpyCWVN518JXE","hash":1919923569,"tx":48736},"tLqdQCgLBZOSaYBm":{"id":"tLqdQCgLBZOSaYBm","type":"file","name":"2021-09-14-CA_LEGv8-ISA2","parentId":"3czWpyCWVN518JXE","hash":1207510580,"tx":48776},"3pPfZNfURBxowOxC":{"id":"3pPfZNfURBxowOxC","type":"file","name":"2023-11-10-카카오클라우드스쿨 합격후기","parentId":"QaEMZoJUSOrF5AKA","hash":232985421,"tx":51384},"3pPfZNfURBxowOxC/content":{"id":"3pPfZNfURBxowOxC/content","type":"content","text":"---\npermalink: /2024-05-10-카카오 클라우드 스쿨 3기 개발자 과정 합격 후기/\npublished: true\ntitle: \"[후기] 카카오 클라우드 스쿨 3기 개발자 과정 합격 후기\"\ndate: 2023-11-10 09:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"카카오 클라우드 스쿨 개발자 과정 합격 후기\"\ncategories:\n- 후기\ntags:\n- 카카오 클라우드 스쿨 3기\n---\n<br><br><br>\n\n\n## ✅ 카카오 클라우드 스쿨 합격 후기\n\n초초초초 엄청 늦은 카카오 클라우드 스쿨 합격 후기..! 합격한지 1년 그리고 수료한지 6개월 정도가 지났고 지금은 개발자로 일하고 있지만 후기를 아직도 작성하지 않은게 생각나 굉장히 늦은 후기를 작성합니다..! ( 글 등록일은 23년11월로 되어있지만 사실은 24년 5월에 쓰고있어요.. ㅎㅎ ) 이 후기를 얼마나 많은 분들이 보겠냐만은 그래도 앞으로 카카오 클라우드 스쿨에 지원할 많은 분들에게 조금이나마 도움이 됐으면 하는 마음에 지원하고 합격한 후기를 작성해봅니다.\n\n\n<br><br><br><br><br><br>\n\n## ✅ 지원 동기\n\n23년 2월에 대학교를 졸업하고 누구나 그렇듯 열심히 취업준비를 하고 있었습니다. 웹개발자가 되고싶었기에 입사를 위한 코딩테스트도 풀고 자소서도 써보고 지원도 해보고 CS공부도 해왔죠. 근데 취업시장이 내가 생각한 것보다 만만치가 않았어요. 뭔가 개발자는 학력도 크게 중요하지 않다고 들었고 \"실력이 더 중요하다..!\" 이런말을 워낙 많이 들어왔기에 학력,자격증 같은 정량적 요소보다는 개발자로서의 역량을 기르는데 시간을 많이 보내왔어요. 그런데 현실은 좀 달랐습니다. 누구나 가고싶은 기업일 수록 정량적 요소도 매우 중요했고, 그들이 요구하는 실력과 커리어는 제가 가진 역량보다 훨씬 높았습니다. 그래도 해보자 해보자 하면서 자소서를 난사했지만 서류가 합격해도 코딩테스트에서 번번히 떨어졌죠.. 솔직히 좀 벽을 느꼈습니다. 제 역량이 부족한 탓도 있었겠지만 취업시장도 워낙 안좋았어요.. 그래서 저는 취업을 잠시 미루고 제대로 공부를 해보자 마음먹고 여러 프로그램을 찾아봤습니다. 개발 공부를 빡세게 하면서 프로젝트 경험도 쌓고 코딩테스트 공부도 할 수 있는 방법을 찾아봤는데 부트캠프에 들어가는게 가장 좋아보였습니다.\n\n부트캠프도 종류가 정말 많더군요. 제일 유명한 SSAPY, 우테코, 소마부터 여러 학원들에서 국비로 진행하는 수업들까지 선택의 폭이 굉장히 넓었습니다. SSAPY는 들어가는게 어려워보이진 않았지만 1년이라는 교육기간이 너무 길다고 느껴졌고, 우테코/소마는 제가 들어가기에는 수준이 너무 높았습니다.. ㅎㅎ 그렇다고 동네 학원에서 국비교육을 듣자니 예전에 코딩 단과학원을 수강했던 경험이 너무 안좋기도 하고 주변 경험자들이 딱히 추천하지 않아서 하고싶지 않았습니다.\n\n그러던 중 우연히 카카오 클라우드 스쿨 3기 모집글을 봤습니다. 개발자 과정이랑 엔지니어 과정이 있는데 **개발자 과정은 웹개발(Java) + 클라우드 기본 + 프로젝트 구성이었고** 엔지니어 과정은 python + 클라우드 심화 + 프로젝트 구성이었습니다. \n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/kakaocloud.png?raw=true\">\n</p>\n\n개발자 과정 커리큘럼은 이랬습니다. 저는 웹개발자가 하고싶었기 때문에 개발자 과정이 저에게 좀더 적합하다고 생각했고 프론트부터 백엔드, 클라우드까지 공부할 수 있었기에 교육과정자체는 굉장히 좋아보였습니다. 공부를 혼자 하다보니 방향을 잡기도 어려웠고, 어떤 방식으로 공부를 하는게 좋은 방법인지 깨닫기 어려웠는데 **카카오 재직자분의 멘토링**까지 있다고 하니 상당히 매력적으로 느껴졌습니다. 지원하기 위해 후기를 몇개 찾아봤는데 교육생자체가 많지 않은 프로그램이다 보니 후기를 거의 찾아볼 수가 없더군요.. 일단 지원해버렸습니다..!  \n\n\n<br><br><br><br><br><br>\n\n## ✅ 지원 과정\n\n### 📌 서류전형\n<hr>\n\n먼저 서류를 작성했습니다. 뭔가 문서를 작성해서 제출하진 않았고 **구글폼 형식**으로 서류전형을 접수받더군요. 저는 부트캠프를 지원할때의 서류는 일반적인 기업 입사 지원서류와는 다른 매력을 어필해야 한다고 생각했습니다. 기업 서류는 \"나 이만큼 해왔어\", \"나 이런거 잘해\", \"나 이런 역량 가지고있어\" 처럼 본인이 가진 능력과 경험을 어필해야 한다면, 부트캠프는 \"나 이런 열정있고, 열심히 공부할거야!\" 라는 식의 **성장가능성을 어필해야한다고 판단했습니다.**\n\n그래서 제가 공부해온 과정, 블로그 작성한 것, 프로젝트 한 것 위주로 서류를 작성해서 제출했습니다. ( 이후에 면접에서 프로젝트 기반 질문이 들어옴 )\n\n<BR><BR>\n\n### 📌 사전 테스트\n<hr>\n\n특이하게 코딩테스트 대신 사전테스트가 있습니다. 서류 + 사전테스트를 통과해야 면접기회가 주어집니다. 사전테스트는 기본적인 CS지식 문제들이 나왔던걸로 기억합니다. 엄청나게 어려운 문제도 아니고, 객관식이기 때문에 기본적으로 전공자시라면 쉽게 풀수있는 정도였습니다. 혹시 본인이 비전공자거나 CS지식이 부족하다 싶으면 커리큘럼에 나와있는 내용들 위주로 쭉 가볍게 검색해보시고 읽어보시는것 정도 추천드립니다. 막 깊게 공부한다고 해서 그 내용이 출제되는 것도 아니고 공부 안한다고 해서 다 틀릴 내용도 아닙니다. 아! 정보처리기사 준비를 해보셨다면 딱 그런 느낌이라고 생각하시면 될 것 같습니다.\n\n<BR><BR>\n\n### 📌 면접\n<hr>\n\n서류+사전테스트에 합격하셨다면 딱 한번의 최종면접이 남아있습니다. 제가 면접볼 때는 염창에 교육장소가 있어서 염창에서 봤지만 아마 지금은 가산디지털단지에서 면접을 보지않을까 싶네요..\n\n면접은 한팀당 7명 30분씩 봤습니다. 7명에게 많은 질문을 던지기에는 확실히 시간이 부족하긴 합니다. 그렇기에 막 엄청난 면접내용을 준비해가지는 않았습니다.\n\n**1분 자기소개 + 지원동기**는 어느 면접에서나 준비를 해가죠 보통..? 그리고 **본인이 작성한 자소서 내용에 대한 예상질문**과 **커리큘럼 관련 CS지식** 이정도 준비를 해가면 충분할 것 같습니다.\n\n실제 면접 볼 때는 질문을 4가지 정도 받았습니다.\n\n1. **1분 자기소개**\n2. **지원동기**\n3. **자소서에 작성한 프로젝트에 대해 설명해봐라**\n4. **본인의 장/단점**\n\n굉장히 대처하기 쉬운 질문 내용이었습니다. 근데 기억에 되게 남는 순간이 있었는데, 면접 중간에 면접관께서 전공자에게는 \"전공수업 중 가장 재밌었던 과목이 무엇이냐\" 묻고 DB라고 대답하면 \"인덱스에 대해서 설명해보세요\" 라는 식의 질문을 하셨고, 비전공자에게는 \"비전공자인데 컴퓨터 공부를 어떻게 해왔고 부트캠프에서 어떻게 공부하실거냐\" 라는 질문을 하셨습니다. 저는 전공자이기 때문에 머릿속으로 DB대답하고 인덱스 설명드려야지! 하고 있었는데 유일하게 저만! 갑자기 제 자소서에 있는 프로젝트에 대해서 설명해보라고 하시더군요.. ㅎㅎ 물론 제가 한 프로젝트니 갑작스러워도 술술 나와서 괜찮았지만 갑자기 저만!!!! 다른 질문을 주셔서 살짝 당황했던 기억이 있습니다. 혹시라도 CS 관련 질문을 답변하지 못할것 같다 라는분이 계시면 자소서를 프로젝트 관련 내용으로 채우는 것도 좋은 꿀팁이 될 거라 생각합니다. \n\n\n<br><br><br><br><br><br>\n\n## ✅ 합격\n\n이렇게 해서 카카오 클라우드 스쿨 3기 - 개발자과정에 합격하게 되었습니다. 사실 이글을 쓰는 시점은 이미 다 수료까지 하고 난 뒤라 합격의 기쁨? 보다는 정보전달을 위해 글을 쓰긴했네요 .. 이후에 수료직후 시점으로 후기를 하나더 작성해서 교육과정에 대한 자세한 얘기를 해 볼 예정이지만 이곳에도 간단하게 총평을 적어보면\n\n개인적으로는 **정말 정말 도움이 많이 됐습니다..!** 이 부트캠프가 아니었다면 저는 정말 입에 풀칠도 못하고 살았을 거 같아요. **개발실력 향상 + 프로젝트 수행 + 생활패턴 생성 + 개발자 동료 + 동기부여**까지 엄청 많은 부분에서 도움이 많이 됐습니다.\n\n**그렇지만 역시 가장 중요한 건 본인이 얼마나 의지가 있고, 얼마나 열심히 공부하느냐에 달려있습니다. 개인적으로 교육과정의 수업 그 자체는 도움이 안된다고 볼 수는 없지만 그냥 일반적으로 어디서나 들을 수 있는 수준의 수업 그 이상 그 이하도 아닙니다. 그 안에서 본인에게 필요한 내용을 골라 학습하고, 배운 내용을 프로젝트에 적극적으로 녹이고, 주변 동료들과 소통하면서 다양한 경험을 쌓는것이 이 부트캠프의 가장 큰 강점이라고 봅니다. 결국 본인이 하기 나름이에요 본인이!! 저는 개인적으로 정말 열심히 했고 후회가 전혀 없었습니다.. ㅎㅎ**\n\n아무튼 이런 과정으로 카카오 클라우드 스쿨 3기 개발자과정에 합격할 수 있었습니다..! 다른 궁금하신 점이 있다거나 서류,사전테스트,면접 등 필요한 정보 있으시면 댓글 혹은 메일 남겨주시면 가능한 선에서 최대한 답변 드리겠습니다.. !\n","properties":"\n","discussions":{},"comments":{},"hash":-1001392443,"tx":51389},"3pPfZNfURBxowOxC/contentState":{"id":"3pPfZNfURBxowOxC/contentState","type":"contentState","selectionStart":190,"selectionEnd":190,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717977128441,"tx":51398},"D6AI3WmiULa0MQox/content":{"id":"D6AI3WmiULa0MQox/content","type":"content","text":"---\npublished: true\ntitle: \"[머신러닝] [Python] Support Vector Machine (SVM) 이란?\"\ndate: 2021-09-24 06:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"SVM이란?\"\nuse_math: true\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- Classification\n---\n\n<br><br><br>\n\n\n## ✅ SVM이란?\n\n**서포트 벡터 머신(이하 SVM)**은 **결정 경계, 즉 분류를 위한 기준 선**을 정의하는 모델이다. SVM의 궁극적인 목표는 한 클래스의 데이터 점을 다른 클래스의 데이터 점과 가능한 한 가장 잘 구분해내는 초평면을 찾는 것이다. \"가장 잘 구분한다\" 라는 기준은 두 클래스 사이의 가장 큰 마진(공백)을 갖는 초평면으로 정의된다. 따라서 분류되지 않은 새로운 점이 나타나면 경계의 어느 쪽에 속하는지 확인해서 분류 과제를 수행할 수 있게 된다. \n\n따라서 SVM을 정확히 이해하기 위해서는 먼저  **결정 경계**를 확실히 짚고 넘어가야만 한다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm1.png?raw=true\">\n</p>\n\n데이터에 2개의 속성만 존재한다면 위와 같은 분포가 나타날 것이다. 이때 두 데이터 분포를 완벽하게 나누는 선, 즉 **결정 경계**는 무수히 많이 존재할 수 있다. 때문에 우리는 두 데이터 분포를 가장 정확하게 분류할 수 있는 단 하나의 결정 경계를 파악할 필요가 있다. 이를 **Decision Boundary(최적의 결정경계)** 라고 부른다.\n\n<br><br><br><br><br><br>\n\n## ✅ Decision Boundary ( 최적의 결정경계 )\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm2.png?raw=true\">\n</p>\n\n그렇다면 **어떤 결정 경계가 가장 최적의 결정 경계일까**를 판단하는 것이 관건이 된다. 위의 그림에서는 오른쪽 분포가 최적의 결정 경계를 나타낸다. 가장 직관적으로 받아들일 수 있는 이유는 **경계를 기준으로 데이터가 더 멀리 분포되어 있기 때문이다**.\n\n<br><br><br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm3.png?raw=true\">\n</p>\n원활한 이해를 돕기위해 간단하게 용어정리를 하고 넘어가겠다. \n\n- Cluster : 데이터가 모여있는 집합 또는 데이터군\n- Decision boundry (Separating line 또는 Classifier) : 결정 경계\n- Support Vectors : 결정 경계에서 가장 가까운 데이터 점\n- Margin : 결정 경계로부터 Support Vectors 까지의 거리\n\n<br><br><br>\n\n여기서 하나의 결론을 얻을 수 있다. **최적의 결정 경계는 마진을 최대화한다.**\n\n또한 SVM알고리즘의 장점을 하나 알수 있다. 대부분의 머신러닝 지도 학습 알고리즘은 학습 데이터 모두를 사용하여 모델을 학습한다. 그런데 **SVM에서는 결정 경계를 정의하는 게 결국 Support Vectors이기 때문에 데이터 포인트 중에서 서포트 벡터만 잘 골라내면 나머지 쓸 데 없는 수많은 데이터 포인트들을 무시할 수 있다. 그래서 매우 빠르다.**\n\n<br><br><br><br><br><br>\n\n\n## ✅ Soft Margin\n\n앞서 살펴본 예시는 매우 이상적인 형태의 데이터 분포로 명확하게 Decision Boundary를 구할 수 있었다. 그러나 대부분의 데이터들은 명확하게 분류 할 수 없는 형태를 띈다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm4.png?raw=true\">\n</p>\n\n위와 같은 cluster를 형성한 경우에는 직관적으로 Support Vectors를 구한다거나 Decision Boundry를 정의하기 어렵다. 이럴 때 SVM에서는 두가지 방법을 사용해 데이터를 분류 할 수 있다. 첫번째 방법은 **Soft Margin**을 사용하는 것이다.\n\n**Soft Margin은 SVM에서 Margin은 최대화 하면서 약간의 오류를 허용하는 방법이다.** Soft Margin의 핵심 아이디어는 두가지이다.\n\n1. **마진 최대화** : SVM의 기본 목표는 두 클래스의 마진을 최대화 하는 것이다. 즉, 결정 경계에서 가장 가까운 데이터(Supprot Vectors)와 결정 경계 사이의 거리를 최대화 한다.\n  \n3. **약간의 Error 허용**  : 모든 데이터가 완벽히 올바르게 분류되지 않아도 된다. 일부 데이터는 경계를 넘어서거나 마진 내에 위치할 수 있으며, 이를 통해 모델이 더 유연하게 데이터에 적응할 수 있게 한다.\n\n위의 두가지 아이디어를 충족시키기 위해 SVM에서는 **\"C\"**라고 불리는 penalty parameter를 사용한다.\n\n<BR><BR>\n\n### 📌 C Parameter\n<hr>\n\n**C는 결정 경계에서 Error를 얼마나 허용할지를 결정하는 파라미터이다.** C의 값에 따라 모델의 유연성을 조절할 수 있다. \n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm5.png?raw=true\">\n</p>\n\n- **C값이 클수록** : Hard margin(Error 허용 안 함). 즉 오류를 거의 허용하지 않는다. 모델은 데이터를 최대한 올바르게 분류하려고 하기 때문에 margin은 작아지고 overfitting(과적합)의 위험이 있다.\n\n- **C값이 작을수록** : Soft maring(Error를 허용함). 즉 더 많은 오류를 허용한다. 모델은 margin을 최대화 하면서 일부 데이터가 잘 못 분류되는 것을 허용한다. 때문에 underfitting(과소적합)의 위험을 줄여준다.\n\n<BR><BR>\n\n### 📌 Soft Margin의 구현\n<hr>\n\nscikit-learn에서 Soft Maring을 구현하는 방법은 매우 간단하다. SVM 모델을 정의할 때 C 파라미터 값을 설정해주면 된다. 이때 C의 기본값은 1이다.\n\n```python\nfrom sklearn.svm import SVC \n\n# C 값을 0.01로 설정하여 소프트 마진을 사용 \nclassifier = SVC(C=0.01)\n```\n\n위 처럼 설정하면 모델은 일부 오류를 허용하면서도 margin을 최대화 하려고 한다. C 값의 최적 값은 주어진 데이터마다 다르기 때문에 여러가지 C값을 시도하면서 모델을 검증하는 것이 중요하다.\n\n\n\n<br><br><br><br><br><br>\n\n## ✅ Kernel\n\nSVM의 기본 아이디어는 데이터를 고차원 공간으로 매핑하여 선형적으로 분리할 수 있는 초평면을 찾는 것이다. 앞서 설명한 것들은 모두 Linear하게 분리가 가능한 데이터셋이였지만 만약 선형으로 분리 할 수 없는 데이터셋이 있다면 어떻게 해야할까? 이때 **Kernel**이 중요한 역할을 수행한다.\n\n<BR><BR>\n\n### 📌 Kernel이란?\n<hr>\n**Kernel**은 데이터를 현재 차원보다 더 높은 차원으로 매핑하여 선형적으로 분리 가능하게 만드는 함수이다. Kernel 함수는 두 벡터의 내적을 계산하여 새로운 고차원 공간으로 변환된 결과를 나타내는데, 이를 통해 비선형적인 데이터도 선형적으로 분리할 수 있다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm6.png?raw=true\">\n</p>\n\n위와같은 데이터는 어떤식으로도 선형으로는 분류할 수 없는 데이터이다. 이때 우리는 SVM을 적용하기 위해 Kernel을 활용하여 2차원 데이터를 3차원 데이터로 변경할 수 있다. 그 결과는 다음과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm7.png?raw=true\">\n</p>\n\n위 그림처럼 2차원 데이터를 3차원 데이터로 변경한 뒤 데이터군을 분리할 수 있는 초평면을 구성함으로써 SVM을 사용할 수 있게되었다.\n\n그러나 저차원 데이터를 분류하기 위해 고차원 데이터 형태로 실제 변환하는 작업은 효율적이지 못하고 데이터 분류 작업보다 어려울 수 있다. 데이터 분류를 위해 수행하는 변환 작업이 오히려 데이터 분류 작업 자체 효율을 낮출 수 있는 문제가 생긴다. 때문에 SVM에서는 이러한 고차원 공간으로의 변환 작업을 직접 수행하지 않고 효율적으로 계산할 수 있는 **Kernel Trick**을 제시한다.\n\n\n<BR><BR>\n\n### 📌 Kernel Trick이란?\n<hr>\n\n**Kernel Trick**은 데이터를 명시적으로 고차원 공간으로 변환하지 않고, Kernel 함수를 통해 변환된 고차원 공간에서의 내적을 효율적으로 계산하는 방법이다. Kernel Trick을 사용하면 계산 비용을 크게 줄이면서도 고차원 공간에서의 분리를 가능하게 한다.\n\n즉, 고차원 공간의 특징을 계산하지 않고도 고차원 공간에서의 내적을 직접 계산할 수 있게 해주는 기법이다. 이를 통해 SVM은 실제로 고차원 공간으로 데이터를 변환하지 않고도 비선형 분류를 수행할 수 있다.\n\n<BR><BR>\n\n### 📌 대표적인 kernel 함수\n<hr>\n\nscikit-learn에서 지원하는 대표적인 kernel 함수는 크게 4가지가 있다.\n\n1. **Linear Kernel**: 선형 커널은 원래 공간에서 선형 분리를 수행한다.\n\t\n\t$K(x,y)=x⋅y$\n\n 2. **Polynomial kernel** : 다항식 커널은 입력 벡터의 다항식 형태로 매핑한다.\n\n\t$K(x,y)=(x⋅y+c)^d$ \n\n\n 3. **RBF kernel (=Gaussian kernel)** : 가우시안 커널이라고도 하며, 무한 차원 공간으로 매핑한다.  ($γ$는 커널의 폭을 조절하는 파라미터)\n\n\t$K(x,y)=exp(−γ∥x−y∥^2)$\n\n 4. **Sigmoid kernel** : 시그모이드 커널은 신경망에서 사용하는 활성화 함수와 유사한 형태이다.\n\n\t$K(x,y)=tanh(αx⋅y+c)$\n\n\n<BR><BR>\n\n### 📌 RBF kernel\n<hr>\n\nkernel 함수 중 Default로 지정되어 가장 많이 사용되는 함수는 **RBF 커널**이다. RBF 커널 함수는 두 데이터 포인트 $x$와 $y$ 사이의 거리에 기초한다. 구체적으로, RBF 커널 함수는 다음과 같이 정의된다.\n\n$K(x,y)=exp(−γ∥x−y∥^2)$\n\n$∥x−y∥$는 두 벡터 $x$와 $y$사이의 유클리드 거리이고, $γ$는 커널의 폭을 조절하는 매개변수로 사용된다. 이때 $γ$는 반드시 양수값이다.\n\n\n<BR><BR>\n\n### 📌 RBF kernel의 파라미터 : $γ$\n<hr>\n\nRBF kernel을 사용할 때 매개변수로 사용되는 **$γ$(gamma)**는 데이터 포인트 사이의 유사성을 측정하는데 사용된다. \n\n`gamma`는 쉽게 표현하면 결정 경계를 얼마나 유연하게 그을지 정해주는 매개변수이다. 학습 데이터에 얼마나 민감하게 반응할 것인지 모델을 조정하는 것이므로 SVM의 C파라미터와 비슷하다고 볼 수 있다.\n\n-   `gamma`값을  **높이면**  학습 데이터에 많이 의존하면서 데이터 포인트의 가까운 이웃을 위주로 같은 집단으로 분류하려고 한다. 한마디로 데이터에 매우 민감하게 반응한다. 결과적으로는 **결정 경계를 구불구불**  긋게 된다. 이는  모델의 **과적합(Overfitting)**을 초래할 수 있다.\n\n-   `gamma`를  **낮추면**  학습 데이터에 별로 의존하지 않고  더 넓은 영역의 데이터 포인트를 같은 집단으로 분류하려고 한다. 한마디로 데이터에 민감하게 반응하지 않는다. 결과적으로는 **결정 경계를 직선에 가깝게**  긋게 된다. 이는 모델의  **과소적합(Underfitting)**을 발생 시킬 수 있다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm8.png?raw=true\">\n</p>\n\n위의 그림을 통해 감마 값에 대한 분류 추이를 살펴볼 수 있다.\n\ngamma = 3.0 인 경우가 가장 이상적으로 분류된 정도라고 보이고,  \ngamma = 0.008인 경우 너무 낮아 경계가 직선형을 띄는 모습,  \ngamma = 11.0인 경우 너무 높아 경계가 제대로 이루어지지 못한 모습이다.\n\n\n<BR><BR>\n\n### 📌 RBF kernel 구현 - python\n<hr>\n\n이를 scikit-learn으로 구현한 코드는 아래와 같다. 먼저 scikit-learn 라이브러리를 설치해준다.\n\n```python\npip install numpy matplotlib scikit-learn\n```\n\nSVM 모델 적용방법은 다음과 같다.\n\n```python\nfrom sklearn.svm import SVC\n\nclassifier = SVC(kernel='rbf')\n```\n\n모델을 불러올 때 kernel의 Default는 `'rbf'`이고, 이 외에도 `'linear'`, `'poly'`, `'sigmoid'` 와 같은 다른 함수로 지정해줄 수도 있다.\n\n `'rbf'`,  `'poly'`,  `'sigmoid'` 커널을 사용할 때는 `gamma`값을 설정해줘야 한다.\n \n```python\nclassifier = SVC(kernel = \"rbf\", C = 2, gamma = 0.5)\n```\n\n이를 실제로 데이터와 연동하여 적용한 예제는 다음과 같다. scikit-learn의 datasets 모듈에서 테스트용 데이터셋인 Iris를 불러오고 전처리 후 SVM 모델을 적용해준다.\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import svm, datasets\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report, accuracy_score\n\n# 데이터셋 생성\n# iris 데이터셋을 사용합니다.\niris = datasets.load_iris()\nX = iris.data[:, :2]  # 꽃잎 길이와 폭만 사용\ny = iris.target\n\n# 데이터셋을 훈련 세트와 테스트 세트로 나눔\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# SVM 모델 생성 및 학습 (RBF 커널 사용)\nmodel = svm.SVC(kernel='rbf', gamma='scale')\nmodel.fit(X_train, y_train)\n\n# 테스트 데이터로 예측 수행\ny_pred = model.predict(X_test)\n\n# 모델 성능 평가\nprint(\"Accuracy:\", accuracy_score(y_test, y_pred))\nprint(\"Classification Report:\\n\", classification_report(y_test, y_pred))\n\n# 학습 데이터와 결정 경계 시각화\ndef plot_decision_boundary(X, y, model):\n    h = .02  # 결정 경계의 해상도\n    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),\n                         np.arange(y_min, y_max, h))\n    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])\n    Z = Z.reshape(xx.shape)\n\n    plt.contourf(xx, yy, Z, alpha=0.8)\n    plt.scatter(X[:, 0], X[:, 1], c=y, edgecolors='k', marker='o')\n    plt.xlabel('Sepal length')\n    plt.ylabel('Sepal width')\n    plt.title('SVM with RBF Kernel')\n    plt.show()\n\n# 결정 경계 시각화\nplot_decision_boundary(X_train, y_train, model)\n\n```\n<br><br><br><br><br><br>\n\n\n## ✅ Multi-Class SVM\nSVM은 Binary Classifier로 이진분류만 가능하지만 SVM을 이용해 다중 Class의 분류도 가능하다. 간단하게 예시를 들어 맛만보자.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/svm9.png?raw=true\">\n</p>\n\n원리는 간단하다. 세개의 클래스중 한개를 제외한 나머지를 하나의 클래스로 분류한뒤 이진분류를 진행해주면 된다.\n\n<br><br><br><br><br><br>\n\n## ✅ SVM의 장/단점\n\n### 📌 Advantages\n\n - 마진이 명확하게 구분될때 잘 작동한다. \n - 고차원 데이터 ( Feature가 많은 경우) 일때 효과적이다. \n - Support Vector만 사용해 경계를 계산하므로 메모리를 효율적으로 쓴다.\n\n### 📌 Disadvantages\n- 데이터셋이 많은 경우 Training time이 오래걸린다.\n- 데이터에 noise가 많은 경우 잘 작동하지 않는다\n- 정확도를 직접적으로 보여주진 않는다.\n\n<br><br><br><br><br><br>\n\n## ✅ SVM을 사용할 때 유의점\n1. 어떤 커널을 사용할 지 결정해야만 한다. \n\t- `rgf`가 기본값으로 설정되어있다.\n2. 커널 파라미터를 결정해야 한다.\n\t- gamma, 가우시안 커널의 σ\n3. 하드마진 vs 소프트마진 어떤걸 사용할지 C를 이용해 결정해야 한다.\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1299026778,"tx":52026},"w2rF7i814I5K61Gi/contentState":{"id":"w2rF7i814I5K61Gi/contentState","type":"contentState","selectionStart":3097,"selectionEnd":3097,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717981001738,"tx":52107},"nZtkP309cM7hcqO2/contentState":{"id":"nZtkP309cM7hcqO2/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717981707356,"tx":52120},"O7ZdI0GnNZ8IGhYW/contentState":{"id":"O7ZdI0GnNZ8IGhYW/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717981707809,"tx":52121},"w6ADipsYQPt3OgNW/content":{"id":"w6ADipsYQPt3OgNW/content","type":"content","text":"---\npermalink: /2023-06-16-Static/\npublished: true\ntitle: \"[JAVA] Static이란? \"\ndate: 2023-06-16 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"객체지향 한방에 정리하기\"\ncategories:\n- JAVA\ntags:\n- JAVA\n- 객체지향\n- 객체지향 한방에 정리하기\n---\n\n<br><br>\n\n## ✅ Static - 클래스의, 공통적인\nStatic은 단어 그대로는 정적인, 고정된 이라는 의미를 가지지만 객체지향에서의 static은 **'클래스의'** 또는 **'공통적인'**의 의미를 가지고 있다. static 키워드를 사용하여 **static변수와 static 메소드**를 만들 수 있는데 다른말로 각각 **정적필드와 정적 메소드**라고하며 이 둘을 합쳐 **정적 멤버**라고 한다.\n\n인스턴스 변수는 하나의 클래스로부터 생성되었더라고 각자 다른 값을 유지하지만, **static 멤버 변수(클래스변수)는 인스턴스에 관계없이 같은 값을 가진다.** static 멤버는 인스턴스에 소속된 멤버가 아니라 **클래스에 고정된 멤버**이기 때문이다. 그래서 클래스로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할때 클래스 별로 관리된다. \n\n\n<br><br><Br><br>\n## ✅ Static 멤버 메모리 영역\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/static3.png?raw=true\">\n</p>\n\nStatic 키워드를 통해 생성된 정적멤버들은 Heap영역이 아닌 Static영역에 할당된다. **Static 영역에 할당된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점**을 가지지만 **Garbage Collector의 관리 영역 밖에 존재하기에 Static영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 존재**하게 된다. 그렇기에 Static을 너무 남발하게 되면 만들고자 하는 시스템 성능에 악영향을 줄 수 있다.\n\n<br><br><Br><br>\n## ✅ Static 메서드와 인스턴스 메서드\n일반적으로 메서드 앞에 static이 붙어있으면 클래스 메서드 (static 메서드)이고 붙어있지 않으면 인스턴스 메서드로 정의한다. 클래스 메서드는 앞서 언급한것처럼 static 메모리 영역에 저장되기 때문에 **객체를 생성하지 않고도 `클래스이름.메서드이름(매개변수)` 와 같은 형태로 호출이 가능하다.**  반면에 **인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있다.**\n\n<br>\n\n```java\nclass Calculator {\n  long a,b;\n\n  // 인스턴스 변수 a,b를 사용하기 때문에 매개변수가 필요없다\n  long add() { return a+b; }  // a,b는 인스턴스 변수\n  long sub() { return a-b; }\n  long multi() { return a*b; }\n  double div() { return a/b; }\n\n  // 인스턴스 변수와 관계없이 매개변수만으로 작업 가능하다\n  static long add(long a, long b) { return a+b; }  // a,b는 지역변수\n  static long long sub(long a, long b) { return a-b; }\n  static long multi(long a, long b) { return a*b; }\n  static double div(long a, long b) { return a/(double)b; }\n}\n\n\nclass Main {\n  public static void main(String args[]){\n    // 클래스 메서드 호출. 인스턴스 생성없이 호출 가능\n    System.out.println(Calculator.add(200L,100L);\n    System.out.println(Calculator.sub(200L,100L);\n    System.out.println(Calculator.multi(200L,100L);\n    System.out.println(Calculator.div(200L,100L);\n\n    Calculator cal = new Calculator(); // 인스턴스 생성\n    cal.a = 200L;\n    cal.b = 200L;\n\t\n\t// 인스턴스 메서드는 객체생성후에 호출 가능\n    System.out.println(mm.add());\n    System.out.println(mm.sub());\n    System.out.println(mm.multi());\n    System.out.println(mm.div());\n  }\n}\n```\n\n<br>\n\n인스턴스 메서드인 `add(), sub(), multi(), div()` 는 인스턴스 변수인 a,b로 충분히 작업이 가능하기 때문에 굳이 매개변수를 선언하지 않았다. \n\n반면에 클래스 메서드인 add(long a, long b), sub(long a, long b)등은 인스턴스 변수 없이 매개변수만으로 작업을 수행하기 때문에 static 메서드를 붙여 클래스 메서드로 선언하였다.\n\n그래서 main에서 클래스메서드는 객체호출없이 바로 사용했지만, 인스턴스 메서드는 객체호출을 한뒤 사용한걸 볼 수 있다.\n\n\n<br><br><Br><br>\n## ✅ static을 언제 붙여야 할까?\n\n1. **클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.**\n\t생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스 변수로 정의해야 한다.\n\n2. **클래스 변수(Static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.**\n\tstatic이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.\n\n3.  **클래스 메서드(Static메서드)는 인스턴스 변수를 사용할 수 없다.**\n\t인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 생성없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그래서 클래스 메서드에서 인스턴스 변수의 사용을 금지한다.\n\t반면에 인스턴스 변수나 인스턴스 메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.\n\n4. **메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.**\n\t메서드의 작업내용 중에서 인스턴스 변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스 변수를 필요로 하지 않는다면 static을 붙이자. 메서드 호출시간이 짧아지므로 성능이 향상된다. static을 안붙인 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-1443243072,"tx":52128},"omFvrSXYtukeVixH/contentState":{"id":"omFvrSXYtukeVixH/contentState","type":"contentState","selectionStart":75,"selectionEnd":75,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717981719751,"tx":52129},"hsMOxKWCChERUD8N/contentState":{"id":"hsMOxKWCChERUD8N/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717981720573,"tx":52130},"C8kg3so81QVoun72/contentState":{"id":"C8kg3so81QVoun72/contentState","type":"contentState","selectionStart":75,"selectionEnd":75,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717981723030,"tx":52132},"w6ADipsYQPt3OgNW/contentState":{"id":"w6ADipsYQPt3OgNW/contentState","type":"contentState","selectionStart":376,"selectionEnd":376,"scrollPosition":{"sectionIdx":4,"posInSection":0.1},"hash":1717981861428,"tx":52135},"ZrlBGkPkFqYFyKak/contentState":{"id":"ZrlBGkPkFqYFyKak/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717982179882,"tx":52195},"08K40WXSblJ4yn74/contentState":{"id":"08K40WXSblJ4yn74/contentState","type":"contentState","selectionStart":1678,"selectionEnd":1642,"scrollPosition":{"sectionIdx":47,"posInSection":0.26666666666666666},"hash":1717986182322,"tx":52961},"9MtDBGhyQQWuisRx/contentState":{"id":"9MtDBGhyQQWuisRx/contentState","type":"contentState","selectionStart":239,"selectionEnd":239,"scrollPosition":{"sectionIdx":55,"posInSection":0.996309963099631},"hash":1717986185871,"tx":52963},"7LHwr5vMhDvsF6qJ/contentState":{"id":"7LHwr5vMhDvsF6qJ/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1717992923714,"tx":53549},"fazmhohPrMfu2qvK/content":{"id":"fazmhohPrMfu2qvK/content","type":"content","text":"---\npermalink: /aws-ec2-computing/\ntitle: \"[AWS] AWS EC2(Amazon Elastic Compute Cloud)란?\"\ndate: 2023-05-19 14:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"AWS 컴퓨팅 서비스 EC2\"\ncategories:\n- AWS\ntags:\n- 카카오 클라우드 스쿨\n- AWS\n- EC2\n---\n<br><br>\n\n\n## ✅ AWS EC2(Elastic Compute Cloud)란?\n\nEC2는 AWS에서 제공하는 **클라우드 컴퓨팅 서비스** 이다. EC2를 통해서 아마존이 전 세계에 구축한 데이터 센터의 서버용 컴퓨터들의 자원을 원격으로 사용할 수 있다. 쉽게 말해 아마존으로부터 한대의 컴퓨터를 빌리는 것이다.\n\n물론, 가정용 컴퓨터와 EC2는 중요한 차이가 존재한다. EC2는 생성 요청시 바로 생성되고 삭제 역시 즉시 제거된다. 또한 초기 구입비, 세팅비가 전혀 없고 사용한 만큼 비용을 지불하면 된다. \n\n또한 복잡한 공유기 세팅없이 인터넷을 통해서 자유롭게 접속 할 수 있고, AMI 기능을 사용해서 OS 및 기타 SW 세팅을 편리하게 할 수 있다.\n\n그리고 원하는 만큼의 가상 서버를 구축하고 보안 및 네트워킹을 구성하며 스토리지를 관리할 수 있으며 추가 요구사항이나 갑작스러운 트래픽 증가 등 변동 사항에 따라 신속하게 규모를 확장하거나 축소 할 수 있어 서버 트래픽 예측 필요성이 줄어든다는 장점이 있다.\n\n실제 컴퓨터는 OS세팅, SW설치, 하드웨어 설치, 초기비용 등 여러가지 준비해야 할 것들이 많지만 EC2는 이런 모든 세팅을 편리하게 도와주기 때문에 굉장히 편리하다.\n\n\n<br><br>\n\n### 📌 EC2 특징 요약\n<hr>\n\nEC2의 특징을 요약 정리하자면 다음과 같다.\n\n- 컴퓨팅 요구사항의 변화에 따라 컴퓨팅 파워를 조정할 수 있다.\n\n- 실제로 사용한 용량 만큼만 지불한다 ( HW비용x, 선입금x )\n\n- AMI를 통해 Linux, Windows 중 OS 선택이 쉽게 가능하다.\n\n- 빠르게 많은 PC를 생성 할 수 있다.\n\n- 여러 다른 AWS 서비스와의 유기적인 연동이 가능하다. \n\n\n<br><br><br><br><br><br>\n\n## ✅ EC2의 구성요소\n\n<br><br>\n\n### 📌 인스턴스\n<hr>\n\nAWS 클라우드에서 사용하는 **가상 컴퓨터** 라고 이해하면 된다.\n\n가상 컴퓨터의 CPU, 메모리, 그래픽 카드 등 연산을 위한 하드웨어 부분을 담당한다.\n\n내가 어떤 용도로 EC2를 사용하고자 하는지에 따라 적합한 인스턴스를 선택하면 된다. 이를 인스턴스 유형(타입) 이라고 한다.\n\n\n\n<br><br>\n\n### 📌 인스턴스 유형\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec25.png?raw=true\">\n</p>\n\n\n한정된 요금으로 EC2 인스턴스의 유형을 고르고 사이즈를 골라 인스턴스 별 사용 목적에 따라 최적화를 시키기 위해 적절한 인스턴스 유형을 선택하면 된다.\n\n예를들어 CPU에 힘을 실어 연산능력이 좋은 서버를 만든다던지, 메모리 위주에 힘을 실어 저장소로서 기능을 구성한다던지, 그래픽 카드에 힘을 실어 게임을 돌린다던지 등 다양하게 구성이 가능하다.\n\n\n<br><br>\n\n### 📌 인스턴스 명명규칙\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec22.png?raw=true\">\n</p>\n\n인스턴스 타입이 어떤게 있고 사이즈는 뭐가 있고를 전부다 외울 필요는 없다. 다만 위 사진 처럼 인스턴스가 주어졌을 때 무슨무슨 의미인지만 알면 된다.\n\n- **인스턴스 타입** : 사용 목적 ( 서버용, 머신러닝용, 게임용 )에 따라 이름을 구분지어 사용한다.\n\n- **세대** : 1세대, 2세대 ... 숫자가 높을 수록 최신 버전이라고 보면 된다.\n\n- **접두사** : a는 amd기반의 CPU 프로세서를 사용한다는 의미이다.\n\n- **사이즈** : nano, micro, small, medium, large, xlarge, 2xlarge 로 구성되고 사이즈가 클수록 더 많은 메모리, 더 많은 CPU, 더 많은 네트워크 대역폭을 가질 수 있다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec23.png?raw=true\"> </p>\n\n\n<br><br>\n\n### 📌 AMI ( Amazon Machine Image )\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec26.png?raw=true\">\n</p>\n\n인스턴스를 시작하는데 필요한 소프트웨어 구성 ( OS, 애플리케이션 서버 및 애플리케이션 ) 이 포함된 템플릿이다.\n\nEC2를 실행하기 위해서는 CPU 프로세서 타입이라던지 저장공간 용량은 몇인지, 32비트인지 64비트인지, OS는 윈도우인지 리눅스인지, 소프트웨어는 어떤게 설치되었는지 등의 정보가 필요한데 이러한 세팅정보를 템플릿단위로 저장한 것을 AMI라고 한다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec24.png?raw=true\">\n</p>\n\n<br><br>\n\n### 📌 기타 구성요소\n<hr>\n\n- **키 페어(선택)** : 인스턴스 로그인 정보를 보호한다. (AWS는 공개키를 저장하고, 사용자는 개인키를 안전한 장소에 보관하는 방식)\n\n- **Elastic Block Store(EBS)** : HDD, SSD 같은 하드디스크 용량이라고 보면 된다.\n\n- **리전 및 가용영역**\n\n- **태그** : key-value로 태그를 달아준다. 일반적으로 기업에서 보통 수백개의 ec2를 사용하는데, 부서별, 사용자별로 사용 EC2가 굉장히 많다. 이런 EC2들을 효과적으로 관리하기 위해 태그를 반드시 달아줘야 한다. 이를 통해 같은 태그가 달린 EC2들을 일괄적으로 관리하는데 예를들면 test태그가 붙은 ec2는 전부 사용종료해라 혹은 temp태그가 붙은 ec2는 전부 실행해라 이런식으로 관리에 용이하다.\n\n- **사용자 데이터 (User Data)** : EC2 인스턴스가 start 되자 마자 실행할 스크립트 \n\n- **배치그룹** : 인스턴스를 시작할 클러스터 그룹이다. 일부 인스턴스 유형에서만 지원되며, 호환되지 않는 인스턴스 유형을 지정하면 인스턴스를 시작하는 데 실패합니다.\n\n- **네트워크 설정** : VPC, subnet, 보안그룹 등\n\n\n<br><br>\n\n### 📌 EC2 인스턴스 스토어\n<hr>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec28.png?raw=true\">\n</p>\n\n<br>\n인스턴스 스토어는 인스턴스에 블록 수준의 임시 스토리지를 제공한다. 스토리지가 물리적으로 연결된 디스크라면 인스턴스 스토어는 버퍼, 캐시 등 자주 변경되는 정보의 임시 저장소라고 보면 된다. \n\n인스턴스 실행시 인스턴스 스토어 볼륨을 지정할 수 있고 하나의 인스턴스에서 인스턴스 스토어를 분리해서 다른 인스턴스에 연결하는것은 불가능하다.\n\n인스턴스가 재부팅(의도적이든 의도적이지 않든)되어도 인스턴스 스토어의 데이터는 유지되지만 일부 상황에서는 데이터가 손실 된다.\n- 인스턴스 중지\n- 인스턴스 종료\n- 인스턴스 최대 절전 모드 전환\n- 기본 디스크 드라이브 오류\n\n때문에 중요한 장기 데이터는 인스턴스 스토어에 저장하지 않는것이 좋다.\n\n\n<br><br>\n\n### 📌 EC2 인스턴스 생명주기\n<hr>\n\nAmazon EC2 인스턴스는 시작한 순간부터 종료될 때까지 다양한 상태로 전환된다. 아래 그림은 인스턴스 상태 간 전환을 나타낸다. \n \n <p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ec21.png?raw=true\">\n</p>\n\n\n\n| 인스턴스 상태 | 설명 |\t인스턴스 사용 요금|\n|--|--|--|\n| pending | 인스턴스는 running 상태로 될 준비를 하고있습니다. 인스턴스는 시작되거나 stopped 상태 이후에 시작되면 pending 상태로 들어갑니다. | 미청구 |\n| running | 인스턴스를 실행하고 사용할 준비가 되었습니다. | 청구 |\n| stopping | 인스턴스를 중지할 준비를 하고 있습니다. | 미청구 |\n| stopped | 인스턴스가 종료되고 사용이 불가합니다. 언제든지 인스턴스를 다시 시작할 수 있습니다. | 미청구 |\n| shutting-down | 인스턴스가 종료할 준비를 하고 있습니다. | 미청구|\n| terminated | 인스턴스가 영구적으로 삭제되었으며 시작할 수 없습니다.| 미청구 |\n\n\n<br><br><br><br>\n\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1258253301,"tx":54218},"6d0K7UYUnaJHcUwH/content":{"id":"6d0K7UYUnaJHcUwH/content","type":"content","text":"---\npermalink: /aws-storage-service/\ntitle: \"[AWS] AWS 스토리지 서비스 - S3 ( Simple Storage Service )\"\ndate: 2023-05-19 15:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"AWS 스토리지 서비스 - S3 ( Simple Storage Service )\"\ncategories:\n- AWS\ntags:\n- 카카오 클라우드 스쿨\n- AWS\n- S3\n---\n<br><br>\n\n\n\n## ✅ AWS 스토리지 종류\n\n### 📌 스토리지 종류\n<hr>\n\nAWS에서 제공하는 스토리지 서비스는 5가지이다. \n\n- Amazon EBS ( Elastic Block Storage )\n- Amazon EFS ( Elastic File System )\n- Amazon S3 ( Simple Storage Service )\n- Amazon S3 Galcier\n- AWS Storage Gateway\n\n오늘은 이런 스토리지 서비스중 가장 많이 쓰이는 S3에 대해 알아보도록 하겠다.\n\n그전에 전통적 스토리지에 대한 종류와 특징을 간단하게 알아보고 넘어가자.\n\n<br><Br>\n\n### 📌 전통적 스토리지\n<hr>\n\n1. **블록 스토리지 ( Block Storage )**\n\n\t데이터를 블록 단위로 관리하는 스토리지이다. **데이터베이스처럼 빈번히 갱신되거나, 고속의 액세스가 필요할 때 사용된다.** 일부 파일 내용 변경시에 해당 block만 갱신이 가능하다. 쉽게 예를 들면 엑셀에서 블록 하나 수정하는것과 유사하다. 계층 구조를 가지고, 계층구조는 `/doc/storage/a.txt` 이런식으로 구조를 갖는것을 말한다. AWS 스토리지 서비스 중에서는 **EBS(Elastic Block Storage), 인스턴스 스토어**가 해당한다.\n\n<br>\n\n \n2. **파일 스토리지 ( File Storage )**\n\n\t블록 스토리지 위에 파일 시스템을 구성해서 파일 단위로 관리하는 스토리지이다. **복수의 클라이언트로 부터 네트워크를 경유하여 파일에 접근 하거나, 데이터를 일괄 저장하는 용도로 많이 쓰인다.** 파일 단위로 관리하기 때문에 일부 파일 내용 변경시 전체 파일이 갱신된다. 예를 들면 구글드라이브에 올라가져 있는 파일을 일부 수정하면 파일 자체를 다시 업로드 해야하는 것과 유사하다. 블록 스토리지와 마찬가지로 계층구조를 가진다. AWS 스토리지 서비스 중에서는 **EFS ( Elastic File Storage ), FSx**가 해당한다.\n\n<br>\n\n\n3. **오브젝트 스토리지 ( Object Storage )**\n\n\t**파일에 임의의 메타데이터를 추가하여 오브젝트 단위로 관리하는 스토리지이다.** **HTTP 프로토콜**을 사용하여 데이터를 추가, 삭제할 수 있다. **갱신 빈도가 적은 데이터나 대용량 멀티미디어 컨텐츠를 보관하는 용도**로 사용된다. 앞선 두 스토리지와는 다르게 계층 구조가 없는 **flat한 구조**를 가진다. `doc/storage/a.txt`, `doc/storage/b.txt`처럼 폴더를 만들어 보관할 수는 있지만, 실제 데이터는 `a.txt`와 `b.txt`가 같이 존재하지 않고 폴더정보는 그저 파일의 접두어일 뿐, 단일 저장소에 보관된다. 기존의 계층구조는 메타데이터가 굉장히 많이 쌓여 효율적이지 못하므로 이를 최소화 하기위해 이런 구조를 가진다. AWS 스토리지 서비스 중에서는 **S3**가 해당한다.\n\n<br><br><Br><Br><br><Br>\n\n## ✅ Amazon S3 ( Simple Storage Service )\n\n**매우 우수한 내구성을 가진 용량 무제한의 오브젝트 스토리지 서비스**이다. 오브젝트 스토리지 이기때문에 디렉토리 구조를 가지지 않는 **플랫한 구성**과, 유저가 독자적으로 **메타 데이터를 부여**할 수 있다.\n\nS3의 각 오브젝트에는 **REST나 SOAP같은 HTTP API를 통한 액세스가 가능**하다 ( 최신 Amazon S3 기능은 SOAP를 더이상 지원하지 않는다 ). 유연성이 매우 강한 서비스이기 때문에 아이디어만 있다면 수만가지의 방법으로 사용할 수 있고, AWS 중에서도 매우 중요한 서비스로서의 위치를 가지고 있다. S3가 포함되지 않은 AWS 서비스를 찾아보기가 힘들정도로 많이 사용된다.\n\n- 데이터 백업\n- 정적 웹 컨텐츠와 미디어 저장 및 배포\n- 전체 정적 웹 사이트 호스팅 ( HTML, Image, 동영상 등 )\n- 간략한 Key-Value 형식의 데이터 베이스\n- Auto Scaling 구성의 EC2 인스턴스나 컨테이너로 부터의 로그 전송\n- 연산 및 대규모 분석용 데이터 스토어\n\n\n<br><Br>\n\n### 📌 Amazon S3의 구성요소\n<hr>\n\n- **버킷** : 오브젝트를 저장하기 위한 영역이다. 버킷이름은 고유해야 한다. S3 버킷에 policy(정책)을 추가하여 다른 AWS 계정 또는 사용자에게 액세스하도록 허용할 수 있다.\n\n- **오브젝트** : 버킷내에 저장될 데이터를 말한다. 각 오브젝트는 키가 부여되고, [버킷명 + 키명 + 버전 ID ]로 유니크한 URL이 만들어 진다. 버킷내에 저장되는 오브젝트 수는 제한이 없지만, 하나의 오브젝트 사이즈는 최대 5TB이다.\n\n- **메타 데이터** : S3는 오브젝트 스토리지이므로 메타 데이터를 가진다. 오브젝트를 관리하기 위한 정보이고, 오브젝트 작성 일시나 사이즈 등의 메타 데이터 뿐만 아니라 유저가 정의한 메타 데이터를 가질 수도 있다.\n\n\n<br><Br>\n\n### 📌 Amazon S3의 스토리지 클래스\n<hr>\n\n데이터의 복원력, 액세스, 및 비용에 따라 선택할 수 있는 다양한 스토리지 클래스가 있다. 종류에 대해 간단하게 알아보자.\n\n- **Amazon S3 Standard**\n\t가장 범용적인 클래스. 즉시 액세스 할 수 있어야 하고, 자주 요청되는 데이터를 다룬다.\n\n- **Amazon S3 Standard - Infrequent Access**\n\t표준 데이터와 마찬가지로 즉시 액세스 할 수 있어야 하지만 자주 요청되지 않을 것으로 예상되는 데이터를 저장한다. 저장된 GB당 비용은 저렴하지만, HTTP API 요청당 비용이 높다.\n\n- **Amazon S3 One Zone - Infrequent Access**\n\t최소 3개의 AZ(가용영역)에 데이터를 저장하는 다른 스토리지 클래스와는 달리 단일 AZ에 데이터를 저장한다. 때문에 S3 Standard -IA 보다 20%정도 저렴하다.\n\n- **Amazon S3 Glacier**\n\t거의 참조되지 않는 아카이브 목적의 데이터를 저장하는 스토리지 클래스이다. 오브젝트 신규 작성시에는 이 클래스를 사용할 수 없고, 이후에  라이프 사이클 관리 기능을 사용하여 S3 Glacier를 사용하는것이 가능하다. 이 클래스에 저장된 데이터에 엑세스 하는 경우 사전에 액세스 Request를 해둘 필요가 있고, 액세스를 가능하도록 하는데 수시간이 걸린다. 데이터를 불러오는데에는 몇분~수시간이 걸린다.\n\n- **Amazon S3 - Intelligent - Tiering**\n\t성능에 대한 영향, 검색 요금 또는 운영 부담 없이 액세스 빈도에 따라 가장 비용 효율적인 액세스 티어로 데이터를 자동으로 이동하여 세분화된 객체 수준에서 스토리지 비용을 자동으로 절감해주는 최초의 클라우드 스토리지이다. S3 Intelligent-Tiering은 Frequent, Infrequent Access 및 Archive Instant Access 티어에서 자주 액세스하는 데이터, 자주 액세스하지 않는 데이터, 그리고 거의 액세스하지 않는 데이터에 대해 밀리초 단위의 대기 시간과 높은 처리량을 제공한다. 거의 모든 워크로드, 특히 데이터 레이크, 데이터 분석, 새로운 애플리케이션 및 사용자 생성 콘텐츠에 대한 기본 스토리지 클래스로 S3 Intelligent-Tiering을 사용할 수 있습니다.\n\n- **Amazon S3 스토리지 클래스 분석**\n\t스토리지 액세스 패턴을 분석해 데이터를 적절한 스토리지 클래스로 옮길 시점을 알려준다. 예를 들면 자주 액세스 하지 않는 Standard 스토리지를 Standard-IA 스토리지 클래스로 옮길 시점을 알려준다. 단, Standard 스토리지와 Standard-IA 클래스에 대한 분석만 제공한다.\n\n\n\n<br><Br>\n\n### 📌 Amazon S3의 수명 주기 관리\n<hr>\n\n수명 주기 동안 객체가 비용 효율적으로 저장되도록 관리하기 위해 Amazon S3의 수명 주기를 구성한다. 크게 두 가지 유형의 작업으로 나뉜다.\n\n- 전환 작업\n\n\t객체가 다른 스토리지 클래스로 전환되는 시기를 정의한다. 예를 들어 생성 후 30일이 지난 객체는 S3 Standard-IA 스토리지 클래스로 전환하거나, 생성 후 1년이 지난 객체는 S3 Glacier Flexible Retrieval 스토리지 클래스로 전환하는 경우가 있다.\n\n- 만료 작업\n\n\t객체가 만료되는 시기를 정의한다. 만료 시기 이후에는 Amazon S3에서 자동으로 객체를 삭제한다.\n\n\n공부하거나 프로젝트를 제작할 때 수명 주기 정책을 함께 사용해보면 좋을 것 같다.\n","properties":"\n","discussions":{},"comments":{},"hash":-749999736,"tx":54316},"QfcCQHZlB9I2iOQ0/content":{"id":"QfcCQHZlB9I2iOQ0/content","type":"content","text":"---\npermalink: /aws-global-infra-architecture/\ntitle: \"[AWS] AWS 글로벌 인프라 구성 (Region/ AZ / Edge Location)\"\ndate: 2023-05-19 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"AWS 글로벌 인프라 구성\"\ncategories:\n- AWS\ntags:\n- 카카오 클라우드 스쿨\n- AWS\n---\n<br><br>\n\n## ✅ AWS 기본 용어 정리\n\n\nAWS 글로벌 인프라는 **리전(Region), 가용영역(AZ, Availability Zones), 엣지 로케이션(Edge Location), 리전 엣지 캐시(Regional Edge Cache)** 네가지 요소로 구성 되어 있다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws1.png?raw=true\">\n</p>\n\n<Br>\n\nAWS를 입문하는데 가장 기초적인 내용이며, 가장 핵심적인 구조 이다.\n\n각 용어에 대해 완벽히 숙지를 해야, 이 다음에 이어질 VPC구성이나 이외의 클라우드 구축을 하는데 이해를 하고 수월하게 할 수 있다.\n\n<br>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws-term-3.png?raw=true\">\n</p>\n\n<br><br><Br><br><br><Br>\n\n## ✅리전 ( Region )\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws-term-4.jpg?raw=true\">\n</p>\n\nAWS가 전 세계에서 데이터 센터를 클러스터링 하는 서버의 물리적 국가/도시단위의 위치를 리전(Region)이라고 한다. AWS 리전은 지리적 영역 내에서 격리되고 물리적으로 분리된 최소 3개의 AZ(가용영역)로 구성된다. 현재는 31개 리전이 존재하는데 AWS에서 리전을 계속 추가하고 있기 때문에 리전의 개수는 계속 변동될 것이다. 아프리카, 아시아 태평양, 유럽, 중동, 미국 등 다양한 리전이 존재하고, 우리나라에서 서비스를 운영할 목적이면 ap-northeast-2 리전을 주로 사용한다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws-term-2.png?raw=true\">\n</p>\n\n<br><br>\n\n### 📌 리전 선택 고려사항\n<hr>\n\n사용자가 적절한 리전을 선택 해야할 때 고려해야 할 사항은 4가지 정도가 있다. \n\n1. **가격(Pricing)** : 리전에 따라 제공하는 서비스의 가격이 다르다.\n2. **지연시간(Latency)** : 사용자의 지리적 위치와 리전의 위치에 따라 지연시간이 다르다. \n3. **서비스 유무** : 모든 리전에서 AWS의 모든 서비스를 제공하지는 않는다. 일부 리전에 따라 제공하지 않는 서비스가 존재할 수 있다.\n4. **법 규제** : 가장 중요한 고려사항이다. 예를 들어 중국 국민들의 개인정보가 담긴 데이터를 AWS에 저장하고자 한다. 그런데 중국에는 자국민의 개인정보는 반드시 자국내의 데이터센터에 존재해야 한다는 법 규제가 있다고 가정하자. 그렇다면 AWS 리전은 중국에 위치한 리전을 사용해야만 하는 상황이 발생한다.\n\n<br><br><Br><br><br><Br>\n\n## ✅가용 영역 ( Available Zone )\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws-term-1.png?raw=true\">\n</p>\n\n리전이 국가/도시 단위의 지리적 위치에 따라 구분된 것이라면, 가용영역(AZ)은 각 리전 안의 데이터센터 이다. AWS의 서비스는 매우 높은 가용성 목표에 따라 구축된다. 따라서 장애가 발생할 경우에도 복원력을 유지하도록 시스템이 설계되어있다. 이를 위해 설계된 기능이 가용영역이다. \n\n가용 영역은 **논리적으로 격리된 AWS 리전의 섹션이다.** 각 리전에는 독립적으로 운영되도록 설계된 여러 개의 가용영역이 있고 이를 통해 일부 애플리케이션이 장애가 발생하더라도 중단 없이 신속하게 장애를 조치할 수 있다. **각 리전마다 일반적으로 3개, 최소 3개, 최대 6개의 AZ를 가진다.**\n\n예를들어 ap-southeast-2 리전에는 ap-southeast-2a, ap-southeast-2b, ap-southeast-2c AZ가 존재한다.\n\n모든 AZ는 서로 100km 이내의 거리에 위치해 있어야 한다.\n\n각 데이터 센터는 광통신 전용망(고속 프라이빗 네트워크)로 연결 되어있는데 서로간 너무 멀리 떨어져 있느면 속도면에서 감점이 될 수 있기 때문이다.\n\n\n<br><br><br><br><br><br>\n\n## ✅엣지 로케이션 ( Edge Location )\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws-term-5.png?raw=true\">\n</p>\n\n엣지 로케이션(Edge Location)은 AWS에서 제공하는 글로벌 콘텐츠 배포 네트워크(Content Delivery Network, CDN) 서비스인 Amazon CloudFront와 관련된 중요한 구성 요소이다. \n\n엣지 로케이션은 aws의 cdn들의 여러 서비스들을 가장 빠른 속도로 제공(캐싱) 하기 위한 **거점**이다. Amazon의 CDN 서비스인 Amazon CloudFront를 위한 캐시 서버들의 모음이고, 콘텐츠(HTML, 이미지, 동영상, 기타 파일)를 사용자가 빠르게 받을 수 있도록 전세계 곳곳에 위치한 캐시 서버에 복제해주는 서비스이다.\n\n\n<p class=\"notice--info\">\nCloudFront란 AWS에서 제공하는 CDN 서비스를 의미한다.  <br><br>\n  \nCDN(Contents Delivery Network) 서비스는 콘텐츠를 보다 빠르게 전송하는 기술로, 속도 개선과 회선 비용 절감에 용이하다.  <br>\n최초 요청 시에는 서버로부터 콘텐츠를 가져와 고객에게 전송하며, 동시에 CDN 캐싱장비에 저장한다.  <br>\n이후에는 CDN 캐싱 장비에 저장된 콘텐츠를 바로 전송하는 방식이다.   <br>\nCDN 업체에서 지정하는 컨텐츠 만료 지점까지 호출이 없으면 주기적으로 삭제한다.  <br><br>\n   \nCloud Front는 EC2나 S3 같은 서비스에서 사용할 경우, 가장 가까운 엣지로 라우팅되어 콘텐츠 전송 속도를 향상할 수 있다.  <br>\n이를 통해 데이터, 동영상, 애플리케이션 및 API까지 전송 가능하다.  <br>\n- Static 캐싱 = 운영자가 콘텐츠를 미리 캐시 서버에 복사해서 요청 시 무조건 캐시 서버를 이용 가능  <br>\n- Dynamic 캐싱 = 운영자가 미리 복사하지 않아 콘텐츠가 없을 때 Origin 서버로부터 다운받아 전달하는 방식 <br>\n\n</p>\n\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":-365762171,"tx":54370},"WJFVWbFTBiUUqpiQ/content":{"id":"WJFVWbFTBiUUqpiQ/content","type":"content","text":"---\npermalink: /aws-account-setting/\ntitle: \"[AWS] AWS 루트 계정 설정 (Access Key / MFA) \"\ndate: 2023-05-19 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"AWS 계정 설정 ( Access Key / MFA )\"\ncategories:\n- AWS\ntags:\n- 카카오 클라우드 스쿨\n- AWS\n---\n<br><br>\n\n## ✅ AWS 계정 루트 사용자\n\nAWS 계정을 처음 생성한다면 계정의 모든 AWS 서비스 및 리소스에 대한 전체 엑세스 권한을 지닌 **루트 사용자(Root User)**를 가지게 된다. 루트 사용자는 AWS 계정 내의 모든 리소스와 서비스에 대한 최대 권한을 지니고 있기 때문에 이 계정을 사용하면 모든 읽기, 쓰기. 삭제 작업을 수행할 수 있다. 따라서, 루투 계정이 노출되면 계정 전체가 위험해 질 수 있다.\n\n때문에 AWS에서는 루트 사용자를 거의 사용하지 않을 것을 강력히 권장하고 있다. AWS를 처음 접하는 사람이라면 아마 대부분 루트 계정을 통해 프리티어 EC2를 생성해보거나 S3를 만들어보는 등 간단한 실습을 진행해 볼텐데, 이때가 사실 가장 위험하다. 아무런 정보 없이 그저 구글에 나와있는 실습을 따라서 진행하다가 제대로 된 보안규칙 없이 혹은 루트 사용자에 접근할 수 있는 Access Key를 노출하게 된다면 당신의 계정은 어느새 비트코인 채굴용 서버로 이용되고 있을지도 모른다. \n\n그래서 AWS를 좀 쓸 줄 안다 하는 사람들과 초보자들을 가장 먼저 구별할 수 있는 대표적인 방법이 바로 루트 계정에 대한 보안작업을 수행해주느냐 안해주느냐 라고 볼 수도 있다. 오늘은 루트 계정에 대한 두가지 보안작업인 **AWS 액세스 키(Access Key) 비활성화 및 삭제**, 그리고 **MFA 활성화** 두가지 작업을 알아보도록 하겠다.\n\n\n<br><br><br><br><br><br>\n\n## ✅ AWS 루트 사용자 Access Key 비활성화 및 삭제\n\n\n### 📌 Access Key란?\n<hr>\n\nAWS의 액세스 키는 AWS 서비스에 접근하기 위해 사용되는 인증 정보라고 보면 된다. 크게 두 부분으로 구성된다.\n\n1. **액세스 키 ID** : 사용자나 프로그램이 AWS API 요청을 보낼 때 사용하는 공개 식별자\n2. **비밀 액세스 키** : 액세스 키 ID와 함께 사용되며 AWS 인증을 완료하는데 필요하다.\n\n \n\n\n\n\n<br><br>\n\n### 📌 Access Key 비활성화 방법\n<hr>\n\n\n1. Root user로 로그인 후 IAM 서비스 화면으로 이동한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws2.png?raw=true\">\n</p>\n\n<br><br><Br>\n\n2. 루트 사용자의 Access Key를 선택한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws3.png?raw=true\">\n</p>\n\n<br><Br><Br>\n\n3. 비활성화 버튼을 클릭한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws4.png?raw=true\">\n</p>\n\n<br><br><br>\n\n4. 비활성화 버튼을 한번 더 클릭한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws5.png?raw=true\">\n</p>\n\n<br><br><br>\n\n5. 삭제를 위해 키를 입력하고 삭제버튼을 클릭한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws6.png?raw=true\">\n</p>\n\n<br><br><br>\n\n6. 루트 사용자의 Access Key 삭제가 완료되면 다음과 같이 나온다. ( MFA 활성화도 이루어지고 난 후의 이미지)\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/aws7.png?raw=true\">\n</p>\n\n\n<br><br><br><br><br><br>\n\n\n## ✅ AWS 루트 사용자 MFA 활성화\n\n\n### 📌 MFA란?\n<hr>\n\nMFA(Multi-Factor Authentication, 다중 인증)는 사용자가 시스템에 접근할 때 두가지 이상의 인증을 요구하는 보안 프로세스이다. 쉽게 말해 1차,2차,3차.. 등의 비밀번호를 다중으로 설정한다고 생각하면 된다.\n\nAWS에서는 MFA를 사용하여 보안을 강화할 수 있다. 여러 유형의 MFA가 있기 때문에 루트 사용자에 대해 최소 2개 이상의 MFA 디바이스를 활성화 하는 것이 보안상 좋다.\n\n이 포스팅에서는 루트 계정에 대해 MFA 설정하는 방법을 알아보도록 하겠다.\n\n<br><br>\n\n### 📌 루트 사용자 MFA 활성화\n<hr>\n\n1. 루트 유저로 로그인 후 IAM > Security credentials 로 이동한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mfa1.png?raw=true\">\n</p>\n\n<br><Br><Br>\n\n2. MFA 활성화를 할 디바이스를 선택한다. 여기서는 Authenticator app을 선택했다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mfa2.png?raw=true\">\n</p>\n\n<br><br><Br>\n\n3. 사용중인 스마트폰 기기의 OS 유형에 따라 Google Play Store 또는 Apple App Store에서 Google OTP 어플을 다운받아 설치한다.\n\n<br><br><br>\n\n4. 2번 Show QR code를 클릭하면 QR코드가 생성되는데 이를 Google OTP 앱으로 스캔하여 MFA 할당을 설정한다. Google OTP 앱에 표시되는 MFA 코드 2개 ( OTP하나 입력후, 기다리면 새로운 OTP 번호가 발급된다)를 각각 입력후 하단 MFA 할당을 클릭하면 설정이 완료된다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mfa3.png?raw=true\">\n</p>\n\n\n<br><br><br>\n\n","properties":"\n","discussions":{},"comments":{},"hash":-2030089552,"tx":54403},"QfcCQHZlB9I2iOQ0/contentState":{"id":"QfcCQHZlB9I2iOQ0/contentState","type":"contentState","selectionStart":3611,"selectionEnd":3611,"scrollPosition":{"sectionIdx":36,"posInSection":0.8791208791208791},"hash":1717997287276,"tx":54419},"D6AI3WmiULa0MQox/contentState":{"id":"D6AI3WmiULa0MQox/contentState","type":"contentState","selectionStart":111,"selectionEnd":111,"scrollPosition":{"sectionIdx":4,"posInSection":0.7050359712230215},"hash":1717997906941,"tx":54453},"localSettings":{"id":"localSettings","type":"data","data":{"welcomeFileHashes":{"1789794481":1},"filePropertiesTab":"simple","htmlExportTemplate":"styledHtml","pdfExportTemplate":"styledHtml","pandocExportFormat":"pdf","googleDriveRestrictedAccess":false,"googleDriveFolderId":"","googleDriveWorkspaceFolderId":"","googleDrivePublishFormat":"markdown","googleDrivePublishTemplate":"styledHtml","bloggerBlogUrl":"","bloggerPublishTemplate":"plainHtml","dropboxRestrictedAccess":false,"dropboxPublishTemplate":"styledHtml","githubRepoFullAccess":true,"githubRepoUrl":"","githubWorkspaceRepoUrl":"https://github.com/idkim97/stackEdit.git","githubPublishTemplate":"jekyllSite","gistIsPublic":false,"gistPublishTemplate":"plainText","gitlabServerUrl":"","gitlabApplicationId":"","gitlabProjectUrl":"","gitlabWorkspaceProjectUrl":"","gitlabPublishTemplate":"plainText","wordpressDomain":"","wordpressPublishTemplate":"plainHtml","zendeskSiteUrl":"","zendeskClientId":"","zendescPublishSectionId":"","zendescPublishLocale":"","zendeskPublishTemplate":"plainHtml","syncSub":"112840480486770494084","syncStartPageToken":"290022"},"hash":803156959,"tx":54479},"2YcBlgoRtPYITlYT/contentState":{"id":"2YcBlgoRtPYITlYT/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718066457280,"tx":54480},"1x2SS92trda8Dql0/content":{"id":"1x2SS92trda8Dql0/content","type":"content","text":"---\npublished: true\ntitle: \"[컴퓨터 구조] LEGv8의 ISA 명령어 종류와 특징\"\ndate: 2021-09-13 13:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"LEGv8의 ISA 명령어 종류와 특징\"\ncategories:\n- Computer Architecture\ntags:\n- Instruction\n- Instruction Set Architecture\n- ISA\n- LEGv8\n---\n\n<br><br><br>\n\n지난 포스팅에 이어 ISA에 대해 작성하겠다. 마이크로프로세서마다 기계어 코드의 길이와 숫자 코드가 다르기 때문에 그 양이 방대하므로 본 포스팅에서는 **ARMv8**의 ISA에 대해서 다루도록 하겠다.\n\n<br><br><br><br><br><br>\n\n## ✅ Arithmetic Operations ( 산술 연산 )\n\nadd와 sub, 그리고 3개의 operands(피연산자)가 존재한다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ari.jpg?raw=true\">\n</p>\noperands에는 두개의 source(b,c)와 한개의 destination(a)이 존재한다.\n\n모든 산술연산은 이러한 형태를 가지고있다.\n\n### Design Principle 1 : Simplicity favors regularity\n여기서 첫번째 하드웨어 설계원칙을 살펴볼 수 있다. 모든 명령어가 operand를 3개씩 갖도록 제한함으로써 하드웨어를 단순하게 할 수 있다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ari2.jpg?raw=true\">\n</p>\n\n위 그림에서 Arithmetic Operation의 산술 과정을 살펴보자.\n\n**C 코드 :** \n```c\nf = ( g + h ) - ( i + j )\n```\n컴퓨터는 위의 코드를 다음과 같이 처리한다.\n\nt0 라는 임의의 변수에 g + h 값을 저장하고 t1이라는 변수에 i + j를 저장한다.\n\n그후 sub operation은 t0 - t1을 수행해 결과를 출력한다.\n\n<br><br><br><br><br><br>\n\n## The Stored-Program Concept\n\n위의 산술 연산자 뿐만아니라 다른 연산자를 실행할때 컴퓨터가 데이터를 저장하는 방법에 대해 알아보자.\n\n> **Instructions와 Data는 Binary(2진법)으로 Main Memory에 저장된다.**\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ari3.jpg?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n본 노이만 컴퓨터 구조에서 반드시 알아둬야할 몇가지 note를 보자\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/ari4.jpg?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n## Register Operands\n**레지스터는 프로세서 내부적으로 관리하는 저장공간**으로, 데이터를 담을 수 있는 가장 기본적인 단위이다. 일반적으로 레지스터의 크기는 **32bit**이다.\n\n그러나 본 포스팅에서 다룰 LEGv8같은 경우는 32,64bit의 레지스터를 둘다 가지며\n\n**64-bit 데이터는 \"double word\" 라고 불리우며\n32-bit 데이터는 \"word\" 라고 불린다.**\n\n**이때 레지스터는 0~31로 번호가 매겨져 있음을 유의해야 한다.**\n\n<br><br><br><br><br><br>\n\n### Design Principle 2 : Smaller is Faster\nLEGv8에서 레지스터의 수는 32개로 제한 됐으며 이는 더 빠른 연산을 위함이다.\ncf ) 메인메모리는 수백만개의 저장공간을 가진다.\n\n<br><br><br><br><br><br>\n\nLEGv8에서 제공하는 레지스터의 역할은 다음과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/re1.jpg?raw=true\">\n</p>\n\n**X0 ~ X7 : Procedure arguments / results\nX9 ~ X15 : 임시적으로 값을 저장\nX19 ~ X27 : 레지스터 저장\nXZR ( = X31 ) : 절대상수 0을 항상 갖고있음**\n\n<br><br><br><br><br><br>\n\n레지스터 피연산자의 예시를 보자.\n\n**C코드 :**\n```c\nf = ( g + h ) - ( i + j )\n```\n\n이때 f, ... , j 는 X19, X20, X21, X22, X23 에 각각 저장된다.\n이를 LEGv8 내부에서 인식하는 코드로 살펴보면 다음과 같다.\n\n\n\n> **ADD X9, X20, X21** \n> **ADD X10, X22, X23** \n> **SUB X19, X9, X10**\n\n<BR><BR><BR><BR><BR><BR>\n\n## Register vs Main Memory\n\n레지스터는 32비트 혹은 64비트의 저장소를 32개 가지므로 128B / 256B 의 크기를 가진다.\n\n메모리는 훨씬 큰 데이터를 저장할 수 있다.\n\n레지스터는 CPU내에 존재하는데 더 빠른 데이터 처리를 위해 존재한다. CPU가 메모리에 접근할 때마다 **BUS를 통해 이동하는 시간 + 메모리 처리 시간**이 소요되는데 이를 절약하기 위해 레지스터에 필요한 데이터를 미리 저장해두고 필요할 때마다 메모리에 접근하지 않고 레지스터에서 데이터를 빼가는 구조이다.\n\n이런 구조속에서 메모리와 레지스터 간에 데이터를 전달하기 위해서 우리는 **data transfer instruction**가 반드시 필요하다. 이때 사용되는 명령어는 단 두개! **load와 store**가 있다.\n\n> **load : memory -> register** \n> **store : register -> memory**\n\n이때 load와 store를 하기 위해선 반드시 **Memory Operands(Address)**가 필요하다.\n\n<br><br><br><br><br><br>\n\n## Memory Operands\n\n - **보통 메모리는 혼합된 데이터 ( 배열, 구조체, 동적할당 등 )을 위해 사용된다.** \n - **Arithmetic Operation을 위해 Register Operand를 사용하려면,** \n - **가장 먼저 Memory의 데이터를 Register로 Load 해야한다.**\n - **그리고 Register에서 연산하고, 결과 값을 다시 Memory에 Store한다.** \n - **이런 구조를 Load - Store 구조라고 한다.**\n\n<br><br><br><br><br><br>\n\n## Memory Operand Example\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/mo1.jpg?raw=true\">\n</p>\n\n **1. h는 X21 레지스터에 저장되어 있고, 배열 A의 base address는 X22에 있다.\n 2. 먼저 A[8]을 가져오기 위해 Load 명령어를 실행한다.\n 3. A의 base address인 X22 레지스터부터\n 4. 배열의 8번째 값을 load하기 위해 8byte x 8번째 = 64의 byte offset을  X9라는 임시레지스터에서 Load한다.\n 5. X9에 저장된 A[8]과 X21에 저장된 h를 더해 X9에 다시 저장한다.\n 6. X9에 h + A[8]의 값인 A[12]를 Store 한다.**\n\n<br><br><br><br><br><br>\n\n## Immediate Operands\n우리가 상수를 더하고자 할때는 Instruction을 Load하는 과정을 거치지 않고 직접 더해버린다.\n\n**C코드 :** \n```c\nx = x + 4\n```\n이를 LEGv8에서는 다음과 같이 컴파일한다.\n\n> **ADDI X22, X22, #4**\n\n<br><br><br><br><br><br>\n\n### Design Principle 3 : Make the common case fast\n-> 작은 상수는 common에 해당한다.\n-> Immediate Operand는 불필요한 Load를 피한다!\n\n<br><br><br><br><br><br>\n\n## The Constant Zero\nLEGv8의 31번째 레지스터는 XZR, 즉 절대상수 0이다.\n이는 Common Operations에 굉장히 유용하다.\n\n**C코드 :** \n```c\ny = z\n```\n\n위와 같은 연산을 처리할때 또 다른 Instruction을 만들지말고 XZR을 활용할 수 있다.\n\n> **ADD X10, X11, XZR 또는 ORR X10, X11, XZR**\n\n","properties":"\n","discussions":{},"comments":{},"hash":910217373,"tx":54497},"tLqdQCgLBZOSaYBm/content":{"id":"tLqdQCgLBZOSaYBm/content","type":"content","text":"---\npublished: true\ntitle: \"[컴퓨터 구조] LEGv8의 ISA 명령어 종류와 특징 (2)\"\ndate: 2021-09-14 14:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"LEGv8의 ISA 명령어 종류와 특징\"\ncategories:\n- Computer Architecture\ntags:\n- Instruction\n- Instruction Set Architecture\n- ISA\n- LEGv8\n---\n\n<br><br><br>\n\n지난 포스팅에 이어 Instruction Set에 대해 작성해보겠다. 해당 포스팅은 가천대학교 소프트웨어학과 정용주 교수님의 강의를 기반으로 필요한 정보를 더 추가해 제작했음을 알립니다. \n\n<br><br><br><br><br><br>\n\n# Instruction Format ( 명령어 구조 )\n<hr>\nInstruction은 일정한 구조를 띈 채로 저장되는데 그 구조는 그림과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa1.png?raw=true\">\n</p>\n\n▪ LEGv8에서 Instruction (명령어)는 정확히 **32비트**의 크기를 가진다.\n▪ 각각의 segment는 **\"field\"**라고 부른다\n<br><br><br>\n명령어 구조는 우리가 보기 편하게 나타낸 것이고 실제로 컴퓨터가 받아드리는 것은 **binary number**로 인식한다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa2.png?raw=true\">\n</p>\n\n위와같이 numeric 하게 표현된 명령어를 **Machine Language (기계어)**라고 부른다.\n\n<br><br><br><br><br><br>\n\n# Types of Instructions\n<hr>\n\n명령어에는 일반적으로 3가지 종류가 있다.\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa3.png?raw=true\">\n</p>\n\n지금부터 각 명령어의 구조에 대해서 살펴보자.\n\n<br><br><br><br><br><br>\n\n## R-Format Instructions\n두개의 operand를 가지는 레지스터 2개와 연산 결과를 저장하는 레지스터 1개를 가리키는 명령어 구조이며, 일반적으로 **Arithmetic Operation**이나 **Logic Operation**에 사용된다. ( add, sub, mul, div, and, or 등 )\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa4.png?raw=true\">\n</p>\n\n▪ **Opcode** : 명령어의 종류를 나타낸다. ( Operation Code )\n\n▪ **Rm** : 두번째 오퍼랜드가 들어가는 레지스터의 주소를 담고있다. ( Source register )\n\n▪ **shamt** : 얼마나 쉬프트를 할지에 대한 정보를 담고있다. ( Shift amount )\n\n▪ **Rn** : 첫번째 오퍼랜드가 들어가는 레지스터의 주소를 담고있다. ( Target register )\n\n▪ **Rd** : 결과값이 담길 레지스터의 주소를 담고 있다. ( Destination register )\n\n<br><br><br>\n\n## R-Format Example\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa5.png?raw=true\">\n</p>\n\n▪ ADD X9, X20, X21 이라는 명령어가 주어졌을 때의 명령어 집합이다.\n\n▪ X9 = X20 + X21을 의미한다.\n\n▪ LEGv8에서 ADD의 opcode는 1112로 지정되어있다.\n\n▪ Rm에는 두번째 오퍼랜드인 X21의 레지스터 주소인 10101<sub>2</sub>(=21)을 담고있다.\n\n▪ shamt에는 따로 쉬프트 연산이 존재하지 않으므로 000000<sub>2</sub>을 담고있다.\n\n▪ Rn에는 첫번째 오퍼랜드인 X20의 레지스터 주소인 10100<sub>2</sub>(=20)을 담고있다.\n\n▪ Rd에는 결과값인 X9의 레지스터 주소인 01001<sub>2</sub>(=9)을 담고있다.\n\n▪ **이때 Rm, Rn, Rd는 5bit만 담을 수 있는데 그 이유는 LEGv8이 32개의 레지스터를 가지기 때문이다.**\n\n<br><br><br><br><br><br>\n\n## D-Format Instruction\nData Transfer를 하는 명령어 구조이다. **데이터를 가져오는 LDUR**과 **데이터를 저장하는 STUR 명령어**가 대표적이다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa6.png?raw=true\">\n</p>\n\n▪ **Opcode** : 명령어의 종류를 나타낸다. ( Operation Code )\n\n▪ **Address** : 저장될 데이터 Base register의 Offset ( 상대주소 ) 이 저장된다 \n\n▪ **Rn** : Base register의 주소를 담고있다.\n\n▪ **Rt** : Destination(Load) 또는 Source(Store)의 레지스터 주소를 담고있다.\n\n\n<br><br><br>\n\n## D-Format Example\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa7.png?raw=true\">\n</p>\n\n▪  LDUR : 어떤 데이터를 저장하겠다는 명령어이다.\n\n▪  X9가 Rt, 즉 결과값이 저장될 Destination이다.\n\n▪  [ X10 , #240 ] : X10 레지스터에 저장된 Base register의 240bit (= 30바이트) 짜리 크기가 240bit( = 30byte )인 데이터를 의미한다.\n\n<br><br><br><br><br><br>\n\n## I - Format Instruction\n\nImmediate Operation, Transfer(lw/sw 등), Branch 등을 위해 사용되는 Instruction Format이다. I-Foramt이 쓰이는 가장 중요한 이유는 레지스터가 아닌 메모리에 접근해서 무언가를 가져오거나, 상수를 반드시 써야할 때 사용된다. (레지스터가 아닌 오퍼랜드를 쓸때 I Format을 유용하게 사용한다)\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/isa8.png?raw=true\">\n</p>\n\n▪ 다른 format과 거의 비슷한 구조이므로 나머지는 생략하겠다.\n\n▪ **immediate** : 나타내고 싶은 상수의 값은 **byte offset**으로 표현한다.\n","properties":"\n","discussions":{},"comments":{},"hash":-516077178,"tx":54501},"tLqdQCgLBZOSaYBm/contentState":{"id":"tLqdQCgLBZOSaYBm/contentState","type":"contentState","selectionStart":378,"selectionEnd":378,"scrollPosition":{"sectionIdx":8,"posInSection":0.23333333333333334},"hash":1718071740807,"tx":54509},"Fhx75tVk2bMRrChl/content":{"id":"Fhx75tVk2bMRrChl/content","type":"content","text":"---\npermalink: /2022-08-22-아파치(Apache)와 톰캣(Tomcat)/\npublished: true\ntitle: \"[Web & Server] 아파치(Apache)와 톰캣(Tomcat) 그리고 웹서버와 WAS\"\ndate: 2022-08-22 18:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"아파치(Apache)와 톰캣(Tomcat) 그리고 웹서버와 WAS\"\ndescription: \"아파치(Apache)와 톰캣(Tomcat)의 차이점과 웹 서버(Web Server)와 WAS(Web Application Server)에 대해 알아보자.\"\ncategories:\n- Web & Server\ntags:\n- Apache\n- Tomcat\n- WAS\n- Web 서버\n- 개발상식\n- Server\n- Web\n\n---\n\n<br><br><br>\n\n오늘은 **아파치와 톰캣**이 무엇인지, 그 차이점은 뭐가있는지, 그리고 아파치가 속해있는 **Web 서버**와 톰캣이 속해있는 **WAS(Web Application Server)** 에 대해 알아보자.\n\n<br><br><br>\n\n## ✅ 아파치 톰캣 (Apache Tomcat)\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/apache1.png?raw=true\" alt=\"아파치 톰캣\">\n</p>\n스프링 뿐만 아니라 웹개발을 공부하는 사람이라면 **아파치 톰캣(Apache Tomcat)** 이라는 서버를 많이 들어봤을 것이다. 우리가 사용하는 많은 웹페이지는 아파치 톰캣을 서버로 사용하고, 세계에서 가장 많이 사용중인 WAS중 하나이다. \n\n**정적페이지를 처리하는 아파치(Web Server)** 와 **동적 페이지를 처리하는 톰캣 (WAS)** 이 합쳐진 구조로 각각의 기능을 일부 가져와서 제공하는 형태이기 때문에 합쳐서 부른다. **아파치, 톰캣**과 함께 **웹서버**와 **WAS**에 대해 알아보자.\n\n<br><br><br>\n\n## ✅ Web 서버\nWeb서버는 보통 **HTTP 서버**를 의미한다. HTTP 서버는 **URL(웹주소)** 및 **HTTP(프로토콜 주소)** 를 이해하는 소프트웨어 이다. HTTP 서버는 저장하는 웹 사이트의 **도메인 이름**을 통해 액세스 할 수 있으며 호스팅 된 웹 사이트의 콘텐츠를 사용자의 장치로 전달한다. \n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet2.png?raw=true\" alt=\"웹서버와 클라이언트 통신\">\n</p>\n\n브라우저에 Web 서버에서 호스팅되는 파일이 필요할 때마다 브라우저는 **HTTP**를 통해 파일을 요청한다. 요청이 올바른 Web 서버에 도달하면 HTTP서버가 요청을 수락하고 요청된 문서를 찾은 다음 HTTP를 통해 브라우저로 다시 보낸다. ( 이때, 요청된 문서를 찾지 못하면 우리가 많이 접해본 **'404 Not Found'** 를 반환한다! )\n\n<br><br>\n\n이러한 Web 서버는 **정적인 자료**를 처리하는 서버이다. **HTML, CSS, IMAGE** 등의 정적인 파일들을 **서버에 저장하고, 요청이 들어올때 마다 서버에 저장된 파일을 사용자에게 HTML파일로 뿌려주기 때문에** **서버 자원의 한계가 생기고 리소스를 많이 차지하게 되는 단점**이 있다! 이를 보완하기 위해 생긴 것이 바로 **동적으로 파일을 처리하는 WAS 서버** 이다..!\n\n<br><br>\n### 📌 Web 서버 예시\n- Apache 재단의 Apache\n- Microsoft사의 IIS, NGINX\n- Google Web Server\n- Node.js ( 자체 웹 서버 내장 )\n\n<br><br><br>\n\n## ✅ 아파치 (Apache)\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/apache2.png?raw=true\" alt=\"아파치\">\n</p>\n결국 **아파치 서버**는 클라이언트에서 요청한 **HTTP Request**를 처리하는 **웹서버** 이다. 아파치는 **정적 타입 (HTML, CSS, IMAGE)** 의 데이터만을 처리 한다!\n\n<br><br><br>\n\n\n\n## ✅ WAS (Web Application Server) 서버\nWAS 서버는 **동적인 자료**를 처리하는 서버이다. 기존 WEB서버는 정적 데이터만 처리가 가능하기때문에, 요청이 들어올때마다 HTML페이지, 이미지 등을 계속 응답해줘야 하고 이는 리소스의 낭비를 일으킨다. 때문에 이러한 단점을 커버하기 위해 WAS라는 서버를 만들었다. \n\n<BR>\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/servlet3.png?raw=true\" alt=\"was서버 통신과정\">\n</p>\n\nWAS는 **웹서버 + 서블릿 컨테이너 ( 웹 컨테이너 )** 로 구성되어 있다.  클라이언트에서 HTTP Request를 보내면 먼저 웹서버를 통해 정적데이터 처리만 필요한 요청인지 확인한다. 이후 정적 데이터 처리만 필요하다면 그대로 웹서버에서 요청에 대한 응답을 다시 클라이언트로 보내준다.\n\n그러나 동적데이터 처리가 필요한 요청이라면 이를 서블릿 컨테이너(웹컨테이너) 에 넘겨준다. 서블릿 컨테이너는 요청정보를 파악하여 실시간으로 페이지에 필요한 파일을 생성한다. 요청이 올 때마다 페이지에 필요한 정보를 그때그때 생성하므로 서버의 리소스의 부하를 줄일 수 있다는 장점이 있다.\n\n<br><br>\n### 📌 WAS 예시\n- Tomcat\n- JBoss\n- Jeus\n\n<br><br>\n\n## ✅ 톰캣(Tomcat)\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/tomcat1.png?raw=true\" alt=\"톰캣\">\n</p>\n톰캣은 **동적인 웹을 만들기 위한 웹 컨테이너** ,  **JSP와 Servlet을 구동하기 위한 서블릿 컨테이너** 역할을 수행한다. 한마디로 정적페이지를 제외한 JSP, ASP, PHP 등은 톰캣에서 처리한다. 또한 **DB연결, 데이터 조작, 다른 응용 프로그램과 상호작용**이 가능하다.\n\n<br><br><br>\n\n\n\n## ✅ 웹서버와 WAS의 구조\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/apa1.png?raw=true\" alt=\"웹서버와 was 구조\">\n</p>\n<br>\n\n- 사용자 (Client)가 HTTP Request를 던졌을 때 필요한 데이터가 **정적데이터** 라면 **Web 서버(Apache)** 에서는 바로 **HTTP Response**를 통해 **정적 HTML을 반환**하고 **동적 데이터**라면 이를 **Web Container(Servlet Container)** 로 보내 동적 데이터 처리를 한 뒤 Web 서버를 통해 사용자에게 반환한다.\n\n- 기본적으로 아파치와 톰캣의 기능은 나뉘어져 있지만, 톰캣 안의 컨테이너를 통해 일부 아파치 기능을 발휘하기 때문에 아파치톰캣 이라고 합쳐서 부른다.\n\n- 아파치만 쓰면 정적 웹페이지만 처리가 가능하다\n\n- 톰캣만 쓰면 정적 웹페이지 + 동적 웹페이지 처리가 모두 가능하지만, 아파치에서 필요한 기능을 가져올 수 없고, 과부하가 걸릴 가능성이 높다.\n\n- 따라서 **아파치와 톰캣을 같이 사용하여 아파치는 정적 데이터 처리, 톰캣은 JSP, ASP, PHP 등 동적 데이터 처리를 분담한다.**\n\n- 그리고 이러한 서블릿 컨테이너는 **MVC 패턴에서 Controller**에 주로 사용된다.\n\n<br><br>\n","properties":"\n","discussions":{},"comments":{},"hash":1293885482,"tx":54679},"JZO7E1GRXJiiFfhC/content":{"id":"JZO7E1GRXJiiFfhC/content","type":"content","text":"---\npublished: true\ntitle: \"[컴퓨터 구조] Instruction(명령어) 이란?\"\ndate: 2021-09-09 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Instruction 이란\"\ndescription: \"Instruction(명령어)이란 무엇이고 Instruction의 구성요소, 예시 그리고 이를 이해하기 위한 2의 보수와 폰 노이만 구조에 대해 알아보자.\"\ncategories:\n- Computer Architecture\ntags:\n- Computer Architecture\n---\n\n<br><br><br>\n\n## ✅ Number Representations\n인간은 기본적으로 모든 수를 10진수에 기반해 생각한다. 그러나 컴퓨터는 모든 연산을 0과 1로 처리를 하는 2진수에 기반한다. 이 때문에 컴퓨터 구조를 이해하기 위해서는 기본적으로 컴퓨터가 어떻게 2진수로 연산을 하고 처리하는지 알 필요가 있다. 컴퓨터는 산술 연산(덧셈, 뺄셈 등)을 명령어를 통해 수행하기 때문에 먼저 어떻게 음수와 양수를 2진수로 표현하는지 알아보자.\n\n<br><br>\n\n### 📌 2's Complement( = 2의 보수 )\n<hr>\n양수는 이진법으로 어떻게 나타내는지 잘 알고 있을 것이다. 8비트 수가 주어진다고 했을때 11을 이진수로 나타낸다면 다음과 같다.\n\n> **0000 1011<sub>2</sub>**\n\n그렇다면 -11을 이진수로 나타내려면 어떻게 표기해야 할까? 이때 우리는 **2의 보수**라는 것을 사용해서 음수를 표현할 수 있다. 컴퓨터 시스템에서 음수를 표현하고 연산을 수행하는 데 사용된다.\n\n방법은 간단하다. 이진법으로 나타낸 수의 각 비트를 반전시켜 먼저 1의 보수로 만들고 그 결과에 1을 더하면 2의 보수를 구할 수 있다. **한마디로 1로 나타낸 수는 0으로, 0으로 나타낸 수는 1로 바꿔주고 그 결과에 1을 더하면 된다.**\n\n<p class=\"notice--info\">\n⚠️ 1의 보수 : 이진수의 각 비트를 반전(0을 1로, 1을 0으로)시킨 것. <br>\n⚠️ 2의 보수 : 1의 보수에 1을 더한 것.\n</p>\n\n<br><Br>\n\n\n> **+11 : 0000 1011**  \n> **-11 :  1111 0101**  \n\n이렇게 0과 1을 변경해주고 마지막에 1만 더해주면 음수로 바꿀수 있다. 그런데 우리가 일반적으로 32비트 연산에서 -11이라고 표현한 위의 수는 실제로는 128 + 64 + 32 + 16 + 4 + 1 = 242 이다. 우리는 1111 0101<sub>2</sub>를 아무도 -11이라고 생각하지 않는다.\n\n그러나 컴퓨터 시스템에서는 **연산의 편의**를 위해 1의 보수, 2의 보수라는 개념을 정의했고 사용한다. 1111 0101<sub>2</sub>를 -11로 인식하게 끔 정의한 것이다. **그렇다면 2의 보수가 어떤식으로 연산의 편의를 제공하길래 이렇게 정의한걸까?** \n\n<br><br>\n\n앞서 살펴본 +11과 -11을 이진법으로 나타낸 각 자리를 한번 더해보자. \n\n> **+11 : 0000 1011**  \n> **-11 :  1111 0101**  \n> **00 : 10000 0000**  \n\n**모든 자릿수의 합이 2가 되면서 올림이 들어가고 결국 맨 앞에 1이 올림된다. 그러나 컴퓨터는 32bit 혹은 64bit를 사용하기 때문에 올림된 1은 결국 overflow되어 버려진다.** 최종적으로 2의 보수를 활용한다면 **양수 + 음수 = 0** 이라는 산수의 진리를 만족하면서도 **양수끼리의 합**으로 뺄셈 연산까지 표현할 수 있는 컴퓨터 시스템을 만들어 낼 수 있다.\n\n<br><br>\n\n이를 통해 우리는 몇가지 공식을 뽑아낼 수 있다.\n\n> **A + A's(A의 보수) = 1111 1111 <sub>2</sub>**  \n>**-A = A's + 1**  \n\n이를 통해 오로지 양수만으로 컴퓨터 산술 연산(덧셈, 뺄셈)을 할 수 있게 된 것이다. 이와 관련된 간단한 연습 문제를 살펴보자.\n\n<br><br>\n\n### 📌 연습 문제\n<hr>\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/2's.jpg?raw=true\" alt=\"2의보수 연습문제.\">\n</p>\n\n1111 1111 1111 1111 1111 1111 1111 1000<sub>2</sub>의 값을 구하라는 문제이다. 물론 컴퓨터 시스템 내에서의 값을 말한다.\n\n2의 보수를 모른다면 풀 수 없을 것이다. 저걸 언제 다 계산해서 정답을 작성 할 수 있을까..\n당연히 2의 보수를 사용하면 쉽게 풀 수 있다.\n\n-A = A's +1 을 활용한다면 정답은\n -0000 0000 0000 0000 0000 0000 0000 1000 <sub>2</sub> 즉, -8이 된다.\n\n<br><br><br><br><br><br>\n\n## ✅ The Von-Nuemann Model ( 폰 노이만 구조 )\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/Von.png?raw=true\" alt=\"폰 노이만 구조.\">\n</p>\n\n<br>\n\nInstruction을 알고싶어서 포스팅을 보고있는데 도대체 폰노이만 구조는 왜나오는 거야.. 싶겠지만 컴퓨터가 명령어를 처리하고 실행하는 방식을 설명하는데 폰노이만 구조는 매우 중요하다. 폰노이만 구조에 대해 간략하게 알아보고 넘어가자.\n\n폰 노이만 구조는 컴퓨터 시스템의 기본적인 설계 원리를 제시한 모델로 다음과 같은 주요 구성 요소로 이루어져 있다.\n\n1. **메모리** : 데이터를 저장하는 공간으로, 프로그램의 명령어와 데이터를 저장한다.\n\n2. **중앙 처리 장치(CPU)** : 명령어를 해석하고 실행하는 장치이다.\n\t- **산술 논리 장치(ALU)** : 산술 연산과 논리 연산을 수행한다.\n\t- **레지스터** : 연산에 필요한 데이터를 일시적으로 저장하는 작은 메모리이다.\n\t- **제어 장치** : 명령어를 해석하고 실행 순서를 제어한다.\n\n3. **입출력 장치 (I/O)** : 외부와 데이터를 주고받는 장치이다.\n\n4. **버스** : 데이터, 주소, 제어 신호를 전달하는 통로이다.\n\n<br><br>\n\n### 📌 폰 노이만 구조와 명령어 사이클\n<hr>\n폰 노이만 구조에서는 명령어를 처리하기 위해 명령어 사이클(Instruction Cycle)을 따른다. 명령어 사이클은 다음과 같은 단계로 이루어진다.\n\n-   **명령어 인출(Fetch)**: 메모리에서 명령어를 가져온다.\n-   **명령어 해독(Decode)**: 가져온 명령어를 해석하여 어떤 작업을 수행해야 하는지 결정한다.\n-   **명령어 실행(Execute)**: 해석된 명령어에 따라 실제 작업을 수행한다.\n-   **명령어 저장(Store)**: 연산 결과를 저장한다.\n\n<br><br>\n\n### 📌 폰 노이만 구조를 왜 알아야해?\n<hr>\n\n폰 노이만 구조는 명령어가 어떻게 인출, 해독, 실행되는지 이해하는데 가장 기본이 된다. 이를 통해 컴퓨터가 명령어를 처리하는 방식을 이해할 수 있다. 또한  폰 노이만 구조에서 메모리는 프로그램의 명령어와 데이터를 저장한다. 명령어는 메모리에서 인출되어 CPU에 의해 처리되므로, 메모리와 명령어의 관계를 이해하는 것 역시 중요하다. \n\n<br><br><br><br><br><br>\n\n## ✅ Instructions (명령어) 란?\n\n**Instruction(명령어)은 컴퓨터가 수행할 특정 작업을 정의하는 명령이다.** 명령어는 컴퓨터 프로그램을 구성하는 기본 단위로, CPU가 해석하고 실행하여 다양한 연산을 수행하게 한다. 컴퓨터 시스템에서 명령어는 주로 기계어(machine language) 또는 어셈블리어(assembly language)로 표현된다.\n\n<br><br>\n\n### 📌Instruction의 구성 요소\n<hr>\n\n-   **연산 코드(Operation Code, Opcode)**:\n    \n    -   명령어가 수행할 작업의 종류를 정의한다. 예를 들어, 덧셈, 뺄셈, 데이터 이동 등의 작업이 포함된다.\n\n-   **오퍼랜드(Operands)**:\n    \n    -   명령어가 처리할 데이터 또는 데이터의 위치를 지정한다. 이는 레지스터, 메모리 주소, 상수 값 등이 될 수 있다.\n\n-   **주소 지정 모드(Addressing Mode)**:\n    \n    -   오퍼랜드를 참조하는 방법을 정의한다. 이는 직접 주소 지정, 간접 주소 지정, 즉시 주소 지정 등의 방식으로 데이터를 참조한다.\n\n\n<br><br>\n\n### 📌Instruction 예시\n<hr>\n\n위의 정의만으로는 Instruction이 무엇인지 크게 와닿지 않을 것 같아 간단한 예시와 함께 설명하도록 하겠다.\n\n1. **ADD R1, R2, R3:**\n- 연산 코드 : ADD(덧셈)\n- 오퍼랜드 : R1, R2, R3 (레지스터)\n- 의미 : R2와 R3의 값을 더하여 R1에 저장한다.\n\n\n2. **MOV R1, 5:**\n- 연산 코드 : MOV (데이터 이동)\n- 오퍼랜드 : R1, 5\n- 의미 : 상수 5를 R1 레지스터에 저장한다.\n\n3. **LOAD R1, [1000]:**\n- 연산 코드 : LOAD (메모리에서 데이터읽기)\n- 오퍼랜드 : R1, [1000] (메모리 주소)\n- 의미 : 메모리 주소 1000번지의 값을 R1에 저장한다.\n\n\n사실 우리가 직접 명령어를 작성하거나 명령어를 두눈으로 볼 일은 거의 없을 것 같다. 이정도의 글을 읽는 정도 수준이면 대부분 CS이론을 학습하는 학생이거나 비전공자 정도 일테니 깊게 모든 예제를 파악할 필요는 없어보인다. 일단 명령어가 무엇이고 이런 식으로 쓰이는구나 정도만 알아가면 될 것 같다.\n\n\n<BR><BR><BR><BR><BR><BR>\n\n## ✅ 결론\n\nInstruction은 컴퓨터가 수행할 작업을 정의하는 기본 단위로, 컴퓨터 시스템의 작동 원리를 이해하는 데 핵심적인 역할을 한다. 명령어는 연산 코드, 오퍼랜드, 주소 지정 모드 등의 구성 요소로 이루어져 있으며, 이러한 명령어들이 모여 프로그램을 형성한다. \n\n컴퓨터 구조에 대한 깊이 있는 이해는 효율적인 소프트웨어 개발과 하드웨어 설계를 가능하게 하며, 나아가 컴퓨팅 성능을 극대화하는 데 도움을 준다. 앞으로의 학습에서도 이 기본 개념들을 바탕으로 더 복잡하고 정교한 컴퓨터 시스템의 작동 방식을 이해해 나가기를 바란다.\n","properties":"\n","discussions":{},"comments":{},"hash":-366733336,"tx":54766},"oT3RS2G9LsJ6xJ1f/content":{"id":"oT3RS2G9LsJ6xJ1f/content","type":"content","text":"---\npublished: true\ntitle: \"[컴퓨터 구조] Instruction Set Architecture (ISA) 이란?\"\ndate: 2021-09-12 12:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"ISA란?\"\ndescription: \"Instruction Set(명령어 집합)이란 무엇이고 ISA의 구성요소 및 특징을 알아보자. RISC와 CISC의 특징과 차이점을 알아보자.\"\ncategories:\n- Computer Architecture\ntags:\n- Computer Architecture\n---\n\n<br><br><br>\n\n## ✅ Instruction Set (명령어 집합)\n\n**Instruction Set**은 프로세서가 이해하고 실행할 수 있는 모든 명령어의 목록을 말한다. 이 목록에는 산술 연산, 논리 연산, 데이터 전송, 제어 명령 등의 다양한 명령어가 포함된다. 간단히 말해, Instruction Set는 프로세서가 수행할 수 있는 모든 명령어들의 집합이다.\n\n-   `ADD`: 두 레지스터 값을 더하는 명령어.\n-   `SUB`: 두 레지스터 값을 빼는 명령어.\n-   `LW`: 메모리에서 레지스터로 데이터를 로드하는 명령어.\n-   `SW`: 레지스터에서 메모리로 데이터를 저장하는 명령어.\n-   `BEQ`: 두 레지스터 값이 같으면 분기하는 명령어.\n\n\n<br><br><br><Br><Br><Br>\n\n## ✅ Instruction Set Architecture (ISA)\n\n**Instruction Set Architecture (ISA)는 Instruction Set을 포함한 더 포괄적인 개념으로,  컴퓨터의 하드웨어와 소프트웨어 간의 인터페이스를 정의하는 개념이다.** ISA는 프로세서가 실행할 수 있는 명령어의 집합과 이 명령어들이 실행되는 방식을 정의한다. 이는 컴퓨터 아키텍처의 핵심 요소 중 하나로, 특정 프로세서 설계와 소프트웨어 개발에 중요한 역할을 한다.\n\n좀더 쉽게 풀어쓰면 **ISA**는 **HW와 SW간의 추상적인 인터페이스**로 기계어를 작성하기 위해 필요한 **모든 정보**를 말하며 단순히 Instructions의 집합뿐만 아니라 **register, memory, access** 등을 포함한 모든 정보를 의미한다. \n\n\n<BR><BR>\n\n### 📌 ISA는 다양하다\n<hr>\n\nISA(Instruction Set Architecture)는 회사마다 다양할 수 있다. 이는 각 회사가 목표로 하는 설계 철학, 성능 요구 사항, 전력 소비, 응용 분야 등에 따라 서로 다른 ISA를 개발하기 때문이다.\n\nISA를 개발하는 대표적인 회사는 Intel과 AMD, ARM이 있다. Intel과 AMD는 고성능 데스크탑과 서버용 프로세서를 위해 x86 ISA를 개발했으며, ARM은 모바일 장치와 임베디드 시스템을 위한 저전력, 고효율 프로세서를 위해 ARM ISA를 개발했다.\n\n또한 다양한 응용 분야에 맞춘 ISA가 필요하다. 예를 들어, 서버용 프로세서는 높은 연산 성능과 멀티스레드 처리를 중시하고, 모바일 프로세서는 전력 효율성과 낮은 발열을 중시한다. 때문에 각 응용 분야에 맞춘 최적화된 ISA를 필요로 한다.\n\n특정 ISA는 소프트웨어와의 호환성 및 생태계를 형성한다. 예를 들어, x86 ISA는 오랫동안 사용되어 온 소프트웨어 생태계와의 호환성을 유지하기 위해 지속적으로 발전하고 있다. 새로운 ISA를 도입하면 기존 소프트웨어와의 호환성을 유지하는 데 어려움이 있을 수 있다.\n\n<BR><BR><BR><BR><BR><BR>\n\n## ✅ ISA 구성 요소\n앞서 언급한 ISA의 구성 요소를 살펴보면 다음과 같다.\n\n-   **명령어 형식(Instruction Format)** : 각 명령어의 길이와 각 필드(Opcode, 오퍼랜드 등)의 위치를 정의한다.\n-   **명령어 집합(Instruction Set)** : 프로세서가 이해하고 실행할 수 있는 모든 명령어의 목록을 정의한다. 산술 연산, 논리 연산, 데이터 전송, 제어 명령 등이 포함된다.\n-   **레지스터 집합(Register Set)** : 프로세서가 사용할 수 있는 레지스터의 목록을 정의한다. 레지스터는 연산 중간 결과나 중요한 데이터를 일시적으로 저장하는 데 사용된다.\n-   **주소 지정 모드(Addressing Modes)** : 명령어가 오퍼랜드를 참조하는 다양한 방식을 정의한다. 직접 주소 지정, 간접 주소 지정, 즉시 값, 레지스터 주소 지정 등이 포함된다.\n-   **데이터 타입(Data Types)** : 프로세서가 처리할 수 있는 데이터의 종류를 정의한다. 정수, 실수, 문자, 논리값 등을 포함한다.\n-   **인터럽트와 예외(Interrupts and Exceptions)** : 프로세서가 외부 신호나 오류 조건을 처리하는 방식을 정의한다.\n\n\n<br><br><Br><Br><Br><Br>\n\n\n\n\n## ✅ RISC와 CISC\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/RISC.jpg?raw=true\">\n</p>\n\n**RISC**(Reduced Instruction Set Computer)와 **CISC**(Complex Instruction Set Computer)는 두 가지 주요 프로세서 설계 철학을 나타내는 용어이다. 각 설계 철학은 명령어 집합(Instruction Set)과 프로세서 아키텍처에 대한 다른 접근 방식을 특징으로 한다.\n\n<BR><BR>\n\n\n### 📌 RISC ( Reduced Instruction Set Computer )\n<hr>\n\n- 비교적 적은 명령어를 가져 구조가 좀더 간단하다.\n- 적은수의 명령어로 Instruction Set을 이루므로 속도가 빠르다.\n- 일반적으로 많이 쓰이는 명령어를 주로 가진다.\n- **메모리에 접근하는 명령어**로 **load와 store**만을 가진다!\n- 대표적으로 MIPS 가 있다.\n\n\n\n### 📌 CISC (Complex Instruction Set Computer )\n<hr>\n\n- 1000개가 넘는 Instructions를 가진다.\n- 명령어를 해석하는데 시간이 오래걸리며 명령어 해석에 필요한 회로도 복잡하다.\n- 10여개가 넘는 addressing mode를 가진다.\n- 대표적으로 x86 이있다.\n\n\n\n<br><br>\n\n### 📌주요 차이점 \n<hr>\n\n-   **명령어 수**: RISC는 적은 수의 명령어를, CISC는 많은 수의 명령어를 가진다.\n-   **명령어 실행 시간**: RISC는 대부분의 명령어가 동일한 시간에 실행되도록 설계되었지만, CISC는 명령어마다 실행 시간이 다를 수 있다.\n-   **파이프라이닝**: RISC는 파이프라이닝에 최적화되어 있어 고속 처리가 가능하다. CISC는 명령어의 복잡성 때문에 파이프라이닝이 어렵다.\n-   **메모리 접근**: RISC는 load와 store 명령어를 통해서만 메모리에 접근할 수 있다. CISC는 다양한 명령어를 통해 메모리에 접근할 수 있다.\n\n이러한 차이점 때문에, RISC는 높은 성능과 효율성을, CISC는 복잡한 명령어 처리를 목표로 한다. 각 아키텍처는 특정 응용 분야와 목적에 따라 장단점이 있다.\n\n<br><br><br><br><br><br>\n\n## ✅ 결론\n\n이번 포스팅에서는 Instruction Set과 Instruction Set Architecture(ISA)의 개념을 살펴보고, RISC와 CISC의 차이점을 알아보았다. ISA는 컴퓨터 시스템의 중요한 구성 요소로, 프로세서가 실행할 수 있는 명령어 집합과 이 명령어들이 실행되는 방식을 정의한다. ISA는 하드웨어와 소프트웨어 간의 인터페이스 역할을 하며, 다양한 요소를 포함한다.\n\nRISC와 CISC는 서로 다른 설계 철학을 바탕으로 명령어 집합을 구성한다. RISC는 단순하고 효율적인 명령어 세트를 통해 고속 처리를 목표로 하며, 파이프라이닝에 최적화되어 있다. 반면, CISC는 복잡한 명령어 세트와 다양한 주소 지정 모드를 통해 복잡한 작업을 효율적으로 처리할 수 있도록 설계되었다.\n\n각 아키텍처는 특정 응용 분야와 목적에 따라 장단점이 있으며, 최적의 성능을 달성하기 위해 적합한 ISA를 선택하고 설계하는 것이 중요하다. 컴퓨터 아키텍처를 이해하고 설계하는 데 있어 ISA와 명령어 집합의 개념을 잘 이해하는 것이 필수적이다.\n\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":1657941504,"tx":54830},"oT3RS2G9LsJ6xJ1f/contentState":{"id":"oT3RS2G9LsJ6xJ1f/contentState","type":"contentState","selectionStart":242,"selectionEnd":242,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718074450660,"tx":54830},"1x2SS92trda8Dql0/contentState":{"id":"1x2SS92trda8Dql0/contentState","type":"contentState","selectionStart":267,"selectionEnd":267,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718074466337,"tx":54834},"JZO7E1GRXJiiFfhC/contentState":{"id":"JZO7E1GRXJiiFfhC/contentState","type":"contentState","selectionStart":241,"selectionEnd":140,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718074521079,"tx":54837},"mXfQrwQgdNgA8wLp/content":{"id":"mXfQrwQgdNgA8wLp/content","type":"content","text":"---\npermalink: /2022-08-17-CRUD란/\npublished: true\ntitle: \"[개발상식] CRUD란?\"\ndate: 2022-08-17 05:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"CRUD란\"\ndescription: \"CRUD란 무엇이고 예시와 함께 알아보자. REST API에서의 CRUD, DB에서의 CRUD에 대해 알아보자.\"\ncategories:\n- 개발상식\ntags:\n- CRUD\n- 개발상식\n- DB\n- REST API\n---\n\n<br><br><br>\n\n  \n\n## ✅ CRUD란?\n\nCRUD는 \"Create, Read, Update, Delete\"의 약어로 데이터베이스와 같은 시스템에서 기본적인 데이터 관리 기능을 의미한다.\n\nCRUD는 거의 모든 시스템에 적용되는 가장 기본이 되는 개념이라고 볼 수 있다. 프로젝트를 진행 할 때나 대규모 시스템을 살펴만 봐도 CRUD 개념이 안들어가 있는것을 보기 어렵고, 개발자끼리 회의를 할때도 많이 사용되는 단어이기 때문에 어디서 사용되고 무슨 의미인지 알아두면 좋다.\n\n필자는 크게 **데이터베이스에서의 CRUD**와 **RESTful API 설계시 사용되는 CRUD**에 대해 소개해보도록 하겠다.\n\n\n<br><br><br><br>\n\n\n## ✅ DB에서의 CRUD\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/crud1.png?raw=true\" alt=\"DB에서의 CRUD.\">\n</p>\n\n<br>\n\n1. **Create ( 생성 )**\n\n\t새로운 데이터를 생성한다. 이는 데이터베이스에 새로운 레코드를 추가하거나 파일 시스템에 새로운 파일을 생성하는 것과 같은 작업을 의미한다.\n\n2. **Read ( 읽기 )**\n\n\t데이터를 조회한다. 데이터베이스나 파일시스템에서 저장된 데이터를 검색하고 읽어오는 작업을 의미한다.\n\n3. **Update ( 갱신 )**\n\n\t기존 데이터를 수정한다. 데이터베이스에서 기존 레코드를 수정하거나 파일 시스템에서 파일의 내용을 갱신하는 것과 같은 작업을 의미한다.\n\n4. **Delete ( 삭제 )**\n\n\t데이터를 삭제한다. 데이터베이스에서 레코드를 삭제하거나 파일 시스템에서 파일을 삭제하는 것과 같은 작업을 의미한다. \n\n<br>\n\n\n\n\n\n\n\n\n\n<br><br><br><br>\n\n## ✅ REST API에서의 CRUD\n\n클라이언트 <-> 서버간 HTTP 프로토콜을 이용해 REST API를 설계하고 작성할 때에도 CRUD 개념이 사용된다. 클라이언트는 적절한 HTTP 메서드와 URL을 사용하여 서버에 요청을 보내어 데이터를 생성,조회,수정,삭제 할 수 있다.\n\n<br>\n\n<p align=\"left\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/crud2.png?raw=true\" alt=\"REST API에서의 CRUD\">\n</p>\n\n<br>\n\n1.  **Create (생성)**\n\n    -   HTTP 메서드: `POST`\n    -   예시: 새로운 사용자를 생성하는 경우\n        -   요청: `POST /users`\n        -   요청 본문(body): 새로운 사용자의 정보를 포함하는 JSON 또는 XML 데이터\n        -   응답: 새로운 사용자의 ID와 함께 성공 메시지 또는 적절한 상태 코드 (예: 201 Created)\n\n<br>\n\n2.  **Read (읽기)**:\n    \n    -   HTTP 메서드: `GET`\n    -   예시: 모든 사용자 목록을 가져오는 경우\n        -   요청: `GET /users`\n        -   응답: 모든 사용자의 목록을 포함하는 JSON 또는 XML 데이터 또는 적절한 상태 코드와 함께 성공 메시지 (예: 200 OK)\n        \n<br>\n\n3.  **Update (갱신)**:\n    \n    -   HTTP 메서드: `PUT` 또는 `PATCH`\n    -   예시: 특정 사용자의 정보를 업데이트하는 경우\n        -   요청: `PUT /users/{id}` 또는 `PATCH /users/{id}`\n        -   요청 본문: 업데이트할 사용자의 정보를 포함하는 JSON 또는 XML 데이터\n        -   응답: 적절한 상태 코드와 함께 성공 메시지 또는 업데이트된 사용자의 정보\n\n<br>\n\n4.  **Delete (삭제)**:\n    \n    -   HTTP 메서드: `DELETE`\n    -   예시: 특정 사용자를 삭제하는 경우\n        -   요청: `DELETE /users/{id}`\n        -   응답: 적절한 상태 코드와 함께 성공 메시지 또는 삭제된 사용자의 정보\n\n<BR><BR>\n\n한마디로,\n\n**Create는 데이터를 생성하고**\n\n**Read는 데이터를 읽으며**\n\n**Update는 새로운 데이터를 업데이트하고**\n\n**Delete는 데이터를 삭제하는 것을 의미한다!**\n\n\n\n\n\n  \n\n<br><br><br>\n\n## ✅ 간단한 CRUD 예시 \n\n필자가 프로젝트 수행하면서 CRUD를 사용했던 대화 몇개를 차용해보면 보통 이런 흐름이다.\n\n<br><br>\n\n**[ 댓글 CRUD ]**  \nA : \"테드님이 댓글 CRUD 구현해주세요\"  \nB : \"넹\"  \n... ( 뚝딱뚝딱 )  \nB : \"댓글 작성(CRUD의 C)이랑 댓글 조회(CRUD의 R)까지 구현했고, 댓글 수정(CRUD의 U)이랑 삭제(CRUD의 D)는 구현중입니다~\"  \nA : \"나머지 댓글 수정이랑 삭제도 빨리해주세요!\"  \n<Br><br>\n\n**[ 게시글 CRUD ]**  \nA : \"테드님이 게시글 CRUD 구현해주세요\"  \nB : \"넹\"  \n... ( 뚝딱뚝딱 )  \nB : \"게시글 작성, 조회, 수정, 삭제 전부다 구현 완료했습니다~\"  \n\n<br><br>\n이런 흐름으로 보통 CRUD라는 단어를 사용하곤 한다. 엄청나게 어려운 개념은 아니지만 되게 많이 사용되는 단어이기 때문에 어떤 의미인지 정확하게 알아두면 좋다.\n\n<br><br><br><br>\n\n\n","properties":"\n","discussions":{},"comments":{},"hash":-1762397547,"tx":54893},"Fhx75tVk2bMRrChl/contentState":{"id":"Fhx75tVk2bMRrChl/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718084251992,"tx":54942},"RTduSDZPEbBuUVtA/contentState":{"id":"RTduSDZPEbBuUVtA/contentState","type":"contentState","selectionStart":236,"selectionEnd":236,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718155277251,"tx":54945},"CVoMq6D4LAjPbCG5/contentState":{"id":"CVoMq6D4LAjPbCG5/contentState","type":"contentState","selectionStart":591,"selectionEnd":591,"scrollPosition":{"sectionIdx":28,"posInSection":0.9722222222222222},"hash":1718155342774,"tx":54965},"ATRuUFMbG6IBvDuO/contentState":{"id":"ATRuUFMbG6IBvDuO/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718155344217,"tx":54966},"jFo1UfZG6pqBFoBN/contentState":{"id":"jFo1UfZG6pqBFoBN/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718155346767,"tx":54967},"wmLsksMuEWVovfap/contentState":{"id":"wmLsksMuEWVovfap/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718155345800,"tx":54967},"OiVTXhxEC6PT4wfS/contentState":{"id":"OiVTXhxEC6PT4wfS/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718155348040,"tx":54968},"iXzCHT0T4V83pjgR/contentState":{"id":"iXzCHT0T4V83pjgR/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718155349248,"tx":54969},"EO4J8PI1VIfZ6v35/contentState":{"id":"EO4J8PI1VIfZ6v35/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718155349985,"tx":54970},"Nz2EkixXKQGcuEag/contentState":{"id":"Nz2EkixXKQGcuEag/contentState","type":"contentState","selectionStart":3018,"selectionEnd":3005,"scrollPosition":{"sectionIdx":37,"posInSection":0.3522504892367906},"hash":1718155385428,"tx":54979},"yZcqkNTKpThPrnfx/contentState":{"id":"yZcqkNTKpThPrnfx/contentState","type":"contentState","selectionStart":2023,"selectionEnd":1907,"scrollPosition":{"sectionIdx":16,"posInSection":0.8752598752598753},"hash":1718155396851,"tx":54984},"MTb2rEZmbJruPLxT/contentState":{"id":"MTb2rEZmbJruPLxT/contentState","type":"contentState","selectionStart":4687,"selectionEnd":4663,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718344956076,"tx":54988},"WJFVWbFTBiUUqpiQ/contentState":{"id":"WJFVWbFTBiUUqpiQ/contentState","type":"contentState","selectionStart":3005,"selectionEnd":3005,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718344975819,"tx":54999},"J3qxgGs4hhBbD0IK/contentState":{"id":"J3qxgGs4hhBbD0IK/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718344982636,"tx":55004},"6d0K7UYUnaJHcUwH/contentState":{"id":"6d0K7UYUnaJHcUwH/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718345334838,"tx":55024},"fazmhohPrMfu2qvK/contentState":{"id":"fazmhohPrMfu2qvK/contentState","type":"contentState","selectionStart":3005,"selectionEnd":3005,"scrollPosition":{"sectionIdx":35,"posInSection":0.7341389728096677},"hash":1718345338435,"tx":55026},"mXfQrwQgdNgA8wLp/contentState":{"id":"mXfQrwQgdNgA8wLp/contentState","type":"contentState","selectionStart":1509,"selectionEnd":1373,"scrollPosition":{"sectionIdx":17,"posInSection":0.4},"hash":1718345346547,"tx":55031},"9JHueTxb1xmg5ZXP/content":{"id":"9JHueTxb1xmg5ZXP/content","type":"content","text":"---\npermalink: /2022-08-16-프레임워크 vs 라이브러리/\npublished: true\ntitle: \"[개발상식] 프레임워크(Framework)와 라이브러리(Library)의 차이\"\ndate: 2022-08-16 21:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"프레임워크 vs 라이브러리\"\ndescription: \"프레임워크 라이브러리 차이. 라이브러리 프레임워크 차이.\"\ncategories:\n- 개발상식\ntags:\n- 라이브러리\n- 프레임워크\n- 개발상식\n---\n\n<br><br>\n\n<p align=\"center\">\n  <img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/framework1.webp?raw=true\" width=\"600\" height=\"600\" alt=\"프레임워크와 라이브러리의 차이\">\n</p>\n\n\n\n<div style=\"text-align: center;\">\n <br>\n  <p><strong>\"라이브러리와 프레임워크의 차이가 뭔지 알아요?\"</strong></p><br>\n  <p>\"음.. 라이브러리는 그냥 메소드같은걸 갖다 쓰는거고.. 프레임워크는 틀?\"</p><br>\n  <p><strong>\"스프링은 라이브러리 일까요 프레임워크일까요?\"</strong></p><br>\n  <p>\"음.. 프레임워크?\"</p>\n  <p><strong>\"최근에 사용한 라이브러리와 프레임워크는 뭐에요?\"</strong></p><br>\n  <p>\"...\"</p>\n</div>\n\n\n<br>\n\n개발자로 공부하다보면 라이브러리, 프레임워크 라는 용어를 정말 많이 듣고 사용하는데 정작 라이브러리와 프레임워크의 정확한 정의는 무엇인지, 무슨 차이가 있는지는 모른채 혼용하여 사용하는 경우가 많다. 위의 짤막한 인터뷰 내용은 실제 필자가 인턴 근무 하는 중 받은 질문이였고, 질문에 대답하지 못했다. 그래서 오늘은 라이브러리와 프레임워크의 정의와 기능, 예시, 차이점을 정리해서 포스팅 해보고자 한다! 참고로 기술면접에서도 자주 등장하는 질문이니 자세히 정확하게 알아두는게 좋다!\n\n<br><br><br><br><br><br>\n\n## ✅ 프레임워크(Framework)란?\n\n**원하는 기능 구현에 집중하여 개발할 수 있도록 일정한 형태와 기능을 갖추고 있는 골격, 뼈대**를 의미합니다. \n\n**프레임워크는 애플리케이션 개발 시 필수적인 코드, 알고리즘, DB연동과 같은 기능을 위해 어느정도 구조(뼈대)를 제공하고, 이러한 구조위에서 사용자가 코드를 작성해서 애플리케이션을 개발** 합니다. \n\n**앱/서버 등의 구동, 메모리관리, 이벤트 루프** 등 공통된 부분은 프레임워크가 관리하고, **사용자는 프레임워크가 정해준 방식대로 클래스, 메소드를 구현**하면 됩니다.\n\n한마디로 **소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합** 이라고 볼 수 있습니다.\n\n\n<br><br>\n\n### 📌 프레임워크의 기능\n<hr>\n\n1. **코드 재사용성** : 프레임워크는 공통 기능을 제공하여 코드 재사용에 용이합니다.\n2. **일정한 구조 제공** : 프레임워크는 애플리케이션의 구조를 정의하여 개발자가 그 구조를 따르도록 합니다.\n3. **모듈화** : 프레임워크는 기능을 모듈화하여 독립적인 컴포넌트로 나눌 수 있게 합니다.\n4. **생산성 향상** : 반복적인 작업을 자동화하고 개발 생산성을 높입니다.\n5. **유지보수성** : 일관된 코드 구조를 유지하여 유지보수성을 향상시킵니다.\n\n<br><br>\n\n### 📌 프레임워크 예시\n<hr>\n\n- JAVA 서버 개발에 사용되는 **Spring Framework**\n- Python 서버 개발에 사용되는 **Django, Flask**\n- 안드로이드 앱 개발에 사용되는 **Android**\n- 웹 개발에 사용되는 **Angular, Vue.js**\n- JAVA 기반의 JSP를 위한 **Struts**\n\n\n<br><br><br><br><br><br>\n\n## ✅ 라이브러리(Library)란?\n**라이브러리는 단순 활용가능한 도구들의 집합을 말합니다.**\n\n**소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임 입니다.**\n\n**미리 작성된 코드, 변수, 함수, 클래스가 포함됩니다.**\n\n\n<br><br>\n\n### 📌 라이브러리의 기능\n<hr>\n\n1. **코드 재사용성**: 라이브러리는 특정 작업을 처리하는 코드의 재사용을 촉진합니다.\n2. **추상화**: 복잡한 작업을 간단한 함수 호출로 추상화합니다.\n3. **모듈화**: 라이브러리는 기능별로 모듈화되어 필요에 따라 가져다 쓸 수 있습니다.\n4. **유연성**: 개발자가 필요에 따라 라이브러리를 선택하여 사용할 수 있습니다.\n\n\n<br><br>\n\n### 📌 라이브러리 예시\n<hr>\n\n-   **TensorFlow**: 머신러닝과 딥러닝을 위한 Python 라이브러리.\n-   **Pandas**: 데이터 분석과 조작을 위한 Python 라이브러리.\n-   **NumPy**: 수치 계산을 위한 Python 라이브러리.\n-   **jQuery**: HTML 문서 탐색 및 조작, 이벤트 처리, 애니메이션, Ajax를 쉽게 처리할 수 있게 하는 JavaScript 라이브러리.\n-   **Lodash**: JavaScript 유틸리티 라이브러리로서 배열, 객체, 문자열 등 다양한 작업을 편리하게 처리할 수 있게 해줍니다.\n\n\n<br><br><br><br><br><br>\n\n## ✅ 프레임워크와 라이브러리의 차이점\n\n### 📌 제어의 역전 (Inversion of Control)\n<hr>\n\n라이브러리와 프레임워크의 가장 큰 차이는 **제어 흐름에 대한 주도성이 누구에게/어디에 있는가**에 있습니다. 즉, **어플리케이션의 Flow(흐름)를 누가 쥐고 있느냐**에 달려있습니다.\n\n**프레임워크**는 **전체적인 흐름을 프레임워크가 쥐고 있으며** 사용자는 그 안에 필요한 코드를 짜 넣으면 되고,\n반면에 **라이브러리**는 **사용자가 전체적인 흐름을 직접 만들고** 필요에 따라 라이브러리를 가져다가 쓰는 것이라고 할 수 있습니다.\n\n한마디로 **프레임워크**는 **그 틀안에 제어 흐름에 대한 주도성이 내포**되어 있고, **라이브러리**는 **사용자가 전적으로 제어 흐름에 대한 주도성**을 가집니다.\n\n<br><br>\n\n### 📌 구조 제공 유무\n<hr>\n\n**프레임워크는 전체 어플리케이션의 구조를 정의하여 일정한 개발 패턴을 따르게끔 합니다.** 앞서 말한 제어 흐름을 가지고 있다는 것과 거의 유사한 의미입니다. \n\n**그러나 라이브러리는 특정 기능만을 제공할 뿐 어플리케이션의 전체 구조에는 관여하지 않습니다.** 사용하는 개발자 스스로 원하는 방식으로 구조를 설계할 수 있습니다.\n\n<br><br>\n\n<p class=\"notice--danger\">\n⚠️ 프레임워크 : 프레임워크가 흐름을 제어하고 사용자가 만든 코드를 사용 (제어의 역전)  \n</p>\n\n<p class=\"notice--danger\">\n⚠️ 라이브러리 : 사용자가 흐름을 제어하고 라이브러리를 가져다 사용\n</p>\n\n\n<br><br><br><br><br><br>\n\n## ✅ 결론\n\n프레임워크와 라이브러리는 각각의 장단점이 있으며, 특정 상황과 요구에 따라 선택하여 사용합니다. 프레임워크는 애플리케이션의 구조와 흐름을 제어하며, 일관된 개발 패턴을 제공합니다. 반면에 라이브러리는 특정 기능을 쉽게 사용할 수 있도록 도와주며, 개발자가 전체 흐름을 제어할 수 있게 합니다.\n","properties":"\n","discussions":{},"comments":{},"hash":1691988984,"tx":55592},"9JHueTxb1xmg5ZXP/contentState":{"id":"9JHueTxb1xmg5ZXP/contentState","type":"contentState","selectionStart":517,"selectionEnd":517,"scrollPosition":{"sectionIdx":12,"posInSection":0.675},"hash":1718351268365,"tx":55600},"fuIXk253HaqdwDFg/contentState":{"id":"fuIXk253HaqdwDFg/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718351300482,"tx":55601},"f5vTQlCLsBu2JtIV/contentState":{"id":"f5vTQlCLsBu2JtIV/contentState","type":"contentState","selectionStart":0,"selectionEnd":0,"scrollPosition":{"sectionIdx":0,"posInSection":0},"hash":1718351301405,"tx":55602},"lastOpened":{"id":"lastOpened","type":"data","data":{"x2LBqte2UHd95dF6":1710111435512,"vCSdbkmBz8WS1NuE":1710111936526,"wTK8ucAfkpXnll6C":1711328165895,"ZQ1P22aGt9pYBZQY":1711328165417,"1hoxohbjUViggy6d":1710894432694,"VQOgcLROQ4ay0oXW":1715814088929,"mXfQrwQgdNgA8wLp":1718345340989,"kRBjdpE8Q87pKDBk":1713740901138,"eZPD4ts8Xo7mlluk":1716439101736,"ADbe6HrECGC5ROmU":1716968142004,"Kl8goLjOCe4Y2iU1":1716439106848,"xJpL045jRDmgWJHa":1710747950033,"C0Q29ajZZPzh3Jcv":1710747954086,"jfStBciYCU0re8LF":1715218280956,"PV7SRqnI3929RHIh":1713491381507,"7LHwr5vMhDvsF6qJ":1717992923717,"Bars6CC7H5Joqa8P":1713482652330,"VhXoCDuP9kB8fjSR":1710747904140,"MRasIncXHMnDEsl4":1713482651946,"JZO7E1GRXJiiFfhC":1718074518820,"QCDOYp9baGlX0tfx":1713511352699,"sXFUuwDsSBfhbhTA":1713511356570,"fxktNjN7Qbqln352":1711600086995,"N72RguIezt8KuflR":1710897326130,"06MckntYpMDISZ8b":1710718819747,"WJFVWbFTBiUUqpiQ":1718344973236,"QfcCQHZlB9I2iOQ0":1717997287162,"6d0K7UYUnaJHcUwH":1718345334728,"J3qxgGs4hhBbD0IK":1718344981113,"ZrlBGkPkFqYFyKak":1717982177531,"jeNuMwclaWKHJJjy":1716768167777,"2OTxNzpMQajxUPNa":1716439106493,"Nz2EkixXKQGcuEag":1718155354910,"MTb2rEZmbJruPLxT":1718344946666,"jCnq3Wvv7Hqcz9L7":1716426841587,"vznoAKrCVFYxkwJ0":1716438411101,"dmRttHYhrK5WFmOh":1716438411452,"QBAJWTNeLD7raJPY":1716426850803,"9TTmPv43PVpNQndV":1716438411885,"X3mDwXGkmeIJpTbt":1716872394778,"fklYIJyOheHqvfTa":1710892504514,"Fhx75tVk2bMRrChl":1718084251996,"RTduSDZPEbBuUVtA":1718155276482,"LOPgwVDwC6boRNzS":1716450524920,"1yvS1owczbvG7a0y":1716450624250,"0jwjWW7L0cw2iQtV":1716877537808,"14iOQ0JTNwFklzQv":1716968274920,"Fr15DxYxCrywoW1c":1710898374146,"vVPdin3FmpSihQxj":1710747879430,"aJrzklaPe7FlmPv5":1710747885842,"bHqTE0XjV1KS586A":1710747917739,"6L2BLz0U8N7KSVN2":1710892595877,"VCnzbwtUALknf6h2":1710747927262,"JbeDoZUm857e8fdL":1710892450882,"9JHueTxb1xmg5ZXP":1718345348147,"jWIAbpACKd6mffUH":1712130597957,"27FCLunQqiKehP51":1710748650930,"g55C7cqcezctQpDW":1710898369631,"jFo1UfZG6pqBFoBN":1718155346783,"wmLsksMuEWVovfap":1718155345805,"lxMWY3IFzi3Fwd8Q":1716872403601,"Q630m9jJvuuKh53I":1715218316566,"QO3PlLKwWnIiwVqK":1715814100569,"nZtkP309cM7hcqO2":1717981707363,"O7ZdI0GnNZ8IGhYW":1717981707813,"9MtDBGhyQQWuisRx":1717986184353,"hsMOxKWCChERUD8N":1717981720576,"omFvrSXYtukeVixH":1717981719753,"w6ADipsYQPt3OgNW":1717981861024,"MviwGZUVucL3T4n8":1714107544129,"5xTVal0mYmIYU6Hk":1710891096564,"yCviR51sRbUk47WF":1711350744058,"1nZnksY9YPlL4cyi":1713333130177,"nOITFWSLtVkWensy":1714107544867,"B30uFDwmYERr6MWH":1710891104756,"toS351vpmJre9cYC":1714107545876,"C8kg3so81QVoun72":1717981723031,"AccPceb6fVYGLjbn":1716872404501,"yZcqkNTKpThPrnfx":1718155396745,"HImeteZ1A700ZipO":1711680119923,"VLaa02Loo6VepSNT":1716872409698,"by4gQGx95Mp30v8Z":1716768157544,"rJtXtpzzHWYRjcMJ":1716443592197,"D6AI3WmiULa0MQox":1717997906831,"2YcBlgoRtPYITlYT":1718066456946,"Rkbhu5EBtxTalmMn":1715827360326,"8IFmCnOfvma2Povc":1713413803185,"bZrfx6XKev82ul2h":1716877656943,"RXviSkk9OEup22my":1716877649937,"DYReayvPEWh2qfnj":1718351302351,"w2rF7i814I5K61Gi":1717980993889,"4VlIZeIFebGuQ7Yr":1713513533114,"fazmhohPrMfu2qvK":1718345335903,"cbpX0FKBzhieTySP":1715221524945,"ptoLJUzGpYr1U2Hq":1715220917118,"YDJJdqjhA30zySZh":1716872404876,"EuU8pmiZWx04CkEn":1716872405196,"08K40WXSblJ4yn74":1717986180454,"3pPfZNfURBxowOxC":1717976998931,"1mdCDouqVJGvLxrK":1716443343181,"EAHxuW5JgATJ3mo2":1716449863004,"KvfIbjNY2ObhRnU0":1716449848787,"31ixuwejQY1ahmSf":1716449857065,"cc0DNjIMHfpFRRJW":1716449859906,"I9XIrcsCCqJCsXnW":1716449861352,"3LsY0S6l92HdtfPP":1716449865312,"00TrVRATmgNqHn1N":1716450854813,"ygsX3wnSWEPl4aQH":1716450856217,"FfQclKsMdVNJJRNd":1716511766737,"WD9Bzi9mPGSI4cK9":1716450857091,"1x2SS92trda8Dql0":1718074463341,"tLqdQCgLBZOSaYBm":1718071690397,"oT3RS2G9LsJ6xJ1f":1718074373551,"f5vTQlCLsBu2JtIV":1718351301409,"fuIXk253HaqdwDFg":1718351300378,"OiVTXhxEC6PT4wfS":1718155348043,"iXzCHT0T4V83pjgR":1718155349250,"EO4J8PI1VIfZ6v35":1718155349987,"CVoMq6D4LAjPbCG5":1718155295101,"ATRuUFMbG6IBvDuO":1718155344229},"hash":2118753210,"tx":55603},"DYReayvPEWh2qfnj/content":{"id":"DYReayvPEWh2qfnj/content","type":"content","text":"---\npublished: true\ntitle: \"[머신러닝] [Python] 3. Logistic Regression (로지스틱 회귀)\"\ndate: 2021-09-14 02:00:00\ntoc: true\ntoc_sticky: true\ntoc_label: \"Logistic Regression\"\ncategories:\n- Machine Learning\ntags:\n- Machine Learning\n- Regression\n- Linear Regression\n- Logistic Regression\n---\n\n<br><br><br>\n\n이번 포스팅에서는 Categorical 변수를 예측하는 모델인 Logistic Regression ( 로지스틱 회귀)에 대해 살펴보겠습니다. 포스팅에서 사용된 자료에 대해서는 가천대학교 소프트웨어학과 김원 교수님의 강의를 기반으로 작성되었음을 밝힙니다.\n\n<br><br><br><br><br><br>\n\n## ✅ Linear Regression ( 선형 회귀 )\n\nLogistic Regression에 대한 설명에 앞서 기본적인 이해를 위해 선형 회귀에 대해서 간단하게 알아보겠습니다. \n\n<br><br><br><br><br><br>\n\n시험 공부하는 시간을 늘리면 늘릴 수록 성적이 잘 나옵니다. 하루에 걷는 횟수를 늘릴 수록, 몸무게는 줄어듭니다. 집의 평수가 클수록, 집의 매매 가격은 비싼 경향이 있습니다. 이는 수학적으로 생각해보면 어떤 요인의 수치에 따라서 특정 요인의 수치가 영향을 받고있다고 말할 수 있습니다. 조금 더 수학적인 표현을 써보면 어떤 변수의 값에 따라서 특정 변수의 값이 영향을 받고 있다고 볼 수 있습니다. 다른 변수의 값을 변하게 하는 변수를 x, 변수 x에 의해서 값이 종속적으로 변하는 변수 y라고 해봅시다.\n\n이때 변수 x의 값은 독립적으로 변할 수 있는 것에 반해, y값은 계속해서 x의 값에 의해서, 종속적으로 결정되므로 **x를 독립 변수**, **y를 종속 변수**라고도 합니다. **선형 회귀**는 **한 개 이상의 독립 변수 x와 y의 선형 관계**를 모델링합니다. 만약, **독립 변수 x가 1개라면 단순 선형 회귀**라고 합니다.\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/linear.jpg?raw=true\" alt=\"단순선형회귀\">\n</p>\n\n<br><br><br><br><br><br>\n\n생각해보니 집의 매매가격은 단순히 집의 평수가 크다고 결정되는 것이 아니라, 집의 층수, 방의 개수, 역세권인지 아닌지 등 여러가지 요소에 영향을 많이 받는것 같습니다. 이제 이러한 다수의 요소를 가지고 집의 매매 가격을 예측해 보고 싶습니다. y(집의 매매가격)는 여전히 1개이지만 x(층수, 방개수, 역세권 등)는 여러개가 되었습니다. 이를 **Multiple Linear Regression (다중 선형 회귀)**라고 부릅니다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/multi.png?raw=true\">\n</p>\n\n<br><br><br><br><br><br>\n\n## ✅ Logistic Regression ( 로지스틱 회귀)\n**Logistic Regression**은 데이터가 어떤 범주에 속할 확률을 0에서 1사이의 값으로 예측하고 그 확률에 따라 가능성이 더 높은 범주에 속하는 것으로 분류해주는 지도 학습 알고리즘이다.\n\n스펨 메일 분류기 같은 예시를 생각하면 쉬운데, 어떤 메일을 받았을 때 그 메일이 스팸일 확률이 0.5이상이면 스팸으로 분류하고, 메일이 스팸일 확률이 0.5보다 낮으면 일반 메일로 분류하는 것이다. 이렇게 데이터가 2개의 범주 중 하나에 속하도록 결정하는 것을 **Binary Classification (2진 분류)**라고 한다.\n\n로지스틱 회귀 역시 X와 Y의 관계식으로 설명 할 수 있는데, X는 **Binary(양분된), Categorical(범주형), Continuous(연속형)** 한 데이터 모두를 가질 수 있지만, Y는 **Binary**한 데이터만을 가질 수 있다.\n\n<br><br><br><br><br><br>\n\n\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/data.png?raw=true\">\n</p>\n예시를 보며 자세히 살펴보자. **X로 Age**가 주어졌고 **Y로는 심장병 유무**가 주어진 데이터셋이다. 이를 **Linear Regression**으로 나타내면 아래 그림과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/linear1.png?raw=true\">\n</p>\n\n한눈에 보기에도 이상하다. Y가 Binary한 데이터로 주어졌기 때문에 Linear Regression으로 표현하면 정확도가 떨어지는 문제가 발생한다. 이를 해결하기 위해 데이터셋을 일부 수정한 뒤  **Logistic Regression**으로 나타내 보겠다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logic1.png?raw=true\">\n</p>\n\nX로 주어진 Age를 나이대별로 묶은 뒤 심장병에 걸린 사람수를 나타낸 데이터셋이다. 이를 **Logistic Regression**으로 나타내면 아래 그림과 같다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logic2.png?raw=true\">\n</p>\nY값은 0~1사이의 값으로 표현되며 y<0.5일때는 0으로 치환되고 y>=0.5일때는 1로 치환되는 결과를 보여준다. 위의 그래프처럼 나타내는 것을 **Sigmoid Function** (시그모이드 함수) 이라고 부른다.\n\n**이처럼 Y가 Binary한 데이터로 주어질때는 Linear Regression을 사용하는 것 보다는 Logistic Regression을 사용하는 것이 훨씬 정확도가 높다.**\n\n<br><br><br><br><br><br>\n\n## ✅ Logit(로짓) - log + odds \n\nLogistic Regression을 구현하는 것은 어렵지 않다. 파이썬에 있는 scikit-learn 라이브러리를 사용하면 코드 몇줄로 바로 구현할 수 있다. 그러나 그 작동 원리를 알고 구현하는 것과 모른채 blackbox식으로 구현하는 것은 엄연히 다르다. Logistic Regression의 작동 원리를 공부하기 위해 선행되어 알아야만 하는 몇가지 Keyword를 소개하겠다.\n\n\n<br><br>\n\n### 📌 Odds\n<hr>\n\n**Odds**는 **어떤 사건이 발생할 확률을 발생하지 않을 확률로 나눈 값**을 의미한다. 어떤 사건이 일어날 확률을 p라고 했을때 **Odds값은 p / (1-p)** 이다.\n\n예를 들어 p가 0.2라면 Odds = 0.2 / (1 - 0.8) = 0.25 이다.\n\n<br><br>\n\n### 📌 Odds Ratio\n<hr>\n\nOdds Ratio는 두개의 Odds의 비율을 나타내는 값이다. 예를들어 Odds1 = 0.25 이고 Odds2 = 0.30이면 Odds Ratio = 0.25 / 0.30 = 0.833이다.\n\n\n<br><br>\n\n### 📌 Logit\n<hr>\n\n사실상 Logit을 설명하기 위해 앞서 Odds와 Odds Ratio를 소개했다고 봐도 무방하다.  확률 p의 Logit은 다음과 같이 정의된다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/logit.jpg?raw=true\">\n</p>\n\n즉, Odds에 자연로그를 씌운 형태로 Logit이라는 말이 Log + Odds에서 나온말이다. 예를들어, p=0.5라고 하면 Odds = 0.5 / 0.5 = 1, Logit = ln(1) = 0 이된다.\n\n<br><br><br><br><br><br>\n\n## ✅ Solver Algorithms for Logistic Regression \n\n파이썬의 Scikit-Learn에서는 다섯개의 알고리즘으로 Logic Regression을 해결한다. 각각의 알고리즘이 어떤식으로 동작하는지는 내용이 너무 방대하므로 설명하지 않겠고 그냥 이런게 있구나 하고 넘어가면 좋을 것 같다.\n\n - **newton-cg**\n - **lbfgs**\n - **liblinear**\n - **sag**\n - **saga**\n\n<br><br><br><br><br><br>\n\n## ✅ Logistic Regression Python Code\n\n이제 로지스틱 회귀를 파이썬으로 직접 구현하는 연습을 해보자.\n\n<br><br>\n\n### 📌 1. 데이터 불러오기\n<hr>\n\n\n먼저 seaborn에 내재된 타이타닉 데이터셋을 불러오도록 하자.\n```python\nimport seaborn as sns  \n  \npassengers = sns.load_dataset('titanic')  \nprint(passengers.shape)  \nprint(passengers.head())\n```\n\n<br>\n\n총 891명의 데이터가 있고 총 15개의 컬럼이 있는걸 확인했다.\n\n<p align=\"center\">\n<img src=\"https://github.com/idkim97/idkim97.github.io/blob/master/img/res.png?raw=true\">\n</p>\n\n우리의 Target 데이터는 survived 이다. 살았는지 죽었는지 확인하는 컬럼이고 1은 생존, 0는 사망을 의미한다.\n\n\n<br><br>\n\n### 📌 2. 데이터 전처리\n<hr>\n\n\n### 분석에 사용할 Feature 선택\n\n먼저 생존여부에 큰 영향을 미쳤을 것으로 예상되는 컬럼을 sex, age, pclass로 지정했다. 여성, 어린이, 1/2/3등석 순으로 살아남을 확률이 높다고 가정해본 것이다.\n\n<br><br><br>\n### 문자열을 숫자로 변환\nsex는 male과 female로 설정되있으므로 이를 숫자 데이터 1과 0으로 바꿔주자.\n여성이 살아남을 확률이 높을것으로 예상하므로 남성을 0, 여성을 1이라고 바꿔주자.\n```python\npassengers['sex'] = passengers['sex'].map({'female':1,'male':0})\n```\n\n<br><br><br>\n\n### 결측치 채워주기\n데이터를 살펴보면 age가 비어있는 경우가 있다. 이는 age의 평균치로 대체하겠다.\n```python\npassengers['age'].fillna(value=passengers['age'].mean(), inplace=True)\n```\n\n<br><br><br>\n### Feature 분리하기\npclass의 경우 1등석에 탔는지, 2등석에 탔는지 각각의 feature로 만들어주기 위해 컬럼을 새로 생성해 분류하겠다.\n```python\npassengers['FirstClass'] = passengers['pclass'].apply(lambda x: 1 if x == 1 else 0)  \npassengers['SecondClass'] = passengers['pclass'].apply(lambda x: 1 if x == 2 else 0)\n```\n\n```python\nfeatures = passengers[['sex', 'age', 'FirstClass', 'SecondClass']]  \nsurvival = passengers['survived']\n```\n\n<br><br>\n\n### 📌 3. Train/Test set 분리하기\n<hr>\n\n\n```python\nfrom sklearn.model_selection import train_test_split  \n  \ntrain_features, test_features, train_labels, test_labels = train_test_split(features, survival)\n```\n\n\n<br><br>\n\n### 📌 4. 데이터 정규화(Scaling) 하기\n<hr>\n\n\nStandardScaler를 사용해 데이터를 정규화 하였다.\n```python\nfrom sklearn.preprocessing import StandardScaler  \n  \nscaler = StandardScaler()  \n  \ntrain_features = scaler.fit_transform(train_features)  \ntest_features = scaler.transform(test_features)\n```\n\n\n<br><br>\n\n### 📌 5. 모델 생성 및 평가하기\n<hr>\n\n```python\nfrom sklearn.linear_model import LogisticRegression  \n  \nmodel = LogisticRegression()  \nmodel.fit(train_features, train_labels)\n```\nmodel을 생성해 LogisticRegression 함수를 넣어주면 끝이다.\n\n<br><br><br>\n\n이제 학습세트로 정확도를 바로 알아보자.\n```python\nprint(model.score(train_features, train_labels))\n```\n\n\n결과 : \n```\n0.7919161676646707\n```\n\n79%의 정확도를 가진다고 나온다.\n\n<br><br><br>\n\nTest Set에서도 정확도를 확인해보자.\n```python\nprint(model.score(test_features, test_labels))\n```\n결과 : \n```\n0.766816143498\n```\n76%의 정확도를 가진다고 나온다.\n\n<br><br><br>\n\n이제 각 Feature들의 계수(Coefficients)를 확인해볼 차례이다. 어떤 Feature가 생존에 큰 영향을 주는지 확인해 볼 수 있다.\n```python\nprint(model.coef_)\n```\n결과 : \n```\n[[ 1.21512352 -0.34590989  0.99346516  0.49466482]]\n```\nsex, age, firstclass, secondclass 순으로 넣었으므로 그순서대로 확인해주면 된다. 성별은 1에 가까우므로 여자이고, 일등석 탑승 여부가 중요하다는 걸 알 수 있다. 반면에 나이는 음수가 나오는데 이는 나이가 많을수록 생존 확률이 낮아진다는 의미로 해석할 수 있다.\n\n\n<br><br>\n\n### 📌 6. 예측하기\n<hr>\n\n이번에는 새로운 임의의 데이터를 넣어서 예측해보자.\n```python\nJack = np.array([0.0, 20.0, 0.0, 0.0])  \nRose = np.array([1.0, 17.0, 1.0, 0.0])  \nME = np.array([0.0, 32.0, 1.0, 0.0])\n\nsample_passengers = np.array([Jack, Rose, ME])\n```\n\n<br><br><br>\n이제 스케일링을 다시해주자.\n```python\nsample_passengers = scaler.transform(sample_passengers)\n```\n\n<br><br><br>\n마지막으로 예측을 해보자.\n```python\nprint(model.predict(sample_passengers))  \n  \nprint(model.predict_proba(sample_passengers))\n```\n```\n[0 1 0]\n\n[[0.88995985 0.11004015]\n [0.05240318 0.94759682]\n [0.51644668 0.48355332]]\n ```\nJack과 나는 죽고 Rose만 산다..\n","properties":"\n","discussions":{},"comments":{},"hash":458081793,"tx":55621},"DYReayvPEWh2qfnj/contentState":{"id":"DYReayvPEWh2qfnj/contentState","type":"contentState","selectionStart":1054,"selectionEnd":1054,"scrollPosition":{"sectionIdx":7,"posInSection":0.5909090909090909},"hash":1718351392177,"tx":55628}}